---
id: network
title: "Сеть"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

## Введение

Playwright предоставляет API для **мониторинга** и **модификации** сетевого трафика браузера, как HTTP, так и HTTPS. Любые запросы, которые выполняет страница, включая [XHR](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) и [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) запросы, могут быть отслежены, изменены и обработаны.

## Мокирование API

Посмотрите наше [руководство по мокированию API](./mock.mdx), чтобы узнать больше о том, как
- мокировать API запросы и никогда не обращаться к API
- выполнять API запрос и изменять ответ
- использовать HAR файлы для мокирования сетевых запросов.

## Мокирование сети

Вам не нужно ничего настраивать для мокирования сетевых запросов. Просто определите пользовательский [Route], который будет мокировать сеть для контекста браузера.

```js title="example.spec.ts"
import { test, expect } from '@playwright/test';

test.beforeEach(async ({ context }) => {
  // Блокировать любые css запросы для каждого теста в этом файле.
  await context.route(/.css$/, route => route.abort());
});

test('загружает страницу без css', async ({ page }) => {
  await page.goto('https://playwright.dev');
  // ... тест здесь
});
```

В качестве альтернативы, вы можете использовать [page.route()](/api/class-page.mdx#page-route), чтобы мокировать сеть на одной странице.

```js title="example.spec.ts"
import { test, expect } from '@playwright/test';

test('загружает страницу без изображений', async ({ page }) => {
  // Блокировать png и jpeg изображения.
  await page.route(/(png|jpeg)$/, route => route.abort());

  await page.goto('https://playwright.dev');
  // ... тест здесь
});
```

## HTTP Аутентификация

Выполните HTTP аутентификацию.

<Tabs
  groupId="js-flavor"
  defaultValue="test"
  values={[
    {label: 'Тест', value: 'test'},
    {label: 'Библиотека', value: 'library'}
  ]
}>
<TabItem value="test">

```js title="playwright.config.ts"
import { defineConfig } from '@playwright/test';
export default defineConfig({
  use: {
    httpCredentials: {
      username: 'bill',
      password: 'pa55w0rd',
    }
  }
});
```

</TabItem>
<TabItem value="library">

```js
const context = await browser.newContext({
  httpCredentials: {
    username: 'bill',
    password: 'pa55w0rd',
  },
});
const page = await context.newPage();
await page.goto('https://example.com');
```

</TabItem>
</Tabs>

## HTTP Прокси

Вы можете настроить страницы для загрузки через HTTP(S) прокси или SOCKSv5. Прокси может быть установлен глобально для всего браузера или для каждого контекста браузера индивидуально.

Вы также можете указать имя пользователя и пароль для HTTP(S) прокси, а также указать хосты, для которых следует игнорировать [прокси](/api/class-browser.mdx#browser-new-context-option-proxy).

Вот пример глобального прокси:

<Tabs
  groupId="js-flavor"
  defaultValue="test"
  values={[
    {label: 'Тест', value: 'test'},
    {label: 'Библиотека', value: 'library'}
  ]
}>
<TabItem value="test">

```js title="playwright.config.ts"
import { defineConfig } from '@playwright/test';
export default defineConfig({
  use: {
    proxy: {
      server: 'http://myproxy.com:3128',
      username: 'usr',
      password: 'pwd'
    }
  }
});
```

</TabItem>
<TabItem value="library">

```js
const browser = await chromium.launch({
  proxy: {
    server: 'http://myproxy.com:3128',
    username: 'usr',
    password: 'pwd'
  }
});
```

</TabItem>
</Tabs>

Также возможно указать его для каждого контекста:

<Tabs
  groupId="js-flavor"
  defaultValue="test"
  values={[
    {label: 'Тест', value: 'test'},
    {label: 'Библиотека', value: 'library'}
  ]
}>
<TabItem value="test">

```js title="example.spec.ts"
import { test, expect } from '@playwright/test';

test('должен использовать пользовательский прокси в новом контексте', async ({ browser }) => {
  const context = await browser.newContext({
    proxy: {
      server: 'http://myproxy.com:3128',
    }
  });
  const page = await context.newPage();

  await context.close();
});
```

</TabItem>
<TabItem value="library">

```js
const browser = await chromium.launch();
const context = await browser.newContext({
  proxy: { server: 'http://myproxy.com:3128' }
});
```

</TabItem>
</Tabs>

## Сетевые события

Вы можете отслеживать все [Request] и [Response]:

```js
// Подписаться на события 'request' и 'response'.
page.on('request', request => console.log('>>', request.method(), request.url()));
page.on('response', response => console.log('<<', response.status(), response.url()));

await page.goto('https://example.com');
```

Или дождаться сетевого ответа после нажатия кнопки с помощью [page.waitForResponse()](/api/class-page.mdx#page-wait-for-response):

```js
// Используйте шаблон URL с глобом. Обратите внимание, что нет await.
const responsePromise = page.waitForResponse('**/api/fetch_data');
await page.getByText('Обновить').click();
const response = await responsePromise;
```

#### Вариации

Дождитесь [Response] с помощью [page.waitForResponse()](/api/class-page.mdx#page-wait-for-response):

```js
// Используйте RegExp. Обратите внимание, что нет await.
const responsePromise = page.waitForResponse(/\.jpeg$/);
await page.getByText('Обновить').click();
const response = await responsePromise;

// Используйте предикат, принимающий объект Response. Обратите внимание, что нет await.
const responsePromise = page.waitForResponse(response => response.url().includes(token));
await page.getByText('Обновить').click();
const response = await responsePromise;
```

## Обработка запросов

```js
await page.route('**/api/fetch_data', route => route.fulfill({
  status: 200,
  body: testData,
}));
await page.goto('https://example.com');
```

Вы можете мокировать API конечные точки, обрабатывая сетевые запросы в вашем скрипте Playwright.

#### Вариации

Настройте маршрут для всего контекста браузера с помощью [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) или страницы с помощью [page.route()](/api/class-page.mdx#page-route). Это будет применяться к всплывающим окнам и открытым ссылкам.

```js
await browserContext.route('**/api/login', route => route.fulfill({
  status: 200,
  body: 'accept',
}));
await page.goto('https://example.com');
```

## Модификация запросов

```js
// Удалить заголовок
await page.route('**/*', async route => {
  const headers = route.request().headers();
  delete headers['X-Secret'];
  await route.continue({ headers });
});

// Продолжить запросы как POST.
await page.route('**/*', route => route.continue({ method: 'POST' }));
```

Вы можете продолжать запросы с модификациями. Пример выше удаляет HTTP заголовок из исходящих запросов.

## Прерывание запросов

Вы можете прервать запросы, используя [page.route()](/api/class-page.mdx#page-route) и [route.abort()](/api/class-route.mdx#route-abort).

```js
await page.route('**/*.{png,jpg,jpeg}', route => route.abort());

// Прервать на основе типа запроса
await page.route('**/*', route => {
  return route.request().resourceType() === 'image' ? route.abort() : route.continue();
});
```

## Модификация ответов

Чтобы изменить ответ, используйте [APIRequestContext], чтобы получить оригинальный ответ, а затем передайте ответ в [route.fulfill()](/api/class-route.mdx#route-fulfill). Вы можете переопределить отдельные поля в ответе через параметры:

```js
await page.route('**/title.html', async route => {
  // Получить оригинальный ответ.
  const response = await route.fetch();
  // Добавить префикс к заголовку.
  let body = await response.text();
  body = body.replace('<title>', '<title>Мой префикс:');
  await route.fulfill({
    // Передать все поля из ответа.
    response,
    // Переопределить тело ответа.
    body,
    // Принудительно установить тип контента как html.
    headers: {
      ...response.headers(),
      'content-type': 'text/html'
    }
  });
});
```

## Шаблоны URL с глобом

Playwright использует упрощенные шаблоны глобов для сопоставления URL в методах перехвата сети, таких как [page.route()](/api/class-page.mdx#page-route) или [page.waitForResponse()](/api/class-page.mdx#page-wait-for-response). Эти шаблоны поддерживают базовые подстановочные знаки:
1. Звездочки:
   - Одна `*` соответствует любым символам, кроме `/`
   - Двойная `**` соответствует любым символам, включая `/`
1. Вопросительный знак `?` соответствует любому одному символу, кроме `/`
1. Фигурные скобки `{}` могут использоваться для сопоставления списка опций, разделенных запятыми `,`
1. Квадратные скобки `[]` могут использоваться для сопоставления набора символов
1. Обратная косая черта `\` может использоваться для экранирования любых специальных символов (обратите внимание, что для экранирования самой обратной косой черты используйте `\\`)

Примеры:
- `https://example.com/*.js` соответствует `https://example.com/file.js`, но не соответствует `https://example.com/path/file.js`
- `https://example.com/\\?page=1` соответствует `https://example.com/?page=1`, но не соответствует `https://example.com`
- `**/v[0-9]*` соответствует `https://example.com/v1/`, но не соответствует `https://example.com/vote/`
- `**/*.js` соответствует как `https://example.com/file.js`, так и `https://example.com/path/file.js`
- `**/*.{png,jpg,jpeg}` соответствует всем запросам изображений

Важные примечания:
- Шаблон глобов должен соответствовать всему URL, а не только его части.
- При использовании глобов для сопоставления URL учитывайте полную структуру URL, включая протокол и разделители пути.
- Для более сложных требований к сопоставлению рассмотрите возможность использования [RegExp] вместо шаблонов глобов.

## WebSockets

Playwright поддерживает [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) инспекцию, мокирование и модификацию из коробки. Посмотрите наше [руководство по мокированию API](./mock.mdx#mock-websockets), чтобы узнать, как мокировать WebSockets.

Каждый раз, когда создается WebSocket, срабатывает событие [page.on('websocket')](/api/class-page.mdx#page-event-web-socket). Это событие содержит экземпляр [WebSocket] для дальнейшей инспекции веб-сокетных кадров:

```js
page.on('websocket', ws => {
  console.log(`WebSocket открыт: ${ws.url()}>`);
  ws.on('framesent', event => console.log(event.payload));
  ws.on('framereceived', event => console.log(event.payload));
  ws.on('close', () => console.log('WebSocket закрыт'));
});
```

## Пропущенные сетевые события и сервисные работники

Встроенные [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [page.route()](/api/class-page.mdx#page-route) Playwright позволяют вашим тестам нативно маршрутизировать запросы и выполнять мокирование и перехват.
1. Если вы используете нативные [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [page.route()](/api/class-page.mdx#page-route) Playwright, и кажется, что сетевые события отсутствуют, отключите сервисные работники, установив [serviceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
2. Возможно, вы используете инструмент мокирования, такой как Mock Service Worker (MSW). Хотя этот инструмент работает из коробки для мокирования ответов, он добавляет своего собственного сервисного работника, который перехватывает сетевые запросы, делая их невидимыми для [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [page.route()](/api/class-page.mdx#page-route). Если вас интересует как тестирование сети, так и мокирование, рассмотрите возможность использования встроенных [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [page.route()](/api/class-page.mdx#page-route) для [мокирования ответов](#handle-requests).
3. Если вас интересует не только использование сервисных работников для тестирования и мокирования сети, но и маршрутизация и прослушивание запросов, сделанных самими сервисными работниками, пожалуйста, смотрите [эту экспериментальную функцию](https://github.com/microsoft/playwright/issues/15684).