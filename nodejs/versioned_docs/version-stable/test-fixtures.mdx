---
id: test-fixtures
title: "Фикстуры"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

## Введение

Playwright Test основан на концепции тестовых фикстур. Тестовые фикстуры используются для создания окружения для каждого теста, предоставляя тесту все необходимое и ничего лишнего. Тестовые фикстуры изолированы между тестами. С помощью фикстур вы можете группировать тесты по их смыслу, а не по общему окружению.

### Встроенные фикстуры

Вы уже использовали тестовые фикстуры в своем первом тесте.

```js
import { test, expect } from '@playwright/test';

test('basic test', async ({ page }) => {
  await page.goto('https://playwright.dev/');

  await expect(page).toHaveTitle(/Playwright/);
});
```

Аргумент `{ page }` говорит Playwright Test настроить фикстуру `page` и предоставить ее вашей тестовой функции.

Вот список предопределенных фикстур, которые вы, вероятно, будете использовать чаще всего:

|Фикстура    |Тип               |Описание                      |
|:----------|:------------------|:--------------------------------|
|page       |[Page]             |Изолированная страница для этого запуска теста. |
|context    |[BrowserContext]   |Изолированный контекст для этого запуска теста. Фикстура `page` также принадлежит этому контексту. Узнайте, как [настроить контекст](./test-configuration.mdx). |
|browser    |[Browser]          |Браузеры разделяются между тестами для оптимизации ресурсов. Узнайте, как [настроить браузер](./test-configuration.mdx). |
|browserName|[string]           |Имя браузера, в котором в данный момент выполняется тест. Это может быть `chromium`, `firefox` или `webkit`.|
|request    |[APIRequestContext]|Изолированный экземпляр [APIRequestContext](./api/class-apirequestcontext.mdx) для этого запуска теста.|

### Без фикстур

Вот как типичная настройка окружения теста отличается между традиционным стилем тестирования и основанным на фикстурах.

`TodoPage` — это класс, который помогает взаимодействовать со страницей "списка дел" веб-приложения, следуя паттерну [Page Object Model](./pom.mdx). Он использует `page` Playwright внутри.

<details>

<summary>Нажмите, чтобы развернуть код для <code>TodoPage</code></summary>

<div>

```js title="todo-page.ts"
import type { Page, Locator } from '@playwright/test';

export class TodoPage {
  private readonly inputBox: Locator;
  private readonly todoItems: Locator;

  constructor(public readonly page: Page) {
    this.inputBox = this.page.locator('input.new-todo');
    this.todoItems = this.page.getByTestId('todo-item');
  }

  async goto() {
    await this.page.goto('https://demo.playwright.dev/todomvc/');
  }

  async addToDo(text: string) {
    await this.inputBox.fill(text);
    await this.inputBox.press('Enter');
  }

  async remove(text: string) {
    const todo = this.todoItems.filter({ hasText: text });
    await todo.hover();
    await todo.getByLabel('Delete').click();
  }

  async removeAll() {
    while ((await this.todoItems.count()) > 0) {
      await this.todoItems.first().hover();
      await this.todoItems.getByLabel('Delete').first().click();
    }
  }
}
```

</div>

</details>

```js title="todo.spec.ts"
const { test } = require('@playwright/test');
const { TodoPage } = require('./todo-page');

test.describe('тесты todo', () => {
  let todoPage;

  test.beforeEach(async ({ page }) => {
    todoPage = new TodoPage(page);
    await todoPage.goto();
    await todoPage.addToDo('item1');
    await todoPage.addToDo('item2');
  });

  test.afterEach(async () => {
    await todoPage.removeAll();
  });

  test('должен добавить элемент', async () => {
    await todoPage.addToDo('my item');
    // ...
  });

  test('должен удалить элемент', async () => {
    await todoPage.remove('item1');
    // ...
  });
});
```

### С фикстурами

Фикстуры имеют ряд преимуществ по сравнению с хуками before/after:
- Фикстуры **инкапсулируют** настройку и очистку в одном месте, что упрощает написание. Если у вас есть хук after, который очищает то, что было создано в хуке before, подумайте о том, чтобы превратить их в фикстуру.
- Фикстуры **переиспользуемы** между тестовыми файлами - вы можете определить их один раз и использовать во всех ваших тестах. Так работает встроенная фикстура `page` в Playwright. Если у вас есть вспомогательная функция, которая используется в нескольких тестах, подумайте о том, чтобы превратить ее в фикстуру.
- Фикстуры **по требованию** - вы можете определить столько фикстур, сколько хотите, и Playwright Test настроит только те, которые нужны вашему тесту, и ничего лишнего.
- Фикстуры **композируемы** - они могут зависеть друг от друга, чтобы предоставить сложное поведение.
- Фикстуры **гибкие**. Тесты могут использовать любые комбинации фикстур, чтобы настроить точное окружение, которое им нужно, не влияя на другие тесты.
- Фикстуры упрощают **группировку**. Вам больше не нужно оборачивать тесты в `describe`, которые настраивают окружение, и вы можете свободно группировать свои тесты по их смыслу.

<details>

<summary>Нажмите, чтобы развернуть код для <code>TodoPage</code></summary>

<div>

```js title="todo-page.ts"
import type { Page, Locator } from '@playwright/test';

export class TodoPage {
  private readonly inputBox: Locator;
  private readonly todoItems: Locator;

  constructor(public readonly page: Page) {
    this.inputBox = this.page.locator('input.new-todo');
    this.todoItems = this.page.getByTestId('todo-item');
  }

  async goto() {
    await this.page.goto('https://demo.playwright.dev/todomvc/');
  }

  async addToDo(text: string) {
    await this.inputBox.fill(text);
    await this.inputBox.press('Enter');
  }

  async remove(text: string) {
    const todo = this.todoItems.filter({ hasText: text });
    await todo.hover();
    await todo.getByLabel('Delete').click();
  }

  async removeAll() {
    while ((await this.todoItems.count()) > 0) {
      await this.todoItems.first().hover();
      await this.todoItems.getByLabel('Delete').first().click();
    }
  }
}
```

</div>

</details>

```js title="example.spec.ts"
import { test as base } from '@playwright/test';
import { TodoPage } from './todo-page';

// Расширяем базовый тест, предоставляя фикстуру "todoPage".
const test = base.extend<{ todoPage: TodoPage }>({
  todoPage: async ({ page }, use) => {
    const todoPage = new TodoPage(page);
    await todoPage.goto();
    await todoPage.addToDo('item1');
    await todoPage.addToDo('item2');
    await use(todoPage);
    await todoPage.removeAll();
  },
});

test('должен добавить элемент', async ({ todoPage }) => {
  await todoPage.addToDo('my item');
  // ...
});

test('должен удалить элемент', async ({ todoPage }) => {
  await todoPage.remove('item1');
  // ...
});
```

## Создание фикстуры

Чтобы создать свою собственную фикстуру, используйте [test.extend()](/api/class-test.mdx#test-extend), чтобы создать новый объект `test`, который будет включать ее.

Ниже мы создаем две фикстуры `todoPage` и `settingsPage`, которые следуют паттерну [Page Object Model](./pom.mdx).

<details>

<summary>Нажмите, чтобы развернуть код для <code>TodoPage</code> и <code>SettingsPage</code></summary>

<div>

```js title="todo-page.ts"
import type { Page, Locator } from '@playwright/test';

export class TodoPage {
  private readonly inputBox: Locator;
  private readonly todoItems: Locator;

  constructor(public readonly page: Page) {
    this.inputBox = this.page.locator('input.new-todo');
    this.todoItems = this.page.getByTestId('todo-item');
  }

  async goto() {
    await this.page.goto('https://demo.playwright.dev/todomvc/');
  }

  async addToDo(text: string) {
    await this.inputBox.fill(text);
    await this.inputBox.press('Enter');
  }

  async remove(text: string) {
    const todo = this.todoItems.filter({ hasText: text });
    await todo.hover();
    await todo.getByLabel('Delete').click();
  }

  async removeAll() {
    while ((await this.todoItems.count()) > 0) {
      await this.todoItems.first().hover();
      await this.todoItems.getByLabel('Delete').first().click();
    }
  }
}
```

SettingsPage аналогичен:

```js title="settings-page.ts"
import type { Page } from '@playwright/test';

export class SettingsPage {
  constructor(public readonly page: Page) {
  }

  async switchToDarkMode() {
    // ...
  }
}
```

</div>

</details>

```js title="my-test.ts"
import { test as base } from '@playwright/test';
import { TodoPage } from './todo-page';
import { SettingsPage } from './settings-page';

// Объявите типы ваших фикстур.
type MyFixtures = {
  todoPage: TodoPage;
  settingsPage: SettingsPage;
};

// Расширьте базовый тест, предоставляя "todoPage" и "settingsPage".
// Этот новый "test" может использоваться в нескольких тестовых файлах, и каждый из них получит фикстуры.
export const test = base.extend<MyFixtures>({
  todoPage: async ({ page }, use) => {
    // Настройка фикстуры.
    const todoPage = new TodoPage(page);
    await todoPage.goto();
    await todoPage.addToDo('item1');
    await todoPage.addToDo('item2');

    // Используйте значение фикстуры в тесте.
    await use(todoPage);

    // Очистка фикстуры.
    await todoPage.removeAll();
  },

  settingsPage: async ({ page }, use) => {
    await use(new SettingsPage(page));
  },
});
export { expect } from '@playwright/test';
```

:::note
Имена пользовательских фикстур должны начинаться с буквы или подчеркивания и могут содержать только буквы, цифры, подчеркивания.
:::

## Использование фикстуры

Просто укажите фикстуру в аргументе вашей тестовой функции, и тестовый раннер позаботится об этом. Фикстуры также доступны в хуках и других фикстурах. Если вы используете TypeScript, фикстуры будут иметь правильный тип.

Ниже мы используем фикстуры `todoPage` и `settingsPage`, определенные выше.

```js
import { test, expect } from './my-test';

test.beforeEach(async ({ settingsPage }) => {
  await settingsPage.switchToDarkMode();
});

test('базовый тест', async ({ todoPage, page }) => {
  await todoPage.addToDo('что-то хорошее');
  await expect(page.getByTestId('todo-title')).toContainText(['что-то хорошее']);
});
```

## Переопределение фикстур

В дополнение к созданию собственных фикстур, вы также можете переопределить существующие фикстуры, чтобы соответствовать вашим потребностям. Рассмотрим следующий пример, который переопределяет фикстуру `page`, автоматически переходя на некоторый `baseURL`:

```js
import { test as base } from '@playwright/test';

export const test = base.extend({
  page: async ({ baseURL, page }, use) => {
    await page.goto(baseURL);
    await use(page);
  },
});
```

Обратите внимание, что в этом примере фикстура `page` может зависеть от других встроенных фикстур, таких как [testOptions.baseURL](/api/class-testoptions.mdx#test-options-base-url). Теперь мы можем настроить `baseURL` в конфигурационном файле или локально в тестовом файле с помощью [test.use()](/api/class-test.mdx#test-use).

```js title="example.spec.ts"

test.use({ baseURL: 'https://playwright.dev' });
```

Фикстуры также могут быть переопределены, когда базовая фикстура полностью заменяется чем-то другим. Например, мы могли бы переопределить фикстуру [testOptions.storageState](/api/class-testoptions.mdx#test-options-storage-state), чтобы предоставить наши собственные данные.

```js
import { test as base } from '@playwright/test';

export const test = base.extend({
  storageState: async ({}, use) => {
    const cookie = await getAuthCookie();
    await use({ cookies: [cookie] });
  },
});
```

## Фикстуры, охватывающие рабочие процессы

Playwright Test использует [рабочие процессы](./test-parallel.mdx) для выполнения тестовых файлов. Аналогично тому, как тестовые фикстуры настраиваются для отдельных запусков тестов, рабочие фикстуры настраиваются для каждого рабочего процесса. Здесь вы можете настраивать службы, запускать серверы и т. д. Playwright Test будет повторно использовать рабочий процесс для столько тестовых файлов, сколько сможет, при условии, что их рабочие фикстуры совпадают, и, следовательно, окружения идентичны.

Ниже мы создадим фикстуру `account`, которая будет общая для всех тестов в одном рабочем процессе, и переопределим фикстуру `page`, чтобы войти в эту учетную запись для каждого теста. Чтобы сгенерировать уникальные учетные записи, мы будем использовать [workerInfo.workerIndex](/api/class-workerinfo.mdx#worker-info-worker-index), который доступен для любого теста или фикстуры. Обратите внимание на синтаксис, похожий на кортеж, для рабочей фикстуры - мы должны передать `{scope: 'worker'}`, чтобы тестовый раннер настроил эту фикстуру один раз на рабочий процесс.

```js title="my-test.ts"
import { test as base } from '@playwright/test';

type Account = {
  username: string;
  password: string;
};

// Обратите внимание, что мы передаем типы рабочих фикстур как второй параметр шаблона.
export const test = base.extend<{}, { account: Account }>({
  account: [async ({ browser }, use, workerInfo) => {
    // Уникальное имя пользователя.
    const username = 'user' + workerInfo.workerIndex;
    const password = 'verysecure';

    // Создаем учетную запись с помощью Playwright.
    const page = await browser.newPage();
    await page.goto('/signup');
    await page.getByLabel('User Name').fill(username);
    await page.getByLabel('Password').fill(password);
    await page.getByText('Sign up').click();
    // Убедитесь, что все в порядке.
    await expect(page.getByTestId('result')).toHaveText('Success');
    // Не забудьте очистить.
    await page.close();

    // Используйте значение учетной записи.
    await use({ username, password });
  }, { scope: 'worker' }],

  page: async ({ page, account }, use) => {
    // Входим с нашей учетной записью.
    const { username, password } = account;
    await page.goto('/signin');
    await page.getByLabel('User Name').fill(username);
    await page.getByLabel('Password').fill(password);
    await page.getByText('Sign in').click();
    await expect(page.getByTestId('userinfo')).toHaveText(username);

    // Используйте страницу с авторизацией в тесте.
    await use(page);
  },
});
export { expect } from '@playwright/test';
```

## Автоматические фикстуры

Автоматические фикстуры настраиваются для каждого теста/рабочего процесса, даже если тест не перечисляет их напрямую. Чтобы создать автоматическую фикстуру, используйте синтаксис кортежа и передайте `{ auto: true }`.

Вот пример фикстуры, которая автоматически прикрепляет журналы отладки, когда тест не проходит, чтобы мы могли позже просмотреть журналы в репортере. Обратите внимание, как она использует объект [TestInfo], который доступен в каждом тесте/фикстуре для получения метаданных о выполняемом тесте.

```js title="my-test.ts"
import debug from 'debug';
import fs from 'fs';
import { test as base } from '@playwright/test';

export const test = base.extend<{ saveLogs: void }>({
  saveLogs: [async ({}, use, testInfo) => {
    // Сбор журналов во время теста.
    const logs = [];
    debug.log = (...args) => logs.push(args.map(String).join(''));
    debug.enable('myserver');

    await use();

    // После теста мы можем проверить, прошел ли тест или нет.
    if (testInfo.status !== testInfo.expectedStatus) {
      // outputPath() API гарантирует уникальное имя файла.
      const logFile = testInfo.outputPath('logs.txt');
      await fs.promises.writeFile(logFile, logs.join('\n'), 'utf8');
      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });
    }
  }, { auto: true }],
});
export { expect } from '@playwright/test';
```

## Таймаут фикстуры

По умолчанию фикстура делит таймаут с тестом. Однако для медленных фикстур, особенно [охватывающих рабочие процессы](#worker-scoped-fixtures), удобно иметь отдельный таймаут. Таким образом, вы можете сохранить общий таймаут теста небольшим и дать медленной фикстуре больше времени.

```js
import { test as base, expect } from '@playwright/test';

const test = base.extend<{ slowFixture: string }>({
  slowFixture: [async ({}, use) => {
    // ... выполнить медленную операцию ...
    await use('hello');
  }, { timeout: 60000 }]
});

test('пример теста', async ({ slowFixture }) => {
  // ...
});
```

## Опции фикстур

Playwright Test поддерживает выполнение нескольких тестовых проектов, которые могут быть отдельно настроены. Вы можете использовать "опционные" фикстуры, чтобы сделать ваши параметры конфигурации декларативными и проверяемыми по типу. Узнайте больше о [параметризации тестов](./test-parameterize.mdx).

Ниже мы создадим опцию `defaultItem` в дополнение к фикстуре `todoPage` из других примеров. Эта опция будет установлена в конфигурационном файле. Обратите внимание на синтаксис кортежа и аргумент `{ option: true }`.

<details>

<summary>Нажмите, чтобы развернуть код для <code>TodoPage</code></summary>

<div>

```js title="todo-page.ts"
import type { Page, Locator } from '@playwright/test';

export class TodoPage {
  private readonly inputBox: Locator;
  private readonly todoItems: Locator;

  constructor(public readonly page: Page) {
    this.inputBox = this.page.locator('input.new-todo');
    this.todoItems = this.page.getByTestId('todo-item');
  }

  async goto() {
    await this.page.goto('https://demo.playwright.dev/todomvc/');
  }

  async addToDo(text: string) {
    await this.inputBox.fill(text);
    await this.inputBox.press('Enter');
  }

  async remove(text: string) {
    const todo = this.todoItems.filter({ hasText: text });
    await todo.hover();
    await todo.getByLabel('Delete').click();
  }

  async removeAll() {
    while ((await this.todoItems.count()) > 0) {
      await this.todoItems.first().hover();
      await this.todoItems.getByLabel('Delete').first().click();
    }
  }
}
```

</div>

</details>

```js title="my-test.ts"
import { test as base } from '@playwright/test';
import { TodoPage } from './todo-page';

// Объявите ваши опции для проверки типов вашей конфигурации.
export type MyOptions = {
  defaultItem: string;
};
type MyFixtures = {
  todoPage: TodoPage;
};

// Укажите как типы опций, так и фикстур.
export const test = base.extend<MyOptions & MyFixtures>({
  // Определите опцию и предоставьте значение по умолчанию.
  // Мы можем позже переопределить его в конфигурации.
  defaultItem: ['Что-то хорошее', { option: true }],

  // Наша фикстура "todoPage" зависит от опции.
  todoPage: async ({ page, defaultItem }, use) => {
    const todoPage = new TodoPage(page);
    await todoPage.goto();
    await todoPage.addToDo(defaultItem);
    await use(todoPage);
    await todoPage.removeAll();
  },
});
export { expect } from '@playwright/test';
```

Теперь мы можем использовать фикстуру `todoPage` как обычно и установить опцию `defaultItem` в конфигурационном файле.

```js title="playwright.config.ts"
import { defineConfig } from '@playwright/test';
import type { MyOptions } from './my-test';

export default defineConfig<MyOptions>({
  projects: [
    {
      name: 'покупки',
      use: { defaultItem: 'Купить молоко' },
    },
    {
      name: 'благополучие',
      use: { defaultItem: 'Упражняться!' },
    },
  ]
});
```

**Массив как значение опции**

Если значение вашей опции является массивом, например `[{ name: 'Alice' }, { name: 'Bob' }]`, вам нужно будет обернуть его в дополнительный массив при предоставлении значения. Это лучше всего проиллюстрировать на примере.

```js
type Person = { name: string };
const test = base.extend<{ persons: Person[] }>({
  // Объявите опцию, значение по умолчанию - пустой массив.
  persons: [[], { option: true }],
});

// Значение опции - массив людей.
const actualPersons = [{ name: 'Alice' }, { name: 'Bob' }];
test.use({
  // ПРАВИЛЬНО: оберните значение в массив и передайте область видимости.
  persons: [actualPersons, { scope: 'test' }],
});

test.use({
  // НЕПРАВИЛЬНО: передача значения массива напрямую не сработает.
  persons: actualPersons,
});
```

## Порядок выполнения

Каждая фикстура имеет фазу настройки и очистки, разделенные вызовом `await use()` в фикстуре. Настройка выполняется перед использованием фикстуры тестом/хуком, а очистка выполняется, когда фикстура больше не будет использоваться тестом/хуком.

Фикстуры следуют этим правилам для определения порядка выполнения:
* Когда фикстура A зависит от фикстуры B: B всегда настраивается перед A и очищается после A.
* Неавтоматические фикстуры выполняются лениво, только когда тест/хук нуждается в них.
* Фикстуры, охватывающие тесты, очищаются после каждого теста, в то время как фикстуры, охватывающие рабочие процессы, очищаются только при завершении рабочего процесса, выполняющего тесты.

Рассмотрим следующий пример:

```js
import { test as base } from '@playwright/test';

const test = base.extend<{
  testFixture: string,
  autoTestFixture: string,
  unusedFixture: string,
}, {
  workerFixture: string,
  autoWorkerFixture: string,
}>({
  workerFixture: [async ({ browser }) => {
    // настройка workerFixture...
    await use('workerFixture');
    // очистка workerFixture...
  }, { scope: 'worker' }],

  autoWorkerFixture: [async ({ browser }) => {
    // настройка autoWorkerFixture...
    await use('autoWorkerFixture');
    // очистка autoWorkerFixture...
  }, { scope: 'worker', auto: true }],

  testFixture: [async ({ page, workerFixture }) => {
    // настройка testFixture...
    await use('testFixture');
    // очистка testFixture...
  }, { scope: 'test' }],

  autoTestFixture: [async () => {
    // настройка autoTestFixture...
    await use('autoTestFixture');
    // очистка autoTestFixture...
  }, { scope: 'test', auto: true }],

  unusedFixture: [async ({ page }) => {
    // настройка unusedFixture...
    await use('unusedFixture');
    // очистка unusedFixture...
  }, { scope: 'test' }],
});

test.beforeAll(async () => { /* ... */ });
test.beforeEach(async ({ page }) => { /* ... */ });
test('первый тест', async ({ page }) => { /* ... */ });
test('второй тест', async ({ testFixture }) => { /* ... */ });
test.afterEach(async () => { /* ... */ });
test.afterAll(async () => { /* ... */ });
```

Обычно, если все тесты проходят и не возникает ошибок, порядок выполнения будет следующим.
* настройка рабочего процесса и секция `beforeAll`:
  * настройка `browser`, так как он требуется для `autoWorkerFixture`.
  * настройка `autoWorkerFixture`, так как автоматические рабочие фикстуры всегда настраиваются перед чем-либо другим.
  * выполняется `beforeAll`.
* секция `первый тест`:
  * настройка `autoTestFixture`, так как автоматические тестовые фикстуры всегда настраиваются перед тестом и хуками `beforeEach`.
  * настройка `page`, так как он требуется в хуке `beforeEach`.
  * выполняется `beforeEach`.
  * выполняется `первый тест`.
  * выполняется `afterEach`.
  * очистка `page`, так как это фикстура, охватывающая тесты, и должна быть очищена после завершения теста.
  * очистка `autoTestFixture`, так как это фикстура, охватывающая тесты, и должна быть очищена после завершения теста.
* секция `второй тест`:
  * настройка `autoTestFixture`, так как автоматические тестовые фикстуры всегда настраиваются перед тестом и хуками `beforeEach`.
  * настройка `page`, так как он требуется в хуке `beforeEach`.
  * выполняется `beforeEach`.
  * настройка `workerFixture`, так как он требуется для `testFixture`, который требуется для `второго теста`.
  * настройка `testFixture`, так как он требуется для `второго теста`.
  * выполняется `второй тест`.
  * выполняется `afterEach`.
  * очистка `testFixture`, так как это фикстура, охватывающая тесты, и должна быть очищена после завершения теста.
  * очистка `page`, так как это фикстура, охватывающая тесты, и должна быть очищена после завершения теста.
  * очистка `autoTestFixture`, так как это фикстура, охватывающая тесты, и должна быть очищена после завершения теста.
* секция `afterAll` и очистка рабочего процесса:
  * выполняется `afterAll`.
  * очистка `workerFixture`, так как это фикстура, охватывающая рабочие процессы, и должна быть очищена один раз в конце.
  * очистка `autoWorkerFixture`, так как это фикстура, охватывающая рабочие процессы, и должна быть очищена один раз в конце.
  * очистка `browser`, так как это фикстура, охватывающая рабочие процессы, и должна быть очищена один раз в конце.

Несколько наблюдений:
* `page` и `autoTestFixture` настраиваются и очищаются для каждого теста, как фикстуры, охватывающие тесты.
* `unusedFixture` никогда не настраивается, так как она не используется ни в одном из тестов/хуков.
* `testFixture` зависит от `workerFixture` и вызывает его настройку.
* `workerFixture` настраивается лениво перед вторым тестом, но очищается один раз во время завершения рабочего процесса, как фикстура, охватывающая рабочие процессы.
* `autoWorkerFixture` настраивается для хуков `beforeAll`, но `autoTestFixture` не настраивается.

## Объединение пользовательских фикстур из нескольких модулей

Вы можете объединить тестовые фикстуры из нескольких файлов или модулей:

```js title="fixtures.ts"
import { mergeTests } from '@playwright/test';
import { test as dbTest } from 'database-test-utils';
import { test as a11yTest } from 'a11y-test-utils';

export const test = mergeTests(dbTest, a11yTest);
```

```js title="test.spec.ts"
import { test } from './fixtures';

test('проходит', async ({ database, page, a11y }) => {
  // используйте фикстуры базы данных и доступности.
});
```

## Упаковка фикстур

Обычно пользовательские фикстуры отображаются как отдельные шаги в режиме UI, Trace Viewer и различных отчетах тестов. Они также появляются в сообщениях об ошибках от тестового раннера. Для часто используемых фикстур это может означать много шума. Вы можете остановить отображение шагов фикстур в UI, "упаковав" их.

```js
import { test as base } from '@playwright/test';

export const test = base.extend({
  helperFixture: [async ({}, use, testInfo) => {
    // ...
  }, { box: true }],
});
```

Это полезно для неинтересных вспомогательных фикстур. Например, автоматическая фикстура, которая настраивает некоторые общие данные, может быть безопасно скрыта от отчета теста.

## Пользовательский заголовок фикстуры

Вместо обычного имени фикстуры вы можете дать фикстурам пользовательский заголовок, который будет отображаться в отчетах тестов и сообщениях об ошибках.

```js
import { test as base } from '@playwright/test';

export const test = base.extend({
  innerFixture: [async ({}, use, testInfo) => {
    // ...
  }, { title: 'моя фикстура' }],
});
```

## Добавление глобальных хуков beforeEach/afterEach

[test.beforeEach()](/api/class-test.mdx#test-before-each) и [test.afterEach()](/api/class-test.mdx#test-after-each) хуки выполняются перед/после каждого теста, объявленного в том же файле и том же [test.describe()](/api/class-test.mdx#test-describe) блоке (если таковой имеется). Если вы хотите объявить хуки, которые выполняются перед/после каждого теста глобально, вы можете объявить их как автоматические фикстуры следующим образом:

```ts title="fixtures.ts"
import { test as base } from '@playwright/test';

export const test = base.extend<{ forEachTest: void }>({
  forEachTest: [async ({ page }, use) => {
    // Этот код выполняется перед каждым тестом.
    await page.goto('http://localhost:8000');
    await use();
    // Этот код выполняется после каждого теста.
    console.log('Последний URL:', page.url());
  }, { auto: true }],  // автоматически запускается для каждого теста.
});
```

А затем импортируйте фикстуры во все ваши тесты:

```ts title="mytest.spec.ts"
import { test } from './fixtures';
import { expect } from '@playwright/test';

test('базовый', async ({ page }) => {
  expect(page).toHaveURL('http://localhost:8000');
  await page.goto('https://playwright.dev');
});
```

## Добавление глобальных хуков beforeAll/afterAll

[test.beforeAll()](/api/class-test.mdx#test-before-all) и [test.afterAll()](/api/class-test.mdx#test-after-all) хуки выполняются перед/после всех тестов, объявленных в том же файле и том же [test.describe()](/api/class-test.mdx#test-describe) блоке (если таковой имеется), один раз на рабочий процесс. Если вы хотите объявить хуки, которые выполняются перед/после всех тестов в каждом файле, вы можете объявить их как автоматические фикстуры с `scope: 'worker'` следующим образом:

```ts title="fixtures.ts"
import { test as base } from '@playwright/test';

export const test = base.extend<{}, { forEachWorker: void }>({
  forEachWorker: [async ({}, use) => {
    // Этот код выполняется перед всеми тестами в рабочем процессе.
    console.log(`Запуск тестового рабочего процесса ${test.info().workerIndex}`);
    await use();
    // Этот код выполняется после всех тестов в рабочем процессе.
    console.log(`Остановка тестового рабочего процесса ${test.info().workerIndex}`);
  }, { scope: 'worker', auto: true }],  // автоматически запускается для каждого рабочего процесса.
});
```

А затем импортируйте фикстуры во все ваши тесты:

```ts title="mytest.spec.ts"
import { test } from './fixtures';
import { expect } from '@playwright/test';

test('базовый', async ({ }) => {
  // ...
});
```

Обратите внимание, что фикстуры все равно будут выполняться один раз на [рабочий процесс](./test-parallel.mdx#worker-processes), но вам не нужно повторно объявлять их в каждом файле.


[Accessibility]: /api/class-accessibility.mdx "Доступность"
[Android]: /api/class-android.mdx "Android"
[AndroidDevice]: /api/class-androiddevice.mdx "AndroidDevice"
[AndroidInput]: /api/class-androidinput.mdx "AndroidInput"
[AndroidSocket]: /api/class-androidsocket.mdx "AndroidSocket"
[AndroidWebView]: /api/class-androidwebview.mdx "AndroidWebView"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserServer]: /api/class-browserserver.mdx "BrowserServer"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Coverage]: /api/class-coverage.mdx "Coverage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[Electron]: /api/class-electron.mdx "Electron"
[ElectronApplication]: /api/class-electronapplication.mdx "ElectronApplication"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[GenericAssertions]: /api/class-genericassertions.mdx "GenericAssertions"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Logger]: /api/class-logger.mdx "Logger"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[SnapshotAssertions]: /api/class-snapshotassertions.mdx "SnapshotAssertions"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Fixtures]: /api/class-fixtures.mdx "Fixtures"
[FullConfig]: /api/class-fullconfig.mdx "FullConfig"
[FullProject]: /api/class-fullproject.mdx "FullProject"
[Location]: /api/class-location.mdx "Location"
[Test]: /api/class-test.mdx "Test"
[TestConfig]: /api/class-testconfig.mdx "TestConfig"
[TestInfo]: /api/class-testinfo.mdx "TestInfo"
[TestInfoError]: /api/class-testinfoerror.mdx "TestInfoError"
[TestOptions]: /api/class-testoptions.mdx "TestOptions"
[TestProject]: /api/class-testproject.mdx "TestProject"
[TestStepInfo]: /api/class-teststepinfo.mdx "TestStepInfo"
[WorkerInfo]: /api/class-workerinfo.mdx "WorkerInfo"
[Reporter]: /api/class-reporter.mdx "Reporter"
[Suite]: /api/class-suite.mdx "Suite"
[TestCase]: /api/class-testcase.mdx "TestCase"
[TestError]: /api/class-testerror.mdx "TestError"
[TestResult]: /api/class-testresult.mdx "TestResult"
[TestStep]: /api/class-teststep.mdx "TestStep"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array "Array"
[boolean]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type "Boolean"
[Buffer]: https://nodejs.org/api/buffer.html#buffer_class_buffer "Buffer"
[ChildProcess]: https://nodejs.org/api/child_process.html "ChildProcess"
[Date]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date "Date"
[Error]: https://nodejs.org/api/errors.html#errors_class_error "Error"
[EventEmitter]: https://nodejs.org/api/events.html#events_class_eventemitter "EventEmitter"
[function]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function "Function"
[FormData]: https://developer.mozilla.org/en-US/docs/Web/API/FormData "FormData"
[Map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "Map"
[Metadata]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object&lt;string, any&gt;"
[null]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null "null"
[number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type "Number"
[Object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[Readable]: https://nodejs.org/api/stream.html#stream_class_stream_readable "Readable"
[ReadStream]: https://nodejs.org/api/fs.html#class-fsreadstream "ReadStream"
[RegExp]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp "RegExp"
[string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type "string"
[void]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined "void"
[URL]: https://nodejs.org/api/url.html "URL"
[URLSearchParams]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams "URLSearchParams"