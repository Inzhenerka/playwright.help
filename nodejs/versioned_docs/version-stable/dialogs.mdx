---
id: dialogs
title: "Диалоги"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

## Введение

Playwright может взаимодействовать с диалогами веб-страницы, такими как [`alert`](https://developer.mozilla.org/en-US/docs/Web/API/Window/alert), [`confirm`](https://developer.mozilla.org/en-US/docs/Web/API/Window/confirm), [`prompt`](https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt), а также с подтверждением [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). Для диалогов печати см. [Печать](#print-dialogs).

## Диалоги alert(), confirm(), prompt()

По умолчанию диалоги автоматически закрываются Playwright, поэтому вам не нужно их обрабатывать. Однако вы можете зарегистрировать обработчик диалогов перед действием, которое вызывает диалог, чтобы либо [dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) его.

```js
page.on('dialog', dialog => dialog.accept());
await page.getByRole('button').click();
```

:::note
Слушатель [page.on('dialog')](/api/class-page.mdx#page-event-dialog) **должен обрабатывать** диалог. В противном случае ваше действие будет зависать, будь то [locator.click()](/api/class-locator.mdx#locator-click) или что-то другое. Это связано с тем, что диалоги в вебе являются модальными и, следовательно, блокируют дальнейшее выполнение страницы, пока они не будут обработаны.
:::

В результате следующий фрагмент кода никогда не завершится:

:::warning

НЕПРАВИЛЬНО!
:::

```js
page.on('dialog', dialog => console.log(dialog.message()));
await page.getByRole('button').click(); // Здесь будет зависание
```

:::note
Если для [page.on('dialog')](/api/class-page.mdx#page-event-dialog) нет слушателя, все диалоги автоматически закрываются.
:::

## Диалог beforeunload

Когда вызывается [page.close()](/api/class-page.mdx#page-close) с истинным значением [runBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload), страница выполняет свои обработчики выгрузки. Это единственный случай, когда [page.close()](/api/class-page.mdx#page-close) не ждет фактического закрытия страницы, потому что в конце операции страница может остаться открытой.

Вы можете зарегистрировать обработчик диалогов, чтобы самостоятельно обработать диалог `beforeunload`:

```js
page.on('dialog', async dialog => {
  assert(dialog.type() === 'beforeunload');
  await dialog.dismiss();
});
await page.close({ runBeforeUnload: true });
```

## Диалоги печати

Чтобы подтвердить, что диалог печати через [`window.print`](https://developer.mozilla.org/en-US/docs/Web/API/Window/print) был вызван, вы можете использовать следующий фрагмент кода:

```js
await page.goto('<url>');

await page.evaluate('(() => {window.waitForPrintDialog = new Promise(f => window.print = f);})()');
await page.getByText('Print it!').click();

await page.waitForFunction('window.waitForPrintDialog');
```

Это будет ждать открытия диалога печати после нажатия кнопки. Убедитесь, что вы оценили скрипт перед нажатием кнопки / после загрузки страницы.