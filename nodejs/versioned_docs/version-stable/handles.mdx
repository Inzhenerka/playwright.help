---
id: handles
title: "Обработчики"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

## Введение

Playwright может создавать обработчики для DOM-элементов страницы или любых других объектов внутри страницы. Эти обработчики существуют в процессе Playwright, в то время как сами объекты находятся в браузере. Существует два типа обработчиков:
- [JSHandle] для ссылки на любые JavaScript-объекты на странице
- [ElementHandle] для ссылки на DOM-элементы на странице, который имеет дополнительные методы, позволяющие выполнять действия с элементами и проверять их свойства.

Поскольку любой DOM-элемент на странице также является JavaScript-объектом, любой [ElementHandle] также является [JSHandle].

Обработчики используются для выполнения операций с этими реальными объектами на странице. Вы можете выполнять оценку на обработчике, получать свойства обработчика, передавать обработчик в качестве параметра для оценки, сериализовать объект страницы в JSON и т.д. См. API класса [JSHandle] для этих и других методов.

### Справочник API
- [JSHandle]
- [ElementHandle]

Вот самый простой способ получить [JSHandle].

```js
const jsHandle = await page.evaluateHandle('window');
//  Используйте jsHandle для оценок.
```

## Обработчики элементов

:::warning[Не рекомендуется]

Использование [ElementHandle] не рекомендуется, вместо этого используйте объекты [Locator] и утверждения, ориентированные на веб.
:::

Когда [ElementHandle] необходим, рекомендуется получать его с помощью методов [page.waitForSelector()](/api/class-page.mdx#page-wait-for-selector) или [frame.waitForSelector()](/api/class-frame.mdx#frame-wait-for-selector). Эти API ожидают, пока элемент будет прикреплен и видим.

```js
// Получить обработчик элемента
const elementHandle = page.waitForSelector('#box');

// Проверить границы для элемента
const boundingBox = await elementHandle.boundingBox();
expect(boundingBox.width).toBe(100);

// Проверить атрибут для элемента
const classNames = await elementHandle.getAttribute('class');
expect(classNames.includes('highlighted')).toBeTruthy();
```

## Обработчики в качестве параметров

Обработчики могут быть переданы в [page.evaluate()](/api/class-page.mdx#page-evaluate) и аналогичные методы. Следующий фрагмент создает новый массив на странице, инициализирует его данными и возвращает обработчик этого массива в Playwright. Затем он использует обработчик в последующих оценках:

```js
// Создать новый массив на странице.
const myArrayHandle = await page.evaluateHandle(() => {
  window.myArray = [1];
  return myArray;
});

// Получить длину массива.
const length = await page.evaluate(a => a.length, myArrayHandle);

// Добавить еще один элемент в массив, используя обработчик
await page.evaluate(arg => arg.myArray.push(arg.newElement), {
  myArray: myArrayHandle,
  newElement: 2
});

// Освободить объект, когда он больше не нужен.
await myArrayHandle.dispose();
```

## Жизненный цикл обработчиков

Обработчики могут быть получены с помощью методов страницы, таких как [page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle), [page.$()](/api/class-page.mdx#page-query-selector) или [page.$$()](/api/class-page.mdx#page-query-selector-all) или их эквивалентов для фреймов [frame.evaluateHandle()](/api/class-frame.mdx#frame-evaluate-handle), [frame.$()](/api/class-frame.mdx#frame-query-selector) или [frame.$$()](/api/class-frame.mdx#frame-query-selector-all). После создания обработчики будут удерживать объект от [сборки мусора](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management), пока страница не перейдет или обработчик не будет вручную освобожден с помощью метода [jsHandle.dispose()](/api/class-jshandle.mdx#js-handle-dispose).

### Справочник API
- [JSHandle]
- [ElementHandle]
- [elementHandle.boundingBox()](/api/class-elementhandle.mdx#element-handle-bounding-box)
- [elementHandle.getAttribute()](/api/class-elementhandle.mdx#element-handle-get-attribute)
- [elementHandle.innerText()](/api/class-elementhandle.mdx#element-handle-inner-text)
- [elementHandle.innerHTML()](/api/class-elementhandle.mdx#element-handle-inner-html)
- [elementHandle.textContent()](/api/class-elementhandle.mdx#element-handle-text-content)
- [jsHandle.evaluate()](/api/class-jshandle.mdx#js-handle-evaluate)
- [page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle)
- [page.$()](/api/class-page.mdx#page-query-selector)
- [page.$$()](/api/class-page.mdx#page-query-selector-all)

## Locator против ElementHandle

:::caution

Мы рекомендуем использовать [ElementHandle] только в редких случаях, когда вам необходимо выполнить обширный обход DOM на статической странице. Для всех действий пользователя и утверждений используйте локатор вместо этого.
:::

Разница между [Locator] и [ElementHandle] заключается в том, что последний указывает на конкретный элемент, в то время как локатор захватывает логику того, как получить этот элемент.

В приведенном ниже примере обработчик указывает на конкретный DOM-элемент на странице. Если этот элемент изменит текст или будет использован React для рендеринга совершенно другого компонента, обработчик все равно будет указывать на этот устаревший DOM-элемент. Это может привести к неожиданному поведению.

```js
const handle = await page.$('text=Submit');
// ...
await handle.hover();
await handle.click();
```

С локатором каждый раз, когда используется локатор, актуальный DOM-элемент находится на странице с использованием селектора. Таким образом, в приведенном ниже фрагменте подлежащий DOM-элемент будет найден дважды.

```js
const locator = page.getByText('Submit');
// ...
await locator.hover();
await locator.click();
```