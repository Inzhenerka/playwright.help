---
id: class-locatorassertions
title: "LocatorAssertions"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

Класс [LocatorAssertions] предоставляет методы утверждений, которые можно использовать для проверки состояния [Locator] в тестах.

```js
import { test, expect } from '@playwright/test';

test('статус становится отправленным', async ({ page }) => {
  // ...
  await page.getByRole('button').click();
  await expect(page.locator('.status')).toHaveText('Submitted');
});
```

---

## Методы

### toBeAttached {#locator-assertions-to-be-attached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.33</font><x-search>locatorAssertions.toBeAttached</x-search>

Убедитесь, что [Locator] указывает на элемент, который [подключен](https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected) к документу или ShadowRoot.

**Использование**

```js
await expect(page.getByText('Скрытый текст')).toBeAttached();
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `attached` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-attached-option-attached"/><a href="#locator-assertions-to-be-attached-option-attached" class="list-anchor">#</a>
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-attached-option-timeout"/><a href="#locator-assertions-to-be-attached-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-attached-return"/><a href="#locator-assertions-to-be-attached-return" class="list-anchor">#</a>

---

### toBeChecked {#locator-assertions-to-be-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toBeChecked</x-search>

Убедитесь, что [Locator] указывает на отмеченный элемент ввода.

**Использование**

```js
const locator = page.getByLabel('Подписаться на рассылку');
await expect(locator).toBeChecked();
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `checked` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-checked-option-checked"/><a href="#locator-assertions-to-be-checked-option-checked" class="list-anchor">#</a>
    
    Указывает состояние для проверки. По умолчанию проверяет, что элемент отмечен. Этот параметр не может использоваться, если [indeterminate](/api/class-locatorassertions.mdx#locator-assertions-to-be-checked-option-indeterminate) установлен в true.
  - `indeterminate` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.50</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-checked-option-indeterminate"/><a href="#locator-assertions-to-be-checked-option-indeterminate" class="list-anchor">#</a>
    
    Указывает, что элемент находится в неопределенном (смешанном) состоянии. Поддерживается только для флажков и радиокнопок. Этот параметр не может быть true, если указан [checked](/api/class-locatorassertions.mdx#locator-assertions-to-be-checked-option-checked).
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-checked-option-timeout"/><a href="#locator-assertions-to-be-checked-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-checked-return"/><a href="#locator-assertions-to-be-checked-return" class="list-anchor">#</a>

---

### toBeDisabled {#locator-assertions-to-be-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toBeDisabled</x-search>

Убедитесь, что [Locator] указывает на отключенный элемент. Элемент считается отключенным, если у него есть атрибут "disabled" или он отключен через ['aria-disabled'](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-disabled). Обратите внимание, что только элементы управления, такие как HTML `button`, `input`, `select`, `textarea`, `option`, `optgroup`, могут быть отключены с помощью установки атрибута "disabled". Атрибут "disabled" на других элементах игнорируется браузером.

**Использование**

```js
const locator = page.locator('button.submit');
await expect(locator).toBeDisabled();
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-disabled-option-timeout"/><a href="#locator-assertions-to-be-disabled-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-disabled-return"/><a href="#locator-assertions-to-be-disabled-return" class="list-anchor">#</a>

---

### toBeEditable {#locator-assertions-to-be-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toBeEditable</x-search>

Убедитесь, что [Locator] указывает на редактируемый элемент.

**Использование**

```js
const locator = page.getByRole('textbox');
await expect(locator).toBeEditable();
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `editable` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.26</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-editable-option-editable"/><a href="#locator-assertions-to-be-editable-option-editable" class="list-anchor">#</a>
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-editable-option-timeout"/><a href="#locator-assertions-to-be-editable-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-editable-return"/><a href="#locator-assertions-to-be-editable-return" class="list-anchor">#</a>

---

### toBeEmpty {#locator-assertions-to-be-empty}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toBeEmpty</x-search>

Убедитесь, что [Locator] указывает на пустой редактируемый элемент или на DOM-узел, который не содержит текста.

**Использование**

```js
const locator = page.locator('div.warning');
await expect(locator).toBeEmpty();
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-empty-option-timeout"/><a href="#locator-assertions-to-be-empty-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-empty-return"/><a href="#locator-assertions-to-be-empty-return" class="list-anchor">#</a>

---

### toBeEnabled {#locator-assertions-to-be-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toBeEnabled</x-search>

Убедитесь, что [Locator] указывает на включенный элемент.

**Использование**

```js
const locator = page.locator('button.submit');
await expect(locator).toBeEnabled();
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `enabled` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.26</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-enabled-option-enabled"/><a href="#locator-assertions-to-be-enabled-option-enabled" class="list-anchor">#</a>
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-enabled-option-timeout"/><a href="#locator-assertions-to-be-enabled-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-enabled-return"/><a href="#locator-assertions-to-be-enabled-return" class="list-anchor">#</a>

---

### toBeFocused {#locator-assertions-to-be-focused}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toBeFocused</x-search>

Убедитесь, что [Locator] указывает на сфокусированный DOM-узел.

**Использование**

```js
const locator = page.getByRole('textbox');
await expect(locator).toBeFocused();
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-focused-option-timeout"/><a href="#locator-assertions-to-be-focused-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-focused-return"/><a href="#locator-assertions-to-be-focused-return" class="list-anchor">#</a>

---

### toBeHidden {#locator-assertions-to-be-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toBeHidden</x-search>

Убедитесь, что [Locator] либо не разрешается в какой-либо DOM-узел, либо разрешается в [невидимый](../actionability.mdx#visible) узел.

**Использование**

```js
const locator = page.locator('.my-element');
await expect(locator).toBeHidden();
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-hidden-option-timeout"/><a href="#locator-assertions-to-be-hidden-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-hidden-return"/><a href="#locator-assertions-to-be-hidden-return" class="list-anchor">#</a>

---

### toBeInViewport {#locator-assertions-to-be-in-viewport}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.31</font><x-search>locatorAssertions.toBeInViewport</x-search>

Убедитесь, что [Locator] указывает на элемент, который пересекает область просмотра, согласно [API наблюдателя пересечения](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).

**Использование**

```js
const locator = page.getByRole('button');
// Убедитесь, что хотя бы часть элемента пересекает область просмотра.
await expect(locator).toBeInViewport();
// Убедитесь, что элемент полностью вне области просмотра.
await expect(locator).not.toBeInViewport();
// Убедитесь, что хотя бы половина элемента пересекает область просмотра.
await expect(locator).toBeInViewport({ ratio: 0.5 });
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `ratio` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-in-viewport-option-ratio"/><a href="#locator-assertions-to-be-in-viewport-option-ratio" class="list-anchor">#</a>
    
    Минимальное соотношение элемента, пересекающего область просмотра. Если равно `0`, то элемент должен пересекать область просмотра при любом положительном соотношении. По умолчанию `0`.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-in-viewport-option-timeout"/><a href="#locator-assertions-to-be-in-viewport-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-in-viewport-return"/><a href="#locator-assertions-to-be-in-viewport-return" class="list-anchor">#</a>

---

### toBeVisible {#locator-assertions-to-be-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toBeVisible</x-search>

Убедитесь, что [Locator] указывает на прикрепленный и [видимый](../actionability.mdx#visible) DOM-узел.

Чтобы проверить, что хотя бы один элемент из списка видим, используйте [locator.first()](/api/class-locator.mdx#locator-first).

**Использование**

```js
// Конкретный элемент видим.
await expect(page.getByText('Добро пожаловать')).toBeVisible();

// По крайней мере один элемент в списке видим.
await expect(page.getByTestId('todo-item').first()).toBeVisible();

// По крайней мере один из двух элементов видим, возможно, оба.
await expect(
    page.getByRole('button', { name: 'Войти' })
        .or(page.getByRole('button', { name: 'Зарегистрироваться' }))
        .first()
).toBeVisible();
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-visible-option-timeout"/><a href="#locator-assertions-to-be-visible-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.
  - `visible` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.26</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-visible-option-visible"/><a href="#locator-assertions-to-be-visible-option-visible" class="list-anchor">#</a>

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-visible-return"/><a href="#locator-assertions-to-be-visible-return" class="list-anchor">#</a>

---

### toContainText {#locator-assertions-to-contain-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toContainText</x-search>

Убедитесь, что [Locator] указывает на элемент, который содержит заданный текст. Все вложенные элементы будут учитываться при вычислении текстового содержимого элемента. Вы также можете использовать регулярные выражения для значения.

**Использование**

```js
const locator = page.locator('.title');
await expect(locator).toContainText('подстрока');
await expect(locator).toContainText(/\d сообщения/);
```

Если вы передаете массив в качестве ожидаемого значения, ожидания следующие:
1. Locator разрешается в список элементов.
2. Количество элементов равно количеству ожидаемых значений в массиве.
3. Элементы из списка имеют текст, соответствующий значениям ожидаемого массива, по одному, в порядке.

Например, рассмотрим следующий список:

```html
<ul>
  <li>Текст элемента 1</li>
  <li>Текст элемента 2</li>
  <li>Текст элемента 3</li>
</ul>
```

Посмотрим, как мы можем использовать утверждение:

```js
// ✓ Содержит правильные элементы в правильном порядке
await expect(page.locator('ul > li')).toContainText(['Текст 1', 'Текст 3']);

// ✖ Неправильный порядок
await expect(page.locator('ul > li')).toContainText(['Текст 3', 'Текст 2']);

// ✖ Ни один элемент не содержит этот текст
await expect(page.locator('ul > li')).toContainText(['Некоторые 33']);

// ✖ Locator указывает на внешний элемент списка, а не на элементы списка
await expect(page.locator('ul')).toContainText(['Текст 3']);
```

**Аргументы**
- `expected` [string] | [RegExp] | [Array]&lt;[string] | [RegExp]&gt; <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-option-expected"/><a href="#locator-assertions-to-contain-text-option-expected" class="list-anchor">#</a>
  
  Ожидаемая подстрока или RegExp или список этих значений.
- `options` [Object] *(необязательно)*
  - `ignoreCase` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.23</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-option-ignore-case"/><a href="#locator-assertions-to-contain-text-option-ignore-case" class="list-anchor">#</a>
    
    Указывает, следует ли выполнять регистронезависимое сопоставление. Параметр [ignoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-option-timeout"/><a href="#locator-assertions-to-contain-text-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.
  - `useInnerText` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-option-use-inner-text"/><a href="#locator-assertions-to-contain-text-option-use-inner-text" class="list-anchor">#</a>
    
    Указывает, следует ли использовать `element.innerText` вместо `element.textContent` при получении текста узла DOM.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-return"/><a href="#locator-assertions-to-contain-text-return" class="list-anchor">#</a>

**Детали**

Когда параметр `expected` является строкой, Playwright нормализует пробелы и переносы строк как в фактическом тексте, так и в ожидаемой строке перед сопоставлением. Когда используется регулярное выражение, фактический текст сопоставляется как есть.

---

### toHaveAccessibleDescription {#locator-assertions-to-have-accessible-description}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.44</font><x-search>locatorAssertions.toHaveAccessibleDescription</x-search>

Убедитесь, что [Locator] указывает на элемент с заданным [доступным описанием](https://w3c.github.io/accname/#dfn-accessible-description).

**Использование**

```js
const locator = page.getByTestId('save-button');
await expect(locator).toHaveAccessibleDescription('Сохранить результаты на диск');
```

**Аргументы**
- `description` [string] | [RegExp]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-description-option-description"/><a href="#locator-assertions-to-have-accessible-description-option-description" class="list-anchor">#</a>
  
  Ожидаемое доступное описание.
- `options` [Object] *(необязательно)*
  - `ignoreCase` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-description-option-ignore-case"/><a href="#locator-assertions-to-have-accessible-description-option-ignore-case" class="list-anchor">#</a>
    
    Указывает, следует ли выполнять регистронезависимое сопоставление. Параметр [ignoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-description-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-description-option-timeout"/><a href="#locator-assertions-to-have-accessible-description-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-description-return"/><a href="#locator-assertions-to-have-accessible-description-return" class="list-anchor">#</a>

---

### toHaveAccessibleErrorMessage {#locator-assertions-to-have-accessible-error-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.50</font><x-search>locatorAssertions.toHaveAccessibleErrorMessage</x-search>

Убедитесь, что [Locator] указывает на элемент с заданным [aria errormessage](https://w3c.github.io/aria/#aria-errormessage).

**Использование**

```js
const locator = page.getByTestId('username-input');
await expect(locator).toHaveAccessibleErrorMessage('Имя пользователя обязательно.');
```

**Аргументы**
- `errorMessage` [string] | [RegExp]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-error-message-option-error-message"/><a href="#locator-assertions-to-have-accessible-error-message-option-error-message" class="list-anchor">#</a>
  
  Ожидаемое доступное сообщение об ошибке.
- `options` [Object] *(необязательно)*
  - `ignoreCase` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-error-message-option-ignore-case"/><a href="#locator-assertions-to-have-accessible-error-message-option-ignore-case" class="list-anchor">#</a>
    
    Указывает, следует ли выполнять регистронезависимое сопоставление. Параметр [ignoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-error-message-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-error-message-option-timeout"/><a href="#locator-assertions-to-have-accessible-error-message-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-error-message-return"/><a href="#locator-assertions-to-have-accessible-error-message-return" class="list-anchor">#</a>

---

### toHaveAccessibleName {#locator-assertions-to-have-accessible-name}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.44</font><x-search>locatorAssertions.toHaveAccessibleName</x-search>

Убедитесь, что [Locator] указывает на элемент с заданным [доступным именем](https://w3c.github.io/accname/#dfn-accessible-name).

**Использование**

```js
const locator = page.getByTestId('save-button');
await expect(locator).toHaveAccessibleName('Сохранить на диск');
```

**Аргументы**
- `name` [string] | [RegExp]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-name-option-name"/><a href="#locator-assertions-to-have-accessible-name-option-name" class="list-anchor">#</a>
  
  Ожидаемое доступное имя.
- `options` [Object] *(необязательно)*
  - `ignoreCase` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-name-option-ignore-case"/><a href="#locator-assertions-to-have-accessible-name-option-ignore-case" class="list-anchor">#</a>
    
    Указывает, следует ли выполнять регистронезависимое сопоставление. Параметр [ignoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-name-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-name-option-timeout"/><a href="#locator-assertions-to-have-accessible-name-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-name-return"/><a href="#locator-assertions-to-have-accessible-name-return" class="list-anchor">#</a>

---

### toHaveAttribute(name, value) {#locator-assertions-to-have-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toHaveAttribute(name, value)</x-search>

Убедитесь, что [Locator] указывает на элемент с заданным атрибутом.

**Использование**

```js
const locator = page.locator('input');
await expect(locator).toHaveAttribute('type', 'text');
```

**Аргументы**
- `name` [string] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-option-name"/><a href="#locator-assertions-to-have-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута.
- `value` [string] | [RegExp] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-option-value"/><a href="#locator-assertions-to-have-attribute-option-value" class="list-anchor">#</a>
  
  Ожидаемое значение атрибута.
- `options` [Object] *(необязательно)*
  - `ignoreCase` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-option-ignore-case"/><a href="#locator-assertions-to-have-attribute-option-ignore-case" class="list-anchor">#</a>
    
    Указывает, следует ли выполнять регистронезависимое сопоставление. Параметр [ignoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-attribute-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-option-timeout"/><a href="#locator-assertions-to-have-attribute-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-return"/><a href="#locator-assertions-to-have-attribute-return" class="list-anchor">#</a>

---

### toHaveAttribute(name) {#locator-assertions-to-have-attribute-2}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.39</font><x-search>locatorAssertions.toHaveAttribute(name)</x-search>

Убедитесь, что [Locator] указывает на элемент с заданным атрибутом. Метод будет утверждать наличие атрибута.

```js
const locator = page.locator('input');
// Утверждение существования атрибута.
await expect(locator).toHaveAttribute('disabled');
await expect(locator).not.toHaveAttribute('open');
```

**Использование**

```js
await expect(locator).toHaveAttribute(name);
await expect(locator).toHaveAttribute(name, options);
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-2-option-name"/><a href="#locator-assertions-to-have-attribute-2-option-name" class="list-anchor">#</a>
  
  Имя атрибута.
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-2-option-timeout"/><a href="#locator-assertions-to-have-attribute-2-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-2-return"/><a href="#locator-assertions-to-have-attribute-2-return" class="list-anchor">#</a>

---

### toHaveClass {#locator-assertions-to-have-class}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toHaveClass</x-search>

Убедитесь, что [Locator] указывает на элемент с заданными CSS-классами. Когда передается строка, она должна полностью соответствовать атрибуту `class` элемента. Чтобы сопоставить отдельные классы или выполнить частичное сопоставление, используйте регулярное выражение:

**Использование**

```html
<div class='middle selected row' id='component'></div>
```

```js
const locator = page.locator('#component');
await expect(locator).toHaveClass('middle selected row');
await expect(locator).toHaveClass(/(^|\s)selected(\s|$)/);
```

Когда передается массив, метод утверждает, что список расположенных элементов соответствует соответствующему списку ожидаемых значений классов. Атрибут класса каждого элемента сопоставляется с соответствующей строкой или регулярным выражением в массиве:

```js
const locator = page.locator('list > .component');
await expect(locator).toHaveClass(['component', 'component selected', 'component']);
```

**Аргументы**
- `expected` [string] | [RegExp] | [Array]&lt;[string] | [RegExp]&gt; <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-class-option-expected"/><a href="#locator-assertions-to-have-class-option-expected" class="list-anchor">#</a>
  
  Ожидаемый класс или RegExp или список этих значений.
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-class-option-timeout"/><a href="#locator-assertions-to-have-class-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-class-return"/><a href="#locator-assertions-to-have-class-return" class="list-anchor">#</a>

---

### toHaveCount {#locator-assertions-to-have-count}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toHaveCount</x-search>

Убедитесь, что [Locator] разрешается в точное количество DOM-узлов.

**Использование**

```js
const list = page.locator('list > .component');
await expect(list).toHaveCount(3);
```

**Аргументы**
- `count` [number] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-count-option-count"/><a href="#locator-assertions-to-have-count-option-count" class="list-anchor">#</a>
  
  Ожидаемое количество.
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-count-option-timeout"/><a href="#locator-assertions-to-have-count-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-count-return"/><a href="#locator-assertions-to-have-count-return" class="list-anchor">#</a>

---

### toHaveCSS {#locator-assertions-to-have-css}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toHaveCSS</x-search>

Убедитесь, что [Locator] разрешается в элемент с заданным вычисленным CSS-стилем.

**Использование**

```js
const locator = page.getByRole('button');
await expect(locator).toHaveCSS('display', 'flex');
```

**Аргументы**
- `name` [string] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-css-option-name"/><a href="#locator-assertions-to-have-css-option-name" class="list-anchor">#</a>
  
  Имя CSS-свойства.
- `value` [string] | [RegExp] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-css-option-value"/><a href="#locator-assertions-to-have-css-option-value" class="list-anchor">#</a>
  
  Значение CSS-свойства.
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-css-option-timeout"/><a href="#locator-assertions-to-have-css-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-css-return"/><a href="#locator-assertions-to-have-css-return" class="list-anchor">#</a>

---

### toHaveId {#locator-assertions-to-have-id}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toHaveId</x-search>

Убедитесь, что [Locator] указывает на элемент с заданным идентификатором DOM-узла.

**Использование**

```js
const locator = page.getByRole('textbox');
await expect(locator).toHaveId('lastname');
```

**Аргументы**
- `id` [string] | [RegExp] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-id-option-id"/><a href="#locator-assertions-to-have-id-option-id" class="list-anchor">#</a>
  
  Идентификатор элемента.
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-id-option-timeout"/><a href="#locator-assertions-to-have-id-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-id-return"/><a href="#locator-assertions-to-have-id-return" class="list-anchor">#</a>

---

### toHaveJSProperty {#locator-assertions-to-have-js-property}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toHaveJSProperty</x-search>

Убедитесь, что [Locator] указывает на элемент с заданным свойством JavaScript. Обратите внимание, что это свойство может быть примитивного типа, а также обычным сериализуемым объектом JavaScript.

**Использование**

```js
const locator = page.locator('.component');
await expect(locator).toHaveJSProperty('loaded', true);
```

**Аргументы**
- `name` [string] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-js-property-option-name"/><a href="#locator-assertions-to-have-js-property-option-name" class="list-anchor">#</a>
  
  Имя свойства.
- `value` [Object] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-js-property-option-value"/><a href="#locator-assertions-to-have-js-property-option-value" class="list-anchor">#</a>
  
  Значение свойства.
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-js-property-option-timeout"/><a href="#locator-assertions-to-have-js-property-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-js-property-return"/><a href="#locator-assertions-to-have-js-property-return" class="list-anchor">#</a>

---

### toHaveRole {#locator-assertions-to-have-role}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.44</font><x-search>locatorAssertions.toHaveRole</x-search>

Убедитесь, что [Locator] указывает на элемент с заданной [ARIA ролью](https://www.w3.org/TR/wai-aria-1.2/#roles).

Обратите внимание, что роль сопоставляется как строка, игнорируя иерархию ARIA ролей. Например, утверждение о суперклассе роли `"checkbox"` на элементе с подклассом роли `"switch"` завершится неудачей.

**Использование**

```js
const locator = page.getByTestId('save-button');
await expect(locator).toHaveRole('button');
```

**Аргументы**
- `role` "alert" | "alertdialog" | "application" | "article" | "banner" | "blockquote" | "button" | "caption" | "cell" | "checkbox" | "code" | "columnheader" | "combobox" | "complementary" | "contentinfo" | "definition" | "deletion" | "dialog" | "directory" | "document" | "emphasis" | "feed" | "figure" | "form" | "generic" | "grid" | "gridcell" | "group" | "heading" | "img" | "insertion" | "link" | "list" | "listbox" | "listitem" | "log" | "main" | "marquee" | "math" | "meter" | "menu" | "menubar" | "menuitem" | "menuitemcheckbox" | "menuitemradio" | "navigation" | "none" | "note" | "option" | "paragraph" | "presentation" | "progressbar" | "radio" | "radiogroup" | "region" | "row" | "rowgroup" | "rowheader" | "scrollbar" | "search" | "searchbox" | "separator" | "slider" | "spinbutton" | "status" | "strong" | "subscript" | "superscript" | "switch" | "tab" | "table" | "tablist" | "tabpanel" | "term" | "textbox" | "time" | "timer" | "toolbar" | "tooltip" | "tree" | "treegrid" | "treeitem"<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-role-option-role"/><a href="#locator-assertions-to-have-role-option-role" class="list-anchor">#</a>
  
  Обязательная aria роль.
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-role-option-timeout"/><a href="#locator-assertions-to-have-role-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-role-return"/><a href="#locator-assertions-to-have-role-return" class="list-anchor">#</a>

---

### toHaveScreenshot(name) {#locator-assertions-to-have-screenshot-1}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>locatorAssertions.toHaveScreenshot(name)</x-search>

Эта функция будет ждать, пока два последовательных скриншота локатора не дадут одинаковый результат, а затем сравнит последний скриншот с ожиданием.

**Использование**

```js
const locator = page.getByRole('button');
await expect(locator).toHaveScreenshot('image.png');
```

Обратите внимание, что утверждения скриншотов работают только с тестовым раннером Playwright.

**Аргументы**
- `name` [string] | [Array]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-name"/><a href="#locator-assertions-to-have-screenshot-1-option-name" class="list-anchor">#</a>
  
  Имя снимка.
- `options` [Object] *(необязательно)*
  - `animations` "disabled" | "allow" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-animations"/><a href="#locator-assertions-to-have-screenshot-1-option-animations" class="list-anchor">#</a>
    
    Если установить в `"disabled"`, останавливает CSS-анимации, CSS-переходы и веб-анимации. Анимации обрабатываются по-разному в зависимости от их продолжительности:
    * конечные анимации ускоряются до завершения, чтобы они вызвали событие `transitionend`.
    * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся после скриншота.
    
    По умолчанию `"disabled"`, что отключает анимации.
  - `caret` "hide" | "initial" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-caret"/><a href="#locator-assertions-to-have-screenshot-1-option-caret" class="list-anchor">#</a>
    
    Если установить в `"hide"`, скриншот скроет текстовый курсор. Если установить в `"initial"`, поведение текстового курсора не изменится.  По умолчанию `"hide"`.
  - `mask` [Array]&lt;[Locator]&gt; *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-mask"/><a href="#locator-assertions-to-have-screenshot-1-option-mask" class="list-anchor">#</a>
    
    Укажите локаторы, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут перекрыты розовым квадратом `#FF00FF` (настраиваемым с помощью [maskColor](/api/class-locatorassertions.mdx#locator-assertions-to-have-screenshot-1-option-mask-color)), который полностью покрывает его ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Сопоставление только видимых элементов](../locators.mdx#matching-only-visible-elements), чтобы отключить это.
  - `maskColor` [string] *(необязательно)* <font size="2">Добавлено в: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-mask-color"/><a href="#locator-assertions-to-have-screenshot-1-option-mask-color" class="list-anchor">#</a>
    
    Укажите цвет наложения для замаскированных элементов в [формате цвета CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию - розовый `#FF00FF`.
  - `maxDiffPixelRatio` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-max-diff-pixel-ratio"/><a href="#locator-assertions-to-have-screenshot-1-option-max-diff-pixel-ratio" class="list-anchor">#</a>
    
    Допустимое соотношение пикселей, которые отличаются от общего количества пикселей, между `0` и `1`. По умолчанию настраивается с помощью `TestConfig.expect`. По умолчанию не установлено.
  - `maxDiffPixels` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-max-diff-pixels"/><a href="#locator-assertions-to-have-screenshot-1-option-max-diff-pixels" class="list-anchor">#</a>
    
    Допустимое количество пикселей, которые могут отличаться. По умолчанию настраивается с помощью `TestConfig.expect`. По умолчанию не установлено.
  - `omitBackground` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-omit-background"/><a href="#locator-assertions-to-have-screenshot-1-option-omit-background" class="list-anchor">#</a>
    
    Скрывает белый фон по умолчанию и позволяет делать скриншоты с прозрачностью. Не применяется к изображениям `jpeg`. По умолчанию `false`.
  - `scale` "css" | "device" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-scale"/><a href="#locator-assertions-to-have-screenshot-1-option-scale" class="list-anchor">#</a>
    
    Если установить в `"css"`, скриншот будет иметь один пиксель на каждый CSS-пиксель на странице. Для устройств с высоким разрешением это позволит сохранить скриншоты небольшими. Использование параметра `"device"` создаст один пиксель на каждый пиксель устройства, поэтому скриншоты для устройств с высоким разрешением будут в два раза больше или даже больше.
    
    По умолчанию `"css"`.
  - `stylePath` [string] | [Array]&lt;[string]&gt; *(необязательно)* <font size="2">Добавлено в: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-style-path"/><a href="#locator-assertions-to-have-screenshot-1-option-style-path" class="list-anchor">#</a>
    
    Имя файла, содержащего таблицу стилей, которую следует применить при создании скриншота. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создавать повторяемые скриншоты. Эта таблица стилей проникает в Shadow DOM и применяется к внутренним фреймам.
  - `threshold` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-threshold"/><a href="#locator-assertions-to-have-screenshot-1-option-threshold" class="list-anchor">#</a>
    
    Допустимая воспринимаемая разница в цвете в [цветовом пространстве YIQ](https://en.wikipedia.org/wiki/YIQ) между одним и тем же пикселем в сравниваемых изображениях, от нуля (строго) до одного (свободно), по умолчанию настраивается с помощью `TestConfig.expect`. По умолчанию `0.2`.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-option-timeout"/><a href="#locator-assertions-to-have-screenshot-1-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-1-return"/><a href="#locator-assertions-to-have-screenshot-1-return" class="list-anchor">#</a>

---

### toHaveScreenshot(options) {#locator-assertions-to-have-screenshot-2}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>locatorAssertions.toHaveScreenshot(options)</x-search>

Эта функция будет ждать, пока два последовательных скриншота локатора не дадут одинаковый результат, а затем сравнит последний скриншот с ожиданием.

**Использование**

```js
const locator = page.getByRole('button');
await expect(locator).toHaveScreenshot();
```

Обратите внимание, что утверждения скриншотов работают только с тестовым раннером Playwright.

**Аргументы**
- `options` [Object] *(необязательно)*
  - `animations` "disabled" | "allow" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-animations"/><a href="#locator-assertions-to-have-screenshot-2-option-animations" class="list-anchor">#</a>
    
    Если установить в `"disabled"`, останавливает CSS-анимации, CSS-переходы и веб-анимации. Анимации обрабатываются по-разному в зависимости от их продолжительности:
    * конечные анимации ускоряются до завершения, чтобы они вызвали событие `transitionend`.
    * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся после скриншота.
    
    По умолчанию `"disabled"`, что отключает анимации.
  - `caret` "hide" | "initial" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-caret"/><a href="#locator-assertions-to-have-screenshot-2-option-caret" class="list-anchor">#</a>
    
    Если установить в `"hide"`, скриншот скроет текстовый курсор. Если установить в `"initial"`, поведение текстового курсора не изменится.  По умолчанию `"hide"`.
  - `mask` [Array]&lt;[Locator]&gt; *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-mask"/><a href="#locator-assertions-to-have-screenshot-2-option-mask" class="list-anchor">#</a>
    
    Укажите локаторы, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут перекрыты розовым квадратом `#FF00FF` (настраиваемым с помощью [maskColor](/api/class-locatorassertions.mdx#locator-assertions-to-have-screenshot-2-option-mask-color)), который полностью покрывает его ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Сопоставление только видимых элементов](../locators.mdx#matching-only-visible-elements), чтобы отключить это.
  - `maskColor` [string] *(необязательно)* <font size="2">Добавлено в: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-mask-color"/><a href="#locator-assertions-to-have-screenshot-2-option-mask-color" class="list-anchor">#</a>
    
    Укажите цвет наложения для замаскированных элементов в [формате цвета CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию - розовый `#FF00FF`.
  - `maxDiffPixelRatio` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-max-diff-pixel-ratio"/><a href="#locator-assertions-to-have-screenshot-2-option-max-diff-pixel-ratio" class="list-anchor">#</a>
    
    Допустимое соотношение пикселей, которые отличаются от общего количества пикселей, между `0` и `1`. По умолчанию настраивается с помощью `TestConfig.expect`. По умолчанию не установлено.
  - `maxDiffPixels` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-max-diff-pixels"/><a href="#locator-assertions-to-have-screenshot-2-option-max-diff-pixels" class="list-anchor">#</a>
    
    Допустимое количество пикселей, которые могут отличаться. По умолчанию настраивается с помощью `TestConfig.expect`. По умолчанию не установлено.
  - `omitBackground` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-omit-background"/><a href="#locator-assertions-to-have-screenshot-2-option-omit-background" class="list-anchor">#</a>
    
    Скрывает белый фон по умолчанию и позволяет делать скриншоты с прозрачностью. Не применяется к изображениям `jpeg`. По умолчанию `false`.
  - `scale` "css" | "device" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-scale"/><a href="#locator-assertions-to-have-screenshot-2-option-scale" class="list-anchor">#</a>
    
    Если установить в `"css"`, скриншот будет иметь один пиксель на каждый CSS-пиксель на странице. Для устройств с высоким разрешением это позволит сохранить скриншоты небольшими. Использование параметра `"device"` создаст один пиксель на каждый пиксель устройства, поэтому скриншоты для устройств с высоким разрешением будут в два раза больше или даже больше.
    
    По умолчанию `"css"`.
  - `stylePath` [string] | [Array]&lt;[string]&gt; *(необязательно)* <font size="2">Добавлено в: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-style-path"/><a href="#locator-assertions-to-have-screenshot-2-option-style-path" class="list-anchor">#</a>
    
    Имя файла, содержащего таблицу стилей, которую следует применить при создании скриншота. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создавать повторяемые скриншоты. Эта таблица стилей проникает в Shadow DOM и применяется к внутренним фреймам.
  - `threshold` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-threshold"/><a href="#locator-assertions-to-have-screenshot-2-option-threshold" class="list-anchor">#</a>
    
    Допустимая воспринимаемая разница в цвете в [цветовом пространстве YIQ](https://en.wikipedia.org/wiki/YIQ) между одним и тем же пикселем в сравниваемых изображениях, от нуля (строго) до одного (свободно), по умолчанию настраивается с помощью `TestConfig.expect`. По умолчанию `0.2`.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-option-timeout"/><a href="#locator-assertions-to-have-screenshot-2-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-screenshot-2-return"/><a href="#locator-assertions-to-have-screenshot-2-return" class="list-anchor">#</a>

---

### toHaveText {#locator-assertions-to-have-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toHaveText</x-search>

Убедитесь, что [Locator] указывает на элемент с заданным текстом. Все вложенные элементы будут учитываться при вычислении текстового содержимого элемента. Вы также можете использовать регулярные выражения для значения.

**Использование**

```js
const locator = page.locator('.title');
await expect(locator).toHaveText(/Добро пожаловать, Тестовый пользователь/);
await expect(locator).toHaveText(/Добро пожаловать, .*/);
```

Если вы передаете массив в качестве ожидаемого значения, ожидания следующие:
1. Locator разрешается в список элементов.
2. Количество элементов равно количеству ожидаемых значений в массиве.
3. Элементы из списка имеют текст, соответствующий значениям ожидаемого массива, по одному, в порядке.

Например, рассмотрим следующий список:

```html
<ul>
  <li>Текст 1</li>
  <li>Текст 2</li>
  <li>Текст 3</li>
</ul>
```

Посмотрим, как мы можем использовать утверждение:

```js
// ✓ Имеет правильные элементы в правильном порядке
await expect(page.locator('ul > li')).toHaveText(['Текст 1', 'Текст 2', 'Текст 3']);

// ✖ Неправильный порядок
await expect(page.locator('ul > li')).toHaveText(['Текст 3', 'Текст 2', 'Текст 1']);

// ✖ Последний элемент не соответствует
await expect(page.locator('ul > li')).toHaveText(['Текст 1', 'Текст 2', 'Текст']);

// ✖ Locator указывает на внешний элемент списка, а не на элементы списка
await expect(page.locator('ul')).toHaveText(['Текст 1', 'Текст 2', 'Текст 3']);
```

**Аргументы**
- `expected` [string] | [RegExp] | [Array]&lt;[string] | [RegExp]&gt; <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-option-expected"/><a href="#locator-assertions-to-have-text-option-expected" class="list-anchor">#</a>
  
  Ожидаемая строка или RegExp или список этих значений.
- `options` [Object] *(необязательно)*
  - `ignoreCase` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.23</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-option-ignore-case"/><a href="#locator-assertions-to-have-text-option-ignore-case" class="list-anchor">#</a>
    
    Указывает, следует ли выполнять регистронезависимое сопоставление. Параметр [ignoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-text-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `timeout` [number] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-option-timeout"/><a href="#locator-assertions-to-have-text-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `timeout` в `TestConfig.expect`.
  - `useInnerText` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-option-use-inner-text"/><a href="#locator-assertions-to-have-text-option-use-inner-text" class="list-anchor">#</a>
    
    Указывает, следует ли использовать `element.innerText` вместо `element.textContent` при получении текста узла DOM.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-return"/><a href="#locator-assertions-to-have-text-return" class="list-anchor">#</a>

**Детали**

Когда параметр `expected` является строкой, Playwright нормализует пробелы и переносы строк как в фактическом тексте, так и в ожидаемой строке перед сопоставлением. Когда используется регулярное выражение, фактический текст сопоставляется как есть.

---

### toHaveValue {#locator-assertions-to-have-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.toHaveValue</x-search>

Убедитесь, что [Locator] указывает на элемент с заданным значением ввода. Вы также можете использовать регулярные выражения для значения.

**Использование**

```js
const locator = page.locator('input[type=number]');
await expect(locator).toHaveValue(/[0-9]/);
```

**Аргументы**
