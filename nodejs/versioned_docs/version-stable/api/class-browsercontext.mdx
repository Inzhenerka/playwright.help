---
id: class-browsercontext
title: "BrowserContext"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

BrowserContexts предоставляют способ работы с несколькими независимыми сессиями браузера.

Если страница открывает другую страницу, например, с помощью вызова `window.open`, всплывающее окно будет принадлежать контексту браузера родительской страницы.

Playwright позволяет создавать изолированные непостоянные контексты браузера с помощью метода [browser.newContext()](/api/class-browser.mdx#browser-new-context). Непостоянные контексты браузера не записывают данные о просмотре на диск.

```js
// Создать новый инкогнито контекст браузера
const context = await browser.newContext();
// Создать новую страницу внутри контекста.
const page = await context.newPage();
await page.goto('https://example.com');
// Освободить контекст, когда он больше не нужен.
await context.close();
```

---

## Методы

### addCookies {#browser-context-add-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.addCookies</x-search>

Добавляет куки в этот контекст браузера. Все страницы в этом контексте будут иметь установленные куки. Куки можно получить с помощью [browserContext.cookies()](/api/class-browsercontext.mdx#browser-context-cookies).

**Использование**

```js
await browserContext.addCookies([cookieObject1, cookieObject2]);
```

**Аргументы**
- `cookies` [Array]&lt;[Object]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-option-cookies"/><a href="#browser-context-add-cookies-option-cookies" class="list-anchor">#</a>
  - `name` [string]
    
  - `value` [string]
    
  - `url` [string] *(опционально)*
    
    Либо url, либо домен / путь обязательны. Опционально.
  - `domain` [string] *(опционально)*
    
    Чтобы куки применялись ко всем поддоменам, префиксируйте домен точкой, например: ".example.com". Либо url, либо домен / путь обязательны. Опционально.
  - `path` [string] *(опционально)*
    
    Либо url, либо домен / путь обязательны. Опционально.
  - `expires` [number] *(опционально)*
    
    Unix время в секундах. Опционально.
  - `httpOnly` [boolean] *(опционально)*
    
    Опционально.
  - `secure` [boolean] *(опционально)*
    
    Опционально.
  - `sameSite` "Strict" | "Lax" | "None" *(опционально)*
    
    Опционально.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-return"/><a href="#browser-context-add-cookies-return" class="list-anchor">#</a>

---

### addInitScript {#browser-context-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.addInitScript</x-search>

Добавляет скрипт, который будет оцениваться в одном из следующих сценариев:
* Каждый раз, когда страница создается в контексте браузера или навигируется.
* Каждый раз, когда дочерний фрейм прикрепляется или навигируется на любой странице в контексте браузера. В этом случае скрипт оценивается в контексте вновь прикрепленного фрейма.

Скрипт оценивается после создания документа, но до выполнения любых его скриптов. Это полезно для изменения JavaScript окружения, например, для инициализации `Math.random`.

**Использование**

Пример переопределения `Math.random` перед загрузкой страницы:

```js
// preload.js
Math.random = () => 42;
```

```js
// В вашем скрипте playwright, предполагая, что файл preload.js находится в той же директории.
await browserContext.addInitScript({
  path: 'preload.js'
});
```

:::note
Порядок оценки нескольких скриптов, установленных через [browserContext.addInitScript()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [page.addInitScript()](/api/class-page.mdx#page-add-init-script), не определен.
:::

**Аргументы**
- `script` [function] | [string] | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-option-script"/><a href="#browser-context-add-init-script-option-script" class="list-anchor">#</a>
  - `path` [string] *(опционально)*
    
    Путь к JavaScript файлу. Если `path` является относительным путем, он разрешается относительно текущей рабочей директории. Опционально.
  - `content` [string] *(опционально)*
    
    Содержимое скрипта. Опционально.
  
  Скрипт, который будет оцениваться на всех страницах в контексте браузера.
- `arg` [Serializable] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-option-arg"/><a href="#browser-context-add-init-script-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент, который передается в [script](/api/class-browsercontext.mdx#browser-context-add-init-script-option-script) (поддерживается только при передаче функции).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-return"/><a href="#browser-context-add-init-script-return" class="list-anchor">#</a>

---

### backgroundPages {#browser-context-background-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.backgroundPages</x-search>

:::note

Фоновая страница поддерживается только в браузерах на основе Chromium.
:::

Все существующие фоновые страницы в контексте.

**Использование**

```js
browserContext.backgroundPages();
```

**Возвращает**
- [Array]&lt;[Page]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-background-pages-return"/><a href="#browser-context-background-pages-return" class="list-anchor">#</a>

---

### browser {#browser-context-browser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.browser</x-search>

Возвращает экземпляр браузера контекста. Если он был запущен как постоянный контекст, возвращается null.

**Использование**

```js
browserContext.browser();
```

**Возвращает**
- [null] | [Browser]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-browser-return"/><a href="#browser-context-browser-return" class="list-anchor">#</a>

---

### clearCookies {#browser-context-clear-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.clearCookies</x-search>

Удаляет куки из контекста. Принимает опциональный фильтр.

**Использование**

```js
await context.clearCookies();
await context.clearCookies({ name: 'session-id' });
await context.clearCookies({ domain: 'my-origin.com' });
await context.clearCookies({ domain: /.*my-origin\.com/ });
await context.clearCookies({ path: '/api/v1' });
await context.clearCookies({ name: 'session-id', domain: 'my-origin.com' });
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `domain` [string] | [RegExp] *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-domain"/><a href="#browser-context-clear-cookies-option-domain" class="list-anchor">#</a>
    
    Удаляет только куки с указанным доменом.
  - `name` [string] | [RegExp] *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-name"/><a href="#browser-context-clear-cookies-option-name" class="list-anchor">#</a>
    
    Удаляет только куки с указанным именем.
  - `path` [string] | [RegExp] *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-path"/><a href="#browser-context-clear-cookies-option-path" class="list-anchor">#</a>
    
    Удаляет только куки с указанным путем.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-return"/><a href="#browser-context-clear-cookies-return" class="list-anchor">#</a>

---

### clearPermissions {#browser-context-clear-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.clearPermissions</x-search>

Очищает все переопределения разрешений для контекста браузера.

**Использование**

```js
const context = await browser.newContext();
await context.grantPermissions(['clipboard-read']);
// выполняем действия ..
context.clearPermissions();
```

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-permissions-return"/><a href="#browser-context-clear-permissions-return" class="list-anchor">#</a>

---

### close {#browser-context-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.close</x-search>

Закрывает контекст браузера. Все страницы, принадлежащие контексту браузера, будут закрыты.

:::note

Контекст браузера по умолчанию не может быть закрыт.
:::

**Использование**

```js
await browserContext.close();
await browserContext.close(options);
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `reason` [string] *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-option-reason"/><a href="#browser-context-close-option-reason" class="list-anchor">#</a>
    
    Причина, которая будет сообщена о действиях, прерванных закрытием контекста.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-return"/><a href="#browser-context-close-return" class="list-anchor">#</a>

---

### cookies {#browser-context-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.cookies</x-search>

Если URL не указан, этот метод возвращает все куки. Если указаны URL, возвращаются только куки, которые влияют на эти URL.

**Использование**

```js
await browserContext.cookies();
await browserContext.cookies(urls);
```

**Аргументы**
- `urls` [string] | [Array]&lt;[string]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-option-urls"/><a href="#browser-context-cookies-option-urls" class="list-anchor">#</a>
  
  Опциональный список URL.

**Возвращает**
- [Promise]&lt;[Array]&lt;[Object]&gt;&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-return"/><a href="#browser-context-cookies-return" class="list-anchor">#</a>
  - `name` [string]
    
  - `value` [string]
    
  - `domain` [string]
    
  - `path` [string]
    
  - `expires` [number]
    
    Unix время в секундах.
  - `httpOnly` [boolean]
    
  - `secure` [boolean]
    
  - `sameSite` "Strict" | "Lax" | "None"
    
---

### exposeBinding {#browser-context-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.exposeBinding</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-binding-option-name) на объекте `window` каждого фрейма на каждой странице в контексте. При вызове функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback). Если [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) содержит информацию о вызывающем: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

Смотрите [page.exposeBinding()](/api/class-page.mdx#page-expose-binding) для версии только для страницы.

**Использование**

Пример экспонирования URL страницы для всех фреймов на всех страницах в контексте:

```js
const { webkit } = require('playwright');  // Или 'chromium', или 'firefox'.

(async () => {
  const browser = await webkit.launch({ headless: false });
  const context = await browser.newContext();
  await context.exposeBinding('pageURL', ({ page }) => page.url());
  const page = await context.newPage();
  await page.setContent(`
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Нажми меня</button>
    <div></div>
  `);
  await page.getByRole('button').click();
})();
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-name"/><a href="#browser-context-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции на объекте window.
- `callback` [function]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-callback"/><a href="#browser-context-expose-binding-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.
- `options` [Object] *(опционально)*
  - `handle` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-handle"/><a href="#browser-context-expose-binding-option-handle" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция будет удалена в будущем.
    :::
    
    Указывает, следует ли передавать аргумент как дескриптор, вместо передачи по значению. При передаче дескриптора поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-return"/><a href="#browser-context-expose-binding-return" class="list-anchor">#</a>

---

### exposeFunction {#browser-context-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.exposeFunction</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-function-option-name) на объекте `window` каждого фрейма на каждой странице в контексте. При вызове функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback).

Если [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) возвращает [Promise], он будет ожидаться.

Смотрите [page.exposeFunction()](/api/class-page.mdx#page-expose-function) для версии только для страницы.

**Использование**

Пример добавления функции `sha256` ко всем страницам в контексте:

```js
const { webkit } = require('playwright');  // Или 'chromium', или 'firefox'.
const crypto = require('crypto');

(async () => {
  const browser = await webkit.launch({ headless: false });
  const context = await browser.newContext();
  await context.exposeFunction('sha256', text =>
    crypto.createHash('sha256').update(text).digest('hex'),
  );
  const page = await context.newPage();
  await page.setContent(`
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
      }
    </script>
    <button onclick="onClick()">Нажми меня</button>
    <div></div>
  `);
  await page.getByRole('button').click();
})();
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-name"/><a href="#browser-context-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции на объекте window.
- `callback` [function]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-callback"/><a href="#browser-context-expose-function-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-return"/><a href="#browser-context-expose-function-return" class="list-anchor">#</a>

---

### grantPermissions {#browser-context-grant-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.grantPermissions</x-search>

Предоставляет указанные разрешения контексту браузера. Предоставляет соответствующие разрешения для указанного источника, если он указан.

**Использование**

```js
await browserContext.grantPermissions(permissions);
await browserContext.grantPermissions(permissions, options);
```

**Аргументы**
- `permissions` [Array]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-permissions"/><a href="#browser-context-grant-permissions-option-permissions" class="list-anchor">#</a>
  
  Список разрешений для предоставления.
  
  :::danger
  
  Поддерживаемые разрешения различаются между браузерами и даже между разными версиями одного и того же браузера. Любое разрешение может перестать работать после обновления.
  :::
  
  Вот некоторые разрешения, которые могут поддерживаться некоторыми браузерами:
  * `'accelerometer'`
  * `'ambient-light-sensor'`
  * `'background-sync'`
  * `'camera'`
  * `'clipboard-read'`
  * `'clipboard-write'`
  * `'geolocation'`
  * `'gyroscope'`
  * `'magnetometer'`
  * `'microphone'`
  * `'midi-sysex'` (системно-эксклюзивный midi)
  * `'midi'`
  * `'notifications'`
  * `'payment-handler'`
  * `'storage-access'`
- `options` [Object] *(опционально)*
  - `origin` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-origin"/><a href="#browser-context-grant-permissions-option-origin" class="list-anchor">#</a>
    
    [origin], для которого предоставляются разрешения, например, "https://example.com".

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-return"/><a href="#browser-context-grant-permissions-return" class="list-anchor">#</a>

---

### newCDPSession {#browser-context-new-cdp-session}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.newCDPSession</x-search>

:::note

CDP-сессии поддерживаются только в браузерах на основе Chromium.
:::

Возвращает вновь созданную сессию.

**Использование**

```js
await browserContext.newCDPSession(page);
```

**Аргументы**
- `page` [Page] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-option-page"/><a href="#browser-context-new-cdp-session-option-page" class="list-anchor">#</a>
  
  Цель для создания новой сессии. Для обратной совместимости этот параметр называется `page`, но он может быть типа `Page` или `Frame`.

**Возвращает**
- [Promise]&lt;[CDPSession]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-return"/><a href="#browser-context-new-cdp-session-return" class="list-anchor">#</a>

---

### newPage {#browser-context-new-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.newPage</x-search>

Создает новую страницу в контексте браузера.

**Использование**

```js
await browserContext.newPage();
```

**Возвращает**
- [Promise]&lt;[Page]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-page-return"/><a href="#browser-context-new-page-return" class="list-anchor">#</a>

---

### pages {#browser-context-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.pages</x-search>

Возвращает все открытые страницы в контексте.

**Использование**

```js
browserContext.pages();
```

**Возвращает**
- [Array]&lt;[Page]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-pages-return"/><a href="#browser-context-pages-return" class="list-anchor">#</a>

---

### removeAllListeners {#browser-context-remove-all-listeners}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.47</font><x-search>browserContext.removeAllListeners</x-search>

Удаляет всех слушателей указанного типа (или всех зарегистрированных слушателей, если тип не указан). Позволяет дождаться завершения асинхронных слушателей или игнорировать последующие ошибки от этих слушателей.

**Использование**

```js
await browserContext.removeAllListeners();
await browserContext.removeAllListeners(type, options);
```

**Аргументы**
- `type` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-remove-all-listeners-option-type"/><a href="#browser-context-remove-all-listeners-option-type" class="list-anchor">#</a>
- `options` [Object] *(опционально)*
  - `behavior` "wait" | "ignoreErrors" | "default" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-remove-all-listeners-option-behavior"/><a href="#browser-context-remove-all-listeners-option-behavior" class="list-anchor">#</a>
    
    Указывает, следует ли ждать завершения уже работающих слушателей и что делать, если они выбрасывают ошибки:
    * `'default'` - не ждать завершения текущих вызовов слушателей (если таковые имеются), если слушатель выбрасывает, это может привести к необработанной ошибке
    * `'wait'` - дождаться завершения текущих вызовов слушателей (если таковые имеются)
    * `'ignoreErrors'` - не ждать завершения текущих вызовов слушателей (если таковые имеются), все ошибки, выброшенные слушателями после удаления, будут тихо пойманы

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-remove-all-listeners-return"/><a href="#browser-context-remove-all-listeners-return" class="list-anchor">#</a>

---

### route {#browser-context-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.route</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются любой страницей в контексте браузера. Как только маршрут включен, каждый запрос, соответствующий шаблону URL, будет приостановлен, если его не продолжить, не выполнить или не прервать.

:::note

[browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) не будет перехватывать запросы, перехваченные Service Worker. Смотрите [это](https://github.com/microsoft/playwright/issues/1090) проблему. Рекомендуем отключить Service Workers при использовании перехвата запросов, установив [serviceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

**Использование**

Пример наивного обработчика, который прерывает все запросы изображений:

```js
const context = await browser.newContext();
await context.route('**/*.{png,jpg,jpeg}', route => route.abort());
const page = await context.newPage();
await page.goto('https://example.com');
await browser.close();
```

или тот же фрагмент, использующий регулярное выражение вместо этого:

```js
const context = await browser.newContext();
await context.route(/(\.png$)|(\.jpg$)/, route => route.abort());
const page = await context.newPage();
await page.goto('https://example.com');
await browser.close();
```

Можно проверить запрос, чтобы решить, какое действие предпринять с маршрутом. Например, имитация всех запросов, которые содержат некоторые данные поста, и оставление всех остальных запросов без изменений:

```js
await context.route('/api/**', async route => {
  if (route.request().postData().includes('my-string'))
    await route.fulfill({ body: 'mocked-data' });
  else
    await route.continue();
});
```

Маршруты страниц (установленные с помощью [page.route()](/api/class-page.mdx#page-route)) имеют приоритет над маршрутами контекста браузера, когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [browserContext.unroute()](/api/class-browsercontext.mdx#browser-context-unroute).

:::note

Включение маршрутизации отключает http-кэш.
:::

**Аргументы**
- `url` [string] | [RegExp] | [function]\([URL]\):[boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-url"/><a href="#browser-context-route-option-url" class="list-anchor">#</a>
  
  Шаблон glob, регулярное выражение или предикат, принимающий [URL] для сопоставления при маршрутизации. Когда [baseURL](/api/class-browser.mdx#browser-new-context-option-base-url) через параметры контекста был предоставлен, и переданный URL является путем, он объединяется с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `handler` [function]\([Route], [Request]\):[Promise]&lt;[Object]&gt; | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-handler"/><a href="#browser-context-route-option-handler" class="list-anchor">#</a>
  
  Функция обработчика для маршрутизации запроса.
- `options` [Object] *(опционально)*
  - `times` [number] *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-times"/><a href="#browser-context-route-option-times" class="list-anchor">#</a>
    
    Как часто маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-return"/><a href="#browser-context-route-return" class="list-anchor">#</a>

---

### routeFromHAR {#browser-context-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>browserContext.routeFromHAR</x-search>

Если указано, сетевые запросы, выполняемые в контексте, будут обслуживаться из файла HAR. Узнайте больше о [Воспроизведении из HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из файла HAR. Смотрите [это](https://github.com/microsoft/playwright/issues/1090) проблему. Рекомендуем отключить Service Workers при использовании перехвата запросов, установив [serviceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```js
await browserContext.routeFromHAR(har);
await browserContext.routeFromHAR(har, options);
```

**Аргументы**
- `har` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-har"/><a href="#browser-context-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к файлу [HAR](http://www.softwareishard.com/blog/har-12-spec) с записанными сетевыми данными. Если `path` является относительным путем, он разрешается относительно текущей рабочей директории.
- `options` [Object] *(опционально)*
  - `notFound` "abort" | "fallback" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-not-found"/><a href="#browser-context-route-from-har-option-not-found" class="list-anchor">#</a>
    * Если установлено в 'abort', любой запрос, не найденный в файле HAR, будет прерван.
    * Если установлено в 'fallback', будет переход к следующему обработчику маршрута в цепочке обработчиков.
    
    По умолчанию - прерывание.
  - `update` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update"/><a href="#browser-context-route-from-har-option-update" class="list-anchor">#</a>
    
    Если указано, обновляет данный HAR фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск, когда вызывается [browserContext.close()](/api/class-browsercontext.mdx#browser-context-close).
  - `updateContent` "embed" | "attach" *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-content"/><a href="#browser-context-route-from-har-option-update-content" class="list-anchor">#</a>
    
    Опциональная настройка для управления управлением содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP-архиве. Если указано `embed`, содержимое хранится встроенным в файл HAR.
  - `updateMode` "full" | "minimal" *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-mode"/><a href="#browser-context-route-from-har-option-update-mode" class="list-anchor">#</a>
    
    При установке в `minimal` записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницы, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию - `minimal`.
  - `url` [string] | [RegExp] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-url"/><a href="#browser-context-route-from-har-option-url" class="list-anchor">#</a>
    
    Шаблон glob, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из файла HAR. Если не указано, все запросы обслуживаются из файла HAR.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-return"/><a href="#browser-context-route-from-har-return" class="list-anchor">#</a>

---

### routeWebSocket {#browser-context-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>browserContext.routeWebSocket</x-search>

Этот метод позволяет изменять соединения WebSocket, которые выполняются любой страницей в контексте браузера.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизироваться. Рекомендуется вызывать этот метод перед созданием любых страниц.

**Использование**

Ниже приведен пример простого обработчика, который блокирует некоторые сообщения WebSocket. Смотрите [WebSocketRoute] для получения дополнительных сведений и примеров.

```js
await context.routeWebSocket('/ws', async ws => {
  ws.routeSend(message => {
    if (message === 'to-be-blocked')
      return;
    ws.send(message);
  });
  await ws.connect();
});
```

**Аргументы**
- `url` [string] | [RegExp] | [function]\([URL]\):[boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-url"/><a href="#browser-context-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизироваться. Строковый шаблон может относиться к параметру контекста [baseURL](/api/class-browser.mdx#browser-new-context-option-base-url).
- `handler` [function]\([WebSocketRoute]\):[Promise]&lt;[Object]&gt; | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-handler"/><a href="#browser-context-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция обработчика для маршрутизации WebSocket.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-return"/><a href="#browser-context-route-web-socket-return" class="list-anchor">#</a>

---

### serviceWorkers {#browser-context-service-workers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.serviceWorkers</x-search>

:::note

Service workers поддерживаются только в браузерах на основе Chromium.
:::

Все существующие сервисные работники в контексте.

**Использование**

```js
browserContext.serviceWorkers();
```

**Возвращает**
- [Array]&lt;[Worker]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-service-workers-return"/><a href="#browser-context-service-workers-return" class="list-anchor">#</a>

---

### setDefaultNavigationTimeout {#browser-context-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setDefaultNavigationTimeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных ярлыков:
* [page.goBack()](/api/class-page.mdx#page-go-back)
* [page.goForward()](/api/class-page.mdx#page-go-forward)
* [page.goto()](/api/class-page.mdx#page-goto)
* [page.reload()](/api/class-page.mdx#page-reload)
* [page.setContent()](/api/class-page.mdx#page-set-content)
* [page.waitForNavigation()](/api/class-page.mdx#page-wait-for-navigation)

:::note

[page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) и [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) имеют приоритет над [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```js
browserContext.setDefaultNavigationTimeout(timeout);
```

**Аргументы**
- `timeout` [number]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-navigation-timeout-option-timeout"/><a href="#browser-context-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### setDefaultTimeout {#browser-context-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setDefaultTimeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих опцию [timeout](/api/class-browsercontext.mdx#browser-context-set-default-timeout-option-timeout).

:::note

[page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout), [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) и [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout) имеют приоритет над [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
:::

**Использование**

```js
browserContext.setDefaultTimeout(timeout);
```

**Аргументы**
- `timeout` [number]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-timeout-option-timeout"/><a href="#browser-context-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### setExtraHTTPHeaders {#browser-context-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setExtraHTTPHeaders</x-search>

Дополнительные HTTP заголовки будут отправлены с каждым запросом, инициированным любой страницей в контексте. Эти заголовки объединяются с дополнительными HTTP заголовками, специфичными для страницы, установленными с помощью [page.setExtraHTTPHeaders()](/api/class-page.mdx#page-set-extra-http-headers). Если страница переопределяет определенный заголовок, будет использоваться значение заголовка, специфичное для страницы, вместо значения заголовка контекста браузера.

:::note

[browserContext.setExtraHTTPHeaders()](/api/class-browsercontext.mdx#browser-context-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```js
await browserContext.setExtraHTTPHeaders(headers);
```

**Аргументы**
- `headers` [Object]&lt;[string], [string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-option-headers"/><a href="#browser-context-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP заголовки, которые будут отправлены с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-return"/><a href="#browser-context-set-extra-http-headers-return" class="list-anchor">#</a>

---

### setGeolocation {#browser-context-set-geolocation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setGeolocation</x-search>

Устанавливает геолокацию контекста. Передача `null` или `undefined` эмулирует недоступность позиции.

**Использование**

```js
await browserContext.setGeolocation({ latitude: 59.95, longitude: 30.31667 });
```

:::note
Рекомендуется использовать [browserContext.grantPermissions()](/api/class-browsercontext.mdx#browser-context-grant-permissions), чтобы предоставить разрешения для страниц контекста браузера для чтения его геолокации.
:::

**Аргументы**
- `geolocation` [null] | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-option-geolocation"/><a href="#browser-context-set-geolocation-option-geolocation" class="list-anchor">#</a>
  - `latitude` [number]
    
    Широта от -90 до 90.
  - `longitude` [number]
    
    Долгота от -180 до 180.
  - `accuracy` [number] *(опционально)*
    
    Ненегативное значение точности. По умолчанию 0.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-return"/><a href="#browser-context-set-geolocation-return" class="list-anchor">#</a>

---

### setOffline {#browser-context-set-offline}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setOffline</x-search>

**Использование**

```js
await browserContext.setOffline(offline);
```

**Аргументы**
- `offline` [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-option-offline"/><a href="#browser-context-set-offline-option-offline" class="list-anchor">#</a>
  
  Указывает, следует ли эмулировать отключение сети для контекста браузера.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-return"/><a href="#browser-context-set-offline-return" class="list-anchor">#</a>

---

### storageState {#browser-context-storage-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.storageState</x-search>

Возвращает состояние хранилища для этого контекста браузера, содержит текущие куки, снимок локального хранилища и снимок IndexedDB.

**Использование**

```js
await browserContext.storageState();
await browserContext.storageState(options);
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `indexedDB` [boolean] *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-indexed-db"/><a href="#browser-context-storage-state-option-indexed-db" class="list-anchor">#</a>
    
    Установите в `true`, чтобы включить [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) в снимок состояния хранилища. Если ваше приложение использует IndexedDB для хранения токенов аутентификации, таких как аутентификация Firebase, включите это.
    
    :::note
    
    IndexedDB с типизированными массивами в настоящее время не поддерживается.
    :::
    
  - `path` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-path"/><a href="#browser-context-storage-state-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения состояния хранилища. Если [path](/api/class-browsercontext.mdx#browser-context-storage-state-option-path) является относительным путем, он разрешается относительно текущей рабочей директории. Если путь не указан, состояние хранилища все равно возвращается, но не сохраняется на диск.

**Возвращает**
- [Promise]&lt;[Object]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-return"/><a href="#browser-context-storage-state-return" class="list-anchor">#</a>
  - `cookies` [Array]&lt;[Object]&gt;
    - `name` [string]
      
    - `value` [string]
      
    - `domain` [string]
      
    - `path` [string]
      
    - `expires` [number]
      
      Unix время в секундах.
    - `httpOnly` [boolean]
      
    - `secure` [boolean]
      
    - `sameSite` "Strict" | "Lax" | "None"
      
    
  - `origins` [Array]&lt;[Object]&gt;
    - `origin` [string]
      
    - `localStorage` [Array]&lt;[Object]&gt;
      - `name` [string]
        
        
      - `value` [string]
        
        
      
    

---

### unroute {#browser-context-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.unroute</x-search>

Удаляет маршрут, созданный с помощью [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route). Когда [handler](/api/class-browsercontext.mdx#browser-context-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-browsercontext.mdx#browser-context-unroute-option-url).

**Использование**

```js
await browserContext.unroute(url);
await browserContext.unroute(url, handler);
```

**Аргументы**
- `url` [string] | [RegExp] | [function]\([URL]\):[boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-url"/><a href="#browser-context-unroute-option-url" class="list-anchor">#</a>
  
  Шаблон glob, регулярное выражение или предикат, принимающий [URL], используемый для регистрации маршрута с [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route).
- `handler` [function]\([Route], [Request]\):[Promise]&lt;[Object]&gt; | [Object] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-handler"/><a href="#browser-context-unroute-option-handler" class="list-anchor">#</a>
  
  Опциональная функция обработчика, используемая для регистрации маршрута с [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-return"/><a href="#browser-context-unroute-return" class="list-anchor">#</a>

---

### unrouteAll {#browser-context-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.41</font><x-search>browserContext.unrouteAll</x-search>

Удаляет все маршруты, созданные с помощью [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [browserContext.routeFromHAR()](/api/class-browsercontext.mdx#browser-context-route-from-har).

**Использование**

```js
await browserContext.unrouteAll();
await browserContext.unrouteAll(options);
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `behavior` "wait" | "ignoreErrors" | "default" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-all-option-behavior"/><a href="#browser-context-unroute-all-option-behavior" class="list-anchor">#</a>
    
    Указывает, следует ли ждать завершения уже работающих обработчиков и что делать, если они выбрасывают ошибки:
    * `'default'` - не ждать завершения текущих вызовов обработчиков (если таковые имеются), если не маршрутизированный обработчик выбрасывает, это может привести к необработанной ошибке
    * `'wait'` - дождаться завершения текущих вызовов обработчиков (если таковые имеются)
    * `'ignoreErrors'` - не ждать завершения текущих вызовов обработчиков (если таковые имеются), все ошибки, выброшенные обработчиками после отмены маршрутизации, будут тихо пойманы

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-all-return"/><a href="#browser-context-unroute-all-return" class="list-anchor">#</a>

---

### waitForEvent {#browser-context-wait-for-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.waitForEvent</x-search>

Ожидает, когда событие произойдет, и передает его значение в предикатную функцию. Возвращает, когда предикат возвращает истинное значение. Выдаст ошибку, если контекст закроется до того, как событие произойдет. Возвращает значение данных события.

**Использование**

```js
const pagePromise = context.waitForEvent('page');
await page.getByRole('button').click();
const page = await pagePromise;
```

**Аргументы**
- `event` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-option-event"/><a href="#browser-context-wait-for-event-option-event" class="list-anchor">#</a>
  
  Имя события, то же самое, что и передается в `browserContext.on(event)`.
- `optionsOrPredicate` [function] | [Object] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-option-options-or-predicate"/><a href="#browser-context-wait-for-event-option-options-or-predicate" class="list-anchor">#</a>
  - `predicate` [function]
    
    Принимает данные события и разрешается в истинное значение, когда ожидание должно разрешиться.
  - `timeout` [number] *(опционально)*
    
    Максимальное время ожидания в миллисекундах. По умолчанию `0` - без тайм-аута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью метода [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
  
  Либо предикат, который принимает событие, либо объект параметров. Опционально.
- `options` [Object] *(опционально)*
  - `predicate` [function] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-option-predicate"/><a href="#browser-context-wait-for-event-option-predicate" class="list-anchor">#</a>
    
    Принимает данные события и разрешается в истинное значение, когда ожидание должно разрешиться.

**Возвращает**
- [Promise]&lt;[Object]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-return"/><a href="#browser-context-wait-for-event-return" class="list-anchor">#</a>

---

## Свойства

### clock {#browser-context-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.45</font><x-search>browserContext.clock</x-search>

Playwright имеет возможность имитировать часы и течение времени.

**Использование**

```js
browserContext.clock
```

**Тип**
- [Clock]

---

### request {#browser-context-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.16</font><x-search>browserContext.request</x-search>

Помощник API тестирования, связанный с этим контекстом. Запросы, сделанные с помощью этого API, будут использовать куки контекста.

**Использование**

```js
browserContext.request
```

**Тип**
- [APIRequestContext]

---

### tracing {#browser-context-tracing}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.tracing</x-search>

**Использование**

```js
browserContext.tracing
```

**Тип**
- [Tracing]

---

## События

### on('backgroundpage') {#browser-context-event-background-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.on('backgroundpage')</x-search>

:::note

Работает только с постоянным контекстом браузера Chromium.
:::

Событие, которое возникает, когда новая фоновая страница создается в контексте.

```js
const backgroundPage = await context.waitForEvent('backgroundpage');
```

**Использование**

```js
browserContext.on('backgroundpage', data => {});
```

**Данные события**
- [Page]

---

### on('close') {#browser-context-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.on('close')</x-search>

Событие, которое возникает, когда контекст браузера закрывается. Это может произойти по одной из следующих причин:
* Контекст браузера закрыт.
* Браузерное приложение закрыто или аварийно завершило работу.
* Вызван метод [browser.close()](/api/class-browser.mdx#browser-close).

**Использование**

```js
browserContext.on('close', data => {});
```

**Данные события**
- [BrowserContext]

---

### on('console') {#browser-context-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.on('console')</x-search>

Событие, которое возникает, когда JavaScript на странице вызывает один из методов API консоли, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, и страница доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

```js
context.on('console', async msg => {
  const values = [];
  for (const arg of msg.args())
    values.push(await arg.jsonValue());
  console.log(...values);
});
await page.evaluate(() => console.log('hello', 5, { foo: 'bar' }));
```

**Данные события**
- [ConsoleMessage]

---

### on('dialog') {#browser-context-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.on('dialog')</x-search>

Событие, которое возникает, когда появляется диалог JavaScript, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Слушатель **должен** либо [dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница будет [заморожена](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалога, и такие действия, как клик, никогда не завершатся.

**Использование**

```js
context.on('dialog', dialog => {
  dialog.accept();
});
```

:::note
Когда нет слушателей [page.on('dialog')](/api/class-page.mdx#page-event-dialog) или [browserContext.on('dialog')](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### on('page') {#browser-context-event-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.on('page')</x-search>

Событие, которое возникает, когда новая страница создается в BrowserContext. Страница может все еще загружаться. Событие также срабатывает для всплывающих страниц. Смотрите также [page.on('popup')](/api/class-page.mdx#page-event-popup), чтобы получать события о всплывающих окнах, относящихся к конкретной странице.

Самый ранний момент, когда страница доступна, - это когда она навигировала к начальному URL. Например, при открытии всплывающего окна с помощью `window.open('http://example.com')`, это событие сработает, когда сетевой запрос к "http://example.com" будет завершен, и его ответ начнет загружаться во всплывающее окно. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [browserContext.on('request')](/api/class-browsercontext.mdx#browser-context-event-request) соответственно, вместо аналогичных методов на [Page].

```js
const newPagePromise = context.waitForEvent('page');
await page.getByText('открыть новую страницу').click();
const newPage = await newPagePromise;
console.log(await newPage.evaluate('location.href'));
```

:::note
Используйте [page.waitForLoadState()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев вам это не нужно).
:::

**Использование**

```js
browserContext.on('page', data => {});
```

**Данные события**
- [Page]

---

### on('request') {#browser-context-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.on('request')</x-search>

Событие, которое возникает, когда запрос выдается из любых страниц, созданных через этот контекст. Объект [request] является только для чтения. Чтобы слушать только запросы из конкретной страницы, используйте [page.on('request')](/api/class-page.mdx#page-event-request).

Чтобы перехватить и изменить запросы, смотрите [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) или [page.route()](/api/class-page.mdx#page-route).

**Использование**

```js
browserContext.on('request', data => {});
```

**Данные события**
- [Request]

---

### on('requestfailed') {#browser-context-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.on('requestfailed')</x-search>

Событие, которое возникает, когда запрос не удался, например, из-за тайм-аута. Чтобы слушать только неудачные запросы из конкретной страницы, используйте [page.on('requestfailed')](/api/class-page.mdx#page-event-request-failed).

:::note

HTTP-ошибки, такие как 404 или 503, все еще являются успешными ответами с точки зрения HTTP, поэтому запрос завершится с событием [browserContext.on('requestfinished')](/api/class-browsercontext.mdx#browser-context-event-request-finished) и не с [browserContext.on('requestfailed')](/api/class-browsercontext.mdx#browser-context-event-request-failed).
:::

**Использование**

```js
browserContext.on('requestfailed', data => {});
```

**Данные события**
- [Request]

---

### on('requestfinished') {#browser-context-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.on('requestfinished')</x-search>

Событие, которое возникает, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий - `request`, `response` и `requestfinished`. Чтобы слушать успешные запросы из конкретной страницы, используйте [page.on('requestfinished')](/api/class-page.mdx#page-event-request-finished).

**Использование**

```js
browserContext.on('requestfinished', data => {});
```

**Данные события**
- [Request]

---

### on('response') {#browser-context-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.on('response')</x-search>

Событие, которое возникает, когда статус и заголовки [response] получены для запроса. Для успешного ответа последовательность событий - `request`, `response` и `requestfinished`. Чтобы слушать события ответа из конкретной страницы, используйте [page.on('response')](/api/class-page.mdx#page-event-response).

**Использование**

```js
browserContext.on('response', data => {});
```

**Данные события**
- [Response]

---

### on('serviceworker') {#browser-context-event-service-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.on('serviceworker')</x-search>

:::note

Сервисные работники поддерживаются только в браузерах на основе Chromium.
:::

Событие, которое возникает, когда новый сервисный работник создается в контексте.

**Использование**

```js
browserContext.on('serviceworker', data => {});
```

**Данные события**
- [Worker]

---

### on('weberror') {#browser-context-event-web-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.38</font><x-search>browserContext.on('weberror')</x-search>

Событие, которое возникает, когда исключение не обрабатывается в любой из страниц в этом контексте. Чтобы слушать ошибки из конкретной страницы, используйте [page.on('pageerror')](/api/class-page.mdx#page-event-page-error) вместо этого.

**Использование**

```js
browserContext.on('weberror', data => {});
```

**Данные события**
- [WebError]

---

## Устарело

### setHTTPCredentials {#browser-context-set-http-credentials}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setHTTPCredentials</x-search>

:::warning Устарело

Браузеры могут кэшировать учетные данные после успешной аутентификации. Вместо этого создайте новый контекст браузера.

:::

**Использование**

```js
await browserContext.setHTTPCredentials(httpCredentials);
```

**Аргументы**
- `httpCredentials` [null] | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-http-credentials-option-http-credentials"/><a href="#browser-context-set-http-credentials-option-http-credentials" class="list-anchor">#</a>
  - `username` [string]
    
  - `password` [string]
    
**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-http-credentials-return"/><a href="#browser-context-set-http-credentials-return" class="list-anchor">#</a>



[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[Android]: /api/class-android.mdx "Android"
[AndroidDevice]: /api/class-androiddevice.mdx "AndroidDevice"
[AndroidInput]: /api/class-androidinput.mdx "AndroidInput"
[AndroidSocket]: /api/class-androidsocket.mdx "AndroidSocket"
[AndroidWebView]: /api/class-androidwebview.mdx "AndroidWebView"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserServer]: /api/class-browserserver.mdx "BrowserServer"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Coverage]: /api/class-coverage.mdx "Coverage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[Electron]: /api/class-electron.mdx "Electron"
[ElectronApplication]: /api/class-electronapplication.mdx "ElectronApplication"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[GenericAssertions]: /api/class-genericassertions.mdx "GenericAssertions"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Logger]: /api/class-logger.mdx "Logger"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[SnapshotAssertions]: /api/class-snapshotassertions.mdx "SnapshotAssertions"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Fixtures]: /api/class-fixtures.mdx "Fixtures"
[FullConfig]: /api/class-fullconfig.mdx "FullConfig"
[FullProject]: /api/class-fullproject.mdx "FullProject"
[Location]: /api/class-location.mdx "Location"
[Test]: /api/class-test.mdx "Test"
[TestConfig]: /api/class-testconfig.mdx "TestConfig"
[TestInfo]: /api/class-testinfo.mdx "TestInfo"
[TestInfoError]: /api/class-testinfoerror.mdx "TestInfoError"
[TestOptions]: /api/class-testoptions.mdx "TestOptions"
[TestProject]: /api/class-testproject.mdx "TestProject"
[TestStepInfo]: /api/class-teststepinfo.mdx "TestStepInfo"
[WorkerInfo]: /api/class-workerinfo.mdx "WorkerInfo"
[Reporter]: /api/class-reporter.mdx "Reporter"
[Suite]: /api/class-suite.mdx "Suite"
[TestCase]: /api/class-testcase.mdx "TestCase"
[TestError]: /api/class-testerror.mdx "TestError"
[TestResult]: /api/class-testresult.mdx "TestResult"
[TestStep]: /api/class-teststep.mdx "TestStep"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array "Array"
[boolean]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type "Boolean"
[Buffer]: https://nodejs.org/api/buffer.html#buffer_class_buffer "Buffer"
[ChildProcess]: https://nodejs.org/api/child_process.html "ChildProcess"
[Date]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date "Date"
[Error]: https://nodejs.org/api/errors.html#errors_class_error "Error"
[EventEmitter]: https://nodejs.org/api/events.html#events_class_eventemitter "EventEmitter"
[function]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function "Function"
[FormData]: https://developer.mozilla.org/en-US/docs/Web/API/FormData "FormData"
[Map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "Map"
[Metadata]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object&lt;string, any&gt;"
[null]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null "null"
[number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type "Number"
[Object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[Readable]: https://nodejs.org/api/stream.html#stream_class_stream_readable "Readable"
[ReadStream]: https://nodejs.org/api/fs.html#class-fsreadstream "ReadStream"
[RegExp]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp "RegExp"
[string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type "string"
[void]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined "void"
[URL]: https://nodejs.org/api/url.html "URL"
[URLSearchParams]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams "URLSearchParams"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
