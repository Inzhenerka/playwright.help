---
id: class-page
title: "Page"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

Класс `Page` предоставляет методы для работы с одной вкладкой в [Browser] или фоновыми страницами расширений ([extension background page](https://developer.chrome.com/extensions/background_pages)) в Chromium. Один экземпляр [Browser] может содержать несколько экземпляров [Page].

Пример ниже создаёт страницу, переходит на указанный URL и сохраняет скриншот:

```js
const { webkit } = require('playwright');  // Также можно использовать 'chromium' или 'firefox'.

(async () => {
  const browser = await webkit.launch();
  const context = await browser.newContext();
  const page = await context.newPage();
  await page.goto('https://example.com');
  await page.screenshot({ path: 'screenshot.png' });
  await browser.close();
})();
```

Класс `Page` генерирует различные события (описаны ниже), которые можно обрабатывать с помощью стандартных методов [`EventEmitter`](https://nodejs.org/api/events.html#events_class_eventemitter) в Node.js, таких как `on`, `once` или `removeListener`.

Пример ниже выводит сообщение при загрузке страницы (`load`):

```js
page.once('load', () => console.log('Page loaded!'));
```

Чтобы отписаться от событий, используйте метод `removeListener`:

```js
function logRequest(interceptedRequest) {
  console.log('A request was made:', interceptedRequest.url());
}
page.on('request', logRequest);
// Позже в коде...
page.removeListener('request', logRequest);
```


---

## Методы

### addInitScript {#page-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.addInitScript</x-search>

Добавляет скрипт, который будет выполнен в одном из следующих сценариев:
* Каждый раз, когда страница загружается.
* Каждый раз, когда дочерний фрейм присоединяется или загружается. В этом случае скрипт выполняется в контексте вновь присоединенного фрейма.

Скрипт выполняется после создания документа, но до выполнения любых его скриптов. Это полезно для изменения среды JavaScript, например, для задания начального значения `Math.random`.

**Использование**

Пример переопределения `Math.random` перед загрузкой страницы:

```js
// preload.js
Math.random = () => 42;
```

```js
// В вашем скрипте playwright, предполагая, что файл preload.js находится в той же директории
await page.addInitScript({ path: './preload.js' });
```

```js
await page.addInitScript(mock => {
  window.mock = mock;
}, mock);
```

:::note
Порядок выполнения нескольких скриптов, установленных через [browserContext.addInitScript()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [page.addInitScript()](/api/class-page.mdx#page-add-init-script), не определен.
:::

**Аргументы**
- `script` [function] | [string] | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-option-script"/><a href="#page-add-init-script-option-script" class="list-anchor">#</a>
  - `path` [string] *(опционально)*
    
    Путь к JavaScript файлу. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории. Опционально.
  - `content` [string] *(опционально)*
    
    Сырой контент скрипта. Опционально.
  
  Скрипт для выполнения на странице.
- `arg` [Serializable] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-option-arg"/><a href="#page-add-init-script-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [script](/api/class-page.mdx#page-add-init-script-option-script) (поддерживается только при передаче функции).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-return"/><a href="#page-add-init-script-return" class="list-anchor">#</a>

---

### addLocatorHandler {#page-add-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.42</font><x-search>page.addLocatorHandler</x-search>

При тестировании веб-страницы иногда появляются неожиданные наложения, такие как диалог "Зарегистрироваться", которые блокируют действия, которые вы хотите автоматизировать, например, нажатие кнопки. Эти наложения не всегда появляются одинаково или в одно и то же время, что делает их сложными для обработки в автоматизированных тестах.

Этот метод позволяет вам настроить специальную функцию, называемую обработчиком, которая активируется, когда обнаруживает, что наложение видно. Задача обработчика - удалить наложение, позволяя вашему тесту продолжаться так, как будто наложения не было.

Вещи, которые нужно учитывать:
* Когда наложение показывается предсказуемо, мы рекомендуем явно ожидать его в вашем тесте и отклонять его как часть вашего обычного тестового потока, вместо использования [page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler).
* Playwright проверяет наличие наложения каждый раз перед выполнением или повторной попыткой действия, требующего [проверки возможности действия](../actionability.mdx), или перед выполнением проверки утверждения с автоматическим ожиданием. Когда наложение видно, Playwright сначала вызывает обработчик, а затем продолжает выполнение действия/утверждения. Обратите внимание, что обработчик вызывается только при выполнении действия/утверждения - если наложение становится видимым, но вы не выполняете никаких действий, обработчик не будет вызван.
* После выполнения обработчика Playwright убедится, что наложение, вызвавшее обработчик, больше не видно. Вы можете отказаться от этого поведения с помощью [noWaitAfter](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after).
* Время выполнения обработчика учитывается в тайм-ауте действия/утверждения, которое вызвало обработчик. Если ваш обработчик занимает слишком много времени, это может вызвать тайм-ауты.
* Вы можете зарегистрировать несколько обработчиков. Однако в любой момент времени будет выполняться только один обработчик. Убедитесь, что действия в обработчике не зависят от другого обработчика.

:::warning

Выполнение обработчика изменит состояние вашей страницы в середине теста. Например, это изменит текущий фокус элемента и переместит мышь. Убедитесь, что действия, выполняемые после обработчика, являются автономными и не зависят от неизменности состояния фокуса и мыши.

For example, consider a test that calls [locator.focus()](/api/class-locator.mdx#locator-focus) followed by [keyboard.press()](/api/class-keyboard.mdx#keyboard-press). If your handler clicks a button between these two actions, the focused element most likely will be wrong, and key press will happen on the unexpected element. Use [locator.press()](/api/class-locator.mdx#locator-press) instead to avoid this problem.

Another example is a series of mouse actions, where [mouse.move()](/api/class-mouse.mdx#mouse-move) is followed by [mouse.down()](/api/class-mouse.mdx#mouse-down). Again, when the handler runs between these two actions, the mouse position will be wrong during the mouse down. Prefer self-contained actions like [locator.click()](/api/class-locator.mdx#locator-click) that do not rely on the state being unchanged by a handler.
:::

**Использование**

Пример, который закрывает диалог "Подписаться на рассылку", когда он появляется:

```js
// Настройка обработчика.
await page.addLocatorHandler(page.getByText('Sign up to the newsletter'), async () => {
  await page.getByRole('button', { name: 'No thanks' }).click();
});

// Пишите тест как обычно.
await page.goto('https://example.com');
await page.getByRole('button', { name: 'Start here' }).click();
```

Пример, который пропускает страницу "Подтвердите свои данные безопасности", когда она отображается:

```js
// Настройка обработчика.
await page.addLocatorHandler(page.getByText('Confirm your security details'), async () => {
  await page.getByRole('button', { name: 'Remind me later' }).click();
});

// Пишите тест как обычно.
await page.goto('https://example.com');
await page.getByRole('button', { name: 'Start here' }).click();
```

Пример с пользовательским обратным вызовом на каждой проверке доступности. Используется локатор `<body>`, который всегда виден, поэтому обработчик вызывается перед каждой проверкой доступности. Важно указать [noWaitAfter](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after), потому что обработчик не скрывает элемент `<body>`.

```js
// Настройка обработчика.
await page.addLocatorHandler(page.locator('body'), async () => {
  await page.evaluate(() => window.removeObstructionsForTestIfNeeded());
}, { noWaitAfter: true });

// Пишите тест как обычно.
await page.goto('https://example.com');
await page.getByRole('button', { name: 'Start here' }).click();
```

Обработчик принимает оригинальный локатор в качестве аргумента. Вы также можете автоматически удалить обработчик после определенного количества вызовов, установив [times](/api/class-page.mdx#page-add-locator-handler-option-times):

```js
await page.addLocatorHandler(page.getByLabel('Close'), async locator => {
  await locator.click();
}, { times: 1 });
```

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-locator"/><a href="#page-add-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, который вызывает обработчик.
- `handler` [function]\([Locator]\):[Promise]&lt;[Object]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-handler"/><a href="#page-add-locator-handler-option-handler" class="list-anchor">#</a>
  
  Функция, которая должна быть выполнена, как только [локатор](/api/class-page.mdx#page-add-locator-handler-option-locator) появится. Эта функция должна избавиться от элемента, который блокирует действия, такие как клик.
- `options` [Object] *(опционально)*
  - `noWaitAfter` [boolean] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-no-wait-after"/><a href="#page-add-locator-handler-option-no-wait-after" class="list-anchor">#</a>
    
    По умолчанию, после вызова обработчика Playwright будет ждать, пока оверлей не станет скрытым, и только затем продолжит действие/проверку, которое вызвало обработчик. Эта опция позволяет отказаться от этого поведения, чтобы оверлей мог оставаться видимым после выполнения обработчика.
  - `times` [number] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-times"/><a href="#page-add-locator-handler-option-times" class="list-anchor">#</a>
    
    Указывает максимальное количество раз, которое этот обработчик должен быть вызван. По умолчанию не ограничено.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-return"/><a href="#page-add-locator-handler-return" class="list-anchor">#</a>

---

### addScriptTag {#page-add-script-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.addScriptTag</x-search>

Добавляет тег `<script>` на страницу с нужным URL или содержимым. Возвращает добавленный тег, когда срабатывает onload скрипта или когда содержимое скрипта было внедрено в фрейм.

**Использование**

```js
await page.addScriptTag();
await page.addScriptTag(options);
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `content` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-content"/><a href="#page-add-script-tag-option-content" class="list-anchor">#</a>
    
    Сырой JavaScript-контент для внедрения в фрейм.
  - `path` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-path"/><a href="#page-add-script-tag-option-path" class="list-anchor">#</a>
    
    Путь к JavaScript-файлу для внедрения в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `type` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-type"/><a href="#page-add-script-tag-option-type" class="list-anchor">#</a>
    
    Тип скрипта. Используйте 'module', чтобы загрузить JavaScript ES6 модуль. Подробнее см. [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script).
  - `url` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-url"/><a href="#page-add-script-tag-option-url" class="list-anchor">#</a>
    
    URL скрипта, который нужно добавить.

**Возвращает**
- [Promise]&lt;[ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-return"/><a href="#page-add-script-tag-return" class="list-anchor">#</a>

---

### addStyleTag {#page-add-style-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.addStyleTag</x-search>

Добавляет тег `<link rel="stylesheet">` на страницу с нужным URL или тег `<style type="text/css">` с содержимым. Возвращает добавленный тег, когда срабатывает onload таблицы стилей или когда CSS-контент был внедрен в фрейм.

**Использование**

```js
await page.addStyleTag();
await page.addStyleTag(options);
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `content` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-content"/><a href="#page-add-style-tag-option-content" class="list-anchor">#</a>
    
    Сырой CSS-контент для внедрения в фрейм.
  - `path` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-path"/><a href="#page-add-style-tag-option-path" class="list-anchor">#</a>
    
    Путь к CSS-файлу для внедрения в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `url` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-url"/><a href="#page-add-style-tag-option-url" class="list-anchor">#</a>
    
    URL тега `<link>`.

**Возвращает**
- [Promise]&lt;[ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-return"/><a href="#page-add-style-tag-return" class="list-anchor">#</a>

---

### bringToFront {#page-bring-to-front}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.bringToFront</x-search>

Перемещает страницу на передний план (активирует вкладку).

**Использование**

```js
await page.bringToFront();
```

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-bring-to-front-return"/><a href="#page-bring-to-front-return" class="list-anchor">#</a>

---

### close {#page-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.close</x-search>

Если [runBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) равен `false`, не выполняет обработчики выгрузки и ждет закрытия страницы. Если [runBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) равен `true`, метод выполнит обработчики выгрузки, но **не** будет ждать закрытия страницы.

По умолчанию, `page.close()` **не** выполняет обработчики `beforeunload`.

:::note

если [runBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) передан как true, может быть вызван диалог `beforeunload`, который должен быть обработан вручную через событие [page.on('dialog')](/api/class-page.mdx#page-event-dialog).
:::

**Использование**

```js
await page.close();
await page.close(options);
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `reason` [string] *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-reason"/><a href="#page-close-option-reason" class="list-anchor">#</a>
    
    Причина, которая будет сообщена операциям, прерванным закрытием страницы.
  - `runBeforeUnload` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-run-before-unload"/><a href="#page-close-option-run-before-unload" class="list-anchor">#</a>
    
    По умолчанию `false`. Выполнять ли обработчики страницы [before unload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-return"/><a href="#page-close-return" class="list-anchor">#</a>

---

### content {#page-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.content</x-search>

Получает полный HTML-контент страницы, включая doctype.

**Использование**

```js
await page.content();
```

**Возвращает**
- [Promise]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-content-return"/><a href="#page-content-return" class="list-anchor">#</a>

---

### context {#page-context}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.context</x-search>

Получает контекст браузера, к которому принадлежит страница.

**Использование**

```js
page.context();
```

**Возвращает**
- [BrowserContext]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-context-return"/><a href="#page-context-return" class="list-anchor">#</a>

---

### dragAndDrop {#page-drag-and-drop}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>page.dragAndDrop</x-search>

Этот метод перетаскивает исходный элемент на целевой элемент. Сначала он перемещается к исходному элементу, выполняет `mousedown`, затем перемещается к целевому элементу и выполняет `mouseup`.

**Использование**

```js
await page.dragAndDrop('#source', '#target');
// или укажите точные позиции относительно верхнего левого угла элементов:
await page.dragAndDrop('#source', '#target', {
  sourcePosition: { x: 34, y: 7 },
  targetPosition: { x: 10, y: 20 },
});
```

**Аргументы**
- `source` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source"/><a href="#page-drag-and-drop-option-source" class="list-anchor">#</a>
  
  Селектор для поиска элемента для перетаскивания. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `target` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target"/><a href="#page-drag-and-drop-option-target" class="list-anchor">#</a>
  
  Селектор для поиска элемента, на который нужно сбросить. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(опционально)*
  - `force` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-force"/><a href="#page-drag-and-drop-option-force" class="list-anchor">#</a>
    
    Пропускать ли проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `noWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-no-wait-after"/><a href="#page-drag-and-drop-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `sourcePosition` [Object] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source-position"/><a href="#page-drag-and-drop-option-source-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Кликает на исходный элемент в этой точке относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `strict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-strict"/><a href="#page-drag-and-drop-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `targetPosition` [Object] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target-position"/><a href="#page-drag-and-drop-option-target-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Сбрасывает на целевой элемент в этой точке относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-timeout"/><a href="#page-drag-and-drop-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью параметра `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `trial` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-trial"/><a href="#page-drag-and-drop-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию, без его выполнения.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-return"/><a href="#page-drag-and-drop-return" class="list-anchor">#</a>

---

### emulateMedia {#page-emulate-media}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.emulateMedia</x-search>

Этот метод изменяет `CSS media type` через аргумент `media` и/или медиа-функцию `'prefers-colors-scheme'`, используя аргумент `colorScheme`.

**Использование**

```js
await page.evaluate(() => matchMedia('screen').matches);
// → true
await page.evaluate(() => matchMedia('print').matches);
// → false

await page.emulateMedia({ media: 'print' });
await page.evaluate(() => matchMedia('screen').matches);
// → false
await page.evaluate(() => matchMedia('print').matches);
// → true

await page.emulateMedia({});
await page.evaluate(() => matchMedia('screen').matches);
// → true
await page.evaluate(() => matchMedia('print').matches);
// → false
```

```js
await page.emulateMedia({ colorScheme: 'dark' });
await page.evaluate(() => matchMedia('(prefers-color-scheme: dark)').matches);
// → true
await page.evaluate(() => matchMedia('(prefers-color-scheme: light)').matches);
// → false
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `colorScheme` [null] | "light" | "dark" | "no-preference" *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-color-scheme"/><a href="#page-emulate-media-option-color-scheme" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию [prefers-colors-scheme](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme), поддерживаемые значения: `'light'` и `'dark'`. Передача `null` отключает эмуляцию цветовой схемы. `'no-preference'` устарело.
  - `contrast` [null] | "no-preference" | "more" *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-contrast"/><a href="#page-emulate-media-option-contrast" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'prefers-contrast'`, поддерживаемые значения: `'no-preference'`, `'more'`. Передача `null` отключает эмуляцию контраста.
  - `forcedColors` [null] | "active" | "none" *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-forced-colors"/><a href="#page-emulate-media-option-forced-colors" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'forced-colors'`, поддерживаемые значения: `'active'` и `'none'`. Передача `null` отключает эмуляцию принудительных цветов.
  - `media` [null] | "screen" | "print" *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-media"/><a href="#page-emulate-media-option-media" class="list-anchor">#</a>
    
    Изменяет CSS media type страницы. Единственные допустимые значения: `'screen'`, `'print'` и `null`. Передача `null` отключает эмуляцию CSS media.
  - `reducedMotion` [null] | "reduce" | "no-preference" *(опционально)* <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-reduced-motion"/><a href="#page-emulate-media-option-reduced-motion" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'prefers-reduced-motion'`, поддерживаемые значения: `'reduce'`, `'no-preference'`. Передача `null` отключает эмуляцию уменьшенного движения.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-return"/><a href="#page-emulate-media-return" class="list-anchor">#</a>

---

### evaluate {#page-evaluate}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.evaluate</x-search>

Возвращает значение вызова [pageFunction](/api/class-page.mdx#page-evaluate-option-expression).

Если функция, переданная в [page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает [Promise], то [page.evaluate()](/api/class-page.mdx#page-evaluate) будет ждать разрешения промиса и вернет его значение.

Если функция, переданная в [page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает не-[Serializable] значение, то [page.evaluate()](/api/class-page.mdx#page-evaluate) разрешится в `undefined`. Playwright также поддерживает передачу некоторых дополнительных значений, которые не сериализуются через `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.

**Использование**

Передача аргумента в [pageFunction](/api/class-page.mdx#page-evaluate-option-expression):

```js
const result = await page.evaluate(([x, y]) => {
  return Promise.resolve(x * y);
}, [7, 8]);
console.log(result); // выводит "56"
```

Вместо функции также можно передать строку:

```js
console.log(await page.evaluate('1 + 2')); // выводит "3"
const x = 10;
console.log(await page.evaluate(`1 + ${x}`)); // выводит "11"
```

Экземпляры [ElementHandle] могут быть переданы в качестве аргумента в [page.evaluate()](/api/class-page.mdx#page-evaluate):

```js
const bodyHandle = await page.evaluate('document.body');
const html = await page.evaluate<string, HTMLElement>(([body, suffix]) =>
  body.innerHTML + suffix, [bodyHandle, 'hello']
);
await bodyHandle.dispose();
```

**Аргументы**
- `pageFunction` [function] | [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-expression"/><a href="#page-evaluate-option-expression" class="list-anchor">#</a>
  
  Функция для выполнения в контексте страницы.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-arg"/><a href="#page-evaluate-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [pageFunction](/api/class-page.mdx#page-evaluate-option-expression).

**Возвращает**
- [Promise]&lt;[Serializable]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-return"/><a href="#page-evaluate-return" class="list-anchor">#</a>

---

### evaluateHandle {#page-evaluate-handle}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.evaluateHandle</x-search>

Возвращает значение вызова [pageFunction](/api/class-page.mdx#page-evaluate-handle-option-expression) в виде [JSHandle].

Единственное отличие между [page.evaluate()](/api/class-page.mdx#page-evaluate) и [page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle) заключается в том, что [page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle) возвращает [JSHandle].

Если функция, переданная в [page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle), возвращает [Promise], то [page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle) будет ждать разрешения промиса и вернет его значение.

**Использование**

```js
// Обработчик для объекта window.
const aWindowHandle = await page.evaluateHandle(() => Promise.resolve(window));
```

Вместо функции также можно передать строку:

```js
const aHandle = await page.evaluateHandle('document'); // Обработчик для 'document'
```

Экземпляры [JSHandle] могут быть переданы в качестве аргумента в [page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle):

```js
const aHandle = await page.evaluateHandle(() => document.body);
const resultHandle = await page.evaluateHandle(body => body.innerHTML, aHandle);
console.log(await resultHandle.jsonValue());
await resultHandle.dispose();
```

**Аргументы**
- `pageFunction` [function] | [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-expression"/><a href="#page-evaluate-handle-option-expression" class="list-anchor">#</a>
  
  Функция для выполнения в контексте страницы.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-arg"/><a href="#page-evaluate-handle-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [pageFunction](/api/class-page.mdx#page-evaluate-handle-option-expression).

**Возвращает**
- [Promise]&lt;[JSHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-return"/><a href="#page-evaluate-handle-return" class="list-anchor">#</a>

---

### exposeBinding {#page-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.exposeBinding</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-binding-option-name) в объект `window` каждого фрейма на этой странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-binding-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-binding-option-callback). Если [callback](/api/class-page.mdx#page-expose-binding-option-callback) возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-page.mdx#page-expose-binding-option-callback) содержит информацию о вызывающем: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

Смотрите [browserContext.exposeBinding()](/api/class-browsercontext.mdx#browser-context-expose-binding) для версии, охватывающей весь контекст.

:::note

Функции, установленные через [page.exposeBinding()](/api/class-page.mdx#page-expose-binding), сохраняются при навигации.
:::

**Использование**

Пример предоставления URL страницы всем фреймам на странице:

```js
const { webkit } = require('playwright');  // Или 'chromium' или 'firefox'.

(async () => {
  const browser = await webkit.launch({ headless: false });
  const context = await browser.newContext();
  const page = await context.newPage();
  await page.exposeBinding('pageURL', ({ page }) => page.url());
  await page.setContent(`
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
  `);
  await page.click('button');
})();
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-name"/><a href="#page-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [function]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-callback"/><a href="#page-expose-binding-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.
- `options` [Object] *(опционально)*
  - `handle` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-handle"/><a href="#page-expose-binding-option-handle" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция будет удалена в будущем.
    :::
    
    Передавать ли аргумент как handle, вместо передачи по значению. При передаче handle поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-return"/><a href="#page-expose-binding-return" class="list-anchor">#</a>

---

### exposeFunction {#page-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.exposeFunction</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-function-option-name) в объект `window` каждого фрейма на странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-function-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-function-option-callback).

Если [callback](/api/class-page.mdx#page-expose-function-option-callback) возвращает [Promise], он будет ожидаться.

Смотрите [browserContext.exposeFunction()](/api/class-browsercontext.mdx#browser-context-expose-function) для функции, охватывающей весь контекст.

:::note

Функции, установленные через [page.exposeFunction()](/api/class-page.mdx#page-expose-function), сохраняются при навигации.
:::

**Использование**

Пример добавления функции `sha256` на страницу:

```js
const { webkit } = require('playwright');  // Или 'chromium' или 'firefox'.
const crypto = require('crypto');

(async () => {
  const browser = await webkit.launch({ headless: false });
  const page = await browser.newPage();
  await page.exposeFunction('sha256', text =>
    crypto.createHash('sha256').update(text).digest('hex'),
  );
  await page.setContent(`
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
  `);
  await page.click('button');
})();
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-name"/><a href="#page-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [function]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-callback"/><a href="#page-expose-function-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-return"/><a href="#page-expose-function-return" class="list-anchor">#</a>

---

### frame {#page-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.frame</x-search>

Возвращает фрейм, соответствующий указанным критериям. Должно быть указано либо `name`, либо `url`.

**Использование**

```js
const frame = page.frame('frame-name');
```

```js
const frame = page.frame({ url: /.*domain.*/ });
```

**Аргументы**
- `frameSelector` [string] | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-option-frame-selector"/><a href="#page-frame-option-frame-selector" class="list-anchor">#</a>
  - `name` [string] *(опционально)*
    
    Имя фрейма, указанное в атрибуте `name` тега `iframe`. Опционально.
  - `url` [string] | [RegExp] | [function]\([URL]\):[boolean] *(опционально)*
    
    Глобальный шаблон, регулярное выражение или предикат, получающий `url` фрейма как объект [URL]. Опционально.
  
  Имя фрейма или другие параметры поиска фрейма.

**Возвращает**
- [null] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-return"/><a href="#page-frame-return" class="list-anchor">#</a>

---

### frameLocator {#page-frame-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.17</font><x-search>page.frameLocator</x-search>

При работе с iframes, вы можете создать локатор фрейма, который войдет в iframe и позволит выбирать элементы в этом iframe.

**Использование**

Следующий пример находит элемент с текстом "Submit" в iframe с id `my-frame`, например `<iframe id="my-frame">`:

```js
const locator = page.frameLocator('#my-iframe').getByText('Submit');
await locator.click();
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-option-selector"/><a href="#page-frame-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении DOM элемента.

**Возвращает**
- [FrameLocator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-return"/><a href="#page-frame-locator-return" class="list-anchor">#</a>

---

### frames {#page-frames}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.frames</x-search>

Массив всех фреймов, прикрепленных к странице.

**Использование**

```js
page.frames();
```

**Возвращает**
- [Array]&lt;[Frame]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frames-return"/><a href="#page-frames-return" class="list-anchor">#</a>

---

### getByAltText {#page-get-by-alt-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.getByAltText</x-search>

Позволяет находить элементы по их alt тексту.

**Использование**

Например, этот метод найдет изображение по alt тексту "Playwright logo":

```html
<img alt='Playwright logo'>
```

```js
await page.getByAltText('Playwright logo').click();
```

**Аргументы**
- `text` [string] | [RegExp]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-text"/><a href="#page-get-by-alt-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` [Object] *(опционально)*
  - `exact` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-exact"/><a href="#page-get-by-alt-text-option-exact" class="list-anchor">#</a>
    
    Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-return"/><a href="#page-get-by-alt-text-return" class="list-anchor">#</a>

---

### getByLabel {#page-get-by-label}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.getByLabel</x-search>

Позволяет находить элементы ввода по тексту связанного элемента `<label>` или `aria-labelledby`, или по атрибуту `aria-label`.

**Использование**

Например, этот метод найдет элементы ввода по меткам "Username" и "Password" в следующем DOM:

```html
<input aria-label="Username">
<label for="password-input">Password:</label>
<input id="password-input">
```

```js
await page.getByLabel('Username').fill('john');
await page.getByLabel('Password').fill('secret');
```

**Аргументы**
- `text` [string] | [RegExp]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-text"/><a href="#page-get-by-label-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` [Object] *(опционально)*
  - `exact` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-exact"/><a href="#page-get-by-label-option-exact" class="list-anchor">#</a>
    
    Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-return"/><a href="#page-get-by-label-return" class="list-anchor">#</a>

---

### getByPlaceholder {#page-get-by-placeholder}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.getByPlaceholder</x-search>

Позволяет находить элементы ввода по тексту placeholder.

**Использование**

Например, рассмотрим следующую структуру DOM.

```html
<input type="email" placeholder="name@example.com" />
```

Вы можете заполнить элемент ввода, найдя его по тексту placeholder:

```js
await page
    .getByPlaceholder('name@example.com')
    .fill('playwright@microsoft.com');
```

**Аргументы**
- `text` [string] | [RegExp]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-text"/><a href="#page-get-by-placeholder-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` [Object] *(опционально)*
  - `exact` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-exact"/><a href="#page-get-by-placeholder-option-exact" class="list-anchor">#</a>
    
    Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-return"/><a href="#page-get-by-placeholder-return" class="list-anchor">#</a>

---

### getByRole {#page-get-by-role}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByRole</x-search>

Позволяет находить элементы по их [ARIA роли](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA атрибутам](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) и [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name).

**Использование**

Рассмотрим следующую структуру DOM.

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```

Вы можете найти каждый элемент по его неявной роли:

```js
await expect(page.getByRole('heading', { name: 'Sign up' })).toBeVisible();

await page.getByRole('checkbox', { name: 'Subscribe' }).check();

await page.getByRole('button', { name: /submit/i }).click();
```

**Аргументы**
- `role` "alert" | "alertdialog" | "application" | "article" | "banner" | "blockquote" | "button" | "caption" | "cell" | "checkbox" | "code" | "columnheader" | "combobox" | "complementary" | "contentinfo" | "definition" | "deletion" | "dialog" | "directory" | "document" | "emphasis" | "feed" | "figure" | "form" | "generic" | "grid" | "gridcell" | "group" | "heading" | "img" | "insertion" | "link" | "list" | "listbox" | "listitem" | "log" | "main" | "marquee" | "math" | "meter" | "menu" | "menubar" | "menuitem" | "menuitemcheckbox" | "menuitemradio" | "navigation" | "none" | "note" | "option" | "paragraph" | "presentation" | "progressbar" | "radio" | "radiogroup" | "region" | "row" | "rowgroup" | "rowheader" | "scrollbar" | "search" | "searchbox" | "separator" | "slider" | "spinbutton" | "status" | "strong" | "subscript" | "superscript" | "switch" | "tab" | "table" | "tablist" | "tabpanel" | "term" | "textbox" | "time" | "timer" | "toolbar" | "tooltip" | "tree" | "treegrid" | "treeitem"<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-role"/><a href="#page-get-by-role-option-role" class="list-anchor">#</a>
  
  Требуемая ARIA роль.
- `options` [Object] *(опционально)*
  - `checked` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-checked"/><a href="#page-get-by-role-option-checked" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-checked` или нативных `<input type=checkbox>` контролов.
    
    Узнайте больше о [`aria-checked`](https://www.w3.org/TR/wai-aria-1.2/#aria-checked).
  - `disabled` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-disabled"/><a href="#page-get-by-role-option-disabled" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-disabled` или `disabled`.
    
    :::note
    
    В отличие от большинства других атрибутов, `disabled` наследуется через иерархию DOM. Узнайте больше о [`aria-disabled`](https://www.w3.org/TR/wai-aria-1.2/#aria-disabled).
    :::
    
  - `exact` [boolean] *(опционально)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-exact"/><a href="#page-get-by-role-option-exact" class="list-anchor">#</a>
    
    Указывает, должно ли [name](/api/class-page.mdx#page-get-by-role-option-name) совпадать точно: с учетом регистра и всей строки. По умолчанию false. Игнорируется, когда [name](/api/class-page.mdx#page-get-by-role-option-name) является регулярным выражением. Обратите внимание, что точное совпадение все равно обрезает пробелы.
  - `expanded` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-expanded"/><a href="#page-get-by-role-option-expanded" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-expanded`.
    
    Узнайте больше о [`aria-expanded`](https://www.w3.org/TR/wai-aria-1.2/#aria-expanded).
  - `includeHidden` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-include-hidden"/><a href="#page-get-by-role-option-include-hidden" class="list-anchor">#</a>
    
    Опция, которая контролирует, будут ли скрытые элементы соответствовать. По умолчанию, только не скрытые элементы, как [определено ARIA](https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion), соответствуют селектору роли.
    
    Узнайте больше о [`aria-hidden`](https://www.w3.org/TR/wai-aria-1.2/#aria-hidden).
  - `level` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-level"/><a href="#page-get-by-role-option-level" class="list-anchor">#</a>
    
    Числовой атрибут, который обычно присутствует для ролей `heading`, `listitem`, `row`, `treeitem`, с значениями по умолчанию для элементов `<h1>-<h6>`.
    
    Узнайте больше о [`aria-level`](https://www.w3.org/TR/wai-aria-1.2/#aria-level).
  - `name` [string] | [RegExp] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-name"/><a href="#page-get-by-role-option-name" class="list-anchor">#</a>
    
    Опция для соответствия [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name). По умолчанию, соответствие не учитывает регистр и ищет подстроку, используйте [exact](/api/class-page.mdx#page-get-by-role-option-exact) для управления этим поведением.
    
    Узнайте больше о [доступном имени](https://w3c.github.io/accname/#dfn-accessible-name).
  - `pressed` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-pressed"/><a href="#page-get-by-role-option-pressed" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-pressed`.
    
    Узнайте больше о [`aria-pressed`](https://www.w3.org/TR/wai-aria-1.2/#aria-pressed).
  - `selected` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-selected"/><a href="#page-get-by-role-option-selected" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-selected`.
    
    Узнайте больше о [`aria-selected`](https://www.w3.org/TR/wai-aria-1.2/#aria-selected).

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-return"/><a href="#page-get-by-role-return" class="list-anchor">#</a>

**Детали**

Селектор роли **не заменяет** аудиты доступности и тесты на соответствие, но дает раннюю обратную связь о руководствах ARIA.

Многие HTML элементы имеют неявно [определенную роль](https://w3c.github.io/html-aam/#html-element-role-mappings), которая распознается селектором роли. Вы можете найти все [поддерживаемые роли здесь](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). Руководства ARIA **не рекомендуют** дублировать неявные роли и атрибуты, устанавливая `role` и/или `aria-*` атрибуты на значения по умолчанию.

---

### getByTestId {#page-get-by-test-id}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByTestId</x-search>

Находит элемент по тестовому идентификатору.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<button data-testid="directions">Itinéraire</button>
```

Вы можете найти элемент по его тестовому идентификатору:

```js
await page.getByTestId('directions').click();
```

**Аргументы**
- `testId` [string] | [RegExp]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-option-test-id"/><a href="#page-get-by-test-id-option-test-id" class="list-anchor">#</a>
  
  Идентификатор для нахождения элемента.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-return"/><a href="#page-get-by-test-id-return" class="list-anchor">#</a>

**Детали**

По умолчанию, атрибут `data-testid` используется как тестовый идентификатор. Используйте [selectors.setTestIdAttribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute) для настройки другого атрибута тестового идентификатора, если это необходимо.

```js
// Установите пользовательский атрибут тестового идентификатора из конфигурации @playwright/test:
import { defineConfig } from '@playwright/test';

export default defineConfig({
  use: {
    testIdAttribute: 'data-pw'
  },
});
```

---

### getByText {#page-get-by-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByText</x-search>

Позволяет находить элементы, содержащие заданный текст.

См. также [locator.filter()](/api/class-locator.mdx#locator-filter), который позволяет сопоставлять по другим критериям, таким как доступная роль, а затем фильтровать по содержимому текста.

**Использование**

Рассмотрим следующую структуру DOM:

```html
<div>Hello <span>world</span></div>
<div>Hello</div>
```

Вы можете находить элементы по подстроке текста, точной строке или регулярному выражению:

```js
// Соответствует <span>
page.getByText('world');

// Соответствует первому <div>
page.getByText('Hello world');

// Соответствует второму <div>
page.getByText('Hello', { exact: true });

// Соответствует обоим <div>
page.getByText(/Hello/);

// Соответствует второму <div>
page.getByText(/^hello$/i);
```

**Аргументы**
- `text` [string] | [RegExp]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-text"/><a href="#page-get-by-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` [Object] *(опционально)*
  - `exact` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-exact"/><a href="#page-get-by-text-option-exact" class="list-anchor">#</a>
    
    Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-return"/><a href="#page-get-by-text-return" class="list-anchor">#</a>

**Детали**

Сопоставление по тексту всегда нормализует пробелы, даже при точном совпадении. Например, оно превращает несколько пробелов в один, заменяет разрывы строк на пробелы и игнорирует начальные и конечные пробелы.

Элементы ввода типа `button` и `submit` сопоставляются по их `value`, а не по содержимому текста. Например, поиск по тексту `"Log in"` соответствует `<input type=button value="Log in">`.

---

### getByTitle {#page-get-by-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByTitle</x-search>

Позволяет находить элементы по их атрибуту title.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<span title='Issues count'>25 issues</span>
```

Вы можете проверить количество проблем, найдя его по тексту заголовка:

```js
await expect(page.getByTitle('Issues count')).toHaveText('25 issues');
```

**Аргументы**
- `text` [string] | [RegExp]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-text"/><a href="#page-get-by-title-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` [Object] *(опционально)*
  - `exact` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-exact"/><a href="#page-get-by-title-option-exact" class="list-anchor">#</a>
    
    Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-return"/><a href="#page-get-by-title-return" class="list-anchor">#</a>

---

### goBack {#page-go-back}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.goBack</x-search>

Возвращает основной ответ ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. Если невозможно вернуться назад, возвращает `null`.

Переход на предыдущую страницу в истории.

**Использование**

```js
await page.goBack();
await page.goBack(options);
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-timeout"/><a href="#page-go-back-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах. По умолчанию `0` - без тайм-аута. Значение по умолчанию можно изменить с помощью опции `navigationTimeout` в конфигурации или с помощью методов [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `waitUntil` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-wait-until"/><a href="#page-go-back-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [Promise]&lt;[null] | [Response]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-return"/><a href="#page-go-back-return" class="list-anchor">#</a>

---

### goForward {#page-go-forward}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.goForward</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация завершится с ответом последнего перенаправления. Если невозможно перейти вперед, возвращает `null`.

Переход на следующую страницу в истории.

**Использование**

```js
await page.goForward();
await page.goForward(options);
```

**Аргументы**
- `options` [Object] *(optional)*
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-timeout"/><a href="#page-go-forward-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах. По умолчанию `0` - без тайм-аута. Значение по умолчанию можно изменить с помощью опции `navigationTimeout` в конфигурации или с помощью методов [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `waitUntil` "load" | "domcontentloaded" | "networkidle" | "commit" *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-wait-until"/><a href="#page-go-forward-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [Promise]&lt;[null] | [Response]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-return"/><a href="#page-go-forward-return" class="list-anchor">#</a>

---

### goto {#page-goto}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.goto</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация завершится с первым не перенаправленным ответом.

Метод вызовет ошибку, если:
* произошла ошибка SSL (например, в случае самоподписанных сертификатов).
* целевой URL недействителен.
* превышено [timeout](/api/class-page.mdx#page-goto-option-timeout) во время навигации.
* удаленный сервер не отвечает или недоступен.
* основной ресурс не удалось загрузить.

Метод не вызовет ошибку, если удаленный сервер вернет любой действительный HTTP-код состояния, включая 404 "Not Found" и 500 "Internal Server Error". Код состояния для таких ответов можно получить, вызвав [response.status()](/api/class-response.mdx#response-status).

:::note

Метод либо вызывает ошибку, либо возвращает ответ основного ресурса. Единственные исключения - это навигация на `about:blank` или навигация на тот же URL с другим хэшем, которые будут успешными и вернут `null`.
:::

:::note
Режим без головы не поддерживает навигацию к PDF-документу. См. [проблему в upstream](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).
:::

**Использование**

```js
await page.goto(url);
await page.goto(url, options);
```

**Аргументы**
- `url` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-url"/><a href="#page-goto-option-url" class="list-anchor">#</a>
  
  URL для перехода на страницу. URL должен включать схему, например, `https://`. Когда через параметры контекста был предоставлен [baseURL](/api/class-browser.mdx#browser-new-context-option-base-url) и переданный URL является путем, он объединяется с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` [Object] *(optional)*
  - `referer` [string] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-referer"/><a href="#page-goto-option-referer" class="list-anchor">#</a>
    
    Значение заголовка Referer. Если предоставлено, оно будет иметь приоритет над значением заголовка referer, установленным с помощью [page.setExtraHTTPHeaders()](/api/class-page.mdx#page-set-extra-http-headers).
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-timeout"/><a href="#page-goto-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах. По умолчанию `0` - без тайм-аута. Значение по умолчанию можно изменить с помощью опции `navigationTimeout` в конфигурации или с помощью методов [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `waitUntil` "load" | "domcontentloaded" | "networkidle" | "commit" *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-wait-until"/><a href="#page-goto-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [Promise]&lt;[null] | [Response]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-return"/><a href="#page-goto-return" class="list-anchor">#</a>

---

### isClosed {#page-is-closed}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isClosed</x-search>

Указывает, что страница была закрыта.

**Использование**

```js
page.isClosed();
```

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-closed-return"/><a href="#page-is-closed-return" class="list-anchor">#</a>

---

### locator {#page-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.14</font><x-search>page.locator</x-search>

Метод возвращает локатор элемента, который можно использовать для выполнения действий на этой странице/фрейме. Локатор разрешается в элемент непосредственно перед выполнением действия, поэтому серия действий на одном и том же локаторе может фактически выполняться на разных элементах DOM. Это произойдет, если структура DOM между этими действиями изменилась.

[Узнайте больше о локаторах](../locators.mdx).

**Использование**

```js
page.locator(selector);
page.locator(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-selector"/><a href="#page-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении DOM элемента.
- `options` [Object] *(optional)*
  - `has` [Locator] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has"/><a href="#page-locator-option-has" class="list-anchor">#</a>
    
    Сужает результаты метода до тех, которые содержат элементы, соответствующие этому относительному локатору. Например, `article`, который имеет `text=Playwright`, соответствует `<article><div>Playwright</div></article>`.
    
    Внутренний локатор **должен быть относительным** к внешнему локатору и запрашивается начиная с совпадения внешнего локатора, а не с корня документа. Например, вы можете найти `content`, который имеет `div` в `<article><content><div>Playwright</div></content></article>`. Однако поиск `content`, который имеет `article div`, не удастся, потому что внутренний локатор должен быть относительным и не должен использовать элементы за пределами `content`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `hasNot` [Locator] *(optional)* <font size="2">Added in: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not"/><a href="#page-locator-option-has-not" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат элемент, соответствующий внутреннему локатору. Внутренний локатор запрашивается относительно внешнего. Например, `article`, который не имеет `div`, соответствует `<article><span>Playwright</span></article>`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `hasNotText` [string] | [RegExp] *(optional)* <font size="2">Added in: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not-text"/><a href="#page-locator-option-has-not-text" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат указанный текст где-либо внутри, возможно, в дочернем или потомственном элементе. При передаче [string] сопоставление нечувствительно к регистру и ищет подстроку.
  - `hasText` [string] | [RegExp] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-text"/><a href="#page-locator-option-has-text" class="list-anchor">#</a>
    
    Соответствует элементам, содержащим указанный текст где-либо внутри, возможно, в дочернем или потомственном элементе. При передаче [string] сопоставление нечувствительно к регистру и ищет подстроку. Например, `"Playwright"` соответствует `<article><div>Playwright</div></article>`.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-return"/><a href="#page-locator-return" class="list-anchor">#</a>

---

### mainFrame {#page-main-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.mainFrame</x-search>

Основной фрейм страницы. Гарантируется, что у страницы всегда есть основной фрейм, который сохраняется при навигации.

**Использование**

```js
page.mainFrame();
```

**Возвращает**
- [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-main-frame-return"/><a href="#page-main-frame-return" class="list-anchor">#</a>

---

### opener {#page-opener}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.opener</x-search>

Возвращает родительскую страницу для всплывающих окон или `null` для остальных случаев. Если родительская страница уже закрыта, также возвращается `null`.

**Использование**

```js
await page.opener();
```

**Возвращает**
- [Promise]&lt;[null] | [Page]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-opener-return"/><a href="#page-opener-return" class="list-anchor">#</a>

---

### pause {#page-pause}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.pause</x-search>

Приостанавливает выполнение скрипта. Playwright остановит выполнение и будет ждать, пока пользователь нажмёт кнопку "Resume" в оверлее страницы или вызовет `playwright.resume()` в консоли DevTools.

Во время паузы можно исследовать селекторы или выполнять ручные действия. После возобновления выполнение продолжится с того места, где было приостановлено.

:::note

Этот метод требует запуска Playwright в оконном режиме, с отключённой опцией [headless](/api/class-browsertype.mdx#browser-type-launch-option-headless).
:::

**Использование**

```js
await page.pause();
```

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pause-return"/><a href="#page-pause-return" class="list-anchor">#</a>

---

### pdf {#page-pdf}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.pdf</x-search>

Возвращает буфер PDF.

`page.pdf()` создаёт PDF-версию страницы с CSS-медиа-типом `print`. Чтобы сгенерировать PDF с медиатипом `screen`, вызовите [page.emulateMedia()](/api/class-page.mdx#page-emulate-media) перед `page.pdf()`:

:::note

По умолчанию `page.pdf()` изменяет цвета для печати. Чтобы принудительно использовать точные цвета, применяйте свойство [`-webkit-print-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust).
:::

**Использование**

```js
// Генерирует PDF с медиатипом 'screen'.
await page.emulateMedia({ media: 'screen' });
await page.pdf({ path: 'page.pdf' });
```

Опции [width](/api/class-page.mdx#page-pdf-option-width), [height](/api/class-page.mdx#page-pdf-option-height) и [margin](/api/class-page.mdx#page-pdf-option-margin) поддерживают значения с единицами измерения. Если единицы не указаны, значение трактуется как пиксели.

Примеры:
* `page.pdf({width: 100})` — ширина 100 пикселей
* `page.pdf({width: '100px'})` — ширина 100 пикселей
* `page.pdf({width: '10cm'})` — ширина 10 сантиметров

Поддерживаемые единицы измерения:
* `px` — пиксель
* `in` — дюйм
* `cm` — сантиметр
* `mm` — миллиметр

Опции [format](/api/class-page.mdx#page-pdf-option-format):
* `Letter`: 8.5in x 11in
* `Legal`: 8.5in x 14in
* `Tabloid`: 11in x 17in
* `Ledger`: 17in x 11in
* `A0`: 33.1in x 46.8in
* `A1`: 23.4in x 33.1in
* `A2`: 16.54in x 23.4in
* `A3`: 11.7in x 16.54in
* `A4`: 8.27in x 11.7in
* `A5`: 5.83in x 8.27in
* `A6`: 4.13in x 5.83in

:::note

Разметка [headerTemplate](/api/class-page.mdx#page-pdf-option-header-template) и [footerTemplate](/api/class-page.mdx#page-pdf-option-footer-template) имеет ограничения:
1. Теги `<script>` внутри шаблонов не выполняются.
2. Стили страницы не применяются внутри шаблонов.
:::

**Аргументы**
- `options` [Object] *(необязательно)*
- `displayHeaderFooter` [boolean] *(необязательно)*
Отображать верхний и нижний колонтитулы. По умолчанию `false`.
- `footerTemplate` [string] *(необязательно)*
HTML-шаблон для нижнего колонтитула. Формат должен совпадать с [headerTemplate](/api/class-page.mdx#page-pdf-option-header-template).
- `format` [string] *(необязательно)*
Формат бумаги. Если указан, имеет приоритет над параметрами [width](/api/class-page.mdx#page-pdf-option-width) и [height](/api/class-page.mdx#page-pdf-option-height). По умолчанию `'Letter'`.
- `headerTemplate` [string] *(необязательно)*
HTML-шаблон для верхнего колонтитула. В шаблоне можно использовать классы:
* `'date'` — дата печати
* `'title'` — заголовок документа
* `'url'` — URL документа
* `'pageNumber'` — текущий номер страницы
* `'totalPages'` — общее количество страниц
- `height` [string] | [number] *(необязательно)*
Высота бумаги, поддерживает единицы измерения.
- `landscape` [boolean] *(необязательно)*
Ориентация бумаги. По умолчанию `false` (портретная).
- `margin` [Object] *(необязательно)*
- `top` [string] | [number] *(необязательно)*
Верхнее поле. По умолчанию `0`.
- `right` [string] | [number] *(необязательно)*
Правое поле. По умолчанию `0`.
- `bottom` [string] | [number] *(необязательно)*
Нижнее поле. По умолчанию `0`.
- `left` [string] | [number] *(необязательно)*
Левое поле. По умолчанию `0`.
- `outline` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.42</font>
Включить оглавление в PDF. По умолчанию `false`.
- `pageRanges` [string] *(необязательно)*
Диапазоны страниц для печати, например `'1-5, 8, 11-13'`. По умолчанию печатаются все страницы.
- `path` [string] *(необязательно)*
Путь для сохранения PDF. Если не указан, PDF не сохраняется на диск.
- `preferCSSPageSize` [boolean] *(необязательно)*
Приоритет размеров из CSS `@page` над `width`, `height` или `format`. По умолчанию `false`.
- `printBackground` [boolean] *(необязательно)*
Печатать фоновые изображения. По умолчанию `false`.
- `scale` [number] *(необязательно)*
Масштабирование рендеринга страницы. По умолчанию `1`.
- `tagged` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.42</font>
Генерировать доступный (tagged) PDF. По умолчанию `false`.
- `width` [string] | [number] *(необязательно)*
Ширина бумаги, поддерживает единицы измерения.

**Возвращает**
- [Promise]&lt;[Buffer]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-return"/><a href="#page-pdf-return" class="list-anchor">#</a>

---

### reload {#page-reload}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.reload</x-search>

Этот метод перезагружает текущую страницу так же, как если бы пользователь инициировал обновление браузера. Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления.

**Использование**

```js
await page.reload();
await page.reload(options);
```

**Аргументы**
- `options` [Object] *(optional)*
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-timeout"/><a href="#page-reload-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах. По умолчанию `0` - без тайм-аута. Значение по умолчанию можно изменить с помощью опции `navigationTimeout` в конфигурации или с помощью методов [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `waitUntil` "load" | "domcontentloaded" | "networkidle" | "commit" *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-wait-until"/><a href="#page-reload-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [Promise]&lt;[null] | [Response]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-return"/><a href="#page-reload-return" class="list-anchor">#</a>

---

### removeAllListeners {#page-remove-all-listeners}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.47</font><x-search>page.removeAllListeners</x-search>

Удаляет всех слушателей данного типа (или всех зарегистрированных слушателей, если тип не указан). Позволяет дождаться завершения асинхронных слушателей или игнорировать последующие ошибки от этих слушателей.

**Использование**

```js
page.on('request', async request => {
  const response = await request.response();
  const body = await response.body();
  console.log(body.byteLength);
});
await page.goto('https://playwright.dev', { waitUntil: 'domcontentloaded' });
// Ожидает завершения всех зарегистрированных событий 'request'.
await page.removeAllListeners('request', { behavior: 'wait' });
```

**Аргументы**
- `type` [string] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-all-listeners-option-type"/><a href="#page-remove-all-listeners-option-type" class="list-anchor">#</a>
- `options` [Object] *(optional)*
  - `behavior` "wait" | "ignoreErrors" | "default" *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-all-listeners-option-behavior"/><a href="#page-remove-all-listeners-option-behavior" class="list-anchor">#</a>
    
    Указывает, ждать ли уже выполняющихся слушателей и что делать, если они вызывают ошибки:
    * `'default'` - не ждать завершения текущих вызовов слушателей (если есть), если слушатель вызывает ошибку, это может привести к необработанной ошибке
    * `'wait'` - ждать завершения текущих вызовов слушателей (если есть)
    * `'ignoreErrors'` - не ждать завершения текущих вызовов слушателей (если есть), все ошибки, вызванные слушателями после удаления, будут тихо пойманы

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-all-listeners-return"/><a href="#page-remove-all-listeners-return" class="list-anchor">#</a>

---

### removeLocatorHandler {#page-remove-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.44</font><x-search>page.removeLocatorHandler</x-search>

Удаляет все обработчики локаторов, добавленные с помощью [page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler) для конкретного локатора.

**Использование**

```js
await page.removeLocatorHandler(locator);
```

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-option-locator"/><a href="#page-remove-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, переданный в [page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-return"/><a href="#page-remove-locator-handler-return" class="list-anchor">#</a>

---

### requestGC {#page-request-gc}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.48</font><x-search>page.requestGC</x-search>

Запрашивает у страницы выполнение сборки мусора. Обратите внимание, что нет гарантии, что все недостижимые объекты будут собраны.

Это полезно для обнаружения утечек памяти. Например, если на вашей странице есть большой объект `'suspect'`, который может утекать, вы можете проверить, что он не утек, используя [`WeakRef`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef).

```js
// 1. На вашей странице сохраните WeakRef для "suspect".
await page.evaluate(() => globalThis.suspectWeakRef = new WeakRef(suspect));
// 2. Запросите сборку мусора.
await page.requestGC();
// 3. Убедитесь, что weak ref не ссылается на оригинальный объект.
expect(await page.evaluate(() => !globalThis.suspectWeakRef.deref())).toBe(true);
```

**Использование**

```js
await page.requestGC();
```

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-request-gc-return"/><a href="#page-request-gc-return" class="list-anchor">#</a>

---

### route {#page-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.route</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются страницей.

После включения маршрутизации каждый запрос, соответствующий шаблону URL, будет приостановлен, если он не будет продолжен, выполнен или прерван.

:::note

Обработчик будет вызван только для первого URL, если ответ является перенаправлением.
:::

:::note
[page.route()](/api/class-page.mdx#page-route) не будет перехватывать запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [serviceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

:::note
[page.route()](/api/class-page.mdx#page-route) не будет перехватывать первый запрос всплывающей страницы. Используйте [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) вместо этого.
:::

**Использование**

Пример простого обработчика, который прерывает все запросы изображений:

```js
const page = await browser.newPage();
await page.route('**/*.{png,jpg,jpeg}', route => route.abort());
await page.goto('https://example.com');
await browser.close();
```

или тот же фрагмент, используя шаблон регулярного выражения:

```js
const page = await browser.newPage();
await page.route(/(\.png$)|(\.jpg$)/, route => route.abort());
await page.goto('https://example.com');
await browser.close();
```

Можно исследовать запрос, чтобы решить, какое действие предпринять. Например, имитировать все запросы, содержащие некоторые данные POST, и оставлять все остальные запросы как есть:

```js
await page.route('/api/**', async route => {
  if (route.request().postData().includes('my-string'))
    await route.fulfill({ body: 'mocked-data' });
  else
    await route.continue();
});
```

Маршруты страницы имеют приоритет над маршрутами контекста браузера (настроенными с помощью [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route)), когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [page.unroute()](/api/class-page.mdx#page-unroute).

:::note

Включение маршрутизации отключает HTTP-кэш.
:::

**Аргументы**
- `url` [string] | [RegExp] | [function]\([URL]\):[boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-url"/><a href="#page-route-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, шаблон регулярного выражения или предикат, получающий [URL] для сопоставления при маршрутизации. Когда [baseURL](/api/class-browser.mdx#browser-new-context-option-base-url) через параметры контекста был предоставлен и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `handler` [function]\([Route], [Request]\):[Promise]&lt;[Object]&gt; | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-handler"/><a href="#page-route-option-handler" class="list-anchor">#</a>
  
  функция-обработчик для маршрутизации запроса.
- `options` [Object] *(optional)*
  - `times` [number] *(optional)* <font size="2">Added in: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-times"/><a href="#page-route-option-times" class="list-anchor">#</a>
    
    Сколько раз маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-return"/><a href="#page-route-return" class="list-anchor">#</a>

---

### routeFromHAR {#page-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.23</font><x-search>page.routeFromHAR</x-search>

Если указано, сетевые запросы, сделанные на странице, будут обслуживаться из HAR-файла. Подробнее читайте в разделе [Воспроизведение из HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из HAR-файла. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [serviceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```js
await page.routeFromHAR(har);
await page.routeFromHAR(har, options);
```

**Аргументы**
- `har` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-har"/><a href="#page-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec) файлу с предварительно записанными сетевыми данными. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `options` [Object] *(опционально)*
  - `notFound` "abort" | "fallback" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-not-found"/><a href="#page-route-from-har-option-not-found" class="list-anchor">#</a>
    * Если установлено значение 'abort', любой запрос, не найденный в HAR-файле, будет прерван.
    * Если установлено значение 'fallback', отсутствующие запросы будут отправлены в сеть.
    
    По умолчанию abort.
  - `update` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update"/><a href="#page-route-from-har-option-update" class="list-anchor">#</a>
    
    Если указано, обновляет данный HAR с фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск при вызове [browserContext.close()](/api/class-browsercontext.mdx#browser-context-close).
  - `updateContent` "embed" | "attach" *(опционально)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-content"/><a href="#page-route-from-har-option-update-content" class="list-anchor">#</a>
    
    Опциональная настройка для управления содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP-архиве. Если указано `embed`, содержимое сохраняется встраиваемым в HAR-файл.
  - `updateMode` "full" | "minimal" *(опционально)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-mode"/><a href="#page-route-from-har-option-update-mode" class="list-anchor">#</a>
    
    Когда установлено значение `minimal`, записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницу, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию `minimal`.
  - `url` [string] | [RegExp] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-url"/><a href="#page-route-from-har-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR-файла. Если не указано, все запросы обслуживаются из HAR-файла.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-return"/><a href="#page-route-from-har-return" class="list-anchor">#</a>

---

### routeWebSocket {#page-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.48</font><x-search>page.routeWebSocket</x-search>

Этот метод позволяет изменять WebSocket-соединения, которые создаются страницей.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизироваться. Рекомендуется вызывать этот метод перед навигацией по странице.

**Использование**

Ниже приведен пример простого мока, который отвечает на одно сообщение. Подробнее и примеры смотрите в [WebSocketRoute].

```js
await page.routeWebSocket('/ws', ws => {
  ws.onMessage(message => {
    if (message === 'request')
      ws.send('response');
  });
});
```

**Аргументы**
- `url` [string] | [RegExp] | [function]\([URL]\):[boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-url"/><a href="#page-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизироваться. Строковый шаблон может быть относительным к [baseURL](/api/class-browser.mdx#browser-new-context-option-base-url) контекстной опции.
- `handler` [function]\([WebSocketRoute]\):[Promise]&lt;[Object]&gt; | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-handler"/><a href="#page-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-return"/><a href="#page-route-web-socket-return" class="list-anchor">#</a>

---

### screenshot {#page-screenshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.screenshot</x-search>

Возвращает буфер с захваченным скриншотом.

**Использование**

```js
await page.screenshot();
await page.screenshot(options);
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `animations` "disabled" | "allow" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-animations"/><a href="#page-screenshot-option-animations" class="list-anchor">#</a>
    
    При установке в `"disabled"`, останавливает CSS-анимации, CSS-переходы и веб-анимации. Анимации получают разное обращение в зависимости от их продолжительности:
    * конечные анимации быстро перематываются до завершения, чтобы они вызвали событие `transitionend`.
    * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся после скриншота.
    
    По умолчанию `"allow"`, что оставляет анимации нетронутыми.
  - `caret` "hide" | "initial" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-caret"/><a href="#page-screenshot-option-caret" class="list-anchor">#</a>
    
    При установке в `"hide"`, скриншот скроет текстовый курсор. При установке в `"initial"`, поведение текстового курсора не будет изменено. По умолчанию `"hide"`.
  - `clip` [Object] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-clip"/><a href="#page-screenshot-option-clip" class="list-anchor">#</a>
    - `x` [number]
      
      x-координата верхнего левого угла области обрезки
    - `y` [number]
      
      y-координата верхнего левого угла области обрезки
    - `width` [number]
      
      ширина области обрезки
    - `height` [number]
      
      высота области обрезки
    
    Объект, который указывает обрезку результирующего изображения.
  - `fullPage` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-full-page"/><a href="#page-screenshot-option-full-page" class="list-anchor">#</a>
    
    Если true, делает скриншот всей прокручиваемой страницы, вместо текущей видимой области. По умолчанию `false`.
  - `mask` [Array]&lt;[Locator]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask"/><a href="#page-screenshot-option-mask" class="list-anchor">#</a>
    
    Укажите локаторы, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут покрыты розовым прямоугольником `#FF00FF` (настраивается с помощью [maskColor](/api/class-page.mdx#page-screenshot-option-mask-color)), который полностью покрывает их ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Сопоставление только видимых элементов](../locators.mdx#matching-only-visible-elements), чтобы отключить это.
  - `maskColor` [string] *(опционально)* <font size="2">Added in: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask-color"/><a href="#page-screenshot-option-mask-color" class="list-anchor">#</a>
    
    Укажите цвет наложения для замаскированных элементов в [CSS формате цвета](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию - розовый `#FF00FF`.
  - `omitBackground` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-omit-background"/><a href="#page-screenshot-option-omit-background" class="list-anchor">#</a>
    
    Скрывает белый фон по умолчанию и позволяет делать скриншоты с прозрачностью. Не применимо к изображениям `jpeg`. По умолчанию `false`.
  - `path` [string] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-path"/><a href="#page-screenshot-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения изображения. Тип скриншота будет определен по расширению файла. Если [path](/api/class-page.mdx#page-screenshot-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, изображение не будет сохранено на диск.
  - `quality` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-quality"/><a href="#page-screenshot-option-quality" class="list-anchor">#</a>
    
    Качество изображения, от 0 до 100. Не применимо к изображениям `png`.
  - `scale` "css" | "device" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-scale"/><a href="#page-screenshot-option-scale" class="list-anchor">#</a>
    
    При установке в `"css"`, скриншот будет иметь один пиксель на каждый css пиксель на странице. Для устройств с высоким разрешением это позволит уменьшить размер скриншотов. Использование опции `"device"` создаст один пиксель на каждый пиксель устройства, так что скриншоты устройств с высоким разрешением будут в два раза больше или даже больше.
    
    По умолчанию `"device"`.
  - `style` [string] *(опционально)* <font size="2">Added in: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-style"/><a href="#page-screenshot-option-style" class="list-anchor">#</a>
    
    Текст таблицы стилей для применения при создании скриншота. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создавать повторяемые скриншоты. Эта таблица стилей проникает в Shadow DOM и применяется к внутренним фреймам.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-timeout"/><a href="#page-screenshot-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без тайм-аута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `type` "png" | "jpeg" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-type"/><a href="#page-screenshot-option-type" class="list-anchor">#</a>
    
    Укажите тип скриншота, по умолчанию `png`.

**Возвращает**
- [Promise]&lt;[Buffer]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-return"/><a href="#page-screenshot-return" class="list-anchor">#</a>

---

### setContent {#page-set-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.setContent</x-search>

Этот метод внутренне вызывает [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), наследуя все его специфические характеристики и поведение.

**Использование**

```js
await page.setContent(html);
await page.setContent(html, options);
```

**Аргументы**
- `html` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-html"/><a href="#page-set-content-option-html" class="list-anchor">#</a>
  
  HTML разметка, которую нужно назначить странице.
- `options` [Object] *(опционально)*
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-timeout"/><a href="#page-set-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах. По умолчанию `0` - без тайм-аута. Значение по умолчанию можно изменить с помощью опции `navigationTimeout` в конфигурации или с помощью методов [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `waitUntil` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-wait-until"/><a href="#page-set-content-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-return"/><a href="#page-set-content-return" class="list-anchor">#</a>

---

### setDefaultNavigationTimeout {#page-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.setDefaultNavigationTimeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных с ними ярлыков:
* [page.goBack()](/api/class-page.mdx#page-go-back)
* [page.goForward()](/api/class-page.mdx#page-go-forward)
* [page.goto()](/api/class-page.mdx#page-goto)
* [page.reload()](/api/class-page.mdx#page-reload)
* [page.setContent()](/api/class-page.mdx#page-set-content)
* [page.waitForNavigation()](/api/class-page.mdx#page-wait-for-navigation)
* [page.waitForURL()](/api/class-page.mdx#page-wait-for-url)

:::note

[page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout), [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) и [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```js
page.setDefaultNavigationTimeout(timeout);
```

**Аргументы**
- `timeout` [number]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-navigation-timeout-option-timeout"/><a href="#page-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### setDefaultTimeout {#page-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.setDefaultTimeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих опцию [timeout](/api/class-page.mdx#page-set-default-timeout-option-timeout).

:::note

[page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
:::

**Использование**

```js
page.setDefaultTimeout(timeout);
```

**Аргументы**
- `timeout` [number]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-timeout-option-timeout"/><a href="#page-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### setExtraHTTPHeaders {#page-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.setExtraHTTPHeaders</x-search>

Дополнительные HTTP-заголовки будут отправляться с каждым запросом, инициированным страницей.

:::note

[page.setExtraHTTPHeaders()](/api/class-page.mdx#page-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```js
await page.setExtraHTTPHeaders(headers);
```

**Аргументы**
- `headers` [Object]&lt;[string], [string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-option-headers"/><a href="#page-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP-заголовки, которые будут отправляться с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-return"/><a href="#page-set-extra-http-headers-return" class="list-anchor">#</a>

---

### setViewportSize {#page-set-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.setViewportSize</x-search>

В случае нескольких страниц в одном браузере каждая страница может иметь свой собственный размер области просмотра. Однако [browser.newContext()](/api/class-browser.mdx#browser-new-context) позволяет установить размер области просмотра (и многое другое) для всех страниц в контексте сразу.

[page.setViewportSize()](/api/class-page.mdx#page-set-viewport-size) изменит размер страницы. Многие веб-сайты не ожидают, что телефоны будут менять размер, поэтому вы должны установить размер области просмотра перед переходом на страницу. [page.setViewportSize()](/api/class-page.mdx#page-set-viewport-size) также сбросит размер `screen`, используйте [browser.newContext()](/api/class-browser.mdx#browser-new-context) с параметрами `screen` и `viewport`, если вам нужен лучший контроль над этими свойствами.

**Использование**

```js
const page = await browser.newPage();
await page.setViewportSize({
  width: 640,
  height: 480,
});
await page.goto('https://example.com');
```

**Аргументы**
- `viewportSize` [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-option-viewport-size"/><a href="#page-set-viewport-size-option-viewport-size" class="list-anchor">#</a>
  - `width` [number]
    
    ширина страницы в пикселях.
  - `height` [number]
    
    высота страницы в пикселях.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-return"/><a href="#page-set-viewport-size-return" class="list-anchor">#</a>

---

### title {#page-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.title</x-search>

Возвращает заголовок страницы.

**Использование**

```js
await page.title();
```

**Возвращает**
- [Promise]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-title-return"/><a href="#page-title-return" class="list-anchor">#</a>

---

### unroute {#page-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.unroute</x-search>

Удаляет маршрут, созданный с помощью [page.route()](/api/class-page.mdx#page-route). Когда [handler](/api/class-page.mdx#page-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-page.mdx#page-unroute-option-url).

**Использование**

```js
await page.unroute(url);
await page.unroute(url, handler);
```

**Аргументы**
- `url` [string] | [RegExp] | [function]\([URL]\):[boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-url"/><a href="#page-unroute-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для сопоставления при маршрутизации.
- `handler` [function]\([Route], [Request]\):[Promise]&lt;[Object]&gt; | [Object] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-handler"/><a href="#page-unroute-option-handler" class="list-anchor">#</a>
  
  Необязательная функция-обработчик для маршрутизации запроса.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-return"/><a href="#page-unroute-return" class="list-anchor">#</a>

---

### unrouteAll {#page-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.41</font><x-search>page.unrouteAll</x-search>

Удаляет все маршруты, созданные с помощью [page.route()](/api/class-page.mdx#page-route) и [page.routeFromHAR()](/api/class-page.mdx#page-route-from-har).

**Использование**

```js
await page.unrouteAll();
await page.unrouteAll(options);
```

**Аргументы**
- `options` [Object] *(опционально)*
  - `behavior` "wait" | "ignoreErrors" | "default" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-option-behavior"/><a href="#page-unroute-all-option-behavior" class="list-anchor">#</a>
    
    Указывает, следует ли ждать уже выполняющихся обработчиков и что делать, если они выбрасывают ошибки:
    * `'default'` - не ждать завершения текущих вызовов обработчиков (если есть), если обработчик выбрасывает ошибку, это может привести к необработанной ошибке
    * `'wait'` - ждать завершения текущих вызовов обработчиков (если есть)
    * `'ignoreErrors'` - не ждать завершения текущих вызовов обработчиков (если есть), все ошибки, выброшенные обработчиками после удаления маршрута, будут тихо пойманы

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-return"/><a href="#page-unroute-all-return" class="list-anchor">#</a>

---

### url {#page-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.url</x-search>

**Использование**

```js
page.url();
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-url-return"/><a href="#page-url-return" class="list-anchor">#</a>

---

### video {#page-video}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.video</x-search>

Объект видео, связанный с этой страницей.

**Использование**

```js
page.video();
```

**Возвращает**
- [null] | [Video]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-video-return"/><a href="#page-video-return" class="list-anchor">#</a>

---

### viewportSize {#page-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.viewportSize</x-search>

**Использование**

```js
page.viewportSize();
```

**Возвращает**
- [null] | [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-viewport-size-return"/><a href="#page-viewport-size-return" class="list-anchor">#</a>
  - `width` [number]
    
    ширина страницы в пикселях.
  - `height` [number]
    
    высота страницы в пикселях.

---

### waitForEvent {#page-wait-for-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForEvent</x-search>

Ожидает, когда событие будет вызвано, и передает его значение в функцию-предикат. Возвращает, когда предикат возвращает истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие будет вызвано. Возвращает значение данных события.

**Использование**

```js
// Начинаем ожидание загрузки перед кликом. Обратите внимание, что нет await.
const downloadPromise = page.waitForEvent('download');
await page.getByText('Download file').click();
const download = await downloadPromise;
```

**Аргументы**
- `event` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-option-event"/><a href="#page-wait-for-event-option-event" class="list-anchor">#</a>
  
  Имя события, обычно передаваемое в `*.on(event)`.
- `optionsOrPredicate` [function] | [Object] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-option-options-or-predicate"/><a href="#page-wait-for-event-option-options-or-predicate" class="list-anchor">#</a>
  - `predicate` [function]
    
    Получает данные события и разрешается в истинное значение, когда ожидание должно завершиться.
  - `timeout` [number] *(optional)*
    
    Максимальное время ожидания в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  
  Либо предикат, который получает событие, либо объект с опциями. Необязательно.
- `options` [Object] *(optional)*
  - `predicate` [function] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-option-predicate"/><a href="#page-wait-for-event-option-predicate" class="list-anchor">#</a>
    
    Получает данные события и разрешается в истинное значение, когда ожидание должно завершиться.

**Возвращает**
- [Promise]&lt;[Object]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-return"/><a href="#page-wait-for-event-return" class="list-anchor">#</a>

---

### waitForFunction {#page-wait-for-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForFunction</x-search>

Возвращает, когда [pageFunction](/api/class-page.mdx#page-wait-for-function-option-expression) возвращает истинное значение. Разрешается в JSHandle истинного значения.

**Использование**

[page.waitForFunction()](/api/class-page.mdx#page-wait-for-function) может быть использован для наблюдения за изменением размера области просмотра:

```js
const { webkit } = require('playwright');  // Или 'chromium' или 'firefox'.

(async () => {
  const browser = await webkit.launch();
  const page = await browser.newPage();
  const watchDog = page.waitForFunction(() => window.innerWidth < 100);
  await page.setViewportSize({ width: 50, height: 50 });
  await watchDog;
  await browser.close();
})();
```

Чтобы передать аргумент в предикат функции [page.waitForFunction()](/api/class-page.mdx#page-wait-for-function):

```js
const selector = '.foo';
await page.waitForFunction(selector => !!document.querySelector(selector), selector);
```

**Аргументы**
- `pageFunction` [function] | [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-expression"/><a href="#page-wait-for-function-option-expression" class="list-anchor">#</a>
  
  Функция, которая будет выполнена в контексте страницы.
- `arg` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-arg"/><a href="#page-wait-for-function-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [pageFunction](/api/class-page.mdx#page-wait-for-function-option-expression).
- `options` [Object] *(optional)*
  - `polling` [number] | "raf" *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-polling"/><a href="#page-wait-for-function-option-polling" class="list-anchor">#</a>
    
    Если [polling](/api/class-page.mdx#page-wait-for-function-option-polling) равно `'raf'`, то [pageFunction](/api/class-page.mdx#page-wait-for-function-option-expression) постоянно выполняется в `requestAnimationFrame` callback. Если [polling](/api/class-page.mdx#page-wait-for-function-option-polling) является числом, то оно рассматривается как интервал в миллисекундах, с которым функция будет выполняться. По умолчанию `raf`.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-timeout"/><a href="#page-wait-for-function-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[JSHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-return"/><a href="#page-wait-for-function-return" class="list-anchor">#</a>

---

### waitForLoadState {#page-wait-for-load-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForLoadState</x-search>

Возвращает, когда достигнуто требуемое состояние загрузки.

Это разрешается, когда страница достигает требуемого состояния загрузки, по умолчанию `load`. Навигация должна быть завершена, когда вызывается этот метод. Если текущий документ уже достиг требуемого состояния, разрешается немедленно.

:::note

В большинстве случаев этот метод не нужен, потому что Playwright [автоматически ожидает перед каждым действием](../actionability.mdx).
:::

**Использование**

```js
await page.getByRole('button').click(); // Клик вызывает навигацию.
await page.waitForLoadState(); // Обещание разрешается после события 'load'.
```

```js
const popupPromise = page.waitForEvent('popup');
await page.getByRole('button').click(); // Клик вызывает всплывающее окно.
const popup = await popupPromise;
await popup.waitForLoadState('domcontentloaded'); // Ожидание события 'DOMContentLoaded'.
console.log(await popup.title()); // Всплывающее окно готово к использованию.
```

**Аргументы**
- `state` "load" | "domcontentloaded" | "networkidle" *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-state"/><a href="#page-wait-for-load-state-option-state" class="list-anchor">#</a>
  
  Необязательное состояние загрузки для ожидания, по умолчанию `load`. Если состояние уже достигнуто при загрузке текущего документа, метод разрешается немедленно. Может быть одним из:
  * `'load'` - ожидание, когда событие `load` будет вызвано.
  * `'domcontentloaded'` - ожидание, когда событие `DOMContentLoaded` будет вызвано.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** ожидание, пока не будет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
- `options` [Object] *(optional)*
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-timeout"/><a href="#page-wait-for-load-state-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `navigationTimeout` в конфигурации или с помощью методов [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-return"/><a href="#page-wait-for-load-state-return" class="list-anchor">#</a>

---

### waitForRequest {#page-wait-for-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForRequest</x-search>

Ожидает соответствующий запрос и возвращает его. Подробнее о событиях см. в разделе [ожидание события](../events.mdx#waiting-for-event).

**Использование**

```js
// Начинаем ожидание запроса перед кликом. Обратите внимание, что await отсутствует.
const requestPromise = page.waitForRequest('https://example.com/resource');
await page.getByText('trigger request').click();
const request = await requestPromise;

// Альтернативный способ с предикатом. Обратите внимание, что await отсутствует.
const requestPromise = page.waitForRequest(request =>
  request.url() === 'https://example.com' && request.method() === 'GET',
);
await page.getByText('trigger request').click();
const request = await requestPromise;
```

**Аргументы**
- `urlOrPredicate` [string] | [RegExp] | [function]\([Request]\):[boolean] | [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-url-or-predicate"/><a href="#page-wait-for-request-option-url-or-predicate" class="list-anchor">#</a>
  
  Строка URL запроса, регулярное выражение или предикат, получающий объект [Request].
- `options` [Object] *(опционально)*
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-timeout"/><a href="#page-wait-for-request-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить с помощью метода [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[Request]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-return"/><a href="#page-wait-for-request-return" class="list-anchor">#</a>

---

### waitForResponse {#page-wait-for-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForResponse</x-search>

Возвращает соответствующий ответ. Подробнее о событиях см. в разделе [ожидание события](../events.mdx#waiting-for-event).

**Использование**

```js
// Начинаем ожидание ответа перед кликом. Обратите внимание, что await отсутствует.
const responsePromise = page.waitForResponse('https://example.com/resource');
await page.getByText('trigger response').click();
const response = await responsePromise;

// Альтернативный способ с предикатом. Обратите внимание, что await отсутствует.
const responsePromise = page.waitForResponse(response =>
  response.url() === 'https://example.com' && response.status() === 200
      && response.request().method() === 'GET'
);
await page.getByText('trigger response').click();
const response = await responsePromise;
```

**Аргументы**
- `urlOrPredicate` [string] | [RegExp] | [function]\([Response]\):[boolean] | [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-url-or-predicate"/><a href="#page-wait-for-response-option-url-or-predicate" class="list-anchor">#</a>
  
  Строка URL запроса, регулярное выражение или предикат, получающий объект [Response]. Когда [baseURL](/api/class-browser.mdx#browser-new-context-option-base-url) предоставлен через параметры контекста и переданный URL является путем, он объединяется с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` [Object] *(опционально)*
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-timeout"/><a href="#page-wait-for-response-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[Response]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-return"/><a href="#page-wait-for-response-return" class="list-anchor">#</a>

---

### waitForURL {#page-wait-for-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>page.waitForURL</x-search>

Ожидает, пока основной фрейм перейдет на указанный URL.

**Использование**

```js
await page.click('a.delayed-navigation'); // Клик по ссылке косвенно вызовет навигацию
await page.waitForURL('**/target.html');
```

**Аргументы**
- `url` [string] | [RegExp] | [function]\([URL]\):[boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-url"/><a href="#page-wait-for-url-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для сопоставления во время ожидания навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
- `options` [Object] *(опционально)*
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-timeout"/><a href="#page-wait-for-url-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах. По умолчанию `0` - без тайм-аута. Значение по умолчанию можно изменить через опцию `navigationTimeout` в конфигурации или с помощью методов [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `waitUntil` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-wait-until"/><a href="#page-wait-for-url-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-return"/><a href="#page-wait-for-url-return" class="list-anchor">#</a>

---

### workers {#page-workers}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.workers</x-search>

Этот метод возвращает все выделенные [WebWorkers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API), связанные со страницей.

:::note

Это не включает ServiceWorkers
:::

**Использование**

```js
page.workers();
```

**Возвращает**
- [Array]&lt;[Worker]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-workers-return"/><a href="#page-workers-return" class="list-anchor">#</a>

---

## Свойства

### clock {#page-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.45</font><x-search>page.clock</x-search>

Playwright имеет возможность имитировать работу часов и течение времени.

**Использование**

```js
page.clock
```

**Тип**
- [Clock]

---

### coverage {#page-coverage}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.coverage</x-search>

:::note

На данный момент доступно только для Chromium.
:::

Реализация покрытия, специфичная для браузера. Подробнее см. [Coverage](./class-coverage).

**Использование**

```js
page.coverage
```

**Тип**
- [Coverage]

---

### keyboard {#page-keyboard}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.keyboard</x-search>

**Использование**

```js
page.keyboard
```

**Тип**
- [Keyboard]

---

### mouse {#page-mouse}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.mouse</x-search>

**Использование**

```js
page.mouse
```

**Тип**
- [Mouse]

---

### request {#page-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.16</font><x-search>page.request</x-search>

Помощник для тестирования API, связанный с этой страницей. Этот метод возвращает тот же экземпляр, что и [browserContext.request](/api/class-browsercontext.mdx#browser-context-request) в контексте страницы. Подробнее см. [browserContext.request](/api/class-browsercontext.mdx#browser-context-request).

**Использование**

```js
page.request
```

**Тип**
- [APIRequestContext]

---

### touchscreen {#page-touchscreen}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.touchscreen</x-search>

**Использование**

```js
page.touchscreen
```

**Тип**
- [Touchscreen]

---

## События

### on('close') {#page-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on('close')</x-search>

Вызывается, когда страница закрывается.

**Использование**

```js
page.on('close', data => {});
```

**Данные события**
- [Page]

---

### on('console') {#page-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on('console')</x-search>

Вызывается, когда JavaScript на странице вызывает один из методов консольного API, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

```js
page.on('console', async msg => {
  const values = [];
  for (const arg of msg.args())
    values.push(await arg.jsonValue());
  console.log(...values);
});
await page.evaluate(() => console.log('hello', 5, { foo: 'bar' }));
```

**Данные события**
- [ConsoleMessage]

---

### on('crash') {#page-event-crash}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on('crash')</x-search>

Вызывается, когда страница падает. Страницы браузера могут падать, если они пытаются выделить слишком много памяти. Когда страница падает, текущие и последующие операции будут вызывать исключения.

Наиболее распространенный способ справиться с падениями - поймать исключение:

```js
try {
  // Падение может произойти во время клика.
  await page.click('button');
  // Или во время ожидания события.
  await page.waitForEvent('popup');
} catch (e) {
  // Когда страница падает, сообщение об исключении содержит 'crash'.
}
```

**Использование**

```js
page.on('crash', data => {});
```

**Данные события**
- [Page]

---

### on('dialog') {#page-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on('dialog')</x-search>

Вызывается, когда появляется JavaScript-диалог, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Слушатель **должен** либо [dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница [заморозится](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалога, и действия, такие как клик, никогда не завершатся.

**Использование**

```js
page.on('dialog', dialog => dialog.accept());
```

:::note
Когда нет слушателей [page.on('dialog')](/api/class-page.mdx#page-event-dialog) или [browserContext.on('dialog')](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### on('domcontentloaded') {#page-event-dom-content-loaded}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on('domcontentloaded')</x-search>

Вызывается, когда JavaScript-событие [`DOMContentLoaded`](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded) отправляется.

**Использование**

```js
page.on('domcontentloaded', data => {});
```

**Данные события**
- [Page]

---

### on('download') {#page-event-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on('download')</x-search>

Вызывается, когда начинается загрузка вложения. Пользователь может получить доступ к основным операциям с файлами на загруженном контенте через переданный экземпляр [Download].

**Использование**

```js
page.on('download', data => {});
```

**Данные события**
- [Download]

---

### on('filechooser') {#page-event-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on('filechooser')</x-search>

Вызывается, когда предполагается появление выбора файла, например, после нажатия на `<input type=file>`. Playwright может ответить на это, установив файлы ввода с помощью [fileChooser.setFiles()](/api/class-filechooser.mdx#file-chooser-set-files), которые могут быть загружены после этого.

```js
page.on('filechooser', async fileChooser => {
  await fileChooser.setFiles(path.join(__dirname, '/tmp/myfile.pdf'));
});
```

**Использование**

```js
page.on('filechooser', data => {});
```

**Данные события**
- [FileChooser]

---

### on('frameattached') {#page-event-frame-attached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on('frameattached')</x-search>

Вызывается, когда фрейм присоединяется.

**Использование**

```js
page.on('frameattached', data => {});
```

**Данные события**
- [Frame]

---

### on('framedetached') {#page-event-frame-detached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on('framedetached')</x-search>

Вызывается, когда фрейм отсоединяется.

**Использование**

```js
page.on('framedetached', data => {});
```

**Данные события**
- [Frame]

---

### on('framenavigated') {#page-event-frame-navigated}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on('framenavigated')</x-search>

Вызывается, когда фрейм переходит на новый URL.

**Использование**

```js
page.on('framenavigated', data => {});
```

**Данные события**
- [Frame]

---

### on('load') {#page-event-load}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on('load')</x-search>

Вызывается, когда JavaScript событие [`load`](https://developer.mozilla.org/en-US/docs/Web/Events/load) отправляется.

**Использование**

```js
page.on('load', data => {});
```

**Данные события**
- [Page]

---

### on('pageerror') {#page-event-page-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on('pageerror')</x-search>

Вызывается, когда на странице происходит необработанное исключение.

```js
// Логировать все необработанные ошибки в терминал
page.on('pageerror', exception => {
  console.log(`Необработанное исключение: "${exception}"`);
});

// Перейти на страницу с исключением.
await page.goto('data:text/html,<script>throw new Error("Test")</script>');
```

**Использование**

```js
page.on('pageerror', data => {});
```

**Данные события**
- [Error]

---

### on('popup') {#page-event-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on('popup')</x-search>

Вызывается, когда страница открывает новую вкладку или окно. Это событие вызывается в дополнение к [browserContext.on('page')](/api/class-browsercontext.mdx#browser-context-event-page), но только для всплывающих окон, относящихся к этой странице.

Самый ранний момент, когда страница доступна, это когда она перешла на начальный URL. Например, при открытии всплывающего окна с помощью `window.open('http://example.com')`, это событие сработает, когда сетевой запрос к "http://example.com" будет выполнен и его ответ начнет загружаться во всплывающем окне. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [browserContext.on('request')](/api/class-browsercontext.mdx#browser-context-event-request) соответственно, вместо аналогичных методов на [Page].

```js
// Начать ожидание всплывающего окна перед кликом. Обратите внимание, что нет await.
const popupPromise = page.waitForEvent('popup');
await page.getByText('open the popup').click();
const popup = await popupPromise;
console.log(await popup.evaluate('location.href'));
```

:::note
Используйте [page.waitForLoadState()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев это не потребуется).
:::

**Использование**

```js
page.on('popup', data => {});
```

**Данные события**
- [Page]

---

### on('request') {#page-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on('request')</x-search>

Вызывается, когда страница отправляет запрос. Объект [request] является доступным только для чтения. Чтобы перехватывать и изменять запросы, см. [page.route()](/api/class-page.mdx#page-route) или [browserContext.route()](/api/class-browsercontext.mdx#browser-context-route).

**Использование**

```js
page.on('request', data => {});
```

**Данные события**
- [Request]

---

### on('requestfailed') {#page-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.on('requestfailed')</x-search>

Вызывается, когда запрос не удается выполнить, например, из-за истечения времени ожидания.

```js
page.on('requestfailed', request => {
  console.log(request.url() + ' ' + request.failure().errorText);
});
```

:::note
Ответы с ошибками HTTP, такие как 404 или 503, все равно считаются успешными с точки зрения HTTP, поэтому запрос завершится событием [page.on('requestfinished')](/api/class-page.mdx#page-event-request-finished), а не [page.on('requestfailed')](/api/class-page.mdx#page-event-request-failed). Запрос будет считаться неудачным только в том случае, если клиент не может получить HTTP-ответ от сервера, например, из-за сетевой ошибки net::ERR_FAILED.
:::

**Использование**

```js
page.on('requestfailed', data => {});
```

**Данные события**
- [Request]

---

### on('requestfinished') {#page-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.on('requestfinished')</x-search>

Вызывается, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```js
page.on('requestfinished', data => {});
```

**Данные события**
- [Request]

---

### on('response') {#page-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on('response')</x-search>

Вызывается, когда статус и заголовки [response] получены для запроса. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```js
page.on('response', data => {});
```

**Данные события**
- [Response]

---

### on('websocket') {#page-event-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.on('websocket')</x-search>

Вызывается, когда отправляется запрос [WebSocket].

**Использование**

```js
page.on('websocket', data => {});
```

**Данные события**
- [WebSocket]

---

### on('worker') {#page-event-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on('worker')</x-search>

Вызывается, когда страница порождает выделенный [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API).

**Использование**

```js
page.on('worker', data => {});
```

**Данные события**
- [Worker]

---

## Устарело

### $ {#page-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.$</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [page.locator()](/api/class-page.mdx#page-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Метод находит элемент, соответствующий указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение разрешается в `null`. Чтобы дождаться появления элемента на странице, используйте [locator.waitFor()](/api/class-locator.mdx#locator-wait-for).

**Использование**

```js
await page.$(selector);
await page.$(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-selector"/><a href="#page-query-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.
- `options` [Object] *(опционально)*
  - `strict` [boolean] *(опционально)* <font size="2">Добавлено в версии: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-strict"/><a href="#page-query-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если указанный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Возвращает**
- [Promise]&lt;[null] | [ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-return"/><a href="#page-query-selector-return" class="list-anchor">#</a>

---

### $$ {#page-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.$$</x-search>

:::warning[Discouraged]

Use locator-based [page.locator()](/api/class-page.mdx#page-locator) instead. Read more about [locators](../locators.mdx).

:::

Метод находит все элементы, соответствующие указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение будет равно `[]`.

**Использование**

```js
await page.$$(selector);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-option-selector"/><a href="#page-query-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для выполнения запроса.

**Возвращает**
- [Promise]&lt;[Array]&lt;[ElementHandle]&gt;&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-return"/><a href="#page-query-selector-all-return" class="list-anchor">#</a>

---

### $eval {#page-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.$eval</x-search>

:::warning[Discouraged]

This method does not wait for the element to pass actionability checks and therefore can lead to the flaky tests. Use [locator.evaluate()](/api/class-locator.mdx#locator-evaluate), other [Locator] helper methods or web-first assertions instead.

:::

Метод находит элемент, соответствующий указанному селектору на странице, и передает его в качестве первого аргумента в [pageFunction](/api/class-page.mdx#page-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выбрасывает ошибку. Возвращает значение [pageFunction](/api/class-page.mdx#page-eval-on-selector-option-expression).

Если [pageFunction](/api/class-page.mdx#page-eval-on-selector-option-expression) возвращает [Promise], то [page.$eval()](/api/class-page.mdx#page-eval-on-selector) будет ожидать разрешения промиса и вернет его значение.

**Использование**

```js
const searchValue = await page.$eval('#search', el => el.value);
const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
const html = await page.$eval('.main-container', (e, suffix) => e.outerHTML + suffix, 'hello');
// В TypeScript, этот пример требует явной аннотации типа (HTMLLinkElement) на el:
const preloadHrefTS = await page.$eval('link[rel=preload]', (el: HTMLLinkElement) => el.href);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-selector"/><a href="#page-eval-on-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для выполнения запроса.
- `pageFunction` [function]\([Element]\) | [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-expression"/><a href="#page-eval-on-selector-option-expression" class="list-anchor">#</a>
  
  Функция для выполнения в контексте страницы.
- `arg` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-arg"/><a href="#page-eval-on-selector-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [pageFunction](/api/class-page.mdx#page-eval-on-selector-option-expression).
- `options` [Object] *(optional)*
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-strict"/><a href="#page-eval-on-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Возвращает**
- [Promise]&lt;[Serializable]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-return"/><a href="#page-eval-on-selector-return" class="list-anchor">#</a>

---

### $$eval {#page-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.$$eval</x-search>

:::warning[Discouraged]

In most cases, [locator.evaluateAll()](/api/class-locator.mdx#locator-evaluate-all), other [Locator] helper methods and web-first assertions do a better job.

:::

Метод находит все элементы, соответствующие указанному селектору на странице, и передает массив найденных элементов в качестве первого аргумента в [pageFunction](/api/class-page.mdx#page-eval-on-selector-all-option-expression). Возвращает результат вызова [pageFunction](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

Если [pageFunction](/api/class-page.mdx#page-eval-on-selector-all-option-expression) возвращает [Promise], то [page.$$eval()](/api/class-page.mdx#page-eval-on-selector-all) будет ожидать разрешения промиса и вернет его значение.

**Использование**

```js
const divCounts = await page.$$eval('div', (divs, min) => divs.length >= min, 10);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-selector"/><a href="#page-eval-on-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для выполнения запроса.
- `pageFunction` [function]\([Array]&lt;[Element]&gt;\) | [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-expression"/><a href="#page-eval-on-selector-all-option-expression" class="list-anchor">#</a>
  
  Функция для выполнения в контексте страницы.
- `arg` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-arg"/><a href="#page-eval-on-selector-all-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [pageFunction](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

**Возвращает**
- [Promise]&lt;[Serializable]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-return"/><a href="#page-eval-on-selector-all-return" class="list-anchor">#</a>

---

### accessibility {#page-accessibility}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.accessibility</x-search>

:::warning Deprecated

This property is discouraged. Please use other libraries such as [Axe](https://www.deque.com/axe/) if you need to test page accessibility. See our Node.js [guide](https://playwright.dev/docs/accessibility-testing) for integration with Axe.

:::

**Использование**

```js
page.accessibility
```

**Тип**
- [Accessibility]

---

### check {#page-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.check</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.check()](/api/class-locator.mdx#locator-check) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод отмечает элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже отмечен, этот метод возвращается немедленно.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [force](/api/class-page.mdx#page-check-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [page.mouse](/api/class-page.mdx#page-mouse), чтобы кликнуть в центр элемента.
1. Убедитесь, что элемент теперь отмечен. Если нет, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [timeout](/api/class-page.mdx#page-check-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```js
await page.check(selector);
await page.check(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-selector"/><a href="#page-check-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(опционально)*
  - `force` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-force"/><a href="#page-check-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `noWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-no-wait-after"/><a href="#page-check-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `position` [Object] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-position"/><a href="#page-check-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `strict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-strict"/><a href="#page-check-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-timeout"/><a href="#page-check-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `trial` [boolean] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-trial"/><a href="#page-check-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-return"/><a href="#page-check-return" class="list-anchor">#</a>

---

### click {#page-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.click</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.click()](/api/class-locator.mdx#locator-click) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод кликает по элементу, соответствующему [selector](/api/class-page.mdx#page-click-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-click-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [force](/api/class-page.mdx#page-click-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [page.mouse](/api/class-page.mdx#page-mouse), чтобы кликнуть в центр элемента или в указанную [position](/api/class-page.mdx#page-click-option-position).
1. Подождите, пока инициированные навигации не завершатся успешно или не завершатся с ошибкой, если только не установлена опция [noWaitAfter](/api/class-page.mdx#page-click-option-no-wait-after).

Когда все шаги в совокупности не завершены в течение указанного [timeout](/api/class-page.mdx#page-click-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```js
await page.click(selector);
await page.click(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-selector"/><a href="#page-click-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(опционально)*
  - `button` "left" | "right" | "middle" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-button"/><a href="#page-click-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `clickCount` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-click-count"/><a href="#page-click-option-click-count" class="list-anchor">#</a>
    
    По умолчанию 1. См. [UIEvent.detail].
  - `delay` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-delay"/><a href="#page-click-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `force` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-force"/><a href="#page-click-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `modifiers` [Array]&lt;"Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-modifiers"/><a href="#page-click-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `noWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-no-wait-after"/><a href="#page-click-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    В будущем эта опция будет по умолчанию `true`.
    :::
    
    Действия, инициирующие навигации, ожидают, пока эти навигации не произойдут и страницы не начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится эта опция только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `position` [Object] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-position"/><a href="#page-click-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `strict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-strict"/><a href="#page-click-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-timeout"/><a href="#page-click-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `trial` [boolean] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-trial"/><a href="#page-click-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-return"/><a href="#page-click-return" class="list-anchor">#</a>

---

### dblclick {#page-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.dblclick</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.dblclick()](/api/class-locator.mdx#locator-dblclick) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет двойной клик по элементу, соответствующему [selector](/api/class-page.mdx#page-dblclick-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-dblclick-option-selector). Если такого элемента нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [force](/api/class-page.mdx#page-dblclick-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [page.mouse](/api/class-page.mdx#page-mouse) для двойного клика в центре элемента или в указанной [position](/api/class-page.mdx#page-dblclick-option-position).

Если все шаги не завершены в течение указанного [timeout](/api/class-page.mdx#page-dblclick-option-timeout), этот метод выбрасывает [TimeoutError]. Установка нулевого таймаута отключает это.

:::note

`page.dblclick()` генерирует два события `click` и одно событие `dblclick`.
:::

**Использование**

```js
await page.dblclick(selector);
await page.dblclick(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-selector"/><a href="#page-dblclick-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(опционально)*
  - `button` "left" | "right" | "middle" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-button"/><a href="#page-dblclick-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `delay` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-delay"/><a href="#page-dblclick-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `force` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-force"/><a href="#page-dblclick-option-force" class="list-anchor">#</a>
    
    Пропускать ли проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `modifiers` [Array]&lt;"Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-modifiers"/><a href="#page-dblclick-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается как "Control" на Windows и Linux и как "Meta" на macOS.
  - `noWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-no-wait-after"/><a href="#page-dblclick-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `position` [Object] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-position"/><a href="#page-dblclick-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `strict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-strict"/><a href="#page-dblclick-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-timeout"/><a href="#page-dblclick-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `trial` [boolean] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-trial"/><a href="#page-dblclick-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-return"/><a href="#page-dblclick-return" class="list-anchor">#</a>

---

### dispatchEvent {#page-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.dispatchEvent</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.dispatchEvent()](/api/class-locator.mdx#locator-dispatch-event) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Пример ниже генерирует событие `click` на элементе. Независимо от состояния видимости элемента, `click` генерируется. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Использование**

```js
await page.dispatchEvent('button#submit', 'click');
```

Внутри создается экземпляр события на основе указанного [type](/api/class-page.mdx#page-dispatch-event-option-type), инициализируется с помощью свойств [eventInit](/api/class-page.mdx#page-dispatch-event-option-event-init) и генерируется на элементе. События по умолчанию `composed`, `cancelable` и всплывают.

Поскольку [eventInit](/api/class-page.mdx#page-dispatch-event-option-event-init) специфичен для события, пожалуйста, обратитесь к документации по событиям для списков начальных свойств:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Вы также можете указать `JSHandle` в качестве значения свойства, если хотите, чтобы живые объекты передавались в событие:

```js
// Обратите внимание, что вы можете создать DataTransfer только в Chromium и Firefox
const dataTransfer = await page.evaluateHandle(() => new DataTransfer());
await page.dispatchEvent('#source', 'dragstart', { dataTransfer });
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-selector"/><a href="#page-dispatch-event-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `type` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-type"/><a href="#page-dispatch-event-option-type" class="list-anchor">#</a>
  
  Тип DOM события: `"click"`, `"dragstart"`, и т.д.
- `eventInit` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-event-init"/><a href="#page-dispatch-event-option-event-init" class="list-anchor">#</a>
  
  Опциональные специфичные для события свойства инициализации.
- `options` [Object] *(опционально)*
  - `strict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-strict"/><a href="#page-dispatch-event-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-timeout"/><a href="#page-dispatch-event-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-return"/><a href="#page-dispatch-event-return" class="list-anchor">#</a>

---

### fill {#page-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.fill</x-search>

:::warning[Discouraged]

Use locator-based [locator.fill()](/api/class-locator.mdx#locator-fill) instead. Read more about [locators](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [selector](/api/class-page.mdx#page-fill-option-selector), ожидает проверки [actionability](../actionability.mdx), фокусирует элемент, заполняет его и вызывает событие `input` после заполнения. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является элементом `<input>`, `<textarea>` или `[contenteditable]`, этот метод вызывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен именно этот контрол.

Чтобы отправить более детализированные события клавиатуры, используйте [locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially).

**Использование**

```js
await page.fill(selector, value);
await page.fill(selector, value, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-selector"/><a href="#page-fill-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `value` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-value"/><a href="#page-fill-option-value" class="list-anchor">#</a>
  
  Значение для заполнения элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `options` [Object] *(optional)*
  - `force` [boolean] *(optional)* <font size="2">Added in: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-force"/><a href="#page-fill-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `noWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-no-wait-after"/><a href="#page-fill-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    Этот параметр не имеет эффекта.
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-strict"/><a href="#page-fill-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-timeout"/><a href="#page-fill-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью параметра `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-return"/><a href="#page-fill-return" class="list-anchor">#</a>

---

### focus {#page-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.focus</x-search>

:::warning[Discouraged]

Use locator-based [locator.focus()](/api/class-locator.mdx#locator-focus) instead. Read more about [locators](../locators.mdx).

:::

Этот метод получает элемент с [selector](/api/class-page.mdx#page-focus-option-selector) и фокусирует его. Если нет элемента, соответствующего [selector](/api/class-page.mdx#page-focus-option-selector), метод ждет, пока соответствующий элемент не появится в DOM.

**Использование**

```js
await page.focus(selector);
await page.focus(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-selector"/><a href="#page-focus-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-strict"/><a href="#page-focus-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-timeout"/><a href="#page-focus-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью параметра `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-return"/><a href="#page-focus-return" class="list-anchor">#</a>

---

### getAttribute {#page-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.getAttribute</x-search>

:::warning[Discouraged]

Use locator-based [locator.getAttribute()](/api/class-locator.mdx#locator-get-attribute) instead. Read more about [locators](../locators.mdx).

:::

Возвращает значение атрибута элемента.

**Использование**

```js
await page.getAttribute(selector, name);
await page.getAttribute(selector, name, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-selector"/><a href="#page-get-attribute-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-name"/><a href="#page-get-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута, чтобы получить его значение.
- `options` [Object] *(optional)*
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-strict"/><a href="#page-get-attribute-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-timeout"/><a href="#page-get-attribute-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью параметра `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[null] | [string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-return"/><a href="#page-get-attribute-return" class="list-anchor">#</a>

---

### hover {#page-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.hover</x-search>

:::warning[Discouraged]

Use locator-based [locator.hover()](/api/class-locator.mdx#locator-hover) instead. Read more about [locators](../locators.mdx).

:::

Этот метод наводит курсор на элемент, соответствующий [selector](/api/class-page.mdx#page-hover-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-hover-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если не установлена опция [force](/api/class-page.mdx#page-hover-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в поле зрения, если это необходимо.
1. Используйте [page.mouse](/api/class-page.mdx#page-mouse), чтобы навести курсор на центр элемента или указанную [position](/api/class-page.mdx#page-hover-option-position).

Если все шаги в совокупности не завершились в течение указанного [timeout](/api/class-page.mdx#page-hover-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```js
await page.hover(selector);
await page.hover(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-selector"/><a href="#page-hover-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `force` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-force"/><a href="#page-hover-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `modifiers` [Array]&lt;"Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-modifiers"/><a href="#page-hover-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается как "Control" на Windows и Linux и как "Meta" на macOS.
  - `noWaitAfter` [boolean] *(optional)* <font size="2">Added in: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-no-wait-after"/><a href="#page-hover-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `position` [Object] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-position"/><a href="#page-hover-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла рамки отступов элемента. Если не указано, используется видимая точка элемента.
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-strict"/><a href="#page-hover-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-timeout"/><a href="#page-hover-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `trial` [boolean] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-trial"/><a href="#page-hover-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-return"/><a href="#page-hover-return" class="list-anchor">#</a>

---

### innerHTML {#page-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.innerHTML</x-search>

:::warning[Discouraged]

Use locator-based [locator.innerHTML()](/api/class-locator.mdx#locator-inner-html) instead. Read more about [locators](../locators.mdx).

:::

Возвращает `element.innerHTML`.

**Использование**

```js
await page.innerHTML(selector);
await page.innerHTML(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-selector"/><a href="#page-inner-html-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-strict"/><a href="#page-inner-html-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-timeout"/><a href="#page-inner-html-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-return"/><a href="#page-inner-html-return" class="list-anchor">#</a>

---

### innerText {#page-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.innerText</x-search>

:::warning[Discouraged]

Use locator-based [locator.innerText()](/api/class-locator.mdx#locator-inner-text) instead. Read more about [locators](../locators.mdx).

:::

Возвращает `element.innerText`.

**Использование**

```js
await page.innerText(selector);
await page.innerText(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-selector"/><a href="#page-inner-text-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-strict"/><a href="#page-inner-text-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-timeout"/><a href="#page-inner-text-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-return"/><a href="#page-inner-text-return" class="list-anchor">#</a>

---

### inputValue {#page-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.13</font><x-search>page.inputValue</x-search>

:::warning[Discouraged]

Use locator-based [locator.inputValue()](/api/class-locator.mdx#locator-input-value) instead. Read more about [locators](../locators.mdx).

:::

Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Вызывает ошибку для элементов, не являющихся вводом. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращает значение этого контрола.

**Использование**

```js
await page.inputValue(selector);
await page.inputValue(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-selector"/><a href="#page-input-value-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(опционально)*
  - `strict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-strict"/><a href="#page-input-value-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-timeout"/><a href="#page-input-value-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-return"/><a href="#page-input-value-return" class="list-anchor">#</a>

---

### isChecked {#page-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isChecked</x-search>

:::warning[Discouraged]

Use locator-based [locator.isChecked()](/api/class-locator.mdx#locator-is-checked) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, отмечен ли элемент. Вызывает ошибку, если элемент не является флажком или радиокнопкой.

**Использование**

```js
await page.isChecked(selector);
await page.isChecked(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-selector"/><a href="#page-is-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(опционально)*
  - `strict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-strict"/><a href="#page-is-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-timeout"/><a href="#page-is-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-return"/><a href="#page-is-checked-return" class="list-anchor">#</a>

---

### isDisabled {#page-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isDisabled</x-search>

:::warning[Discouraged]

Use locator-based [locator.isDisabled()](/api/class-locator.mdx#locator-is-disabled) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, отключен ли элемент, противоположность [enabled](../actionability.mdx#enabled).

**Использование**

```js
await page.isDisabled(selector);
await page.isDisabled(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-selector"/><a href="#page-is-disabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(опционально)*
  - `strict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-strict"/><a href="#page-is-disabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-timeout"/><a href="#page-is-disabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-return"/><a href="#page-is-disabled-return" class="list-anchor">#</a>

---

### isEditable {#page-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isEditable</x-search>

:::warning[Discouraged]

Use locator-based [locator.isEditable()](/api/class-locator.mdx#locator-is-editable) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Использование**

```js
await page.isEditable(selector);
await page.isEditable(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-selector"/><a href="#page-is-editable-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(опционально)*
  - `strict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-strict"/><a href="#page-is-editable-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-timeout"/><a href="#page-is-editable-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-return"/><a href="#page-is-editable-return" class="list-anchor">#</a>

---

### isEnabled {#page-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isEnabled</x-search>

:::warning[Discouraged]

Use locator-based [locator.isEnabled()](/api/class-locator.mdx#locator-is-enabled) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент [enabled](../actionability.mdx#enabled).

**Использование**

```js
await page.isEnabled(selector);
await page.isEnabled(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-selector"/><a href="#page-is-enabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-strict"/><a href="#page-is-enabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-timeout"/><a href="#page-is-enabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-return"/><a href="#page-is-enabled-return" class="list-anchor">#</a>

---

### isHidden {#page-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isHidden</x-search>

:::warning[Discouraged]

Use locator-based [locator.isHidden()](/api/class-locator.mdx#locator-is-hidden) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент скрытым, противоположность [visible](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-hidden-option-selector), который не соответствует ни одному элементу, считается скрытым.

**Использование**

```js
await page.isHidden(selector);
await page.isHidden(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-selector"/><a href="#page-is-hidden-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-strict"/><a href="#page-is-hidden-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-timeout"/><a href="#page-is-hidden-option-timeout" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Эта опция игнорируется. [page.isHidden()](/api/class-page.mdx#page-is-hidden) не ждет, пока элемент станет скрытым, и возвращается немедленно.
    :::
    

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-return"/><a href="#page-is-hidden-return" class="list-anchor">#</a>

---

### isVisible {#page-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isVisible</x-search>

:::warning[Discouraged]

Use locator-based [locator.isVisible()](/api/class-locator.mdx#locator-is-visible) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент [visible](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-visible-option-selector), который не соответствует ни одному элементу, считается невидимым.

**Использование**

```js
await page.isVisible(selector);
await page.isVisible(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-selector"/><a href="#page-is-visible-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-strict"/><a href="#page-is-visible-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-timeout"/><a href="#page-is-visible-option-timeout" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Эта опция игнорируется. [page.isVisible()](/api/class-page.mdx#page-is-visible) не ждет, пока элемент станет видимым, и возвращается немедленно.
    :::
    

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-return"/><a href="#page-is-visible-return" class="list-anchor">#</a>

---

### press {#page-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.press</x-search>

:::warning[Discouraged]

Use locator-based [locator.press()](/api/class-locator.mdx#locator-press) instead. Read more about [locators](../locators.mdx).

:::

Фокусирует элемент, а затем использует [keyboard.down()](/api/class-keyboard.mdx#keyboard-down) и [keyboard.up()](/api/class-keyboard.mdx#keyboard-up).

[key](/api/class-page.mdx#page-press-option-key) может указывать предполагаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или один символ для генерации текста. Надмножество значений [key](/api/class-page.mdx#page-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры клавиш:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются следующие модификационные сочетания: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`. `ControlOrMeta` разрешается как `Control` на Windows и Linux и как `Meta` на macOS.

Удержание `Shift` напечатает текст, соответствующий [key](/api/class-page.mdx#page-press-option-key) в верхнем регистре.

Если [key](/api/class-page.mdx#page-press-option-key) является одним символом, он чувствителен к регистру, поэтому значения `a` и `A` будут генерировать разные тексты.

Также поддерживаются сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++` или `key: "Control+Shift+T"`. При указании с модификатором, модификатор нажимается и удерживается, пока не будет нажата последующая клавиша.

**Использование**

```js
const page = await browser.newPage();
await page.goto('https://keycode.info');
await page.press('body', 'A');
await page.screenshot({ path: 'A.png' });
await page.press('body', 'ArrowLeft');
await page.screenshot({ path: 'ArrowLeft.png' });
await page.press('body', 'Shift+O');
await page.screenshot({ path: 'O.png' });
await browser.close();
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-selector"/><a href="#page-press-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `key` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-key"/><a href="#page-press-option-key" class="list-anchor">#</a>
  
  Имя клавиши для нажатия или символ для генерации, например, `ArrowLeft` или `a`.
- `options` [Object] *(опционально)*
  - `delay` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-delay"/><a href="#page-press-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `keydown` и `keyup` в миллисекундах. По умолчанию 0.
  - `noWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-no-wait-after"/><a href="#page-press-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция по умолчанию будет `true` в будущем.
    :::
    
    Действия, инициирующие навигации, ожидают, пока эти навигации произойдут и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Эта опция нужна только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `strict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-strict"/><a href="#page-press-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-timeout"/><a href="#page-press-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-return"/><a href="#page-press-return" class="list-anchor">#</a>

---

### selectOption {#page-select-option}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.selectOption</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.selectOption()](/api/class-locator.mdx#locator-select-option) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [selector](/api/class-page.mdx#page-select-option-option-selector), ожидает проверки [actionability](../actionability.mdx), ждет, пока все указанные опции будут присутствовать в элементе `<select>`, и выбирает эти опции.

Если целевой элемент не является элементом `<select>`, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован этот control.

Возвращает массив значений опций, которые были успешно выбраны.

Вызывает событие `change` и `input`, как только все предоставленные опции были выбраны.

**Использование**

```js
// Одиночный выбор, соответствующий значению или метке
page.selectOption('select#colors', 'blue');

// одиночный выбор, соответствующий метке
page.selectOption('select#colors', { label: 'Blue' });

// множественный выбор
page.selectOption('select#colors', ['red', 'green', 'blue']);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-selector"/><a href="#page-select-option-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `values` [null] | [string] | [ElementHandle] | [Array]&lt;[string]&gt; | [Object] | [Array]&lt;[ElementHandle]&gt; | [Array]&lt;[Object]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-values"/><a href="#page-select-option-option-values" class="list-anchor">#</a>
  - `value` [string] *(опционально)*
    
    Соответствует `option.value`. Опционально.
  - `label` [string] *(опционально)*
    
    Соответствует `option.label`. Опционально.
  - `index` [number] *(опционально)*
    
    Соответствует индексу. Опционально.
  
  Опции для выбора. Если у `<select>` есть атрибут `multiple`, все соответствующие опции выбираются, в противном случае выбирается только первая опция, соответствующая одной из переданных опций. Строковые значения соответствуют как значениям, так и меткам. Опция считается соответствующей, если все указанные свойства совпадают.
- `options` [Object] *(опционально)*
  - `force` [boolean] *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-force"/><a href="#page-select-option-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `noWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-no-wait-after"/><a href="#page-select-option-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `strict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-strict"/><a href="#page-select-option-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-timeout"/><a href="#page-select-option-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[Array]&lt;[string]&gt;&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-return"/><a href="#page-select-option-return" class="list-anchor">#</a>

---

### setChecked {#page-set-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.15</font><x-search>page.setChecked</x-search>

:::warning[Discouraged]

Use locator-based [locator.setChecked()](/api/class-locator.mdx#locator-set-checked) instead. Read more about [locators](../locators.mdx).

:::

Этот метод устанавливает или снимает флажок элемента, соответствующего [selector](/api/class-page.mdx#page-set-checked-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-set-checked-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку.
1. Если элемент уже имеет правильное состояние флажка, этот метод немедленно возвращает управление.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) для найденного элемента, если не установлена опция [force](/api/class-page.mdx#page-set-checked-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в поле видимости, если это необходимо.
1. Используйте [page.mouse](/api/class-page.mdx#page-mouse) для нажатия в центре элемента.
1. Убедитесь, что элемент теперь отмечен или не отмечен. Если нет, этот метод вызывает ошибку.

Если все шаги не завершены в течение указанного [timeout](/api/class-page.mdx#page-set-checked-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```js
await page.setChecked(selector, checked);
await page.setChecked(selector, checked, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-selector"/><a href="#page-set-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `checked` [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-checked"/><a href="#page-set-checked-option-checked" class="list-anchor">#</a>
  
  Указывает, следует ли установить или снять флажок.
- `options` [Object] *(optional)*
  - `force` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-force"/><a href="#page-set-checked-option-force" class="list-anchor">#</a>
    
    Указывает, следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `noWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-no-wait-after"/><a href="#page-set-checked-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `position` [Object] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-position"/><a href="#page-set-checked-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `strict` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-strict"/><a href="#page-set-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-timeout"/><a href="#page-set-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `trial` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-trial"/><a href="#page-set-checked-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию, без его выполнения.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-return"/><a href="#page-set-checked-return" class="list-anchor">#</a>

---

### setInputFiles {#page-set-input-files}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setInputFiles</x-search>

:::warning[Discouraged]

Use locator-based [locator.setInputFiles()](/api/class-locator.mdx#locator-set-input-files) instead. Read more about [locators](../locators.mdx).

:::

Устанавливает значение элемента ввода файла в указанные пути к файлам или файлы. Если некоторые из `filePaths` являются относительными путями, они разрешаются относительно текущего рабочего каталога. Для пустого массива очищает выбранные файлы. Для входных данных с атрибутом `[webkitdirectory]` поддерживается только один путь к каталогу.

Этот метод ожидает, что [selector](/api/class-page.mdx#page-set-input-files-option-selector) указывает на [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Однако, если элемент находится внутри элемента `<label>`, который имеет связанную [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), он нацелен на контроль вместо этого.

**Использование**

```js
await page.setInputFiles(selector, files);
await page.setInputFiles(selector, files, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-selector"/><a href="#page-set-input-files-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `files` [string] | [Array]&lt;[string]&gt; | [Object] | [Array]&lt;[Object]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-files"/><a href="#page-set-input-files-option-files" class="list-anchor">#</a>
  - `name` [string]
    
    Имя файла
  - `mimeType` [string]
    
    Тип файла
  - `buffer` [Buffer]
    
    Содержимое файла
- `options` [Object] *(optional)*
  - `noWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-no-wait-after"/><a href="#page-set-input-files-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-strict"/><a href="#page-set-input-files-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-timeout"/><a href="#page-set-input-files-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-return"/><a href="#page-set-input-files-return" class="list-anchor">#</a>

---

### tap {#page-tap}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.tap</x-search>

:::warning[Discouraged]

Use locator-based [locator.tap()](/api/class-locator.mdx#locator-tap) instead. Read more about [locators](../locators.mdx).

:::

Этот метод выполняет нажатие на элемент, соответствующий [selector](/api/class-page.mdx#page-tap-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-tap-option-selector). Если такого элемента нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [force](/api/class-page.mdx#page-tap-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [page.touchscreen](/api/class-page.mdx#page-touchscreen) для нажатия на центр элемента или указанную [position](/api/class-page.mdx#page-tap-option-position).

Если все шаги в совокупности не завершились в течение указанного [timeout](/api/class-page.mdx#page-tap-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

:::note

Метод [page.tap()](/api/class-page.mdx#page-tap) выбросит ошибку, если опция [hasTouch](/api/class-browser.mdx#browser-new-context-option-has-touch) контекста браузера равна false.
:::

**Использование**

```js
await page.tap(selector);
await page.tap(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-selector"/><a href="#page-tap-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `force` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-force"/><a href="#page-tap-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `modifiers` [Array]&lt;"Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-modifiers"/><a href="#page-tap-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `noWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-no-wait-after"/><a href="#page-tap-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `position` [Object] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-position"/><a href="#page-tap-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-strict"/><a href="#page-tap-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-timeout"/><a href="#page-tap-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `trial` [boolean] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-trial"/><a href="#page-tap-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-return"/><a href="#page-tap-return" class="list-anchor">#</a>

---

### textContent {#page-text-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.textContent</x-search>

:::warning[Discouraged]

Use locator-based [locator.textContent()](/api/class-locator.mdx#locator-text-content) instead. Read more about [locators](../locators.mdx).

:::

Возвращает `element.textContent`.

**Использование**

```js
await page.textContent(selector);
await page.textContent(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-selector"/><a href="#page-text-content-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-strict"/><a href="#page-text-content-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-timeout"/><a href="#page-text-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[null] | [string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-return"/><a href="#page-text-content-return" class="list-anchor">#</a>

---

### type {#page-type}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.type</x-search>

:::warning Deprecated

In most cases, you should use [locator.fill()](/api/class-locator.mdx#locator-fill) instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially).

:::

Отправляет событие `keydown`, `keypress`/`input` и `keyup` для каждого символа в тексте. `page.type` может использоваться для отправки детализированных событий клавиатуры. Для заполнения значений в полях формы используйте [page.fill()](/api/class-page.mdx#page-fill).

Чтобы нажать специальную клавишу, такую как `Control` или `ArrowDown`, используйте [keyboard.press()](/api/class-keyboard.mdx#keyboard-press).

**Использование**

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-selector"/><a href="#page-type-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `text` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-text"/><a href="#page-type-option-text" class="list-anchor">#</a>
  
  Текст для ввода в фокусированный элемент.
- `options` [Object] *(optional)*
  - `delay` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-delay"/><a href="#page-type-option-delay" class="list-anchor">#</a>
    
    Время ожидания между нажатиями клавиш в миллисекундах. По умолчанию 0.
  - `noWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-no-wait-after"/><a href="#page-type-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-strict"/><a href="#page-type-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-timeout"/><a href="#page-type-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-return"/><a href="#page-type-return" class="list-anchor">#</a>

---

### uncheck {#page-uncheck}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.uncheck</x-search>

:::warning[Discouraged]

Use locator-based [locator.uncheck()](/api/class-locator.mdx#locator-uncheck) instead. Read more about [locators](../locators.mdx).

:::

Этот метод снимает отметку с элемента, соответствующего [selector](/api/class-page.mdx#page-uncheck-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-uncheck-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку. Если элемент уже снят с отметки, этот метод сразу возвращает управление.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если не установлена опция [force](/api/class-page.mdx#page-uncheck-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в поле зрения, если это необходимо.
1. Используйте [page.mouse](/api/class-page.mdx#page-mouse) для нажатия в центре элемента.
1. Убедитесь, что элемент теперь снят с отметки. Если нет, этот метод вызывает ошибку.

Когда все шаги в совокупности не завершены в течение указанного [timeout](/api/class-page.mdx#page-uncheck-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```js
await page.uncheck(selector);
await page.uncheck(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-selector"/><a href="#page-uncheck-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` [Object] *(optional)*
  - `force` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-force"/><a href="#page-uncheck-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `noWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-no-wait-after"/><a href="#page-uncheck-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `position` [Object] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-position"/><a href="#page-uncheck-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла рамки отступов элемента. Если не указано, используется видимая точка элемента.
  - `strict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-strict"/><a href="#page-uncheck-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-timeout"/><a href="#page-uncheck-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `trial` [boolean] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-trial"/><a href="#page-uncheck-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-return"/><a href="#page-uncheck-return" class="list-anchor">#</a>

---

### waitForNavigation {#page-wait-for-navigation}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForNavigation</x-search>

:::warning Deprecated

This method is inherently racy, please use [page.waitForURL()](/api/class-page.mdx#page-wait-for-url) instead.

:::

Ожидает навигации основного фрейма и возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. В случае навигации к другому якорю или навигации из-за использования History API, навигация будет разрешена с `null`.

**Использование**

Это разрешается, когда страница переходит на новый URL или перезагружается. Это полезно, когда вы выполняете код, который косвенно вызывает навигацию страницы. Например, цель клика имеет обработчик `onclick`, который вызывает навигацию из `setTimeout`. Рассмотрим этот пример:

```js
// Начните ожидание навигации перед кликом. Обратите внимание, что нет await.
const navigationPromise = page.waitForNavigation();
await page.getByText('Navigate after timeout').click();
await navigationPromise;
```

:::note
Использование [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) для изменения URL считается навигацией.
:::

**Аргументы**
- `options` [Object] *(optional)*
  - `timeout` [number] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-timeout"/><a href="#page-wait-for-navigation-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить с помощью опции `navigationTimeout` в конфигурации или с помощью методов [browserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `url` [string] | [RegExp] | [function]\([URL]\):[boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-url"/><a href="#page-wait-for-navigation-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для совпадения при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
  - `waitUntil` "load" | "domcontentloaded" | "networkidle" | "commit" *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-wait-until"/><a href="#page-wait-for-navigation-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Promise]&lt;[null] | [Response]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-return"/><a href="#page-wait-for-navigation-return" class="list-anchor">#</a>

---

### waitForSelector {#page-wait-for-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForSelector</x-search>

:::warning[Discouraged]

Use web assertions that assert visibility or a locator-based [locator.waitFor()](/api/class-locator.mdx#locator-wait-for) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, когда элемент, указанный селектором, удовлетворяет опции [state](/api/class-page.mdx#page-wait-for-selector-option-state). Возвращает `null`, если ожидание для `hidden` или `detached`.

:::note

Playwright автоматически ожидает, когда элемент будет готов перед выполнением действия. Использование объектов [Locator] и веб-утверждений в первую очередь делает код свободным от ожидания селектора.
:::

Ожидает, когда [selector](/api/class-page.mdx#page-wait-for-selector-option-selector) удовлетворит опции [state](/api/class-page.mdx#page-wait-for-selector-option-state) (либо появится/исчезнет из DOM, либо станет видимым/скрытым). Если в момент вызова метода [selector](/api/class-page.mdx#page-wait-for-selector-option-selector) уже удовлетворяет условие, метод вернется немедленно. Если селектор не удовлетворяет условие в течение [timeout](/api/class-page.mdx#page-wait-for-selector-option-timeout) миллисекунд, функция выбросит исключение.

**Использование**

Этот метод работает через навигации:

```js
const { chromium } = require('playwright');  // Или 'firefox' или 'webkit'.

(async () => {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  for (const currentURL of ['https://google.com', 'https://bbc.com']) {
    await page.goto(currentURL);
    const element = await page.waitForSelector('img');
    console.log('Загружено изображение: ' + await element.getAttribute('src'));
  }
  await browser.close();
})();
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-selector"/><a href="#page-wait-for-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` [Object] *(опционально)*
  - `state` "attached" | "detached" | "visible" | "hidden" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-state"/><a href="#page-wait-for-selector-option-state" class="list-anchor">#</a>
    
    По умолчанию `'visible'`. Может быть:
    * `'attached'` - ожидание, когда элемент будет присутствовать в DOM.
    * `'detached'` - ожидание, когда элемент не будет присутствовать в DOM.
    * `'visible'` - ожидание, когда элемент будет иметь непустую ограничивающую рамку и не будет `visibility:hidden`. Обратите внимание, что элемент без какого-либо содержимого или с `display:none` имеет пустую ограничивающую рамку и не считается видимым.
    * `'hidden'` - ожидание, когда элемент будет либо отсоединен от DOM, либо иметь пустую ограничивающую рамку или `visibility:hidden`. Это противоположно опции `'visible'`.
  - `strict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-strict"/><a href="#page-wait-for-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `timeout` [number] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-timeout"/><a href="#page-wait-for-selector-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[null] | [ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-return"/><a href="#page-wait-for-selector-return" class="list-anchor">#</a>

---

### waitForTimeout {#page-wait-for-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.waitForTimeout</x-search>

:::warning[Не рекомендуется]

Никогда не ждите таймаута в производственной среде. Тесты, которые ждут времени, по своей природе ненадежны. Используйте действия [Locator] и веб-утверждения, которые ожидают автоматически.

:::

Ожидает заданный [timeout](/api/class-page.mdx#page-wait-for-timeout-option-timeout) в миллисекундах.

Обратите внимание, что `page.waitForTimeout()` следует использовать только для отладки. Тесты, использующие таймер в производственной среде, будут ненадежными. Вместо этого используйте сигналы, такие как сетевые события, селекторы, становящиеся видимыми, и другие.

**Использование**

```js
// ожидание 1 секунду
await page.waitForTimeout(1000);
```

**Аргументы**
- `timeout` [number]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-option-timeout"/><a href="#page-wait-for-timeout-option-timeout" class="list-anchor">#</a>
  
  Таймаут для ожидания

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-return"/><a href="#page-wait-for-timeout-return" class="list-anchor">#</a>

[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[Android]: /api/class-android.mdx "Android"
[AndroidDevice]: /api/class-androiddevice.mdx "AndroidDevice"
[AndroidInput]: /api/class-androidinput.mdx "AndroidInput"
[AndroidSocket]: /api/class-androidsocket.mdx "AndroidSocket"
[AndroidWebView]: /api/class-androidwebview.mdx "AndroidWebView"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserServer]: /api/class-browserserver.mdx "BrowserServer"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Coverage]: /api/class-coverage.mdx "Coverage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[Electron]: /api/class-electron.mdx "Electron"
[ElectronApplication]: /api/class-electronapplication.mdx "ElectronApplication"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[GenericAssertions]: /api/class-genericassertions.mdx "GenericAssertions"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Logger]: /api/class-logger.mdx "Logger"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[SnapshotAssertions]: /api/class-snapshotassertions.mdx "SnapshotAssertions"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Fixtures]: /api/class-fixtures.mdx "Fixtures"
[FullConfig]: /api/class-fullconfig.mdx "FullConfig"
[FullProject]: /api/class-fullproject.mdx "FullProject"
[Location]: /api/class-location.mdx "Location"
[Test]: /api/class-test.mdx "Test"
[TestConfig]: /api/class-testconfig.mdx "TestConfig"
[TestInfo]: /api/class-testinfo.mdx "TestInfo"
[TestInfoError]: /api/class-testinfoerror.mdx "TestInfoError"
[TestOptions]: /api/class-testoptions.mdx "TestOptions"
[TestProject]: /api/class-testproject.mdx "TestProject"
[TestStepInfo]: /api/class-teststepinfo.mdx "TestStepInfo"
[WorkerInfo]: /api/class-workerinfo.mdx "WorkerInfo"
[Reporter]: /api/class-reporter.mdx "Reporter"
[Suite]: /api/class-suite.mdx "Suite"
[TestCase]: /api/class-testcase.mdx "TestCase"
[TestError]: /api/class-testerror.mdx "TestError"
[TestResult]: /api/class-testresult.mdx "TestResult"
[TestStep]: /api/class-teststep.mdx "TestStep"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array "Array"
[boolean]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type "Boolean"
[Buffer]: https://nodejs.org/api/buffer.html#buffer_class_buffer "Buffer"
[ChildProcess]: https://nodejs.org/api/child_process.html "ChildProcess"
[Date]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date "Date"
[Error]: https://nodejs.org/api/errors.html#errors_class_error "Error"
[EventEmitter]: https://nodejs.org/api/events.html#events_class_eventemitter "EventEmitter"
[function]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function "Function"
[FormData]: https://developer.mozilla.org/en-US/docs/Web/API/FormData "FormData"
[Map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map "Map"
[Metadata]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object&lt;string, any&gt;"
[null]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null "null"
[number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type "Number"
[Object]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object "Object"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[Readable]: https://nodejs.org/api/stream.html#stream_class_stream_readable "Readable"
[ReadStream]: https://nodejs.org/api/fs.html#class-fsreadstream "ReadStream"
[RegExp]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp "RegExp"
[string]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type "string"
[void]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined "void"
[URL]: https://nodejs.org/api/url.html "URL"
[URLSearchParams]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams "URLSearchParams"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
