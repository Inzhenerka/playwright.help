---
id: class-elementhandle
title: "ElementHandle"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

* extends: [JSHandle]

ElementHandle представляет собой элемент DOM на странице. ElementHandles могут быть созданы с помощью метода [page.$()](/api/class-page.mdx#page-query-selector).

:::warning[Не рекомендуется]

Использование ElementHandle не рекомендуется, вместо этого используйте объекты [Locator] и утверждения, ориентированные на веб.
:::

```js
const hrefElement = await page.$('a');
await hrefElement.click();
```

ElementHandle предотвращает сборку мусора для элемента DOM, если дескриптор не был освобожден с помощью [jsHandle.dispose()](/api/class-jshandle.mdx#js-handle-dispose). ElementHandles автоматически освобождаются, когда их родительский фрейм переходит по ссылке.

Экземпляры ElementHandle могут использоваться в качестве аргумента в методах [page.$eval()](/api/class-page.mdx#page-eval-on-selector) и [page.evaluate()](/api/class-page.mdx#page-evaluate).

Разница между [Locator] и ElementHandle заключается в том, что ElementHandle указывает на конкретный элемент, в то время как [Locator] захватывает логику получения элемента.

В приведенном ниже примере дескриптор указывает на конкретный элемент DOM на странице. Если этот элемент изменит текст или будет использован React для рендеринга совершенно другого компонента, дескриптор все равно будет указывать на тот самый элемент DOM. Это может привести к неожиданному поведению.

```js
const handle = await page.$('text=Submit');
// ...
await handle.hover();
await handle.click();
```

С помощью локатора каждый раз, когда используется `element`, актуальный элемент DOM находится на странице с использованием селектора. Таким образом, в приведенном ниже фрагменте базовый элемент DOM будет найден дважды.

```js
const locator = page.getByText('Submit');
// ...
await locator.hover();
await locator.click();
```

---

## Методы

### boundingBox {#element-handle-bounding-box}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.boundingBox</x-search>

Этот метод возвращает ограничивающий прямоугольник элемента или `null`, если элемент не виден. Ограничивающий прямоугольник рассчитывается относительно основного фрейма - что обычно совпадает с окном браузера.

Прокрутка влияет на возвращаемый ограничивающий прямоугольник, аналогично [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect). Это означает, что `x` и/или `y` могут быть отрицательными.

Элементы из дочерних фреймов возвращают ограничивающий прямоугольник относительно основного фрейма, в отличие от [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).

Предполагая, что страница статична, безопасно использовать координаты ограничивающего прямоугольника для выполнения ввода. Например, следующий фрагмент должен кликнуть в центре элемента.

**Использование**

```js
const box = await elementHandle.boundingBox();
await page.mouse.click(box.x + box.width / 2, box.y + box.height / 2);
```

**Возвращает**
- [Promise]&lt;[null] | [Object]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-bounding-box-return"/><a href="#element-handle-bounding-box-return" class="list-anchor">#</a>
  - `x` [number]
    
    координата x элемента в пикселях.
  - `y` [number]
    
    координата y элемента в пикселях.
  - `width` [number]
    
    ширина элемента в пикселях.
  - `height` [number]
    
    высота элемента в пикселях.

---

### contentFrame {#element-handle-content-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.contentFrame</x-search>

Возвращает контентный фрейм для дескрипторов элементов, ссылающихся на узлы iframe, или `null` в противном случае.

**Использование**

```js
await elementHandle.contentFrame();
```

**Возвращает**
- [Promise]&lt;[null] | [Frame]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-content-frame-return"/><a href="#element-handle-content-frame-return" class="list-anchor">#</a>

---

### ownerFrame {#element-handle-owner-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.ownerFrame</x-search>

Возвращает фрейм, содержащий данный элемент.

**Использование**

```js
await elementHandle.ownerFrame();
```

**Возвращает**
- [Promise]&lt;[null] | [Frame]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-owner-frame-return"/><a href="#element-handle-owner-frame-return" class="list-anchor">#</a>

---

### waitForElementState {#element-handle-wait-for-element-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.waitForElementState</x-search>

Возвращает, когда элемент удовлетворяет [state](/api/class-elementhandle.mdx#element-handle-wait-for-element-state-option-state).

В зависимости от параметра [state](/api/class-elementhandle.mdx#element-handle-wait-for-element-state-option-state) этот метод ожидает, пока не пройдет одна из проверок [actionability](../actionability.mdx). Этот метод выбрасывает исключение, когда элемент отсоединяется во время ожидания, если не ожидается состояние `"hidden"`.
* `"visible"` Ожидать, пока элемент не станет [видимым](../actionability.mdx#visible).
* `"hidden"` Ожидать, пока элемент не станет [невидимым](../actionability.mdx#visible) или не будет отсоединен. Обратите внимание, что ожидание скрытия не выбрасывает исключение, когда элемент отсоединяется.
* `"stable"` Ожидать, пока элемент не станет как [видимым](../actionability.mdx#visible), так и [стабильным](../actionability.mdx#stable).
* `"enabled"` Ожидать, пока элемент не станет [включенным](../actionability.mdx#enabled).
* `"disabled"` Ожидать, пока элемент не станет [выключенным](../actionability.mdx#enabled).
* `"editable"` Ожидать, пока элемент не станет [редактируемым](../actionability.mdx#editable).

Если элемент не удовлетворяет условию в течение [timeout](/api/class-elementhandle.mdx#element-handle-wait-for-element-state-option-timeout) миллисекунд, этот метод выбрасывает исключение.

**Использование**

```js
await elementHandle.waitForElementState(state);
await elementHandle.waitForElementState(state, options);
```

**Аргументы**
- `state` "visible" | "hidden" | "stable" | "enabled" | "disabled" | "editable"<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-element-state-option-state"/><a href="#element-handle-wait-for-element-state-option-state" class="list-anchor">#</a>
  
  Состояние, которое нужно ожидать, см. ниже для получения дополнительных сведений.
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-element-state-option-timeout"/><a href="#element-handle-wait-for-element-state-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-element-state-return"/><a href="#element-handle-wait-for-element-state-return" class="list-anchor">#</a>

---

## Устарело

### $ {#element-handle-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.$</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [page.locator()](/api/class-page.mdx#page-locator) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Метод находит элемент, соответствующий указанному селектору, в поддереве `ElementHandle`. Если ни один элемент не соответствует селектору, возвращает `null`.

**Использование**

```js
await elementHandle.$(selector);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-option-selector"/><a href="#element-handle-query-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.

**Возвращает**
- [Promise]&lt;[null] | [ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-return"/><a href="#element-handle-query-selector-return" class="list-anchor">#</a>

---

### $$ {#element-handle-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.$$</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [page.locator()](/api/class-page.mdx#page-locator) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Метод находит все элементы, соответствующие указанному селектору, в поддереве `ElementHandle`. Если ни один элемент не соответствует селектору, возвращает пустой массив.

**Использование**

```js
await elementHandle.$$(selector);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-all-option-selector"/><a href="#element-handle-query-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.

**Возвращает**
- [Promise]&lt;[Array]&lt;[ElementHandle]&gt;&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-all-return"/><a href="#element-handle-query-selector-all-return" class="list-anchor">#</a>

---

### $eval {#element-handle-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.$eval</x-search>

:::warning[Не рекомендуется]

Этот метод не ждет, пока элемент пройдет проверки на возможность действия, и поэтому может привести к ненадежным тестам. Используйте [locator.evaluate()](/api/class-locator.mdx#locator-evaluate), другие методы помощников [Locator] или утверждения, ориентированные на веб.

:::


Возвращает значение, возвращаемое [pageFunction](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression).

Метод находит элемент, соответствующий указанному селектору, в поддереве `ElementHandle` и передает его в качестве первого аргумента в [pageFunction](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выбрасывает ошибку.

Если [pageFunction](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression) возвращает [Promise], то [elementHandle.$eval()](/api/class-elementhandle.mdx#element-handle-eval-on-selector) будет ждать разрешения промиса и вернет его значение.

**Использование**

```js
const tweetHandle = await page.$('.tweet');
expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe('100');
expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe('10');
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-option-selector"/><a href="#element-handle-eval-on-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `pageFunction` [function]\([Element]\) | [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-option-expression"/><a href="#element-handle-eval-on-selector-option-expression" class="list-anchor">#</a>
  
  Функция, которая будет оценена в контексте страницы.
- `arg` [EvaluationArgument] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-option-arg"/><a href="#element-handle-eval-on-selector-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [pageFunction](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression).

**Возвращает**
- [Promise]&lt;[Serializable]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-return"/><a href="#element-handle-eval-on-selector-return" class="list-anchor">#</a>

---

### $$eval {#element-handle-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.$$eval</x-search>

:::warning[Не рекомендуется]

В большинстве случаев [locator.evaluateAll()](/api/class-locator.mdx#locator-evaluate-all), другие методы помощников [Locator] и утверждения, ориентированные на веб, выполняют свою работу лучше.

:::


Возвращает значение, возвращаемое [pageFunction](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression).

Метод находит все элементы, соответствующие указанному селектору, в поддереве `ElementHandle` и передает массив найденных элементов в качестве первого аргумента в [pageFunction](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression).

Если [pageFunction](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression) возвращает [Promise], то [elementHandle.$$eval()](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all) будет ждать разрешения промиса и вернет его значение.

**Использование**

```html
<div class="feed">
  <div class="tweet">Hello!</div>
  <div class="tweet">Hi!</div>
</div>
```

```js
const feedHandle = await page.$('.feed');
expect(await feedHandle.$$eval('.tweet', nodes =>
  nodes.map(n => n.innerText))).toEqual(['Hello!', 'Hi!'],
);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-option-selector"/><a href="#element-handle-eval-on-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `pageFunction` [function]\([Array]&lt;[Element]&gt;\) | [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-option-expression"/><a href="#element-handle-eval-on-selector-all-option-expression" class="list-anchor">#</a>
  
  Функция, которая будет оценена в контексте страницы.
- `arg` [EvaluationArgument] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-option-arg"/><a href="#element-handle-eval-on-selector-all-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [pageFunction](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression).

**Возвращает**
- [Promise]&lt;[Serializable]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-return"/><a href="#element-handle-eval-on-selector-all-return" class="list-anchor">#</a>

---

### check {#element-handle-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.check</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.check()](/api/class-locator.mdx#locator-check) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Этот метод отмечает элемент, выполняя следующие шаги:
1. Убедитесь, что элемент является флажком или радио-вводом. Если нет, этот метод выбрасывает исключение. Если элемент уже отмечен, этот метод возвращает сразу.
1. Ожидать проверки [actionability](../actionability.mdx) на элементе, если не установлена опция [force](/api/class-elementhandle.mdx#element-handle-check-option-force).
1. Прокрутить элемент в видимость, если это необходимо.
1. Использовать [page.mouse](/api/class-page.mdx#page-mouse), чтобы кликнуть в центре элемента.
1. Убедитесь, что элемент теперь отмечен. Если нет, этот метод выбрасывает исключение.

Если элемент будет отсоединен от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершились в течение указанного [timeout](/api/class-elementhandle.mdx#element-handle-check-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```js
await elementHandle.check();
await elementHandle.check(options);
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `force` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-force"/><a href="#element-handle-check-option-force" class="list-anchor">#</a>
    
    Нужно ли обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `noWaitAfter` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-no-wait-after"/><a href="#element-handle-check-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `position` [Object] *(необязательно)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-position"/><a href="#element-handle-check-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла области заполнения элемента. Если не указано, используется какая-то видимая точка элемента.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-timeout"/><a href="#element-handle-check-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методов.
  - `trial` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-trial"/><a href="#element-handle-check-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-return"/><a href="#element-handle-check-return" class="list-anchor">#</a>

---

### click {#element-handle-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.click</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.click()](/api/class-locator.mdx#locator-click) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Этот метод кликает по элементу, выполняя следующие шаги:
1. Ожидать проверки [actionability](../actionability.mdx) на элементе, если не установлена опция [force](/api/class-elementhandle.mdx#element-handle-click-option-force).
1. Прокрутить элемент в видимость, если это необходимо.
1. Использовать [page.mouse](/api/class-page.mdx#page-mouse), чтобы кликнуть в центре элемента или в указанной [позиции](/api/class-elementhandle.mdx#element-handle-click-option-position).
1. Ожидать, пока инициированные навигации либо не завершатся успешно, либо не потерпят неудачу, если не установлена опция [noWaitAfter](/api/class-elementhandle.mdx#element-handle-click-option-no-wait-after).

Если элемент будет отсоединен от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершились в течение указанного [timeout](/api/class-elementhandle.mdx#element-handle-click-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```js
await elementHandle.click();
await elementHandle.click(options);
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `button` "left" | "right" | "middle" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-button"/><a href="#element-handle-click-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `clickCount` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-click-count"/><a href="#element-handle-click-option-click-count" class="list-anchor">#</a>
    
    по умолчанию 1. См. [UIEvent.detail].
  - `delay` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-delay"/><a href="#element-handle-click-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `force` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-force"/><a href="#element-handle-click-option-force" class="list-anchor">#</a>
    
    Нужно ли обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `modifiers` [Array]&lt;"Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"&gt; *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-modifiers"/><a href="#element-handle-click-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `noWaitAfter` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-no-wait-after"/><a href="#element-handle-click-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция в будущем будет по умолчанию `true`.
    :::
    
    
    Действия, инициирующие навигацию, ожидают, пока эти навигации произойдут и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам потребуется эта опция только в исключительных случаях, таких как навигация к недоступным страницам. По умолчанию `false`.
  - `position` [Object] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-position"/><a href="#element-handle-click-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла области заполнения элемента. Если не указано, используется какая-то видимая точка элемента.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-timeout"/><a href="#element-handle-click-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методов.
  - `trial` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-trial"/><a href="#element-handle-click-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-return"/><a href="#element-handle-click-return" class="list-anchor">#</a>

---

### dblclick {#element-handle-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.dblclick</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.dblclick()](/api/class-locator.mdx#locator-dblclick) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Этот метод выполняет двойной клик по элементу, выполняя следующие шаги:
1. Ожидать проверки [actionability](../actionability.mdx) на элементе, если не установлена опция [force](/api/class-elementhandle.mdx#element-handle-dblclick-option-force).
1. Прокрутить элемент в видимость, если это необходимо.
1. Использовать [page.mouse](/api/class-page.mdx#page-mouse), чтобы дважды кликнуть в центре элемента или в указанной [позиции](/api/class-elementhandle.mdx#element-handle-dblclick-option-position).

Если элемент будет отсоединен от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершились в течение указанного [timeout](/api/class-elementhandle.mdx#element-handle-dblclick-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

:::note

`elementHandle.dblclick()` вызывает два события `click` и одно событие `dblclick`.
:::

**Использование**

```js
await elementHandle.dblclick();
await elementHandle.dblclick(options);
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `button` "left" | "right" | "middle" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-button"/><a href="#element-handle-dblclick-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `delay` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-delay"/><a href="#element-handle-dblclick-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `force` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-force"/><a href="#element-handle-dblclick-option-force" class="list-anchor">#</a>
    
    Нужно ли обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `modifiers` [Array]&lt;"Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"&gt; *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-modifiers"/><a href="#element-handle-dblclick-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `noWaitAfter` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-no-wait-after"/><a href="#element-handle-dblclick-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `position` [Object] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-position"/><a href="#element-handle-dblclick-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла области заполнения элемента. Если не указано, используется какая-то видимая точка элемента.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-timeout"/><a href="#element-handle-dblclick-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методов.
  - `trial` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-trial"/><a href="#element-handle-dblclick-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-return"/><a href="#element-handle-dblclick-return" class="list-anchor">#</a>

---

### dispatchEvent {#element-handle-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.dispatchEvent</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.dispatchEvent()](/api/class-locator.mdx#locator-dispatch-event) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Приведенный ниже фрагмент вызывает событие `click` на элементе. Независимо от состояния видимости элемента, `click` вызывается. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Использование**

```js
await elementHandle.dispatchEvent('click');
```

Под капотом он создает экземпляр события на основе данного [type](/api/class-elementhandle.mdx#element-handle-dispatch-event-option-type), инициализирует его свойствами [eventInit](/api/class-elementhandle.mdx#element-handle-dispatch-event-option-event-init) и вызывает его на элементе. События по умолчанию являются `composed`, `cancelable` и всплывают.

Поскольку [eventInit](/api/class-elementhandle.mdx#element-handle-dispatch-event-option-event-init) является специфичным для события, пожалуйста, обратитесь к документации по событиям для списков начальных свойств:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Вы также можете указать `JSHandle` в качестве значения свойства, если хотите, чтобы живые объекты были переданы в событие:

```js
// Обратите внимание, что вы можете создать DataTransfer только в Chromium и Firefox
const dataTransfer = await page.evaluateHandle(() => new DataTransfer());
await elementHandle.dispatchEvent('dragstart', { dataTransfer });
```

**Аргументы**
- `type` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dispatch-event-option-type"/><a href="#element-handle-dispatch-event-option-type" class="list-anchor">#</a>
  
  Тип DOM-события: `"click"`, `"dragstart"` и т.д.
- `eventInit` [EvaluationArgument] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dispatch-event-option-event-init"/><a href="#element-handle-dispatch-event-option-event-init" class="list-anchor">#</a>
  
  Необязательные свойства инициализации, специфичные для события.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dispatch-event-return"/><a href="#element-handle-dispatch-event-return" class="list-anchor">#</a>

---

### fill {#element-handle-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.fill</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.fill()](/api/class-locator.mdx#locator-fill) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Этот метод ожидает проверки [actionability](../actionability.mdx), фокусирует элемент, заполняет его и вызывает событие `input` после заполнения. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является элементом `<input>`, `<textarea>` или `[contenteditable]`, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [контроль](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен именно контроль.

Чтобы отправить детализированные события клавиатуры, используйте [locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially).

**Использование**

```js
await elementHandle.fill(value);
await elementHandle.fill(value, options);
```

**Аргументы**
- `value` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-value"/><a href="#element-handle-fill-option-value" class="list-anchor">#</a>
  
  Значение, которое нужно установить для элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `options` [Object] *(необязательно)*
  - `force` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-force"/><a href="#element-handle-fill-option-force" class="list-anchor">#</a>
    
    Нужно ли обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `noWaitAfter` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-no-wait-after"/><a href="#element-handle-fill-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-timeout"/><a href="#element-handle-fill-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методов.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-return"/><a href="#element-handle-fill-return" class="list-anchor">#</a>

---

### focus {#element-handle-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.focus</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.focus()](/api/class-locator.mdx#locator-focus) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Вызывает [focus](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) на элементе.

**Использование**

```js
await elementHandle.focus();
```

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-focus-return"/><a href="#element-handle-focus-return" class="list-anchor">#</a>

---

### getAttribute {#element-handle-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.getAttribute</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.getAttribute()](/api/class-locator.mdx#locator-get-attribute) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает значение атрибута элемента.

**Использование**

```js
await elementHandle.getAttribute(name);
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-get-attribute-option-name"/><a href="#element-handle-get-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута, для которого нужно получить значение.

**Возвращает**
- [Promise]&lt;[null] | [string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-get-attribute-return"/><a href="#element-handle-get-attribute-return" class="list-anchor">#</a>

---

### hover {#element-handle-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.hover</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.hover()](/api/class-locator.mdx#locator-hover) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Этот метод наводит курсор на элемент, выполняя следующие шаги:
1. Ожидать проверки [actionability](../actionability.mdx) на элементе, если не установлена опция [force](/api/class-elementhandle.mdx#element-handle-hover-option-force).
1. Прокрутить элемент в видимость, если это необходимо.
1. Использовать [page.mouse](/api/class-page.mdx#page-mouse), чтобы навести курсор на центр элемента или в указанной [позиции](/api/class-elementhandle.mdx#element-handle-hover-option-position).

Если элемент будет отсоединен от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершились в течение указанного [timeout](/api/class-elementhandle.mdx#element-handle-hover-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```js
await elementHandle.hover();
await elementHandle.hover(options);
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `force` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-force"/><a href="#element-handle-hover-option-force" class="list-anchor">#</a>
    
    Нужно ли обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `modifiers` [Array]&lt;"Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"&gt; *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-modifiers"/><a href="#element-handle-hover-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `noWaitAfter` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-no-wait-after"/><a href="#element-handle-hover-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `position` [Object] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-position"/><a href="#element-handle-hover-option-position" class="list-anchor">#</a>
    - `x` [number]
      
      
    - `y` [number]
      
      
    Точка, используемая относительно верхнего левого угла области заполнения элемента. Если не указано, используется какая-то видимая точка элемента.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-timeout"/><a href="#element-handle-hover-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методов.
  - `trial` [boolean] *(необязательно)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-trial"/><a href="#element-handle-hover-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-return"/><a href="#element-handle-hover-return" class="list-anchor">#</a>

---

### innerHTML {#element-handle-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.innerHTML</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.innerHTML()](/api/class-locator.mdx#locator-inner-html) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает `element.innerHTML`.

**Использование**

```js
await elementHandle.innerHTML();
```

**Возвращает**
- [Promise]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-inner-html-return"/><a href="#element-handle-inner-html-return" class="list-anchor">#</a>

---

### innerText {#element-handle-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.innerText</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.innerText()](/api/class-locator.mdx#locator-inner-text) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает `element.innerText`.

**Использование**

```js
await elementHandle.innerText();
```

**Возвращает**
- [Promise]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-inner-text-return"/><a href="#element-handle-inner-text-return" class="list-anchor">#</a>

---

### inputValue {#element-handle-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>elementHandle.inputValue</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.inputValue()](/api/class-locator.mdx#locator-input-value) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Выбрасывает исключение для не входных элементов. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [контроль](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращает значение контроля.

**Использование**

```js
await elementHandle.inputValue();
await elementHandle.inputValue(options);
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-input-value-option-timeout"/><a href="#element-handle-input-value-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методов.

**Возвращает**
- [Promise]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-input-value-return"/><a href="#element-handle-input-value-return" class="list-anchor">#</a>

---

### isChecked {#element-handle-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isChecked</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.isChecked()](/api/class-locator.mdx#locator-is-checked) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает, отмечен ли элемент. Выбрасывает исключение, если элемент не является флажком или радио-вводом.

**Использование**

```js
await elementHandle.isChecked();
```

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-checked-return"/><a href="#element-handle-is-checked-return" class="list-anchor">#</a>

---

### isDisabled {#element-handle-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isDisabled</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.isDisabled()](/api/class-locator.mdx#locator-is-disabled) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает, отключен ли элемент, противоположный [enabled](../actionability.mdx#enabled).

**Использование**

```js
await elementHandle.isDisabled();
```

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-disabled-return"/><a href="#element-handle-is-disabled-return" class="list-anchor">#</a>

---

### isEditable {#element-handle-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isEditable</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.isEditable()](/api/class-locator.mdx#locator-is-editable) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Использование**

```js
await elementHandle.isEditable();
```

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-editable-return"/><a href="#element-handle-is-editable-return" class="list-anchor">#</a>

---

### isEnabled {#element-handle-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isEnabled</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.isEnabled()](/api/class-locator.mdx#locator-is-enabled) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает, включен ли элемент [enabled](../actionability.mdx#enabled).

**Использование**

```js
await elementHandle.isEnabled();
```

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-enabled-return"/><a href="#element-handle-is-enabled-return" class="list-anchor">#</a>

---

### isHidden {#element-handle-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isHidden</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.isHidden()](/api/class-locator.mdx#locator-is-hidden) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает, скрыт ли элемент, противоположный [visible](../actionability.mdx#visible).

**Использование**

```js
await elementHandle.isHidden();
```

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-hidden-return"/><a href="#element-handle-is-hidden-return" class="list-anchor">#</a>

---

### isVisible {#element-handle-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isVisible</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.isVisible()](/api/class-locator.mdx#locator-is-visible) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Возвращает, виден ли элемент [visible](../actionability.mdx#visible).

**Использование**

```js
await elementHandle.isVisible();
```

**Возвращает**
- [Promise]&lt;[boolean]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-visible-return"/><a href="#element-handle-is-visible-return" class="list-anchor">#</a>

---

### press {#element-handle-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.press</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.press()](/api/class-locator.mdx#locator-press) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Фокусирует элемент, а затем использует [keyboard.down()](/api/class-keyboard.mdx#keyboard-down) и [keyboard.up()](/api/class-keyboard.mdx#keyboard-up).

[key](/api/class-elementhandle.mdx#element-handle-press-option-key) может указывать на предполагаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или один символ для генерации текста. Расширенный набор значений [key](/api/class-elementhandle.mdx#element-handle-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры клавиш:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются следующие сочетания модификаторов: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`.

Удерживание `Shift` будет печатать текст, соответствующий [key](/api/class-elementhandle.mdx#element-handle-press-option-key) в верхнем регистре.

Если [key](/api/class-elementhandle.mdx#element-handle-press-option-key) является одним символом, он чувствителен к регистру, поэтому значения `a` и `A` будут генерировать разные соответствующие тексты.

Сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++` или `key: "Control+Shift+T"` также поддерживаются. Когда указано с модификатором, модификатор удерживается и нажимается во время нажатия последующей клавиши.

**Использование**

```js
await elementHandle.press(key);
await elementHandle.press(key, options);
```

**Аргументы**
- `key` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-key"/><a href="#element-handle-press-option-key" class="list-anchor">#</a>
  
  Имя клавиши для нажатия или символ для генерации, например `ArrowLeft` или `a`.
- `options` [Object] *(необязательно)*
  - `delay` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-delay"/><a href="#element-handle-press-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `keydown` и `keyup` в миллисекундах. По умолчанию 0.
  - `noWaitAfter` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-no-wait-after"/><a href="#element-handle-press-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция будет по умолчанию `true` в будущем.
    :::
    
    
    Действия, инициирующие навигации, ожидают, пока эти навигации произойдут и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам потребуется эта опция только в исключительных случаях, таких как навигация к недоступным страницам. По умолчанию `false`.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-timeout"/><a href="#element-handle-press-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методов.

**Возвращает**
- [Promise]&lt;[void]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-return"/><a href="#element-handle-press-return" class="list-anchor">#</a>

---

### screenshot {#element-handle-screenshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.screenshot</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторе [locator.screenshot()](/api/class-locator.mdx#locator-screenshot) вместо этого. Узнайте больше о [локаторах](../locators.mdx).

:::


Этот метод захватывает скриншот страницы, обрезанный по размеру и положению этого конкретного элемента. Если элемент перекрыт другими элементами, он не будет фактически виден на скриншоте. Если элемент является прокручиваемым контейнером, только текущий прокрученный контент будет виден на скриншоте.

Этот метод ожидает проверки [actionability](../actionability.mdx), затем прокручивает элемент в видимость перед тем, как сделать скриншот. Если элемент отсоединен от DOM, метод выбрасывает ошибку.

Возвращает буфер с захваченным скриншотом.

**Использование**

```js
await elementHandle.screenshot();
await elementHandle.screenshot(options);
```

**Аргументы**
- `options` [Object] *(необязательно)*
  - `animations` "disabled" | "allow" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-animations"/><a href="#element-handle-screenshot-option-animations" class="list-anchor">#</a>
    
    Когда установлено в `"disabled"`, останавливает CSS-анимации, CSS-переходы и веб-анимации. Анимации обрабатываются по-разному в зависимости от их продолжительности:
    * конечные анимации быстро завершаются, чтобы сработало событие `transitionend`.
    * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся после скриншота.
    
    По умолчанию `"allow"`, что оставляет анимации нетронутыми.
  - `caret` "hide" | "initial" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-caret"/><a href="#element-handle-screenshot-option-caret" class="list-anchor">#</a>
    
    Когда установлено в `"hide"`, скриншот скроет текстовый курсор. Когда установлено в `"initial"`, поведение текстового курсора не изменится. По умолчанию `"hide"`.
  - `mask` [Array]&lt;[Locator]&gt; *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-mask"/><a href="#element-handle-screenshot-option-mask" class="list-anchor">#</a>
    
    Укажите локаторы, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут перекрыты розовым квадратом `#FF00FF` (настраиваемым с помощью [maskColor](/api/class-elementhandle.mdx#element-handle-screenshot-option-mask-color)), который полностью покрывает его ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Сопоставление только видимых элементов](../locators.mdx#matching-only-visible-elements), чтобы отключить это.
  - `maskColor` [string] *(необязательно)* <font size="2">Добавлено в: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-mask-color"/><a href="#element-handle-screenshot-option-mask-color" class="list-anchor">#</a>
    
    Укажите цвет наложенного квадрата для замаскированных элементов в [формате цвета CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию - розовый `#FF00FF`.
  - `omitBackground` [boolean] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-omit-background"/><a href="#element-handle-screenshot-option-omit-background" class="list-anchor">#</a>
    
    Скрывает белый фон по умолчанию и позволяет захватывать скриншоты с прозрачностью. Не применяется к изображениям `jpeg`. По умолчанию `false`.
  - `path` [string] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-path"/><a href="#element-handle-screenshot-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения изображения. Тип скриншота будет определен по расширению файла. Если [path](/api/class-elementhandle.mdx#element-handle-screenshot-option-path) является относительным путем, то он разрешается относительно текущего рабочего каталога. Если путь не указан, изображение не будет сохранено на диск.
  - `quality` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-quality"/><a href="#element-handle-screenshot-option-quality" class="list-anchor">#</a>
    
    Качество изображения от 0 до 100. Не применяется к изображениям `png`.
  - `scale` "css" | "device" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-scale"/><a href="#element-handle-screenshot-option-scale" class="list-anchor">#</a>
    
    Когда установлено в `"css"`, скриншот будет иметь один пиксель на каждый CSS-пиксель на странице. Для устройств с высоким разрешением это позволит сохранить скриншоты небольшими. Использование опции `"device"` приведет к тому, что скриншоты будут иметь один пиксель на каждый пиксель устройства, поэтому скриншоты для устройств с высоким разрешением будут в два раза больше или даже больше.
    
    По умолчанию `"device"`.
  - `style` [string] *(необязательно)* <font size="2">Добавлено в: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-style"/><a href="#element-handle-screenshot-option-style" class="list-anchor">#</a>
    
    Текст таблицы стилей, который будет применен при создании скриншота. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создавать повторяемые скриншоты. Эта таблица стилей проникает в Shadow DOM и применяется к внутренним фреймам.
  - `timeout` [number] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-timeout"/><a href="#element-handle-screenshot-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `0` - без таймаута. Значение по умолчанию можно изменить через опцию `actionTimeout` в конфигурации или с помощью методов [browserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методов.
  - `type` "png" | "jpeg" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-type"/><a href="#element-handle-screenshot-option-type" class="list-anchor">#</a>
    
    Укажите тип скриншота, по умолчанию `png`.

**Возвращает**
- [Promise]&lt;[Buffer]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-return"/><a href="#element-handle-screenshot-return" class="list-anchor">#</a>

---

### scrollIntoViewIfNeeded {#element-handle-scroll-into-view-if-needed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.scrollIntoViewIfNeeded</x-search>

:::warning[Не рекомендуется]

Используйте основанный