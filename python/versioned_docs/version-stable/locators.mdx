---
id: locators
title: "Локаторы"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

## Введение

[Локаторы] являются центральной частью автоматического ожидания и возможности повторных попыток в Playwright. Вкратце, локаторы представляют собой способ найти элемент(ы) на странице в любой момент времени.

### Быстрый гайд

Это рекомендуемые встроенные локаторы.
- [page.get_by_role()](#locate-by-role) для поиска по явным и неявным атрибутам доступности.
- [page.get_by_text()](#locate-by-text) для поиска по текстовому содержимому.
- [page.get_by_label()](#locate-by-label) для поиска элемента управления формой по тексту связанной метки.
- [page.get_by_placeholder()](#locate-by-placeholder) для поиска ввода по заполнителю.
- [page.get_by_alt_text()](#locate-by-alt-text) для поиска элемента, обычно изображения, по его текстовой альтернативе.
- [page.get_by_title()](#locate-by-title) для поиска элемента по его атрибуту title.
- [page.get_by_test_id()](#locate-by-test-id) для поиска элемента на основе его атрибута `data-testid` (другие атрибуты могут быть настроены).

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_label("User Name").fill("John")

page.get_by_label("Password").fill("secret-password")

page.get_by_role("button", name="Sign in").click()

expect(page.get_by_text("Welcome, John!")).to_be_visible()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_label("User Name").fill("John")

await page.get_by_label("Password").fill("secret-password")

await page.get_by_role("button", name="Sign in").click()

await expect(page.get_by_text("Welcome, John!")).to_be_visible()
```

</TabItem>
</Tabs>

## Поиск элементов

Playwright предоставляет несколько встроенных локаторов. Чтобы сделать тесты устойчивыми, мы рекомендуем отдавать приоритет атрибутам, ориентированным на пользователя, и явным контрактам, таким как [page.get_by_role()](/api/class-page.mdx#page-get-by-role).

Например, рассмотрим следующую структуру DOM.

<HTMLCard>
<div>
<button>Sign in</button>
</div>

```html
<button>Sign in</button>
```
</HTMLCard>

Найдите элемент по его роли `button` с именем "Sign in".

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("button", name="Sign in").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("button", name="Sign in").click()
```

</TabItem>
</Tabs>

:::note

Используйте [генератор кода](./codegen.mdx) для генерации локатора, а затем отредактируйте его по своему усмотрению.
:::

Каждый раз, когда локатор используется для действия, актуальный элемент DOM находится на странице. В приведенном ниже фрагменте кода базовый элемент DOM будет найден дважды, один раз перед каждым действием. Это означает, что если DOM изменится между вызовами из-за повторного рендеринга, будет использован новый элемент, соответствующий локатору.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
locator = page.get_by_role("button", name="Sign in")

locator.hover()
locator.click()
```

</TabItem>
<TabItem value="async">

```py
locator = page.get_by_role("button", name="Sign in")

await locator.hover()
await locator.click()
```

</TabItem>
</Tabs>

Обратите внимание, что все методы, создающие локатор, такие как [page.get_by_label()](/api/class-page.mdx#page-get-by-label), также доступны в классах [Locator] и [FrameLocator], поэтому вы можете объединять их и постепенно уточнять ваш локатор.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
locator = page.frame_locator("my-frame").get_by_role("button", name="Sign in")

locator.click()
```

</TabItem>
<TabItem value="async">

```py
locator = page.frame_locator("#my-frame").get_by_role("button", name="Sign in")

await locator.click()
```

</TabItem>
</Tabs>

### Поиск по роли

Локатор [page.get_by_role()](/api/class-page.mdx#page-get-by-role) отражает, как пользователи и вспомогательные технологии воспринимают страницу, например, является ли элемент кнопкой или флажком. При поиске по роли обычно следует также указывать доступное имя, чтобы локатор точно указывал на нужный элемент.

Например, рассмотрим следующую структуру DOM.

<HTMLCard>
<div>
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
</div>

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```
</HTMLCard>

Вы можете найти каждый элемент по его неявной роли:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_role("heading", name="Sign up")).to_be_visible()

page.get_by_role("checkbox", name="Subscribe").check()

page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_role("heading", name="Sign up")).to_be_visible()

await page.get_by_role("checkbox", name="Subscribe").check()

await page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
```

</TabItem>
</Tabs>

Локаторы ролей включают [кнопки, флажки, заголовки, ссылки, списки, таблицы и многие другие](https://www.w3.org/TR/html-aria/#docconformance) и следуют спецификациям W3C для [роли ARIA](https://www.w3.org/TR/wai-aria-1.2/#roles), [атрибутов ARIA](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) и [доступного имени](https://w3c.github.io/accname/#dfn-accessible-name). Обратите внимание, что многие HTML-элементы, такие как `<button>`, имеют [неявно определенную роль](https://w3c.github.io/html-aam/#html-element-role-mappings), которая распознается локатором роли.

Обратите внимание, что локаторы ролей **не заменяют** аудиты доступности и тесты на соответствие, но дают раннюю обратную связь о руководствах ARIA.

:::note[Когда использовать локаторы ролей]

Мы рекомендуем отдавать приоритет локаторам ролей для поиска элементов, так как это наиболее близкий способ к тому, как пользователи и вспомогательные технологии воспринимают страницу.
:::

### Поиск по метке

Большинство элементов управления формами обычно имеют выделенные метки, которые можно удобно использовать для взаимодействия с формой. В этом случае вы можете найти элемент управления по его связанной метке, используя [page.get_by_label()](/api/class-page.mdx#page-get-by-label).

Например, рассмотрим следующую структуру DOM.

<HTMLCard>
<div>
<label>Password <input type="password" /></label>

</div>

```html
<label>Password <input type="password" /></label>

```
</HTMLCard>

Вы можете заполнить ввод после его поиска по тексту метки:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_label("Password").fill("secret")
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_label("Password").fill("secret")
```

</TabItem>
</Tabs>

:::note[Когда использовать локаторы меток]

Используйте этот локатор при поиске полей формы.
:::

### Поиск по заполнителю

Вводы могут иметь атрибут заполнителя, чтобы подсказать пользователю, какое значение следует ввести. Вы можете найти такой ввод, используя [page.get_by_placeholder()](/api/class-page.mdx#page-get-by-placeholder).

Например, рассмотрим следующую структуру DOM.

<HTMLCard>
<div>
<input type="email" placeholder="name@example.com" />
</div>

```html
<input type="email" placeholder="name@example.com" />
```
</HTMLCard>

Вы можете заполнить ввод после его поиска по тексту заполнителя:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
```

</TabItem>
</Tabs>

:::note[Когда использовать локаторы заполнителей]

Используйте этот локатор при поиске элементов формы, у которых нет меток, но есть текст заполнителя.
:::

### Поиск по тексту

Найдите элемент по тексту, который он содержит. Вы можете сопоставить по подстроке, точной строке или регулярному выражению, используя [page.get_by_text()](/api/class-page.mdx#page-get-by-text).

Например, рассмотрим следующую структуру DOM.

<HTMLCard>
<div>
<span>Welcome, John</span>
</div>

```html
<span>Welcome, John</span>
```
</HTMLCard>

Вы можете найти элемент по тексту, который он содержит:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_text("Welcome, John")).to_be_visible()
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_text("Welcome, John")).to_be_visible()
```

</TabItem>
</Tabs>

Установите точное совпадение:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_text("Welcome, John", exact=True)).to_be_visible()
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_text("Welcome, John", exact=True)).to_be_visible()
```

</TabItem>
</Tabs>

Совпадение с регулярным выражением:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_text(re.compile("welcome, john", re.IGNORECASE))).to_be_visible()
```

</TabItem>
<TabItem value="async">

```py
await expect(
    page.get_by_text(re.compile("welcome, john", re.IGNORECASE))
).to_be_visible()
```

</TabItem>
</Tabs>

:::note

Сопоставление по тексту всегда нормализует пробелы, даже при точном совпадении. Например, оно превращает несколько пробелов в один, превращает разрывы строк в пробелы и игнорирует начальные и конечные пробелы.
:::

:::note[Когда использовать локаторы текста]
Мы рекомендуем использовать локаторы текста для поиска неинтерактивных элементов, таких как `div`, `span`, `p` и т.д. Для интерактивных элементов, таких как `button`, `a`, `input` и т.д., используйте [локаторы ролей](#locate-by-role).
:::

Вы также можете [фильтровать по тексту](#filter-by-text), что может быть полезно при попытке найти конкретный элемент в списке.

### Поиск по альтернативному тексту

Все изображения должны иметь атрибут `alt`, который описывает изображение. Вы можете найти изображение на основе текстовой альтернативы, используя [page.get_by_alt_text()](/api/class-page.mdx#page-get-by-alt-text).

Например, рассмотрим следующую структуру DOM.

<HTMLCard>
<div>
<img alt="playwright logo" src="/img/playwright-logo.svg" width="100" />
</div>

```html
<img alt="playwright logo" src="/img/playwright-logo.svg" width="100" />
```
</HTMLCard>

Вы можете кликнуть на изображение после его нахождения по текстовой альтернативе:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_alt_text("playwright logo").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_alt_text("playwright logo").click()
```

</TabItem>
</Tabs>

:::note[Когда использовать локаторы по alt]

Используйте этот локатор, когда ваш элемент поддерживает альтернативный текст, например, элементы `img` и `area`.
:::

### Поиск по заголовку

Найдите элемент с соответствующим атрибутом title, используя [page.get_by_title()](/api/class-page.mdx#page-get-by-title).

Например, рассмотрим следующую структуру DOM.

<HTMLCard>
<div>
<span title='Issues count'>25 issues</span>
</div>

```html
<span title='Issues count'>25 issues</span>
```
</HTMLCard>

Вы можете проверить количество проблем после его нахождения по тексту заголовка:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_title("Issues count")).to_have_text("25 issues")
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_title("Issues count")).to_have_text("25 issues")
```

</TabItem>
</Tabs>

:::note[Когда использовать локаторы по заголовку]

Используйте этот локатор, когда ваш элемент имеет атрибут `title`.
:::

### Поиск по тестовому идентификатору

Тестирование по тестовым идентификаторам является наиболее устойчивым способом тестирования, так как даже если ваш текст или роль атрибута изменится, тест все равно пройдет. QA и разработчики должны определять явные тестовые идентификаторы и запрашивать их с помощью [page.get_by_test_id()](/api/class-page.mdx#page-get-by-test-id). Однако тестирование по тестовым идентификаторам не ориентировано на пользователя. Если роль или текстовое значение важны для вас, рассмотрите возможность использования локаторов, ориентированных на пользователя, таких как [role](#locate-by-role) и [text locators](#locate-by-text).

Например, рассмотрим следующую структуру DOM.

<HTMLCard>
<div>
<button data-testid="directions">Itinéraire</button>
</div>

```html
<button data-testid="directions">Itinéraire</button>
```
</HTMLCard>

Вы можете найти элемент по его тестовому идентификатору:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_test_id("directions").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_test_id("directions").click()
```

</TabItem>
</Tabs>

:::note[Когда использовать локаторы по testid]

Вы также можете использовать тестовые идентификаторы, когда выбираете методологию тестовых идентификаторов или когда не можете найти по [role](#locate-by-role) или [text](#locate-by-text).
:::

#### Установите пользовательский атрибут тестового идентификатора

По умолчанию, [page.get_by_test_id()](/api/class-page.mdx#page-get-by-test-id) будет находить элементы на основе атрибута `data-testid`, но вы можете настроить его в конфигурации теста или вызвав [selectors.set_test_id_attribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute).

Установите тестовый идентификатор для использования пользовательского атрибута данных в ваших тестах.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
playwright.selectors.set_test_id_attribute("data-pw")
```

</TabItem>
<TabItem value="async">

```py
playwright.selectors.set_test_id_attribute("data-pw")
```

</TabItem>
</Tabs>

В вашем HTML теперь вы можете использовать `data-pw` в качестве тестового идентификатора вместо стандартного `data-testid`.

<HTMLCard>
<div>
<button data-pw="directions">Itinéraire</button>
</div>

```html
<button data-pw="directions">Itinéraire</button>
```
</HTMLCard>

А затем найдите элемент, как обычно:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_test_id("directions").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_test_id("directions").click()
```

</TabItem>
</Tabs>

### Поиск по CSS или XPath

Если вам абсолютно необходимо использовать локаторы CSS или XPath, вы можете использовать [page.locator()](/api/class-page.mdx#page-locator) для создания локатора, который принимает селектор, описывающий, как найти элемент на странице. Playwright поддерживает селекторы CSS и XPath и автоматически определяет их, если вы опускаете префикс `css=` или `xpath=`.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.locator("css=button").click()
page.locator("xpath=//button").click()

page.locator("button").click()
page.locator("//button").click()
```

</TabItem>
<TabItem value="async">

```py
await page.locator("css=button").click()
await page.locator("xpath=//button").click()

await page.locator("button").click()
await page.locator("//button").click()
```

</TabItem>
</Tabs>

XPath и CSS селекторы могут быть привязаны к структуре DOM или реализации. Эти селекторы могут сломаться, когда структура DOM изменяется. Длинные цепочки CSS или XPath ниже являются примером **плохой практики**, которая приводит к нестабильным тестам:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.locator(
    "#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input"
).click()

page.locator('//*[@id="tsf"]/div[2]/div[1]/div[1]/div/div[2]/input').click()
```

</TabItem>
<TabItem value="async">

```py
await page.locator(
    "#tsf > div:nth-child(2) > div.A8SBwf > div.RNNXgb > div > div.a4bIc > input"
).click()

await page.locator('//*[@id="tsf"]/div[2]/div[1]/div[1]/div/div[2]/input').click()
```

</TabItem>
</Tabs>

:::note[Когда использовать это]

CSS и XPath не рекомендуются, так как DOM может часто изменяться, что приводит к неустойчивым тестам. Вместо этого постарайтесь придумать локатор, который близок к тому, как пользователь воспринимает страницу, например, [локаторы по ролям](#locate-by-role) или [определите явный контракт тестирования](#locate-by-test-id) с использованием тестовых идентификаторов.
:::

## Поиск в Shadow DOM

Все локаторы в Playwright **по умолчанию** работают с элементами в Shadow DOM. Исключения составляют:
- Поиск по XPath не проникает в shadow roots.
- [Закрытые shadow roots](https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow#parameters) не поддерживаются.

Рассмотрим следующий пример с пользовательским веб-компонентом:

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

Вы можете найти элемент так же, как если бы shadow root не существовал.

Чтобы кликнуть `<div>Details</div>`:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_text("Details").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_text("Details").click()
```

</TabItem>
</Tabs>

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

Чтобы кликнуть `<x-details>`:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.locator("x-details", has_text="Details").click()
```

</TabItem>
<TabItem value="async">

```py
await page.locator("x-details", has_text="Details").click()
```

</TabItem>
</Tabs>

```html
<x-details role=button aria-expanded=true aria-controls=inner-details>
  <div>Title</div>
  #shadow-root
    <div id=inner-details>Details</div>
</x-details>
```

Чтобы убедиться, что `<x-details>` содержит текст "Details":

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.locator("x-details")).to_contain_text("Details")
```

</TabItem>
<TabItem value="async">

```py
await expect(page.locator("x-details")).to_contain_text("Details")
```

</TabItem>
</Tabs>

## Фильтрация локаторов

Рассмотрим следующую структуру DOM, где мы хотим кликнуть на кнопку покупки второй карточки продукта. У нас есть несколько вариантов, чтобы отфильтровать локаторы и получить нужный.

<HTMLCard>
<div>
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
</div>

```html
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
```
</HTMLCard>

### Фильтрация по тексту

Локаторы могут быть отфильтрованы по тексту с помощью метода [locator.filter()](/api/class-locator.mdx#locator-filter). Он будет искать определенную строку где-то внутри элемента, возможно, в дочернем элементе, без учета регистра. Вы также можете передать регулярное выражение.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("listitem").filter(has_text="Product 2").get_by_role(
    "button", name="Add to cart"
).click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("listitem").filter(has_text="Product 2").get_by_role(
    "button", name="Add to cart"
).click()
```

</TabItem>
</Tabs>

Используйте регулярное выражение:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("listitem").filter(has_text=re.compile("Product 2")).get_by_role(
    "button", name="Add to cart"
).click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("listitem").filter(has_text=re.compile("Product 2")).get_by_role(
    "button", name="Add to cart"
).click()
```

</TabItem>
</Tabs>

### Фильтрация по отсутствию текста

В качестве альтернативы, фильтруйте по **отсутствию** текста:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# 5 товаров в наличии
expect(page.get_by_role("listitem").filter(has_not_text="Out of stock")).to_have_count(5)
```

</TabItem>
<TabItem value="async">

```py
# 5 товаров в наличии
await expect(page.get_by_role("listitem").filter(has_not_text="Out of stock")).to_have_count(5)
```

</TabItem>
</Tabs>

### Фильтрация по дочернему/потомку

Локаторы поддерживают опцию выбора только тех элементов, которые имеют или не имеют потомка, соответствующего другому локатору. Таким образом, вы можете фильтровать по любому другому локатору, такому как [locator.get_by_role()](/api/class-locator.mdx#locator-get-by-role), [locator.get_by_test_id()](/api/class-locator.mdx#locator-get-by-test-id), [locator.get_by_text()](/api/class-locator.mdx#locator-get-by-text) и т.д.

<HTMLCard>
<div>
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
</div>

```html
<ul>
  <li>
    <h3>Product 1</h3>
    <button>Add to cart</button>
  </li>
  <li>
    <h3>Product 2</h3>
    <button>Add to cart</button>
  </li>
</ul>
```
</HTMLCard>

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("listitem").filter(
    has=page.get_by_role("heading", name="Product 2")
).get_by_role("button", name="Add to cart").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("listitem").filter(
    has=page.get_by_role("heading", name="Product 2")
).get_by_role("button", name="Add to cart").click()
```

</TabItem>
</Tabs>

Мы также можем проверить карточку продукта, чтобы убедиться, что она только одна:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(
    page.get_by_role("listitem").filter(
        has=page.get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
<TabItem value="async">

```py
await expect(
    page.get_by_role("listitem").filter(
        has=page.get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
</Tabs>

Фильтрующий локатор **должен быть относительным** к исходному локатору и запрашивается начиная с совпадения исходного локатора, а не с корня документа. Поэтому следующее не сработает, потому что фильтрующий локатор начинает совпадать с элементом списка `<ul>`, который находится вне элемента списка `<li>`, совпадающего с исходным локатором:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# ✖ НЕПРАВИЛЬНО
expect(
    page.get_by_role("listitem").filter(
        has=page.get_by_role("list").get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
<TabItem value="async">

```py
# ✖ НЕПРАВИЛЬНО
await expect(
    page.get_by_role("listitem").filter(
        has=page.get_by_role("list").get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
</Tabs>

### Фильтрация по отсутствию дочернего/потомка

Мы также можем фильтровать по **отсутствию** соответствующего элемента внутри.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(
    page.get_by_role("listitem").filter(
        has_not=page.get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
<TabItem value="async">

```py
await expect(
    page.get_by_role("listitem").filter(
        has_not=page.get_by_role("heading", name="Product 2")
    )
).to_have_count(1)
```

</TabItem>
</Tabs>

Обратите внимание, что внутренний локатор совпадает, начиная с внешнего, а не с корня документа.

## Операторы локаторов

### Совпадение внутри локатора

Вы можете объединять методы, создающие локатор, такие как [page.get_by_text()](/api/class-page.mdx#page-get-by-text) или [locator.get_by_role()](/api/class-locator.mdx#locator-get-by-role), чтобы сузить поиск до определенной части страницы.

В этом примере мы сначала создаем локатор под названием product, находя его роль `listitem`. Затем мы фильтруем по тексту. Мы можем снова использовать локатор product, чтобы получить роль кнопки и нажать на нее, а затем использовать утверждение, чтобы убедиться, что есть только один продукт с текстом "Product 2".

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
product = page.get_by_role("listitem").filter(has_text="Product 2")

product.get_by_role("button", name="Add to cart").click()
```

</TabItem>
<TabItem value="async">

```py
product = page.get_by_role("listitem").filter(has_text="Product 2")

await product.get_by_role("button", name="Add to cart").click()
```

</TabItem>
</Tabs>

Вы также можете объединить два локатора вместе, например, чтобы найти кнопку "Сохранить" внутри определенного диалога:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
save_button = page.get_by_role("button", name="Save")
# ...
dialog = page.get_by_test_id("settings-dialog")
dialog.locator(save_button).click()
```

</TabItem>
<TabItem value="async">

```py
save_button = page.get_by_role("button", name="Save")
# ...
dialog = page.get_by_test_id("settings-dialog")
await dialog.locator(save_button).click()
```

</TabItem>
</Tabs>

### Совпадение двух локаторов одновременно

Метод [locator.and_()](/api/class-locator.mdx#locator-and) сужает существующий локатор, сопоставляя дополнительный локатор. Например, вы можете объединить [page.get_by_role()](/api/class-page.mdx#page-get-by-role) и [page.get_by_title()](/api/class-page.mdx#page-get-by-title), чтобы сопоставить как по роли, так и по заголовку.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
button = page.get_by_role("button").and_(page.getByTitle("Subscribe"))
```

</TabItem>
<TabItem value="async">

```py
button = page.get_by_role("button").and_(page.getByTitle("Subscribe"))
```

</TabItem>
</Tabs>

### Совпадение одного из двух альтернативных локаторов

Если вы хотите нацелиться на один из двух или более элементов, и вы не знаете, какой из них это будет, используйте [locator.or_()](/api/class-locator.mdx#locator-or), чтобы создать локатор, который соответствует любому из них или обоим альтернативам.

Например, рассмотрим сценарий, в котором вы хотите нажать на кнопку "Новое письмо", но иногда вместо этого появляется диалог настроек безопасности. В этом случае вы можете ожидать либо кнопку "Новое письмо", либо диалог и действовать соответственно.

:::note

Если и кнопка "Новое письмо", и диалог безопасности появляются на экране, локатор "или" будет соответствовать обоим из них, возможно, вызывая ошибку ["strict mode violation"](#strictness). В этом случае вы можете использовать [locator.first](/api/class-locator.mdx#locator-first), чтобы соответствовать только одному из них.
:::

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
new_email = page.get_by_role("button", name="New")
dialog = page.get_by_text("Confirm security settings")
expect(new_email.or_(dialog).first).to_be_visible()
if (dialog.is_visible()):
  page.get_by_role("button", name="Dismiss").click()
new_email.click()
```

</TabItem>
<TabItem value="async">

```py
new_email = page.get_by_role("button", name="New")
dialog = page.get_by_text("Confirm security settings")
await expect(new_email.or_(dialog).first).to_be_visible()
if (await dialog.is_visible()):
  await page.get_by_role("button", name="Dismiss").click()
await new_email.click()
```

</TabItem>
</Tabs>

### Поиск только видимых элементов

:::note

Обычно лучше найти [более надежный способ](./locators.mdx#quick-guide) уникально идентифицировать элемент, чем проверять видимость.
:::

Рассмотрим страницу с двумя кнопками: первая невидима, а вторая [видима](./actionability.mdx#visible).

```html
<button style='display: none'>Invisible</button>
<button>Visible</button>
```

* Это найдет обе кнопки и вызовет ошибку [строгости](./locators.mdx#strictness):
  <Tabs
    groupId="python-flavor"
    defaultValue="sync"
    values={[
      {label: 'Sync', value: 'sync'},
      {label: 'Async', value: 'async'}
    ]
  }>
  <TabItem value="sync">
  
  ```py
  page.locator("button").click()
  ```
  
  </TabItem>
  <TabItem value="async">
  
  ```py
  await page.locator("button").click()
  ```
  
  </TabItem>
  </Tabs>
* Это найдет только вторую кнопку, так как она видима, и затем кликнет по ней.
  
  <Tabs
    groupId="python-flavor"
    defaultValue="sync"
    values={[
      {label: 'Sync', value: 'sync'},
      {label: 'Async', value: 'async'}
    ]
  }>
  <TabItem value="sync">
  
  ```py
  page.locator("button").filter(visible=True).click()
  ```
  
  </TabItem>
  <TabItem value="async">
  
  ```py
  await page.locator("button").filter(visible=True).click()
  ```
  
  </TabItem>
  </Tabs>

## Списки

### Подсчет элементов в списке

Вы можете использовать локаторы, чтобы подсчитать количество элементов в списке.

Например, рассмотрим следующую структуру DOM:

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

Используйте утверждение count, чтобы убедиться, что в списке 3 элемента.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_role("listitem")).to_have_count(3)
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_role("listitem")).to_have_count(3)
```

</TabItem>
</Tabs>

### Утверждение всех текстов в списке

Вы можете использовать локаторы, чтобы найти все тексты в списке.

Например, рассмотрим следующую структуру DOM:

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

Используйте [expect(locator).to_have_text()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text), чтобы убедиться, что в списке есть тексты "apple", "banana" и "orange".

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_role("listitem")).to_have_text(["apple", "banana", "orange"])
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_role("listitem")).to_have_text(["apple", "banana", "orange"])
```

</TabItem>
</Tabs>

### Получение конкретного элемента

Существует множество способов получить конкретный элемент в списке.

#### Получение по тексту

Используйте метод [page.get_by_text()](/api/class-page.mdx#page-get-by-text), чтобы найти элемент в списке по его текстовому содержимому и затем кликнуть по нему.

Например, рассмотрим следующую структуру DOM:

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

Найдите элемент по его текстовому содержимому и кликните по нему.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_text("orange").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_text("orange").click()
```

</TabItem>
</Tabs>

#### Фильтрация по тексту

Используйте [locator.filter()](/api/class-locator.mdx#locator-filter), чтобы найти конкретный элемент в списке.

Например, рассмотрим следующую структуру DOM:

<HTMLCard>
<div>
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
</div>

```html
<ul>
  <li>apple</li>
  <li>banana</li>
  <li>orange</li>
</ul>
```
</HTMLCard>

Найдите элемент по роли "listitem", затем отфильтруйте по тексту "orange" и кликните по нему.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("listitem").filter(has_text="orange").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("listitem").filter(has_text="orange").click()
```

</TabItem>
</Tabs>

#### Получение по тестовому идентификатору

Используйте метод [page.get_by_test_id()](/api/class-page.mdx#page-get-by-test-id), чтобы найти элемент в списке. Возможно, вам потребуется изменить HTML и добавить тестовый идентификатор, если у вас его еще нет.

Например, рассмотрим следующую структуру DOM:

<HTMLCard>
<div>
<ul>
  <li data-testid='apple'>apple</li>
  <li data-testid='banana'>banana</li>
  <li data-testid='orange'>orange</li>
</ul>
</div>

```html
<ul>
  <li data-testid='apple'>apple</li>
  <li data-testid='banana'>banana</li>
  <li data-testid='orange'>orange</li>
</ul>
```
</HTMLCard>

Найдите элемент по его тестовому идентификатору "orange" и кликните по нему.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_test_id("orange").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_test_id("orange").click()
```

</TabItem>
</Tabs>

#### Получение по порядковому номеру

Если у вас есть список идентичных элементов, и единственный способ отличить их - это порядок, вы можете выбрать конкретный элемент из списка с помощью [locator.first](/api/class-locator.mdx#locator-first), [locator.last](/api/class-locator.mdx#locator-last) или [locator.nth()](/api/class-locator.mdx#locator-nth).

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
banana = page.get_by_role("listitem").nth(1)
```

</TabItem>
<TabItem value="async">

```py
banana = await page.get_by_role("listitem").nth(1)
```

</TabItem>
</Tabs>

Однако используйте этот метод с осторожностью. Часто страница может измениться, и локатор будет указывать на совершенно другой элемент, чем вы ожидали. Вместо этого постарайтесь придумать уникальный локатор, который пройдет [критерии строгости](#strictness).

### Цепочка фильтров

Когда у вас есть элементы с различными сходствами, вы можете использовать метод [locator.filter()](/api/class-locator.mdx#locator-filter), чтобы выбрать нужный. Вы также можете объединять несколько фильтров, чтобы сузить выбор.

Например, рассмотрим следующую структуру DOM:

<HTMLCard>
<div>
<ul>
  <li>
    <div>John</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>John</div>
    <div><button>Say goodbye</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say goodbye</button></div>
  </li>
</ul>
</div>

```html
<ul>
  <li>
    <div>John</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say hello</button></div>
  </li>
  <li>
    <div>John</div>
    <div><button>Say goodbye</button></div>
  </li>
  <li>
    <div>Mary</div>
    <div><button>Say goodbye</button></div>
  </li>
</ul>
```
</HTMLCard>

Чтобы сделать скриншот строки с "Mary" и "Say goodbye":

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
row_locator = page.get_by_role("listitem")

row_locator.filter(has_text="Mary").filter(
    has=page.get_by_role("button", name="Say goodbye")
).screenshot(path="screenshot.png")
```

</TabItem>
<TabItem value="async">

```py
row_locator = page.get_by_role("listitem")

await row_locator.filter(has_text="Mary").filter(
    has=page.get_by_role("button", name="Say goodbye")
).screenshot(path="screenshot.png")
```

</TabItem>
</Tabs>

Теперь у вас должен быть файл "screenshot.png" в корневом каталоге вашего проекта.

### Редкие случаи использования

#### Выполнение действий с каждым элементом в списке

Итерация по элементам:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
for row in page.get_by_role("listitem").all():
    print(row.text_content())
```

</TabItem>
<TabItem value="async">

```py
for row in await page.get_by_role("listitem").all():
    print(await row.text_content())
```

</TabItem>
</Tabs>

Итерация с использованием обычного цикла for:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
rows = page.get_by_role("listitem")
count = rows.count()
for i in range(count):
    print(rows.nth(i).text_content())
```

</TabItem>
<TabItem value="async">

```py
rows = page.get_by_role("listitem")
count = await rows.count()
for i in range(count):
    print(await rows.nth(i).text_content())
```

</TabItem>
</Tabs>

#### Выполнение кода на странице

Код внутри [locator.evaluate_all()](/api/class-locator.mdx#locator-evaluate-all) выполняется на странице, там можно вызывать любые DOM API.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
rows = page.get_by_role("listitem")
texts = rows.evaluate_all("list => list.map(element => element.textContent)")
```

</TabItem>
<TabItem value="async">

```py
rows = page.get_by_role("listitem")
texts = await rows.evaluate_all("list => list.map(element => element.textContent)")
```

</TabItem>
</Tabs>

## Строгость

Локаторы являются строгими. Это означает, что все операции с локаторами, которые подразумевают некоторый целевой элемент DOM, вызовут исключение, если будет найдено более одного элемента. Например, следующий вызов вызовет ошибку, если в DOM несколько кнопок:

#### Вызывает ошибку, если более одного элемента

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("button").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("button").click()
```

</TabItem>
</Tabs>

С другой стороны, Playwright понимает, когда вы выполняете операцию с несколькими элементами, поэтому следующий вызов работает нормально, когда локатор разрешается в несколько элементов.

#### Работает нормально с несколькими элементами

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("button").count()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("button").count()
```

</TabItem>
</Tabs>

Вы можете явно отказаться от проверки строгости, указав Playwright, какой элемент использовать, когда несколько элементов совпадают, через [locator.first](/api/class-locator.mdx#locator-first), [locator.last](/api/class-locator.mdx#locator-last) и [locator.nth()](/api/class-locator.mdx#locator-nth). Эти методы **не рекомендуются**, потому что, когда ваша страница изменяется, Playwright может нажать на элемент, который вы не планировали. Вместо этого следуйте лучшим практикам, чтобы создать локатор, который уникально идентифицирует целевой элемент.

## Дополнительные локаторы

Для менее часто используемых локаторов ознакомьтесь с руководством [другие локаторы](./other-locators.mdx).

[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[Error]: /api/class-error.mdx "Error"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Any]: https://docs.python.org/3/library/typing.html#typing.Any "Any"
[bool]: https://docs.python.org/3/library/stdtypes.html "bool"
[bytes]: https://docs.python.org/3/library/stdtypes.html#bytes "bytes"
[Callable]: https://docs.python.org/3/library/typing.html#typing.Callable "Callable"
[EventContextManager]: https://docs.python.org/3/reference/datamodel.html#context-managers "Event context manager"
[EventEmitter]: https://pyee.readthedocs.io/en/latest/#pyee.BaseEventEmitter "EventEmitter"
[Exception]: https://docs.python.org/3/library/exceptions.html#Exception "Exception"
[Dict]: https://docs.python.org/3/library/typing.html#typing.Dict "Dict"
[float]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "float"
[int]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "int"
[List]: https://docs.python.org/3/library/typing.html#typing.List "List"
[NoneType]: https://docs.python.org/3/library/constants.html#None "None"
[Pattern]: https://docs.python.org/3/library/re.html "Pattern"
[URL]: https://en.wikipedia.org/wiki/URL "URL"
[pathlib.Path]: https://realpython.com/python-pathlib/ "pathlib.Path"
[str]: https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str "str"
[Union]: https://docs.python.org/3/library/typing.html#typing.Union "Union"
[datetime]: https://docs.python.org/3/library/datetime.html#datetime.datetime "datetime"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/python/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/python/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-python/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
