---
id: class-browsercontext
title: "BrowserContext"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

BrowserContexts предоставляют способ работать с несколькими независимыми сессиями браузера.

Если страница открывает другую страницу, например вызовом `window.open`, попап будет принадлежать контексту браузера родительской страницы.

Playwright позволяет создавать изолированные непостоянные контексты браузера с помощью метода [browser.new_context()](/api/class-browser.mdx#browser-new-context). Непостоянные контексты браузера не записывают никаких данных о просмотре на диск.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# create a new incognito browser context
context = browser.new_context()
# create a new page inside context.
page = context.new_page()
page.goto("https://example.com")
# dispose context once it is no longer needed.
context.close()
```

</TabItem>
<TabItem value="async">

```py
# create a new incognito browser context
context = await browser.new_context()
# create a new page inside context.
page = await context.new_page()
await page.goto("https://example.com")
# dispose context once it is no longer needed.
await context.close()
```

</TabItem>
</Tabs>

---

## Methods

### add_cookies {#browser-context-add-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.add_cookies</x-search>

Добавляет cookies в этот контекст браузера. Все страницы в этом контексте будут иметь эти cookies. Cookies можно получить через [browser_context.cookies()](/api/class-browsercontext.mdx#browser-context-cookies).

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
browser_context.add_cookies([cookie_object1, cookie_object2])
```

</TabItem>
<TabItem value="async">

```py
await browser_context.add_cookies([cookie_object1, cookie_object2])
```

</TabItem>
</Tabs>

**Аргументы**
- `cookies` [List]\[[Dict]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-option-cookies"/><a href="#browser-context-add-cookies-option-cookies" class="list-anchor">#</a>
  - `name` [str]
    
    
  - `value` [str]
    
    
  - `url` [str] *(опционально)*
    
    Требуется либо `url`, либо одновременно `domain` и `path`. Необязательно.
  - `domain` [str] *(опционально)*
    
    Чтобы cookie применялась ко всем поддоменам, добавьте к домену ведущую точку, например: ".example.com". Требуется либо `url`, либо одновременно `domain` и `path`. Необязательно.
  - `path` [str] *(опционально)*
    
    Требуется либо `url`, либо одновременно `domain` и `path`. Необязательно.
  - `expires` [float] *(опционально)*
    
    Unix time в секундах. Необязательно.
  - `httpOnly` [bool] *(опционально)*
    
    Необязательно.
  - `secure` [bool] *(опционально)*
    
    Необязательно.
  - `sameSite` "Strict" | "Lax" | "None" *(опционально)*
    
    Необязательно.
  - `partitionKey` [str] *(опционально)*
    
    Для разделённых сторонних cookies (также известных как [CHIPS](https://developer.mozilla.org/en-US/docs/Web/Privacy/Guides/Privacy_sandbox/Partitioned_cookies)) — ключ разделения (partition key). Необязательно.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-return"/><a href="#browser-context-add-cookies-return" class="list-anchor">#</a>

---

### add_init_script {#browser-context-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.add_init_script</x-search>

Добавляет скрипт, который будет выполнен в одном из следующих сценариев:
* Каждый раз, когда страница создаётся в контексте браузера или выполняет навигацию.
* Каждый раз, когда дочерний фрейм присоединяется или выполняет навигацию на любой странице в контексте браузера. В этом случае скрипт выполняется в контексте только что присоединённого фрейма.

Скрипт выполняется после создания документа, но до запуска любых его скриптов. Это полезно для изменения среды JavaScript, например, чтобы инициализировать `Math.random`.

**Использование**

Пример переопределения `Math.random` до загрузки страницы:

```js
// preload.js
Math.random = () => 42;
```

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# in your playwright script, assuming the preload.js file is in same directory.
browser_context.add_init_script(path="preload.js")
```

</TabItem>
<TabItem value="async">

```py
# in your playwright script, assuming the preload.js file is in same directory.
await browser_context.add_init_script(path="preload.js")
```

</TabItem>
</Tabs>

:::note

Порядок выполнения нескольких скриптов, установленных через [browser_context.add_init_script()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [page.add_init_script()](/api/class-page.mdx#page-add-init-script), не определён.
:::

**Аргументы**
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-option-path"/><a href="#browser-context-add-init-script-option-path" class="list-anchor">#</a>
  
  Путь к JavaScript-файлу. Если `path` — относительный путь, то он вычисляется относительно текущего рабочего каталога. Необязательно.
- `script` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-option-script"/><a href="#browser-context-add-init-script-option-script" class="list-anchor">#</a>
  
  Скрипт, который будет выполнен на всех страницах в контексте браузера. Необязательно.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-return"/><a href="#browser-context-add-init-script-return" class="list-anchor">#</a>

---

### clear_cookies {#browser-context-clear-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.clear_cookies</x-search>

Удаляет cookies из контекста. Принимает необязательный фильтр.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
context.clear_cookies()
context.clear_cookies(name="session-id")
context.clear_cookies(domain="my-origin.com")
context.clear_cookies(path="/api/v1")
context.clear_cookies(name="session-id", domain="my-origin.com")
```

</TabItem>
<TabItem value="async">

```py
await context.clear_cookies()
await context.clear_cookies(name="session-id")
await context.clear_cookies(domain="my-origin.com")
await context.clear_cookies(path="/api/v1")
await context.clear_cookies(name="session-id", domain="my-origin.com")
```

</TabItem>
</Tabs>

**Аргументы**
- `domain` [str] | [Pattern] *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-domain"/><a href="#browser-context-clear-cookies-option-domain" class="list-anchor">#</a>
  
  Only removes cookies with the given domain.
- `name` [str] | [Pattern] *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-name"/><a href="#browser-context-clear-cookies-option-name" class="list-anchor">#</a>
  
  Only removes cookies with the given name.
- `path` [str] | [Pattern] *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-path"/><a href="#browser-context-clear-cookies-option-path" class="list-anchor">#</a>
  
  Only removes cookies with the given path.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-return"/><a href="#browser-context-clear-cookies-return" class="list-anchor">#</a>

---

### clear_permissions {#browser-context-clear-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.clear_permissions</x-search>

Clears all permission overrides for the browser context.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
context = browser.new_context()
context.grant_permissions(["clipboard-read"])
# do stuff ..
context.clear_permissions()
```

</TabItem>
<TabItem value="async">

```py
context = await browser.new_context()
await context.grant_permissions(["clipboard-read"])
# do stuff ..
context.clear_permissions()
```

</TabItem>
</Tabs>

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-permissions-return"/><a href="#browser-context-clear-permissions-return" class="list-anchor">#</a>

---

### close {#browser-context-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.close</x-search>

Closes the browser context. All the pages that belong to the browser context will be closed.

:::note

The default browser context cannot be closed.
:::

**Использование**

```python
browser_context.close()
browser_context.close(**kwargs)
```

**Аргументы**
- `reason` [str] *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-option-reason"/><a href="#browser-context-close-option-reason" class="list-anchor">#</a>
  
  Причина, которая будет передана операциям, прерванным закрытием контекста.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-return"/><a href="#browser-context-close-return" class="list-anchor">#</a>

---

### cookies {#browser-context-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.cookies</x-search>

Если URL не указаны, этот метод возвращает все cookies. Если URL указаны, возвращаются только cookies, влияющие на эти URL.

**Использование**

```python
browser_context.cookies()
browser_context.cookies(**kwargs)
```

**Аргументы**
- `urls` [str] | [List]\[[str]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-option-urls"/><a href="#browser-context-cookies-option-urls" class="list-anchor">#</a>
  
  Необязательный список URL.

**Возвращает**
- [List]\[[Dict]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-return"/><a href="#browser-context-cookies-return" class="list-anchor">#</a>
  - `name` [str]
    
    
  - `value` [str]
    
    
  - `domain` [str]
    
    
  - `path` [str]
    
    
  - `expires` [float]
    
    Unix time в секундах.
  - `httpOnly` [bool]
    
    
  - `secure` [bool]
    
    
  - `sameSite` "Strict" | "Lax" | "None"
    
    
  - `partitionKey` [str] *(опционально)*
    
    
---

### expect_console_message {#browser-context-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.expect_console_message</x-search>

Выполняет действие и ожидает, пока в страницах контекста будет зарегистрирован [ConsoleMessage]. Если передан predicate, он передаёт значение [ConsoleMessage] в функцию `predicate` и ждёт, пока `predicate(message)` вернёт истинное значение. Выбросит ошибку, если страница будет закрыта до срабатывания события [browser_context.on("console")](/api/class-browsercontext.mdx#browser-context-event-console).

**Использование**

```python
browser_context.expect_console_message()
browser_context.expect_console_message(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[ConsoleMessage]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-predicate"/><a href="#browser-context-wait-for-console-message-option-predicate" class="list-anchor">#</a>
  
  Получает объект [ConsoleMessage] и возвращает truthy-значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-timeout"/><a href="#browser-context-wait-for-console-message-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. Значение по умолчанию — `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[ConsoleMessage]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-return"/><a href="#browser-context-wait-for-console-message-return" class="list-anchor">#</a>

---

### expect_event {#browser-context-wait-for-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.expect_event</x-search>

Ожидает срабатывания события и передаёт его значение в функцию predicate. Возвращается, когда predicate возвращает истинное значение. Выбросит ошибку, если контекст будет закрыт до срабатывания события. Возвращает значение данных события.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with context.expect_event("page") as event_info:
    page.get_by_role("button").click()
page = event_info.value
```

</TabItem>
<TabItem value="async">

```py
async with context.expect_event("page") as event_info:
    await page.get_by_role("button").click()
page = await event_info.value
```

</TabItem>
</Tabs>

**Аргументы**
- `event` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-option-event"/><a href="#browser-context-wait-for-event-option-event" class="list-anchor">#</a>
  
  Имя события, такое же, какое передаётся в `browserContext.on(event)`.
- `predicate` [Callable] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-option-predicate"/><a href="#browser-context-wait-for-event-option-predicate" class="list-anchor">#</a>
  
  Получает данные события и разрешается в истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-option-timeout"/><a href="#browser-context-wait-for-event-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-return"/><a href="#browser-context-wait-for-event-return" class="list-anchor">#</a>

---

### expect_page {#browser-context-wait-for-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>browserContext.expect_page</x-search>

Выполняет действие и ожидает создания новой [Page] в контексте. Если предоставлен предикат, он передает значение [Page] в функцию `predicate` и ожидает, пока `predicate(event)` не вернет истинное значение. Выдаст ошибку, если контекст закроется до создания новой [Page].

**Использование**

```python
browser_context.expect_page()
browser_context.expect_page(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Page]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-predicate"/><a href="#browser-context-wait-for-page-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Page] и разрешает в истинное значение, когда ожидание должно разрешиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-timeout"/><a href="#browser-context-wait-for-page-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Page]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-return"/><a href="#browser-context-wait-for-page-return" class="list-anchor">#</a>

---

### expose_binding {#browser-context-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.expose_binding</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-binding-option-name) в объект `window` каждого фрейма на каждой странице в контексте. При вызове функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback). Если [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) содержит информацию о вызывающем: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

Смотрите [page.expose_binding()](/api/class-page.mdx#page-expose-binding) для версии только для страницы.

**Использование**

Пример предоставления URL страницы всем фреймам на всех страницах в контексте:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch(headless=False)
    context = browser.new_context()
    context.expose_binding("pageURL", lambda source: source["page"].url)
    page = context.new_page()
    page.set_content("""
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
    """)
    page.get_by_role("button").click()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    context = await browser.new_context()
    await context.expose_binding("pageURL", lambda source: source["page"].url)
    page = await context.new_page()
    await page.set_content("""
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
    """)
    await page.get_by_role("button").click()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-name"/><a href="#browser-context-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Callable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-callback"/><a href="#browser-context-expose-binding-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.
- `handle` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-handle"/><a href="#browser-context-expose-binding-option-handle" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Эта опция будет удалена в будущем.
  :::
  
  Передавать ли аргумент как handle, вместо передачи по значению. При передаче handle поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-return"/><a href="#browser-context-expose-binding-return" class="list-anchor">#</a>

---

### expose_function {#browser-context-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.expose_function</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-function-option-name) в объект `window` каждого фрейма на каждой странице в контексте. При вызове функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback).

Если [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) возвращает [Promise], он будет ожидаться.

Смотрите [page.expose_function()](/api/class-page.mdx#page-expose-function) для версии только для страницы.

**Использование**

Пример добавления функции `sha256` на все страницы в контексте:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
import hashlib
from playwright.sync_api import sync_playwright

def sha256(text: str) -> str:
    m = hashlib.sha256()
    m.update(bytes(text, "utf8"))
    return m.hexdigest()


def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch(headless=False)
    context = browser.new_context()
    context.expose_function("sha256", sha256)
    page = context.new_page()
    page.set_content("""
        <script>
          async function onClick() {
            document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
          }
        </script>
        <button onclick="onClick()">Click me</button>
        <div></div>
    """)
    page.get_by_role("button").click()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
import hashlib
from playwright.async_api import async_playwright, Playwright

def sha256(text: str) -> str:
    m = hashlib.sha256()
    m.update(bytes(text, "utf8"))
    return m.hexdigest()


async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    context = await browser.new_context()
    await context.expose_function("sha256", sha256)
    page = await context.new_page()
    await page.set_content("""
        <script>
          async function onClick() {
            document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
          }
        </script>
        <button onclick="onClick()">Click me</button>
        <div></div>
    """)
    await page.get_by_role("button").click()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-name"/><a href="#browser-context-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Callable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-callback"/><a href="#browser-context-expose-function-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-return"/><a href="#browser-context-expose-function-return" class="list-anchor">#</a>

---

### grant_permissions {#browser-context-grant-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.grant_permissions</x-search>

Предоставляет указанные разрешения для контекста браузера. Предоставляет соответствующие разрешения только для указанного источника, если он указан.

**Использование**

```python
browser_context.grant_permissions(permissions)
browser_context.grant_permissions(permissions, **kwargs)
```

**Аргументы**
- `permissions` [List]\[[str]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-permissions"/><a href="#browser-context-grant-permissions-option-permissions" class="list-anchor">#</a>
  
  Список разрешений для предоставления.
  
  :::danger
  
  Поддерживаемые разрешения различаются между браузерами и даже между разными версиями одного и того же браузера. Любое разрешение может перестать работать после обновления.
  :::
  
  Вот некоторые разрешения, которые могут поддерживаться некоторыми браузерами:
  * `'accelerometer'`
  * `'ambient-light-sensor'`
  * `'background-sync'`
  * `'camera'`
  * `'clipboard-read'`
  * `'clipboard-write'`
  * `'geolocation'`
  * `'gyroscope'`
  * `'local-fonts'`
  * `'local-network-access'`
  * `'magnetometer'`
  * `'microphone'`
  * `'midi-sysex'` (системно-эксклюзивный midi)
  * `'midi'`
  * `'notifications'`
  * `'payment-handler'`
  * `'storage-access'`
- `origin` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-origin"/><a href="#browser-context-grant-permissions-option-origin" class="list-anchor">#</a>
  
  [Источник], для которого предоставляются разрешения, например, "https://example.com".

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-return"/><a href="#browser-context-grant-permissions-return" class="list-anchor">#</a>

---

### new_cdp_session {#browser-context-new-cdp-session}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.new_cdp_session</x-search>

:::note

CDP сессии поддерживаются только в браузерах на основе Chromium.
:::

Возвращает вновь созданную сессию.

**Использование**

```python
browser_context.new_cdp_session(page)
```

**Аргументы**
- `page` [Page] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-option-page"/><a href="#browser-context-new-cdp-session-option-page" class="list-anchor">#</a>
  
  Цель для создания новой сессии. Для обратной совместимости этот параметр называется `page`, но он может быть типа `Page` или `Frame`.

**Возвращает**
- [CDPSession]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-return"/><a href="#browser-context-new-cdp-session-return" class="list-anchor">#</a>

---

### new_page {#browser-context-new-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.new_page</x-search>

Создает новую страницу в контексте браузера.

**Использование**

```python
browser_context.new_page()
```

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-page-return"/><a href="#browser-context-new-page-return" class="list-anchor">#</a>

---

### route {#browser-context-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.route</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются любой страницей в контексте браузера. Как только маршрут включен, каждый запрос, соответствующий шаблону URL, будет приостановлен, если он не будет продолжен, выполнен или прерван.

:::note

[browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) не будет перехватывать запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [service_workers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

**Использование**

Пример наивного обработчика, который прерывает все запросы изображений:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
context = browser.new_context()
page = context.new_page()
context.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
page.goto("https://example.com")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
context = await browser.new_context()
page = await context.new_page()
await context.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
await page.goto("https://example.com")
await browser.close()
```

</TabItem>
</Tabs>

или тот же фрагмент кода, используя шаблон регулярного выражения:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
context = browser.new_context()
page = context.new_page()
context.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
page = await context.new_page()
page = context.new_page()
page.goto("https://example.com")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
context = await browser.new_context()
page = await context.new_page()
await context.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
page = await context.new_page()
await page.goto("https://example.com")
await browser.close()
```

</TabItem>
</Tabs>

Возможно исследовать запрос, чтобы решить, какое действие выполнить с маршрутом. Например, имитировать все запросы, содержащие некоторые данные post, и оставлять все остальные запросы как есть:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def handle_route(route: Route):
  if ("my-string" in route.request.post_data):
    route.fulfill(body="mocked-data")
  else:
    route.continue_()
context.route("/api/**", handle_route)
```

</TabItem>
<TabItem value="async">

```py
async def handle_route(route: Route):
  if ("my-string" in route.request.post_data):
    await route.fulfill(body="mocked-data")
  else:
    await route.continue_()
await context.route("/api/**", handle_route)
```

</TabItem>
</Tabs>

Маршруты страницы (установленные с помощью [page.route()](/api/class-page.mdx#page-route)) имеют приоритет над маршрутами контекста браузера, когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [browser_context.unroute()](/api/class-browsercontext.mdx#browser-context-unroute).

:::note

Включение маршрутизации отключает http-кэш.
:::

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-url"/><a href="#browser-context-route-option-url" class="list-anchor">#</a>
  
  Глоб-шаблон, регулярное выражение или предикат, который получает [URL] для сопоставления при маршрутизации. Если в опциях контекста задан [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) и переданный URL — строка, не начинающаяся с `*`, он будет разрешён с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `handler` [Callable]\[[Route], [Request]\]:[Promise]\[[Any]\] | [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-handler"/><a href="#browser-context-route-option-handler" class="list-anchor">#</a>
  
  функция-обработчик для маршрутизации запроса.
- `times` [int] *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-times"/><a href="#browser-context-route-option-times" class="list-anchor">#</a>
  
  Как часто маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-return"/><a href="#browser-context-route-return" class="list-anchor">#</a>

---

### route_from_har {#browser-context-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>browserContext.route_from_har</x-search>

Если указано, сетевые запросы, сделанные в контексте, будут обслуживаться из HAR файла. Подробнее читайте в разделе [Воспроизведение из HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из HAR файла. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [service_workers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```python
browser_context.route_from_har(har)
browser_context.route_from_har(har, **kwargs)
```

**Аргументы**
- `har` [Union]\[[str], [pathlib.Path]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-har"/><a href="#browser-context-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec) файлу с предварительно записанными сетевыми данными. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `not_found` "abort" | "fallback" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-not-found"/><a href="#browser-context-route-from-har-option-not-found" class="list-anchor">#</a>
  * Если установлено в 'abort', любой запрос, не найденный в HAR файле, будет прерван.
  * Если установлено в 'fallback', переходит к следующему обработчику маршрута в цепочке обработчиков.
  
  По умолчанию прерывается.
- `update` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update"/><a href="#browser-context-route-from-har-option-update" class="list-anchor">#</a>
  
  Если указано, обновляет данный HAR с фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск, когда вызывается [browser_context.close()](/api/class-browsercontext.mdx#browser-context-close).
- `update_content` "embed" | "attach" *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-content"/><a href="#browser-context-route-from-har-option-update-content" class="list-anchor">#</a>
  
  Опциональная настройка для управления содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP архиве. Если указано `embed`, содержимое сохраняется встраиваемым в HAR файл.
- `update_mode` "full" | "minimal" *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-mode"/><a href="#browser-context-route-from-har-option-update-mode" class="list-anchor">#</a>
  
  Когда установлено в `minimal`, записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницы, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию `minimal`.
- `url` [str] | [Pattern] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-url"/><a href="#browser-context-route-from-har-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR файла. Если не указано, все запросы обслуживаются из HAR файла.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-return"/><a href="#browser-context-route-from-har-return" class="list-anchor">#</a>

---

### route_web_socket {#browser-context-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>browserContext.route_web_socket</x-search>

Этот метод позволяет изменять соединения websocket, которые создаются любой страницей в контексте браузера.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизироваться. Рекомендуется вызывать этот метод перед созданием любых страниц.

**Использование**

Ниже приведен пример простого обработчика, который блокирует некоторые сообщения websocket. Подробнее и примеры смотрите в [WebSocketRoute].

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  if message == "to-be-blocked":
    return
  ws.send(message)

def handler(ws: WebSocketRoute):
  ws.route_send(lambda message: message_handler(ws, message))
  ws.connect()

context.route_web_socket("/ws", handler)
```

</TabItem>
<TabItem value="async">

```py
def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  if message == "to-be-blocked":
    return
  ws.send(message)

async def handler(ws: WebSocketRoute):
  ws.route_send(lambda message: message_handler(ws, message))
  await ws.connect()

await context.route_web_socket("/ws", handler)
```

</TabItem>
</Tabs>

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-url"/><a href="#browser-context-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизироваться. Строковый шаблон может быть относительным к [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) опции контекста.
- `handler` [Callable]\[[WebSocketRoute]\]:[Promise]\[[Any]\] | [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-handler"/><a href="#browser-context-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-return"/><a href="#browser-context-route-web-socket-return" class="list-anchor">#</a>

---

### set_default_navigation_timeout {#browser-context-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.set_default_navigation_timeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных с ними ярлыков:
* [page.go_back()](/api/class-page.mdx#page-go-back)
* [page.go_forward()](/api/class-page.mdx#page-go-forward)
* [page.goto()](/api/class-page.mdx#page-goto)
* [page.reload()](/api/class-page.mdx#page-reload)
* [page.set_content()](/api/class-page.mdx#page-set-content)
* [page.expect_navigation()](/api/class-page.mdx#page-wait-for-navigation)

:::note

[page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) и [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout) имеют приоритет над [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```python
browser_context.set_default_navigation_timeout(timeout)
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-navigation-timeout-option-timeout"/><a href="#browser-context-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### set_default_timeout {#browser-context-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.set_default_timeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих опцию [timeout](/api/class-browsercontext.mdx#browser-context-set-default-timeout-option-timeout).

:::note

[page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout), [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout) и [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout) имеют приоритет над [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
:::

**Использование**

```python
browser_context.set_default_timeout(timeout)
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-timeout-option-timeout"/><a href="#browser-context-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### set_extra_http_headers {#browser-context-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.set_extra_http_headers</x-search>

Дополнительные HTTP заголовки будут отправляться с каждым запросом, инициированным любой страницей в контексте. Эти заголовки объединяются с дополнительными HTTP заголовками, установленными для страницы с помощью [page.set_extra_http_headers()](/api/class-page.mdx#page-set-extra-http-headers). Если страница переопределяет определенный заголовок, будет использоваться значение заголовка, специфичное для страницы, вместо значения заголовка контекста браузера.

:::note

[browser_context.set_extra_http_headers()](/api/class-browsercontext.mdx#browser-context-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```python
browser_context.set_extra_http_headers(headers)
```

**Аргументы**
- `headers` [Dict]\[[str], [str]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-option-headers"/><a href="#browser-context-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP заголовки, которые будут отправляться с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-return"/><a href="#browser-context-set-extra-http-headers-return" class="list-anchor">#</a>

---

### set_geolocation {#browser-context-set-geolocation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.set_geolocation</x-search>

Устанавливает геолокацию контекста. Передача `null` или `undefined` эмулирует недоступность позиции.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
browser_context.set_geolocation({"latitude": 59.95, "longitude": 30.31667})
```

</TabItem>
<TabItem value="async">

```py
await browser_context.set_geolocation({"latitude": 59.95, "longitude": 30.31667})
```

</TabItem>
</Tabs>

:::note

Рассмотрите возможность использования [browser_context.grant_permissions()](/api/class-browsercontext.mdx#browser-context-grant-permissions) для предоставления разрешений страницам контекста браузера на чтение его геолокации.
:::

**Аргументы**
- `geolocation` [NoneType] | [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-option-geolocation"/><a href="#browser-context-set-geolocation-option-geolocation" class="list-anchor">#</a>
  - `latitude` [float]
    
    Широта между -90 и 90.
  - `longitude` [float]
    
    Долгота между -180 и 180.
  - `accuracy` [float] *(опционально)*
    
    Неотрицательное значение точности. По умолчанию `0`.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-return"/><a href="#browser-context-set-geolocation-return" class="list-anchor">#</a>

---

### set_offline {#browser-context-set-offline}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.set_offline</x-search>

**Использование**

```python
browser_context.set_offline(offline)
```

**Аргументы**
- `offline` [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-option-offline"/><a href="#browser-context-set-offline-option-offline" class="list-anchor">#</a>
  
  Эмулировать ли отключение сети для контекста браузера.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-return"/><a href="#browser-context-set-offline-return" class="list-anchor">#</a>

---

### storage_state {#browser-context-storage-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.storage_state</x-search>

Возвращает состояние хранилища для этого контекста браузера, содержит текущие куки, снимок локального хранилища и снимок IndexedDB.

**Использование**

```python
browser_context.storage_state()
browser_context.storage_state(**kwargs)
```

**Аргументы**
- `indexed_db` [bool] *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-indexed-db"/><a href="#browser-context-storage-state-option-indexed-db" class="list-anchor">#</a>
  
  Установите `true`, чтобы включить [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) в снимок состояния хранилища. Если ваше приложение использует IndexedDB для хранения токенов аутентификации (например, Firebase Authentication), включите это.
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-path"/><a href="#browser-context-storage-state-option-path" class="list-anchor">#</a>
 
  Путь к файлу для сохранения состояния хранилища. Если [path](/api/class-browsercontext.mdx#browser-context-storage-state-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, состояние хранилища все равно возвращается, но не будет сохранено на диск.

**Возвращает**
- [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-return"/><a href="#browser-context-storage-state-return" class="list-anchor">#</a>
  - `cookies` [List]\[[Dict]\]
    - `name` [str]
      
      
    - `value` [str]
      
      
    - `domain` [str]
      
      
    - `path` [str]
      
      
    - `expires` [float]
      
      Время Unix в секундах.
    - `httpOnly` [bool]
      
      
    - `secure` [bool]
      
      
    - `sameSite` "Strict" | "Lax" | "None"
      
      
    
  - `origins` [List]\[[Dict]\]
    - `origin` [str]
      
      
    - `localStorage` [List]\[[Dict]\]
      - `name` [str]
        
        
      - `value` [str]
        
        
      
    
---

### unroute {#browser-context-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.unroute</x-search>

Удаляет маршрут, созданный с помощью [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route). Когда [handler](/api/class-browsercontext.mdx#browser-context-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-browsercontext.mdx#browser-context-unroute-option-url).

**Использование**

```python
browser_context.unroute(url)
browser_context.unroute(url, **kwargs)
```

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-url"/><a href="#browser-context-unroute-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, шаблон регулярного выражения или предикат, получающий [URL], использованный для регистрации маршрутизации с [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route).
- `handler` [Callable]\[[Route], [Request]\]:[Promise]\[[Any]\] | [Any] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-handler"/><a href="#browser-context-unroute-option-handler" class="list-anchor">#</a>
  
  Опциональная функция-обработчик, использованная для регистрации маршрутизации с [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-return"/><a href="#browser-context-unroute-return" class="list-anchor">#</a>

---

### unroute_all {#browser-context-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.41</font><x-search>browserContext.unroute_all</x-search>

Удаляет все маршруты, созданные с помощью [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) и [browser_context.route_from_har()](/api/class-browsercontext.mdx#browser-context-route-from-har).

**Использование**

```python
browser_context.unroute_all()
browser_context.unroute_all(**kwargs)
```

**Аргументы**
- `behavior` "wait" | "ignoreErrors" | "default" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-all-option-behavior"/><a href="#browser-context-unroute-all-option-behavior" class="list-anchor">#</a>
  
  Указывает, следует ли ждать уже выполняющихся обработчиков и что делать, если они вызывают ошибки:
  * `'default'` - не ждать завершения текущих вызовов обработчиков (если есть), если удаленный обработчик вызывает ошибку, это может привести к необработанной ошибке
  * `'wait'` - ждать завершения текущих вызовов обработчиков (если есть)
  * `'ignoreErrors'` - не ждать завершения текущих вызовов обработчиков (если есть), все ошибки, вызванные обработчиками после удаления маршрутизации, тихо перехватываются

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-all-return"/><a href="#browser-context-unroute-all-return" class="list-anchor">#</a>

---

### wait_for_event {#browser-context-wait-for-event-2}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.wait_for_event</x-search>

:::note

В большинстве случаев следует использовать [browser_context.expect_event()](/api/class-browsercontext.mdx#browser-context-wait-for-event).
:::

Ожидает, пока указанный `event` не будет вызван. Если предикат предоставлен, он передает значение события в функцию `predicate` и ждет, пока `predicate(event)` не вернет истинное значение. Выдаст ошибку, если контекст браузера будет закрыт до того, как `event` будет вызван.

**Использование**

```python
browser_context.wait_for_event(event)
browser_context.wait_for_event(event, **kwargs)
```

**Аргументы**
- `event` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-2-option-event"/><a href="#browser-context-wait-for-event-2-option-event" class="list-anchor">#</a>
  
  Имя события, то же самое, которое обычно передается в `*.on(event)`.
- `predicate` [Callable] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-2-option-predicate"/><a href="#browser-context-wait-for-event-2-option-predicate" class="list-anchor">#</a>
  
  Получает данные события и разрешает в истинное значение, когда ожидание должно разрешиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-2-option-timeout"/><a href="#browser-context-wait-for-event-2-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-2-return"/><a href="#browser-context-wait-for-event-2-return" class="list-anchor">#</a>

---

## Properties

### browser {#browser-context-browser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.browser</x-search>

Возвращает экземпляр браузера, которому принадлежит этот контекст. Возвращает `null`, если контекст создан вне обычного браузера, например в Android или Electron.

**Использование**

```python
browser_context.browser
```

**Возвращает**
- [NoneType] | [Browser]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-browser-return"/><a href="#browser-context-browser-return" class="list-anchor">#</a>

---

### clock {#browser-context-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.45</font><x-search>browserContext.clock</x-search>

Playwright имеет возможность имитировать часы и ход времени.

**Использование**

```python
browser_context.clock
```

**Type**
- [Clock]

---

### pages {#browser-context-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.pages</x-search>

Возвращает все открытые страницы в контексте.

**Использование**

```python
browser_context.pages
```

**Возвращает**
- [List]\[[Page]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-pages-return"/><a href="#browser-context-pages-return" class="list-anchor">#</a>

---

### request {#browser-context-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.16</font><x-search>browserContext.request</x-search>

Помощник для тестирования API, связанный с этим контекстом. Запросы, сделанные с помощью этого API, будут использовать куки контекста.

**Использование**

```python
browser_context.request
```

**Type**
- [APIRequestContext]

---

### service_workers {#browser-context-service-workers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.service_workers</x-search>

:::note

Service workers поддерживаются только в браузерах на базе Chromium.
:::

Все существующие service workers в контексте.

**Использование**

```python
browser_context.service_workers
```

**Возвращает**
- [List]\[[Worker]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-service-workers-return"/><a href="#browser-context-service-workers-return" class="list-anchor">#</a>

---

### tracing {#browser-context-tracing}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.tracing</x-search>

**Использование**

```python
browser_context.tracing
```

**Type**
- [Tracing]

---

## Events

### on("close") {#browser-context-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.on("close")</x-search>

Вызывается, когда контекст браузера закрывается. Это может произойти по одной из следующих причин:
* Контекст браузера закрыт.
* Приложение браузера закрыто или аварийно завершило работу.
* Метод [browser.close()](/api/class-browser.mdx#browser-close) был вызван.

**Использование**

```python
browser_context.on("close", handler)
```

**Данные события**
- [BrowserContext]

---

### on("console") {#browser-context-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.on("console")</x-search>

Вызывается, когда JavaScript на странице вызывает один из методов консоли API, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, и страница доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def print_args(msg):
    for arg in msg.args:
        print(arg.json_value())

context.on("console", print_args)
page.evaluate("console.log('hello', 5, { foo: 'bar' })")
```

</TabItem>
<TabItem value="async">

```py
async def print_args(msg):
    values = []
    for arg in msg.args:
        values.append(await arg.json_value())
    print(values)

context.on("console", print_args)
await page.evaluate("console.log('hello', 5, { foo: 'bar' })")
```

</TabItem>
</Tabs>

**Данные события**
- [ConsoleMessage]

---

### on("dialog") {#browser-context-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.on("dialog")</x-search>

Вызывается, когда появляется JavaScript-диалог, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Слушатель **должен** либо [dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница [заморозится](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалог, и действия, такие как клик, никогда не завершатся.

**Использование**

```python
context.on("dialog", lambda dialog: dialog.accept())
```

:::note
Когда нет слушателей [page.on("dialog")](/api/class-page.mdx#page-event-dialog) или [browser_context.on("dialog")](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### on("page") {#browser-context-event-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.on("page")</x-search>

Событие вызывается, когда в BrowserContext создается новая страница. Страница может все еще загружаться. Событие также будет срабатывать для всплывающих страниц. См. также [page.on("popup")](/api/class-page.mdx#page-event-popup) для получения событий о всплывающих окнах, относящихся к конкретной странице.

Самый ранний момент, когда страница доступна, это когда она перешла на начальный URL. Например, при открытии всплывающего окна с помощью `window.open('http://example.com')`, это событие сработает, когда сетевой запрос к "http://example.com" будет выполнен и его ответ начнет загружаться во всплывающем окне. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) и [browser_context.on("request")](/api/class-browsercontext.mdx#browser-context-event-request) соответственно, вместо аналогичных методов на [Page].

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with context.expect_page() as page_info:
    page.get_by_text("open new page").click(),
page = page_info.value
print(page.evaluate("location.href"))
```

</TabItem>
<TabItem value="async">

```py
async with context.expect_page() as page_info:
    await page.get_by_text("open new page").click(),
page = await page_info.value
print(await page.evaluate("location.href"))
```

</TabItem>
</Tabs>

:::note

Используйте [page.wait_for_load_state()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев это не потребуется).
:::

**Использование**

```python
browser_context.on("page", handler)
```

**Данные события**
- [Page]

---

### on("request") {#browser-context-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.on("request")</x-search>

Вызывается, когда запрос отправляется с любой страницы, созданной через этот контекст. Объект [request] доступен только для чтения. Чтобы слушать только запросы с определенной страницы, используйте [page.on("request")](/api/class-page.mdx#page-event-request).

Для перехвата и изменения запросов, см. [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) или [page.route()](/api/class-page.mdx#page-route).

**Использование**

```python
browser_context.on("request", handler)
```

**Данные события**
- [Request]

---

### on("requestfailed") {#browser-context-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.on("requestfailed")</x-search>

Вызывается, когда запрос не удается выполнить, например, из-за тайм-аута. Чтобы слушать только неудачные запросы с определенной страницы, используйте [page.on("requestfailed")](/api/class-page.mdx#page-event-request-failed).

:::note

HTTP ошибки, такие как 404 или 503, все еще считаются успешными ответами с точки зрения HTTP, поэтому запрос завершится событием [browser_context.on("requestfinished")](/api/class-browsercontext.mdx#browser-context-event-request-finished), а не [browser_context.on("requestfailed")](/api/class-browsercontext.mdx#browser-context-event-request-failed).
:::

**Использование**

```python
browser_context.on("requestfailed", handler)
```

**Данные события**
- [Request]

---

### on("requestfinished") {#browser-context-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.on("requestfinished")</x-search>

Вызывается, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`. Чтобы слушать успешные запросы с определенной страницы, используйте [page.on("requestfinished")](/api/class-page.mdx#page-event-request-finished).

**Использование**

```python
browser_context.on("requestfinished", handler)
```

**Данные события**
- [Request]

---

### on("response") {#browser-context-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.on("response")</x-search>

Вызывается, когда [response] статус и заголовки получены для запроса. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`. Чтобы слушать события ответа с определенной страницы, используйте [page.on("response")](/api/class-page.mdx#page-event-response).

**Использование**

```python
browser_context.on("response", handler)
```

**Данные события**
- [Response]

---

### on("serviceworker") {#browser-context-event-service-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.on("serviceworker")</x-search>

:::note

Service workers поддерживаются только в браузерах на базе Chromium.
:::

Вызывается, когда в контексте создается новый service worker.

**Использование**

```python
browser_context.on("serviceworker", handler)
```

**Данные события**
- [Worker]

---

### on("weberror") {#browser-context-event-web-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.38</font><x-search>browserContext.on("weberror")</x-search>

Вызывается, когда исключение не обработано ни на одной из страниц в этом контексте. Чтобы отслеживать ошибки на конкретной странице, используйте [page.on("pageerror")](/api/class-page.mdx#page-event-page-error).

**Использование**

```python
browser_context.on("weberror", handler)
```

**Данные события**
- [WebError]

---

## Deprecated

### on("backgroundpage") {#browser-context-event-background-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.on("backgroundpage")</x-search>

:::warning Deprecated

Фоновые страницы были удалены из Chromium вместе с расширениями Manifest V2.

:::


Это событие не генерируется.

**Использование**

```python
browser_context.on("backgroundpage", handler)
```

**Данные события**
- [Page]

---

### background_pages {#browser-context-background-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.background_pages</x-search>

:::warning Deprecated

Фоновые страницы были удалены из Chromium вместе с расширениями Manifest V2.

:::


Возвращает пустой список.

**Использование**

```python
browser_context.background_pages
```

**Возвращает**
- [List]\[[Page]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-background-pages-return"/><a href="#browser-context-background-pages-return" class="list-anchor">#</a>


[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[Error]: /api/class-error.mdx "Error"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Any]: https://docs.python.org/3/library/typing.html#typing.Any "Any"
[bool]: https://docs.python.org/3/library/stdtypes.html "bool"
[bytes]: https://docs.python.org/3/library/stdtypes.html#bytes "bytes"
[Callable]: https://docs.python.org/3/library/typing.html#typing.Callable "Callable"
[EventContextManager]: https://docs.python.org/3/reference/datamodel.html#context-managers "Event context manager"
[EventEmitter]: https://pyee.readthedocs.io/en/latest/#pyee.BaseEventEmitter "EventEmitter"
[Exception]: https://docs.python.org/3/library/exceptions.html#Exception "Exception"
[Dict]: https://docs.python.org/3/library/typing.html#typing.Dict "Dict"
[float]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "float"
[int]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "int"
[List]: https://docs.python.org/3/library/typing.html#typing.List "List"
[NoneType]: https://docs.python.org/3/library/constants.html#None "None"
[Pattern]: https://docs.python.org/3/library/re.html "Pattern"
[URL]: https://en.wikipedia.org/wiki/URL "URL"
[pathlib.Path]: https://realpython.com/python-pathlib/ "pathlib.Path"
[str]: https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str "str"
[Union]: https://docs.python.org/3/library/typing.html#typing.Union "Union"
[datetime]: https://docs.python.org/3/library/datetime.html#datetime.datetime "datetime"

[все доступные теги образов]: https://mcr.microsoft.com/en-us/product/playwright/python/about "все доступные теги образов"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/python/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-python/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
