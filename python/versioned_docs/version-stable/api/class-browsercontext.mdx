---
id: class-browsercontext
title: "BrowserContext"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

BrowserContexts provide a way to operate multiple independent browser sessions.

If a page opens another page, e.g. with a `window.open` call, the popup will belong to the parent page's browser context.

Playwright allows creating isolated non-persistent browser contexts with [browser.new_context()](/api/class-browser.mdx#browser-new-context) method. Non-persistent browser contexts don't write any browsing data to disk.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# create a new incognito browser context
context = browser.new_context()
# create a new page inside context.
page = context.new_page()
page.goto("https://example.com")
# dispose context once it is no longer needed.
context.close()
```

</TabItem>
<TabItem value="async">

```py
# create a new incognito browser context
context = await browser.new_context()
# create a new page inside context.
page = await context.new_page()
await page.goto("https://example.com")
# dispose context once it is no longer needed.
await context.close()
```

</TabItem>
</Tabs>

---

## Methods

### add_cookies {#browser-context-add-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.add_cookies</x-search>

Adds cookies into this browser context. All pages within this context will have these cookies installed. Cookies can be obtained via [browser_context.cookies()](/api/class-browsercontext.mdx#browser-context-cookies).

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
browser_context.add_cookies([cookie_object1, cookie_object2])
```

</TabItem>
<TabItem value="async">

```py
await browser_context.add_cookies([cookie_object1, cookie_object2])
```

</TabItem>
</Tabs>

**Аргументы**
- `cookies` [List]\[[Dict]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-option-cookies"/><a href="#browser-context-add-cookies-option-cookies" class="list-anchor">#</a>
  - `name` [str]
    
    
  - `value` [str]
    
    
  - `url` [str] *(optional)*
    
    Either url or domain / path are required. Optional.
  - `domain` [str] *(optional)*
    
    For the cookie to apply to all subdomains as well, prefix domain with a dot, like this: ".example.com". Either url or domain / path are required. Optional.
  - `path` [str] *(optional)*
    
    Either url or domain / path are required Optional.
  - `expires` [float] *(optional)*
    
    Unix time in seconds. Optional.
  - `httpOnly` [bool] *(optional)*
    
    Optional.
  - `secure` [bool] *(optional)*
    
    Optional.
  - `sameSite` "Strict" | "Lax" | "None" *(optional)*
    
    Optional.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-return"/><a href="#browser-context-add-cookies-return" class="list-anchor">#</a>

---

### add_init_script {#browser-context-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.add_init_script</x-search>

Adds a script which would be evaluated in one of the following scenarios:
* Whenever a page is created in the browser context or is navigated.
* Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is evaluated in the context of the newly attached frame.

The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend the JavaScript environment, e.g. to seed `Math.random`.

**Использование**

An example of overriding `Math.random` before the page loads:

```js
// preload.js
Math.random = () => 42;
```

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# in your playwright script, assuming the preload.js file is in same directory.
browser_context.add_init_script(path="preload.js")
```

</TabItem>
<TabItem value="async">

```py
# in your playwright script, assuming the preload.js file is in same directory.
await browser_context.add_init_script(path="preload.js")
```

</TabItem>
</Tabs>

:::note

The order of evaluation of multiple scripts installed via [browser_context.add_init_script()](/api/class-browsercontext.mdx#browser-context-add-init-script) and [page.add_init_script()](/api/class-page.mdx#page-add-init-script) is not defined.
:::

**Аргументы**
- `path` [Union]\[[str], [pathlib.Path]\] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-option-path"/><a href="#browser-context-add-init-script-option-path" class="list-anchor">#</a>
  
  Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to the current working directory. Optional.
- `script` [str] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-option-script"/><a href="#browser-context-add-init-script-option-script" class="list-anchor">#</a>
  
  Script to be evaluated in all pages in the browser context. Optional.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-return"/><a href="#browser-context-add-init-script-return" class="list-anchor">#</a>

---

### clear_cookies {#browser-context-clear-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.clear_cookies</x-search>

Removes cookies from context. Accepts optional filter.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
context.clear_cookies()
context.clear_cookies(name="session-id")
context.clear_cookies(domain="my-origin.com")
context.clear_cookies(path="/api/v1")
context.clear_cookies(name="session-id", domain="my-origin.com")
```

</TabItem>
<TabItem value="async">

```py
await context.clear_cookies()
await context.clear_cookies(name="session-id")
await context.clear_cookies(domain="my-origin.com")
await context.clear_cookies(path="/api/v1")
await context.clear_cookies(name="session-id", domain="my-origin.com")
```

</TabItem>
</Tabs>

**Аргументы**
- `domain` [str] | [Pattern] *(optional)* <font size="2">Added in: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-domain"/><a href="#browser-context-clear-cookies-option-domain" class="list-anchor">#</a>
  
  Only removes cookies with the given domain.
- `name` [str] | [Pattern] *(optional)* <font size="2">Added in: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-name"/><a href="#browser-context-clear-cookies-option-name" class="list-anchor">#</a>
  
  Only removes cookies with the given name.
- `path` [str] | [Pattern] *(optional)* <font size="2">Added in: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-path"/><a href="#browser-context-clear-cookies-option-path" class="list-anchor">#</a>
  
  Only removes cookies with the given path.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-return"/><a href="#browser-context-clear-cookies-return" class="list-anchor">#</a>

---

### clear_permissions {#browser-context-clear-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.clear_permissions</x-search>

Clears all permission overrides for the browser context.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
context = browser.new_context()
context.grant_permissions(["clipboard-read"])
# do stuff ..
context.clear_permissions()
```

</TabItem>
<TabItem value="async">

```py
context = await browser.new_context()
await context.grant_permissions(["clipboard-read"])
# do stuff ..
context.clear_permissions()
```

</TabItem>
</Tabs>

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-permissions-return"/><a href="#browser-context-clear-permissions-return" class="list-anchor">#</a>

---

### close {#browser-context-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.close</x-search>

Closes the browser context. All the pages that belong to the browser context will be closed.

:::note

The default browser context cannot be closed.
:::

**Использование**

```python
browser_context.close()
browser_context.close(**kwargs)
```

**Аргументы**
- `reason` [str] *(optional)* <font size="2">Added in: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-option-reason"/><a href="#browser-context-close-option-reason" class="list-anchor">#</a>
  
  The reason to be reported to the operations interrupted by the context closure.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-return"/><a href="#browser-context-close-return" class="list-anchor">#</a>

---

### cookies {#browser-context-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.cookies</x-search>

If no URLs are specified, this method returns all cookies. If URLs are specified, only cookies that affect those URLs are returned.

**Использование**

```python
browser_context.cookies()
browser_context.cookies(**kwargs)
```

**Аргументы**
- `urls` [str] | [List]\[[str]\] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-option-urls"/><a href="#browser-context-cookies-option-urls" class="list-anchor">#</a>
  
  Optional list of URLs.

**Возвращает**
- [List]\[[Dict]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-return"/><a href="#browser-context-cookies-return" class="list-anchor">#</a>
  - `name` [str]
    
    
  - `value` [str]
    
    
  - `domain` [str]
    
    
  - `path` [str]
    
    
  - `expires` [float]
    
    Unix time in seconds.
  - `httpOnly` [bool]
    
    
  - `secure` [bool]
    
    
  - `sameSite` "Strict" | "Lax" | "None"
    
    
---

### expect_console_message {#browser-context-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.34</font><x-search>browserContext.expect_console_message</x-search>

Performs action and waits for a [ConsoleMessage] to be logged by in the pages in the context. If predicate is provided, it passes [ConsoleMessage] value into the `predicate` function and waits for `predicate(message)` to return a truthy value. Will throw an error if the page is closed before the [browser_context.on("console")](/api/class-browsercontext.mdx#browser-context-event-console) event is fired.

**Использование**

```python
browser_context.expect_console_message()
browser_context.expect_console_message(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[ConsoleMessage]\]:[bool] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-predicate"/><a href="#browser-context-wait-for-console-message-option-predicate" class="list-anchor">#</a>
  
  Receives the [ConsoleMessage] object and resolves to truthy value when the waiting should resolve.
- `timeout` [float] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-timeout"/><a href="#browser-context-wait-for-console-message-option-timeout" class="list-anchor">#</a>
  
  Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[ConsoleMessage]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-return"/><a href="#browser-context-wait-for-console-message-return" class="list-anchor">#</a>

---

### expect_event {#browser-context-wait-for-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.expect_event</x-search>

Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy value. Will throw an error if the context closes before the event is fired. Returns the event data value.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with context.expect_event("page") as event_info:
    page.get_by_role("button").click()
page = event_info.value
```

</TabItem>
<TabItem value="async">

```py
async with context.expect_event("page") as event_info:
    await page.get_by_role("button").click()
page = await event_info.value
```

</TabItem>
</Tabs>

**Аргументы**
- `event` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-option-event"/><a href="#browser-context-wait-for-event-option-event" class="list-anchor">#</a>
  
  Event name, same one would pass into `browserContext.on(event)`.
- `predicate` [Callable] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-option-predicate"/><a href="#browser-context-wait-for-event-option-predicate" class="list-anchor">#</a>
  
  Receives the event data and resolves to truthy value when the waiting should resolve.
- `timeout` [float] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-option-timeout"/><a href="#browser-context-wait-for-event-option-timeout" class="list-anchor">#</a>
  
  Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can be changed by using the [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-return"/><a href="#browser-context-wait-for-event-return" class="list-anchor">#</a>

---

### expect_page {#browser-context-wait-for-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>browserContext.expect_page</x-search>

Выполняет действие и ожидает создания новой [Page] в контексте. Если предоставлен предикат, он передает значение [Page] в функцию `predicate` и ожидает, пока `predicate(event)` не вернет истинное значение. Выдаст ошибку, если контекст закроется до создания новой [Page].

**Использование**

```python
browser_context.expect_page()
browser_context.expect_page(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Page]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-predicate"/><a href="#browser-context-wait-for-page-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Page] и разрешает в истинное значение, когда ожидание должно разрешиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-timeout"/><a href="#browser-context-wait-for-page-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Page]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-return"/><a href="#browser-context-wait-for-page-return" class="list-anchor">#</a>

---

### expose_binding {#browser-context-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.expose_binding</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-binding-option-name) в объект `window` каждого фрейма на каждой странице в контексте. При вызове функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback). Если [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) содержит информацию о вызывающем: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

Смотрите [page.expose_binding()](/api/class-page.mdx#page-expose-binding) для версии только для страницы.

**Использование**

Пример предоставления URL страницы всем фреймам на всех страницах в контексте:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch(headless=False)
    context = browser.new_context()
    context.expose_binding("pageURL", lambda source: source["page"].url)
    page = context.new_page()
    page.set_content("""
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
    """)
    page.get_by_role("button").click()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    context = await browser.new_context()
    await context.expose_binding("pageURL", lambda source: source["page"].url)
    page = await context.new_page()
    await page.set_content("""
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
    """)
    await page.get_by_role("button").click()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-name"/><a href="#browser-context-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Callable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-callback"/><a href="#browser-context-expose-binding-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.
- `handle` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-handle"/><a href="#browser-context-expose-binding-option-handle" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Эта опция будет удалена в будущем.
  :::
  
  Передавать ли аргумент как handle, вместо передачи по значению. При передаче handle поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-return"/><a href="#browser-context-expose-binding-return" class="list-anchor">#</a>

---

### expose_function {#browser-context-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.expose_function</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-function-option-name) в объект `window` каждого фрейма на каждой странице в контексте. При вызове функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback).

Если [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) возвращает [Promise], он будет ожидаться.

Смотрите [page.expose_function()](/api/class-page.mdx#page-expose-function) для версии только для страницы.

**Использование**

Пример добавления функции `sha256` на все страницы в контексте:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
import hashlib
from playwright.sync_api import sync_playwright

def sha256(text: str) -> str:
    m = hashlib.sha256()
    m.update(bytes(text, "utf8"))
    return m.hexdigest()


def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch(headless=False)
    context = browser.new_context()
    context.expose_function("sha256", sha256)
    page = context.new_page()
    page.set_content("""
        <script>
          async function onClick() {
            document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
          }
        </script>
        <button onclick="onClick()">Click me</button>
        <div></div>
    """)
    page.get_by_role("button").click()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
import hashlib
from playwright.async_api import async_playwright, Playwright

def sha256(text: str) -> str:
    m = hashlib.sha256()
    m.update(bytes(text, "utf8"))
    return m.hexdigest()


async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    context = await browser.new_context()
    await context.expose_function("sha256", sha256)
    page = await context.new_page()
    await page.set_content("""
        <script>
          async function onClick() {
            document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
          }
        </script>
        <button onclick="onClick()">Click me</button>
        <div></div>
    """)
    await page.get_by_role("button").click()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-name"/><a href="#browser-context-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Callable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-callback"/><a href="#browser-context-expose-function-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-return"/><a href="#browser-context-expose-function-return" class="list-anchor">#</a>

---

### grant_permissions {#browser-context-grant-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.grant_permissions</x-search>

Предоставляет указанные разрешения для контекста браузера. Предоставляет соответствующие разрешения только для указанного источника, если он указан.

**Использование**

```python
browser_context.grant_permissions(permissions)
browser_context.grant_permissions(permissions, **kwargs)
```

**Аргументы**
- `permissions` [List]\[[str]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-permissions"/><a href="#browser-context-grant-permissions-option-permissions" class="list-anchor">#</a>
  
  Список разрешений для предоставления.
  
  :::danger
  
  Поддерживаемые разрешения различаются между браузерами и даже между разными версиями одного и того же браузера. Любое разрешение может перестать работать после обновления.
  :::
  
  Вот некоторые разрешения, которые могут поддерживаться некоторыми браузерами:
  * `'accelerometer'`
  * `'ambient-light-sensor'`
  * `'background-sync'`
  * `'camera'`
  * `'clipboard-read'`
  * `'clipboard-write'`
  * `'geolocation'`
  * `'gyroscope'`
  * `'magnetometer'`
  * `'microphone'`
  * `'midi-sysex'` (системно-эксклюзивный midi)
  * `'midi'`
  * `'notifications'`
  * `'payment-handler'`
  * `'storage-access'`
- `origin` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-origin"/><a href="#browser-context-grant-permissions-option-origin" class="list-anchor">#</a>
  
  [Источник], для которого предоставляются разрешения, например, "https://example.com".

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-return"/><a href="#browser-context-grant-permissions-return" class="list-anchor">#</a>

---

### new_cdp_session {#browser-context-new-cdp-session}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.new_cdp_session</x-search>

:::note

CDP сессии поддерживаются только в браузерах на основе Chromium.
:::

Возвращает вновь созданную сессию.

**Использование**

```python
browser_context.new_cdp_session(page)
```

**Аргументы**
- `page` [Page] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-option-page"/><a href="#browser-context-new-cdp-session-option-page" class="list-anchor">#</a>
  
  Цель для создания новой сессии. Для обратной совместимости этот параметр называется `page`, но он может быть типа `Page` или `Frame`.

**Возвращает**
- [CDPSession]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-return"/><a href="#browser-context-new-cdp-session-return" class="list-anchor">#</a>

---

### new_page {#browser-context-new-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.new_page</x-search>

Создает новую страницу в контексте браузера.

**Использование**

```python
browser_context.new_page()
```

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-page-return"/><a href="#browser-context-new-page-return" class="list-anchor">#</a>

---

### route {#browser-context-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.route</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются любой страницей в контексте браузера. Как только маршрут включен, каждый запрос, соответствующий шаблону URL, будет приостановлен, если он не будет продолжен, выполнен или прерван.

:::note

[browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) не будет перехватывать запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [service_workers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

**Использование**

Пример наивного обработчика, который прерывает все запросы изображений:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
context = browser.new_context()
page = context.new_page()
context.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
page.goto("https://example.com")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
context = await browser.new_context()
page = await context.new_page()
await context.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
await page.goto("https://example.com")
await browser.close()
```

</TabItem>
</Tabs>

или тот же фрагмент кода, используя шаблон регулярного выражения:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
context = browser.new_context()
page = context.new_page()
context.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
page = await context.new_page()
page = context.new_page()
page.goto("https://example.com")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
context = await browser.new_context()
page = await context.new_page()
await context.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
page = await context.new_page()
await page.goto("https://example.com")
await browser.close()
```

</TabItem>
</Tabs>

Возможно исследовать запрос, чтобы решить, какое действие выполнить с маршрутом. Например, имитировать все запросы, содержащие некоторые данные post, и оставлять все остальные запросы как есть:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def handle_route(route: Route):
  if ("my-string" in route.request.post_data):
    route.fulfill(body="mocked-data")
  else:
    route.continue_()
context.route("/api/**", handle_route)
```

</TabItem>
<TabItem value="async">

```py
async def handle_route(route: Route):
  if ("my-string" in route.request.post_data):
    await route.fulfill(body="mocked-data")
  else:
    await route.continue_()
await context.route("/api/**", handle_route)
```

</TabItem>
</Tabs>

Маршруты страницы (установленные с помощью [page.route()](/api/class-page.mdx#page-route)) имеют приоритет над маршрутами контекста браузера, когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [browser_context.unroute()](/api/class-browsercontext.mdx#browser-context-unroute).

:::note

Включение маршрутизации отключает http-кэш.
:::

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-url"/><a href="#browser-context-route-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, шаблон регулярного выражения или предикат, получающий [URL] для сопоставления при маршрутизации. Когда [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) через параметры контекста был предоставлен и переданный URL является путем, он объединяется через [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) конструктор.
- `handler` [Callable]\[[Route], [Request]\]:[Promise]\[[Any]\] | [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-handler"/><a href="#browser-context-route-option-handler" class="list-anchor">#</a>
  
  функция-обработчик для маршрутизации запроса.
- `times` [int] *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-times"/><a href="#browser-context-route-option-times" class="list-anchor">#</a>
  
  Как часто маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-return"/><a href="#browser-context-route-return" class="list-anchor">#</a>

---

### route_from_har {#browser-context-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.23</font><x-search>browserContext.route_from_har</x-search>

Если указано, сетевые запросы, сделанные в контексте, будут обслуживаться из HAR файла. Подробнее читайте в разделе [Воспроизведение из HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из HAR файла. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [service_workers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```python
browser_context.route_from_har(har)
browser_context.route_from_har(har, **kwargs)
```

**Аргументы**
- `har` [Union]\[[str], [pathlib.Path]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-har"/><a href="#browser-context-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec) файлу с предварительно записанными сетевыми данными. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `not_found` "abort" | "fallback" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-not-found"/><a href="#browser-context-route-from-har-option-not-found" class="list-anchor">#</a>
  * Если установлено в 'abort', любой запрос, не найденный в HAR файле, будет прерван.
  * Если установлено в 'fallback', переходит к следующему обработчику маршрута в цепочке обработчиков.
  
  По умолчанию прерывается.
- `update` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update"/><a href="#browser-context-route-from-har-option-update" class="list-anchor">#</a>
  
  Если указано, обновляет данный HAR с фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск, когда вызывается [browser_context.close()](/api/class-browsercontext.mdx#browser-context-close).
- `update_content` "embed" | "attach" *(опционально)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-content"/><a href="#browser-context-route-from-har-option-update-content" class="list-anchor">#</a>
  
  Опциональная настройка для управления содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP архиве. Если указано `embed`, содержимое сохраняется встраиваемым в HAR файл.
- `update_mode` "full" | "minimal" *(опционально)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-mode"/><a href="#browser-context-route-from-har-option-update-mode" class="list-anchor">#</a>
  
  Когда установлено в `minimal`, записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницы, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию `minimal`.
- `url` [str] | [Pattern] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-url"/><a href="#browser-context-route-from-har-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR файла. Если не указано, все запросы обслуживаются из HAR файла.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-return"/><a href="#browser-context-route-from-har-return" class="list-anchor">#</a>

---

### route_web_socket {#browser-context-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.48</font><x-search>browserContext.route_web_socket</x-search>

Этот метод позволяет изменять соединения websocket, которые создаются любой страницей в контексте браузера.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизироваться. Рекомендуется вызывать этот метод перед созданием любых страниц.

**Использование**

Ниже приведен пример простого обработчика, который блокирует некоторые сообщения websocket. Подробнее и примеры смотрите в [WebSocketRoute].

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  if message == "to-be-blocked":
    return
  ws.send(message)

def handler(ws: WebSocketRoute):
  ws.route_send(lambda message: message_handler(ws, message))
  ws.connect()

context.route_web_socket("/ws", handler)
```

</TabItem>
<TabItem value="async">

```py
def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  if message == "to-be-blocked":
    return
  ws.send(message)

async def handler(ws: WebSocketRoute):
  ws.route_send(lambda message: message_handler(ws, message))
  await ws.connect()

await context.route_web_socket("/ws", handler)
```

</TabItem>
</Tabs>

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-url"/><a href="#browser-context-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизироваться. Строковый шаблон может быть относительным к [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) опции контекста.
- `handler` [Callable]\[[WebSocketRoute]\]:[Promise]\[[Any]\] | [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-handler"/><a href="#browser-context-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-return"/><a href="#browser-context-route-web-socket-return" class="list-anchor">#</a>

---

### set_default_navigation_timeout {#browser-context-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.set_default_navigation_timeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных с ними ярлыков:
* [page.go_back()](/api/class-page.mdx#page-go-back)
* [page.go_forward()](/api/class-page.mdx#page-go-forward)
* [page.goto()](/api/class-page.mdx#page-goto)
* [page.reload()](/api/class-page.mdx#page-reload)
* [page.set_content()](/api/class-page.mdx#page-set-content)
* [page.expect_navigation()](/api/class-page.mdx#page-wait-for-navigation)

:::note

[page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) и [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout) имеют приоритет над [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```python
browser_context.set_default_navigation_timeout(timeout)
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-navigation-timeout-option-timeout"/><a href="#browser-context-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### set_default_timeout {#browser-context-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.set_default_timeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих опцию [timeout](/api/class-browsercontext.mdx#browser-context-set-default-timeout-option-timeout).

:::note

[page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout), [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout) и [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout) имеют приоритет над [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
:::

**Использование**

```python
browser_context.set_default_timeout(timeout)
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-timeout-option-timeout"/><a href="#browser-context-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### set_extra_http_headers {#browser-context-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.set_extra_http_headers</x-search>

Дополнительные HTTP заголовки будут отправляться с каждым запросом, инициированным любой страницей в контексте. Эти заголовки объединяются с дополнительными HTTP заголовками, установленными для страницы с помощью [page.set_extra_http_headers()](/api/class-page.mdx#page-set-extra-http-headers). Если страница переопределяет определенный заголовок, будет использоваться значение заголовка, специфичное для страницы, вместо значения заголовка контекста браузера.

:::note

[browser_context.set_extra_http_headers()](/api/class-browsercontext.mdx#browser-context-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```python
browser_context.set_extra_http_headers(headers)
```

**Аргументы**
- `headers` [Dict]\[[str], [str]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-option-headers"/><a href="#browser-context-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP заголовки, которые будут отправляться с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-return"/><a href="#browser-context-set-extra-http-headers-return" class="list-anchor">#</a>

---

### set_geolocation {#browser-context-set-geolocation}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.set_geolocation</x-search>

Устанавливает геолокацию контекста. Передача `null` или `undefined` эмулирует недоступность позиции.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
browser_context.set_geolocation({"latitude": 59.95, "longitude": 30.31667})
```

</TabItem>
<TabItem value="async">

```py
await browser_context.set_geolocation({"latitude": 59.95, "longitude": 30.31667})
```

</TabItem>
</Tabs>

:::note

Рассмотрите возможность использования [browser_context.grant_permissions()](/api/class-browsercontext.mdx#browser-context-grant-permissions) для предоставления разрешений страницам контекста браузера на чтение его геолокации.
:::

**Аргументы**
- `geolocation` [NoneType] | [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-option-geolocation"/><a href="#browser-context-set-geolocation-option-geolocation" class="list-anchor">#</a>
  - `latitude` [float]
    
    Широта между -90 и 90.
  - `longitude` [float]
    
    Долгота между -180 и 180.
  - `accuracy` [float] *(опционально)*
    
    Неотрицательное значение точности. По умолчанию `0`.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-return"/><a href="#browser-context-set-geolocation-return" class="list-anchor">#</a>

---

### set_offline {#browser-context-set-offline}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.set_offline</x-search>

**Использование**

```python
browser_context.set_offline(offline)
```

**Аргументы**
- `offline` [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-option-offline"/><a href="#browser-context-set-offline-option-offline" class="list-anchor">#</a>
  
  Эмулировать ли отключение сети для контекста браузера.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-return"/><a href="#browser-context-set-offline-return" class="list-anchor">#</a>

---

### storage_state {#browser-context-storage-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.storage_state</x-search>

Возвращает состояние хранилища для этого контекста браузера, содержит текущие куки, снимок локального хранилища и снимок IndexedDB.

**Использование**

```python
browser_context.storage_state()
browser_context.storage_state(**kwargs)
```

**Аргументы**
- `indexed_db` [bool] *(опционально)* <font size="2">Added in: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-indexed-db"/><a href="#browser-context-storage-state-option-indexed-db" class="list-anchor">#</a>
  
  Установите в `true`, чтобы включить [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) в снимок состояния хранилища. Если ваше приложение использует IndexedDB для хранения токенов аутентификации, таких как Firebase Authentication, включите это.
  
  :::note
  
  IndexedDB с типизированными массивами в настоящее время не поддерживаются.
  :::
  
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-path"/><a href="#browser-context-storage-state-option-path" class="list-anchor">#</a>
  
  Путь к файлу для сохранения состояния хранилища. Если [path](/api/class-browsercontext.mdx#browser-context-storage-state-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, состояние хранилища все равно возвращается, но не будет сохранено на диск.

**Возвращает**
- [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-return"/><a href="#browser-context-storage-state-return" class="list-anchor">#</a>
  - `cookies` [List]\[[Dict]\]
    - `name` [str]
      
      
    - `value` [str]
      
      
    - `domain` [str]
      
      
    - `path` [str]
      
      
    - `expires` [float]
      
      Время Unix в секундах.
    - `httpOnly` [bool]
      
      
    - `secure` [bool]
      
      
    - `sameSite` "Strict" | "Lax" | "None"
      
      
    
  - `origins` [List]\[[Dict]\]
    - `origin` [str]
      
      
    - `localStorage` [List]\[[Dict]\]
      - `name` [str]
        
        
      - `value` [str]
        
        
      
    
---

### unroute {#browser-context-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.unroute</x-search>

Удаляет маршрут, созданный с помощью [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route). Когда [handler](/api/class-browsercontext.mdx#browser-context-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-browsercontext.mdx#browser-context-unroute-option-url).

**Использование**

```python
browser_context.unroute(url)
browser_context.unroute(url, **kwargs)
```

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-url"/><a href="#browser-context-unroute-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, шаблон регулярного выражения или предикат, получающий [URL], использованный для регистрации маршрутизации с [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route).
- `handler` [Callable]\[[Route], [Request]\]:[Promise]\[[Any]\] | [Any] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-handler"/><a href="#browser-context-unroute-option-handler" class="list-anchor">#</a>
  
  Опциональная функция-обработчик, использованная для регистрации маршрутизации с [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-return"/><a href="#browser-context-unroute-return" class="list-anchor">#</a>

---

### unroute_all {#browser-context-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.41</font><x-search>browserContext.unroute_all</x-search>

Удаляет все маршруты, созданные с помощью [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) и [browser_context.route_from_har()](/api/class-browsercontext.mdx#browser-context-route-from-har).

**Использование**

```python
browser_context.unroute_all()
browser_context.unroute_all(**kwargs)
```

**Аргументы**
- `behavior` "wait" | "ignoreErrors" | "default" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-all-option-behavior"/><a href="#browser-context-unroute-all-option-behavior" class="list-anchor">#</a>
  
  Указывает, следует ли ждать уже выполняющихся обработчиков и что делать, если они вызывают ошибки:
  * `'default'` - не ждать завершения текущих вызовов обработчиков (если есть), если удаленный обработчик вызывает ошибку, это может привести к необработанной ошибке
  * `'wait'` - ждать завершения текущих вызовов обработчиков (если есть)
  * `'ignoreErrors'` - не ждать завершения текущих вызовов обработчиков (если есть), все ошибки, вызванные обработчиками после удаления маршрутизации, тихо перехватываются

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-all-return"/><a href="#browser-context-unroute-all-return" class="list-anchor">#</a>

---

### wait_for_event {#browser-context-wait-for-event-2}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.wait_for_event</x-search>

:::note

В большинстве случаев следует использовать [browser_context.expect_event()](/api/class-browsercontext.mdx#browser-context-wait-for-event).
:::

Ожидает, пока указанный `event` не будет вызван. Если предикат предоставлен, он передает значение события в функцию `predicate` и ждет, пока `predicate(event)` не вернет истинное значение. Выдаст ошибку, если контекст браузера будет закрыт до того, как `event` будет вызван.

**Использование**

```python
browser_context.wait_for_event(event)
browser_context.wait_for_event(event, **kwargs)
```

**Аргументы**
- `event` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-2-option-event"/><a href="#browser-context-wait-for-event-2-option-event" class="list-anchor">#</a>
  
  Имя события, то же самое, которое обычно передается в `*.on(event)`.
- `predicate` [Callable] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-2-option-predicate"/><a href="#browser-context-wait-for-event-2-option-predicate" class="list-anchor">#</a>
  
  Получает данные события и разрешает в истинное значение, когда ожидание должно разрешиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-2-option-timeout"/><a href="#browser-context-wait-for-event-2-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-event-2-return"/><a href="#browser-context-wait-for-event-2-return" class="list-anchor">#</a>

---

## Properties

### background_pages {#browser-context-background-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>browserContext.background_pages</x-search>

:::note

Background pages are only supported on Chromium-based browsers.
:::

Все существующие фоновые страницы в контексте.

**Использование**

```python
browser_context.background_pages
```

**Возвращает**
- [List]\[[Page]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-background-pages-return"/><a href="#browser-context-background-pages-return" class="list-anchor">#</a>

---

### browser {#browser-context-browser}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.browser</x-search>

Возвращает экземпляр браузера для данного контекста. Если он был запущен как постоянный контекст, возвращается null.

**Использование**

```python
browser_context.browser
```

**Возвращает**
- [NoneType] | [Browser]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-browser-return"/><a href="#browser-context-browser-return" class="list-anchor">#</a>

---

### clock {#browser-context-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.45</font><x-search>browserContext.clock</x-search>

Playwright имеет возможность имитировать часы и ход времени.

**Использование**

```python
browser_context.clock
```

**Type**
- [Clock]

---

### pages {#browser-context-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.pages</x-search>

Возвращает все открытые страницы в контексте.

**Использование**

```python
browser_context.pages
```

**Возвращает**
- [List]\[[Page]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-pages-return"/><a href="#browser-context-pages-return" class="list-anchor">#</a>

---

### request {#browser-context-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.16</font><x-search>browserContext.request</x-search>

Помощник для тестирования API, связанный с этим контекстом. Запросы, сделанные с помощью этого API, будут использовать куки контекста.

**Использование**

```python
browser_context.request
```

**Type**
- [APIRequestContext]

---

### service_workers {#browser-context-service-workers}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>browserContext.service_workers</x-search>

:::note

Service workers are only supported on Chromium-based browsers.
:::

Все существующие service workers в контексте.

**Использование**

```python
browser_context.service_workers
```

**Возвращает**
- [List]\[[Worker]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-service-workers-return"/><a href="#browser-context-service-workers-return" class="list-anchor">#</a>

---

### tracing {#browser-context-tracing}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.tracing</x-search>

**Использование**

```python
browser_context.tracing
```

**Type**
- [Tracing]

---

## Events

### on("backgroundpage") {#browser-context-event-background-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>browserContext.on("backgroundpage")</x-search>

:::note

Only works with Chromium browser's persistent context.
:::

Вызывается, когда в контексте создается новая фоновая страница.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
background_page = context.wait_for_event("backgroundpage")
```

</TabItem>
<TabItem value="async">

```py
background_page = await context.wait_for_event("backgroundpage")
```

</TabItem>
</Tabs>

**Использование**

```python
browser_context.on("backgroundpage", handler)
```

**Данные события**
- [Page]

---

### on("close") {#browser-context-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.on("close")</x-search>

Вызывается, когда контекст браузера закрывается. Это может произойти по одной из следующих причин:
* Контекст браузера закрыт.
* Приложение браузера закрыто или аварийно завершило работу.
* Метод [browser.close()](/api/class-browser.mdx#browser-close) был вызван.

**Использование**

```python
browser_context.on("close", handler)
```

**Данные события**
- [BrowserContext]

---

### on("console") {#browser-context-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.34</font><x-search>browserContext.on("console")</x-search>

Вызывается, когда JavaScript на странице вызывает один из методов консоли API, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, и страница доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def print_args(msg):
    for arg in msg.args:
        print(arg.json_value())

context.on("console", print_args)
page.evaluate("console.log('hello', 5, { foo: 'bar' })")
```

</TabItem>
<TabItem value="async">

```py
async def print_args(msg):
    values = []
    for arg in msg.args:
        values.append(await arg.json_value())
    print(values)

context.on("console", print_args)
await page.evaluate("console.log('hello', 5, { foo: 'bar' })")
```

</TabItem>
</Tabs>

**Данные события**
- [ConsoleMessage]

---

### on("dialog") {#browser-context-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.34</font><x-search>browserContext.on("dialog")</x-search>

Вызывается, когда появляется JavaScript-диалог, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Слушатель **должен** либо [dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница [заморозится](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалог, и действия, такие как клик, никогда не завершатся.

**Использование**

```python
context.on("dialog", lambda dialog: dialog.accept())
```

:::note
Когда нет слушателей [page.on("dialog")](/api/class-page.mdx#page-event-dialog) или [browser_context.on("dialog")](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### on("page") {#browser-context-event-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>browserContext.on("page")</x-search>

Событие вызывается, когда в BrowserContext создается новая страница. Страница может все еще загружаться. Событие также будет срабатывать для всплывающих страниц. См. также [page.on("popup")](/api/class-page.mdx#page-event-popup) для получения событий о всплывающих окнах, относящихся к конкретной странице.

Самый ранний момент, когда страница доступна, это когда она перешла на начальный URL. Например, при открытии всплывающего окна с помощью `window.open('http://example.com')`, это событие сработает, когда сетевой запрос к "http://example.com" будет выполнен и его ответ начнет загружаться во всплывающем окне. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) и [browser_context.on("request")](/api/class-browsercontext.mdx#browser-context-event-request) соответственно, вместо аналогичных методов на [Page].

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with context.expect_page() as page_info:
    page.get_by_text("open new page").click(),
page = page_info.value
print(page.evaluate("location.href"))
```

</TabItem>
<TabItem value="async">

```py
async with context.expect_page() as page_info:
    await page.get_by_text("open new page").click(),
page = await page_info.value
print(await page.evaluate("location.href"))
```

</TabItem>
</Tabs>

:::note

Используйте [page.wait_for_load_state()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев это не потребуется).
:::

**Использование**

```python
browser_context.on("page", handler)
```

**Данные события**
- [Page]

---

### on("request") {#browser-context-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.on("request")</x-search>

Вызывается, когда запрос отправляется с любой страницы, созданной через этот контекст. Объект [request] доступен только для чтения. Чтобы слушать только запросы с определенной страницы, используйте [page.on("request")](/api/class-page.mdx#page-event-request).

Для перехвата и изменения запросов, см. [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) или [page.route()](/api/class-page.mdx#page-route).

**Использование**

```python
browser_context.on("request", handler)
```

**Данные события**
- [Request]

---

### on("requestfailed") {#browser-context-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.on("requestfailed")</x-search>

Вызывается, когда запрос не удается выполнить, например, из-за тайм-аута. Чтобы слушать только неудачные запросы с определенной страницы, используйте [page.on("requestfailed")](/api/class-page.mdx#page-event-request-failed).

:::note

HTTP ошибки, такие как 404 или 503, все еще считаются успешными ответами с точки зрения HTTP, поэтому запрос завершится событием [browser_context.on("requestfinished")](/api/class-browsercontext.mdx#browser-context-event-request-finished), а не [browser_context.on("requestfailed")](/api/class-browsercontext.mdx#browser-context-event-request-failed).
:::

**Использование**

```python
browser_context.on("requestfailed", handler)
```

**Данные события**
- [Request]

---

### on("requestfinished") {#browser-context-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.on("requestfinished")</x-search>

Вызывается, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`. Чтобы слушать успешные запросы с определенной страницы, используйте [page.on("requestfinished")](/api/class-page.mdx#page-event-request-finished).

**Использование**

```python
browser_context.on("requestfinished", handler)
```

**Данные события**
- [Request]

---

### on("response") {#browser-context-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>browserContext.on("response")</x-search>

Вызывается, когда [response] статус и заголовки получены для запроса. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`. Чтобы слушать события ответа с определенной страницы, используйте [page.on("response")](/api/class-page.mdx#page-event-response).

**Использование**

```python
browser_context.on("response", handler)
```

**Данные события**
- [Response]

---

### on("serviceworker") {#browser-context-event-service-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>browserContext.on("serviceworker")</x-search>

:::note

Service workers are only supported on Chromium-based browsers.
:::

Вызывается, когда в контексте создается новый service worker.

**Использование**

```python
browser_context.on("serviceworker", handler)
```

**Данные события**
- [Worker]

---

### on("weberror") {#browser-context-event-web-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.38</font><x-search>browserContext.on("weberror")</x-search>

Вызывается, когда исключение не обработано ни на одной из страниц в этом контексте. Чтобы отслеживать ошибки на конкретной странице, используйте [page.on("pageerror")](/api/class-page.mdx#page-event-page-error).

**Использование**

```python
browser_context.on("weberror", handler)
```

**Данные события**
- [WebError]


[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[Error]: /api/class-error.mdx "Error"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Any]: https://docs.python.org/3/library/typing.html#typing.Any "Any"
[bool]: https://docs.python.org/3/library/stdtypes.html "bool"
[bytes]: https://docs.python.org/3/library/stdtypes.html#bytes "bytes"
[Callable]: https://docs.python.org/3/library/typing.html#typing.Callable "Callable"
[EventContextManager]: https://docs.python.org/3/reference/datamodel.html#context-managers "Event context manager"
[EventEmitter]: https://pyee.readthedocs.io/en/latest/#pyee.BaseEventEmitter "EventEmitter"
[Exception]: https://docs.python.org/3/library/exceptions.html#Exception "Exception"
[Dict]: https://docs.python.org/3/library/typing.html#typing.Dict "Dict"
[float]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "float"
[int]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "int"
[List]: https://docs.python.org/3/library/typing.html#typing.List "List"
[NoneType]: https://docs.python.org/3/library/constants.html#None "None"
[Pattern]: https://docs.python.org/3/library/re.html "Pattern"
[URL]: https://en.wikipedia.org/wiki/URL "URL"
[pathlib.Path]: https://realpython.com/python-pathlib/ "pathlib.Path"
[str]: https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str "str"
[Union]: https://docs.python.org/3/library/typing.html#typing.Union "Union"
[datetime]: https://docs.python.org/3/library/datetime.html#datetime.datetime "datetime"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/python/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/python/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-python/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
