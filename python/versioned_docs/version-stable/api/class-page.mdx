---
id: class-page
title: "Page"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';


Класс Page предоставляет методы для взаимодействия с одной вкладкой в [Browser] или со [страницей фонового расширения](https://developer.chrome.com/extensions/background_pages) в Chromium. Один экземпляр [Browser] может иметь несколько экземпляров [Page].

В этом примере создаётся страница, выполняется переход по URL, а затем сохраняется скриншот:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch()
    context = browser.new_context()
    page = context.new_page()
    page.goto("https://example.com")
    page.screenshot(path="screenshot.png")
    browser.close()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch()
    context = await browser.new_context()
    page = await context.new_page()
    await page.goto("https://example.com")
    await page.screenshot(path="screenshot.png")
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

Класс Page генерирует различные события (описаны ниже), которые можно обрабатывать с помощью любых нативных методов Node [`EventEmitter`](https://nodejs.org/api/events.html#events_class_eventemitter), таких как `on`, `once` или `removeListener`.

В этом примере выводится сообщение при одиночном событии загрузки страницы `load`:

```py
page.once("load", lambda: print("page loaded!"))
```

Чтобы отписаться от событий, используйте метод `removeListener`:

```py
def log_request(intercepted_request):
    print("a request was made:", intercepted_request.url)
page.on("request", log_request)
# sometime later...
page.remove_listener("request", log_request)
```


---

## Методы {#methods}

### add_init_script {#page-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.add_init_script</x-search>

Добавляет скрипт, который будет выполнен в одном из следующих случаев:
* При каждом переходе страницы.
* При каждом присоединении или навигации дочернего фрейма. В этом случае скрипт выполняется в контексте только что присоединённого фрейма.

Скрипт выполняется после создания документа, но до запуска любых его собственных скриптов. Это полезно для изменения JavaScript-окружения, например, чтобы зафиксировать значение `Math.random`.

**Использование**

Пример переопределения `Math.random` до загрузки страницы:

```js
// preload.js
Math.random = () => 42;
```

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# in your playwright script, assuming the preload.js file is in same directory
page.add_init_script(path="./preload.js")
```

</TabItem>
<TabItem value="async">

```py
# in your playwright script, assuming the preload.js file is in same directory
await page.add_init_script(path="./preload.js")
```

</TabItem>
</Tabs>

:::note

Порядок выполнения нескольких скриптов, установленных через [browser_context.add_init_script()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [page.add_init_script()](/api/class-page.mdx#page-add-init-script), не определён.
:::

**Аргументы**
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-option-path"/><a href="#page-add-init-script-option-path" class="list-anchor">#</a>
  
  Путь к JavaScript-файлу. Если `path` является относительным путём, он разрешается относительно текущей рабочей директории. Необязательный параметр.
- `script` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-option-script"/><a href="#page-add-init-script-option-script" class="list-anchor">#</a>
  
  Скрипт, который будет выполнен на всех страницах в контексте браузера. Необязательный параметр.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-return"/><a href="#page-add-init-script-return" class="list-anchor">#</a>

---

### add_locator_handler {#page-add-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.42</font><x-search>page.add_locator_handler</x-search>

При тестировании веб-страницы иногда появляются неожиданные оверлеи, например диалог «Sign up», которые блокируют действия, которые вы хотите автоматизировать, например клик по кнопке. Такие оверлеи не всегда появляются одинаково или в одно и то же время, из‑за чего их сложно обрабатывать в автоматических тестах.

Этот метод позволяет настроить специальную функцию — обработчик (handler), — которая срабатывает, когда обнаруживает, что оверлей стал видимым. Задача обработчика — убрать оверлей, чтобы тест мог продолжаться так, как будто его не было.

Что важно учитывать:
* Если оверлей появляется предсказуемо, рекомендуется явно ожидать его в тесте и закрывать как часть обычного сценария теста, вместо использования [page.add_locator_handler()](/api/class-page.mdx#page-add-locator-handler).
* Playwright проверяет наличие оверлея каждый раз перед выполнением или повторной попыткой действия, требующего [проверки возможности действия (actionability check)](../actionability.mdx), либо перед выполнением автождущего утверждения (assertion). Если оверлей видим, Playwright сначала вызывает обработчик, а затем продолжает действие или проверку. Обратите внимание: обработчик вызывается только при выполнении действия или утверждения — если оверлей стал видимым, но вы не выполняете никаких действий, обработчик не будет вызван.
* После выполнения обработчика Playwright удостоверится, что оверлей, вызвавший обработчик, больше не виден. От этого поведения можно отказаться с помощью [no_wait_after](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after).
* Время выполнения обработчика засчитывается в таймаут действия или утверждения, которое его вызвало. Если обработчик выполняется слишком долго, это может привести к таймаутам.
* Можно зарегистрировать несколько обработчиков. Однако одновременно будет выполняться только один обработчик. Убедитесь, что действия внутри обработчика не зависят от другого обработчика.

:::warning

Выполнение обработчика изменяет состояние страницы в середине теста. Например, может измениться элемент в фокусе или положение мыши. Убедитесь, что действия, выполняемые после обработчика, являются самодостаточными и не зависят от того, что фокус и состояние мыши остались неизменными.

Например, рассмотрим тест, который вызывает [locator.focus()](/api/class-locator.mdx#locator-focus), а затем [keyboard.press()](/api/class-keyboard.mdx#keyboard-press). Если ваш обработчик нажмёт кнопку между этими двумя действиями, элемент в фокусе, скорее всего, будет другим, и нажатие клавиши произойдёт не на том элементе. Используйте [locator.press()](/api/class-locator.mdx#locator-press), чтобы избежать этой проблемы.

Другой пример — серия действий мышью, где [mouse.move()](/api/class-mouse.mdx#mouse-move) вызывается перед [mouse.down()](/api/class-mouse.mdx#mouse-down). Если обработчик выполнится между этими действиями, позиция мыши будет неверной во время `mouse.down`. Предпочитайте самодостаточные действия, такие как [locator.click()](/api/class-locator.mdx#locator-click), которые не зависят от неизменности состояния при выполнении обработчика.
:::

**Использование**

Пример, который закрывает диалог «Sign up to the newsletter», когда он появляется:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Setup the handler.
def handler():
  page.get_by_role("button", name="No thanks").click()
page.add_locator_handler(page.get_by_text("Sign up to the newsletter"), handler)

# Write the test as usual.
page.goto("https://example.com")
page.get_by_role("button", name="Start here").click()
```

</TabItem>
<TabItem value="async">

```py
# Setup the handler.
async def handler():
  await page.get_by_role("button", name="No thanks").click()
await page.add_locator_handler(page.get_by_text("Sign up to the newsletter"), handler)

# Write the test as usual.
await page.goto("https://example.com")
await page.get_by_role("button", name="Start here").click()
```

</TabItem>
</Tabs>

Пример, который пропускает страницу «Confirm your security details», когда она появляется:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Setup the handler.
def handler():
  page.get_by_role("button", name="Remind me later").click()
page.add_locator_handler(page.get_by_text("Confirm your security details"), handler)

# Write the test as usual.
page.goto("https://example.com")
page.get_by_role("button", name="Start here").click()
```

</TabItem>
<TabItem value="async">

```py
# Setup the handler.
async def handler():
  await page.get_by_role("button", name="Remind me later").click()
await page.add_locator_handler(page.get_by_text("Confirm your security details"), handler)

# Write the test as usual.
await page.goto("https://example.com")
await page.get_by_role("button", name="Start here").click()
```

</TabItem>
</Tabs>

Пример с пользовательским колбэком при каждой проверке actionability. Используется локатор `<body>`, который всегда видим, поэтому обработчик вызывается перед каждой проверкой actionability. Важно указать [no_wait_after](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after), так как обработчик не скрывает элемент `<body>`.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Setup the handler.
def handler():
  page.evaluate("window.removeObstructionsForTestIfNeeded()")
page.add_locator_handler(page.locator("body"), handler, no_wait_after=True)

# Write the test as usual.
page.goto("https://example.com")
page.get_by_role("button", name="Start here").click()
```

</TabItem>
<TabItem value="async">

```py
# Setup the handler.
async def handler():
  await page.evaluate("window.removeObstructionsForTestIfNeeded()")
await page.add_locator_handler(page.locator("body"), handler, no_wait_after=True)

# Write the test as usual.
await page.goto("https://example.com")
await page.get_by_role("button", name="Start here").click()
```

</TabItem>
</Tabs>

Обработчик принимает исходный локатор в качестве аргумента. Вы также можете автоматически удалить обработчик после определённого количества вызовов, задав параметр [times](/api/class-page.mdx#page-add-locator-handler-option-times):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def handler(locator):
  locator.click()
page.add_locator_handler(page.get_by_label("Close"), handler, times=1)
```

</TabItem>
<TabItem value="async">

```py
async def handler(locator):
  await locator.click()
await page.add_locator_handler(page.get_by_label("Close"), handler, times=1)
```

</TabItem>
</Tabs>

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-locator"/><a href="#page-add-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, который инициирует вызов обработчика.
- `handler` [Callable]\[[Locator]\]:[Promise]\[[Any]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-handler"/><a href="#page-add-locator-handler-option-handler" class="list-anchor">#</a>
  
  Функция, которая должна быть выполнена, когда появляется [locator](/api/class-page.mdx#page-add-locator-handler-option-locator). Эта функция должна устранить элемент, блокирующий действия, такие как клик.
- `no_wait_after` [bool] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-no-wait-after"/><a href="#page-add-locator-handler-option-no-wait-after" class="list-anchor">#</a>
  
  По умолчанию после вызова обработчика Playwright будет ждать, пока оверлей не станет скрытым, и только затем продолжит действие или утверждение, вызвавшее обработчик. Этот параметр позволяет отказаться от такого поведения, чтобы оверлей мог оставаться видимым после выполнения обработчика.
- `times` [int] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-times"/><a href="#page-add-locator-handler-option-times" class="list-anchor">#</a>
  
  Задаёт максимальное количество вызовов этого обработчика. По умолчанию — без ограничений.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-return"/><a href="#page-add-locator-handler-return" class="list-anchor">#</a>

---

### add_script_tag {#page-add-script-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.add_script_tag</x-search>

Добавляет на страницу тег `<script>` с указанным URL или содержимым. Возвращает добавленный тег, когда срабатывает событие `onload` скрипта или когда содержимое скрипта было внедрено во фрейм.

**Использование**

```python
page.add_script_tag()
page.add_script_tag(**kwargs)
```

**Аргументы**
- `content` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-content"/><a href="#page-add-script-tag-option-content" class="list-anchor">#</a>
  
  Необработанное JavaScript-содержимое для внедрения во фрейм.
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-path"/><a href="#page-add-script-tag-option-path" class="list-anchor">#</a>
  
  Путь к JavaScript-файлу для внедрения во фрейм. Если `path` является относительным путём, он разрешается относительно текущей рабочей директории.
- `type` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-type"/><a href="#page-add-script-tag-option-type" class="list-anchor">#</a>
  
  Тип скрипта. Используйте `'module'` для загрузки JavaScript ES6‑модуля. Подробнее см. [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script).
- `url` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-url"/><a href="#page-add-script-tag-option-url" class="list-anchor">#</a>
  
  URL скрипта, который необходимо добавить.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-return"/><a href="#page-add-script-tag-return" class="list-anchor">#</a>

---

### add_style_tag {#page-add-style-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.add_style_tag</x-search>

Добавляет на страницу тег `<link rel="stylesheet">` с указанным URL или тег `<style type="text/css">` с содержимым. Возвращает добавленный тег, когда срабатывает событие `onload` таблицы стилей или когда CSS‑содержимое было внедрено во фрейм.

**Использование**

```python
page.add_style_tag()
page.add_style_tag(**kwargs)
```

**Аргументы**
- `content` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-content"/><a href="#page-add-style-tag-option-content" class="list-anchor">#</a>
  
  Необработанное CSS‑содержимое для внедрения во фрейм.
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-path"/><a href="#page-add-style-tag-option-path" class="list-anchor">#</a>
  
  Путь к CSS‑файлу для внедрения во фрейм. Если `path` является относительным путём, он разрешается относительно текущей рабочей директории.
- `url` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-url"/><a href="#page-add-style-tag-option-url" class="list-anchor">#</a>
  
  URL для тега `<link>`.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-return"/><a href="#page-add-style-tag-return" class="list-anchor">#</a>

---

### bring_to_front {#page-bring-to-front}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.bring_to_front</x-search>

Перемещает страницу на передний план (активирует вкладку).

**Использование**

```python
page.bring_to_front()
```

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-bring-to-front-return"/><a href="#page-bring-to-front-return" class="list-anchor">#</a>

---

### close {#page-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.close</x-search>

Если [run_before_unload](/api/class-page.mdx#page-close-option-run-before-unload) равно `false`, обработчики выгрузки не запускаются, и метод ожидает закрытия страницы. Если [run_before_unload](/api/class-page.mdx#page-close-option-run-before-unload) равно `true`, метод запустит обработчики выгрузки, но **не будет** ждать фактического закрытия страницы.

По умолчанию `page.close()` **не** запускает обработчики `beforeunload`.

:::note

Если [run_before_unload](/api/class-page.mdx#page-close-option-run-before-unload) передан как `true`, может появиться диалог `beforeunload`, который необходимо обрабатывать вручную через событие [page.on("dialog")](/api/class-page.mdx#page-event-dialog).
:::

**Использование**

```python
page.close()
page.close(**kwargs)
```

**Аргументы**
- `reason` [str] *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-reason"/><a href="#page-close-option-reason" class="list-anchor">#</a>
  
  Причина, которая будет передана операциям, прерванным закрытием страницы.
- `run_before_unload` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-run-before-unload"/><a href="#page-close-option-run-before-unload" class="list-anchor">#</a>
  
  По умолчанию `false`. Определяет, следует ли запускать обработчики страницы [before unload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-return"/><a href="#page-close-return" class="list-anchor">#</a>

---

### console_messages {#page-console-messages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.56</font><x-search>page.console_messages</x-search>

Возвращает до (на данный момент) 200 последних сообщений консоли со страницы. Подробнее см. [page.on("console")](/api/class-page.mdx#page-event-console).

**Использование**

```python
page.console_messages()
```

**Возвращает**
- [List]\[[ConsoleMessage]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-console-messages-return"/><a href="#page-console-messages-return" class="list-anchor">#</a>

---

### content {#page-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.content</x-search>

Возвращает полный HTML‑код страницы, включая doctype.

**Использование**

```python
page.content()
```

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-content-return"/><a href="#page-content-return" class="list-anchor">#</a>

---

### drag_and_drop {#page-drag-and-drop}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>page.drag_and_drop</x-search>

Этот метод перетаскивает исходный элемент к целевому элементу. Сначала выполняется перемещение к исходному элементу и `mousedown`, затем перемещение к целевому элементу и `mouseup`.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.drag_and_drop("#source", "#target")
# or specify exact positions relative to the top-left corners of the elements:
page.drag_and_drop(
  "#source",
  "#target",
  source_position={"x": 34, "y": 7},
  target_position={"x": 10, "y": 20}
)
```

</TabItem>
<TabItem value="async">

```py
await page.drag_and_drop("#source", "#target")
# or specify exact positions relative to the top-left corners of the elements:
await page.drag_and_drop(
  "#source",
  "#target",
  source_position={"x": 34, "y": 7},
  target_position={"x": 10, "y": 20}
)
```

</TabItem>
</Tabs>

**Аргументы**
- `source` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source"/><a href="#page-drag-and-drop-option-source" class="list-anchor">#</a>
  
  Селектор для поиска элемента, который нужно перетащить. Если селектору соответствует несколько элементов, будет использован первый.
- `target` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target"/><a href="#page-drag-and-drop-option-target" class="list-anchor">#</a>
  
  Селектор для поиска элемента, на который нужно выполнить сброс. Если селектору соответствует несколько элементов, будет использован первый.
- `force` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-force"/><a href="#page-drag-and-drop-option-force" class="list-anchor">#</a>
  
  Следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-no-wait-after"/><a href="#page-drag-and-drop-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::
  
  
  Этот параметр не имеет эффекта.
- `source_position` [Dict] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source-position"/><a href="#page-drag-and-drop-option-source-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Клик по исходному элементу в этой точке относительно верхнего левого угла области padding элемента. Если не указано, используется некоторая видимая точка элемента.
- `steps` [int] *(опционально)* <font size="2">Добавлено в: v1.57</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-steps"/><a href="#page-drag-and-drop-option-steps" class="list-anchor">#</a>
  
  По умолчанию равно 1. Отправляет `n` интерполированных событий `mousemove`, представляющих перемещение между `mousedown` и `mouseup` во время перетаскивания. При значении 1 отправляется одно событие `mousemove` в конечной точке.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-strict"/><a href="#page-drag-and-drop-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, селектор должен однозначно разрешаться в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `target_position` [Dict] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target-position"/><a href="#page-drag-and-drop-option-target-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Сбрасывает на целевой элемент в этой точке относительно верхнего левого угла области padding элемента. Если не указано, используется некоторая видимая точка элемента.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-timeout"/><a href="#page-drag-and-drop-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-trial"/><a href="#page-drag-and-drop-option-trial" class="list-anchor">#</a>
  
  Если установлено, метод выполняет только проверки [actionability](../actionability.mdx) и пропускает само действие. По умолчанию `false`. Полезно для ожидания готовности элемента к действию без его выполнения.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-return"/><a href="#page-drag-and-drop-return" class="list-anchor">#</a>

---

### emulate_media {#page-emulate-media}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.emulate_media</x-search>

Этот метод изменяет `CSS media type` с помощью аргумента `media` и/или медиавыражение `'prefers-colors-scheme'` с помощью аргумента `colorScheme`.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.evaluate("matchMedia('screen').matches")
# → True
page.evaluate("matchMedia('print').matches")
# → False

page.emulate_media(media="print")
page.evaluate("matchMedia('screen').matches")
# → False
page.evaluate("matchMedia('print').matches")
# → True

page.emulate_media()
page.evaluate("matchMedia('screen').matches")
# → True
page.evaluate("matchMedia('print').matches")
# → False
```

</TabItem>
<TabItem value="async">

```py
await page.evaluate("matchMedia('screen').matches")
# → True
await page.evaluate("matchMedia('print').matches")
# → False

await page.emulate_media(media="print")
await page.evaluate("matchMedia('screen').matches")
# → False
await page.evaluate("matchMedia('print').matches")
# → True

await page.emulate_media()
await page.evaluate("matchMedia('screen').matches")
# → True
await page.evaluate("matchMedia('print').matches")
# → False
```

</TabItem>
</Tabs>

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.emulate_media(color_scheme="dark")
page.evaluate("matchMedia('(prefers-color-scheme: dark)').matches")
# → True
page.evaluate("matchMedia('(prefers-color-scheme: light)').matches")
# → False
```

</TabItem>
<TabItem value="async">

```py
await page.emulate_media(color_scheme="dark")
await page.evaluate("matchMedia('(prefers-color-scheme: dark)').matches")
# → True
await page.evaluate("matchMedia('(prefers-color-scheme: light)').matches")
# → False
```

</TabItem>
</Tabs>

**Аргументы**
- `color_scheme` "light" | "dark" | "no-preference" | "null" *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-color-scheme"/><a href="#page-emulate-media-option-color-scheme" class="list-anchor">#</a>
  
  Эмулирует медиавыражение [prefers-colors-scheme](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme). Поддерживаемые значения: `'light'` и `'dark'`. Передача `'Null'` отключает эмуляцию цветовой схемы. `'no-preference'` устарело.
- `contrast` "no-preference" | "more" | "null" *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-contrast"/><a href="#page-emulate-media-option-contrast" class="list-anchor">#</a>
- `forced_colors` "active" | "none" | "null" *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-forced-colors"/><a href="#page-emulate-media-option-forced-colors" class="list-anchor">#</a>
- `media` "screen" | "print" | "null" *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-media"/><a href="#page-emulate-media-option-media" class="list-anchor">#</a>
  
  Изменяет тип CSS media страницы. Допустимые значения: `'Screen'`, `'Print'` и `'Null'`. Передача `'Null'` отключает эмуляцию CSS media.
- `reduced_motion` "reduce" | "no-preference" | "null" *(опционально)* <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-reduced-motion"/><a href="#page-emulate-media-option-reduced-motion" class="list-anchor">#</a>
  
  Эмулирует медиавыражение `'prefers-reduced-motion'`. Поддерживаемые значения: `'reduce'`, `'no-preference'`. Передача `null` отключает эмуляцию уменьшенного движения.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-return"/><a href="#page-emulate-media-return" class="list-anchor">#</a>

---

### evaluate {#page-evaluate}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.evaluate</x-search>

Возвращает значение выполнения [expression](/api/class-page.mdx#page-evaluate-option-expression).

Если функция, переданная в [page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает [Promise], то [page.evaluate()](/api/class-page.mdx#page-evaluate) дождётся его выполнения и вернёт результат.

Если функция, переданная в [page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает не-[Serializable] значение, то [page.evaluate()](/api/class-page.mdx#page-evaluate) завершится с результатом `undefined`. Playwright также поддерживает передачу некоторых дополнительных значений, которые не сериализуются с помощью `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.

**Использование**

Передача аргумента в [expression](/api/class-page.mdx#page-evaluate-option-expression):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
result = page.evaluate("([x, y]) => Promise.resolve(x * y)", [7, 8])
print(result) # выводит "56"
```

</TabItem>
<TabItem value="async">

```py
result = await page.evaluate("([x, y]) => Promise.resolve(x * y)", [7, 8])
print(result) # выводит "56"
```

</TabItem>
</Tabs>

Вместо функции также можно передать строку:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
print(page.evaluate("1 + 2")) # выводит "3"
x = 10
print(page.evaluate(f"1 + {x}")) # выводит "11"
```

</TabItem>
<TabItem value="async">

```py
print(await page.evaluate("1 + 2")) # выводит "3"
x = 10
print(await page.evaluate(f"1 + {x}")) # выводит "11"
```

</TabItem>
</Tabs>

Экземпляры [ElementHandle] можно передавать как аргумент в [page.evaluate()](/api/class-page.mdx#page-evaluate):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
body_handle = page.evaluate("document.body")
html = page.evaluate("([body, suffix]) => body.innerHTML + suffix", [body_handle, "hello"])
body_handle.dispose()
```

</TabItem>
<TabItem value="async">

```py
body_handle = await page.evaluate("document.body")
html = await page.evaluate("([body, suffix]) => body.innerHTML + suffix", [body_handle, "hello"])
await body_handle.dispose()
```

</TabItem>
</Tabs>

**Аргументы**
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-expression"/><a href="#page-evaluate-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение, которое будет выполнено в контексте браузера. Если выражение вычисляется в функцию, эта функция будет автоматически вызвана.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-arg"/><a href="#page-evaluate-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент, передаваемый в [expression](/api/class-page.mdx#page-evaluate-option-expression).

**Возвращает**
- [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-return"/><a href="#page-evaluate-return" class="list-anchor">#</a>

---

### evaluate_handle {#page-evaluate-handle}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.evaluate_handle</x-search>

Возвращает значение выполнения [expression](/api/class-page.mdx#page-evaluate-handle-option-expression) в виде [JSHandle].

Единственное отличие между [page.evaluate()](/api/class-page.mdx#page-evaluate) и [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle) заключается в том, что [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle) возвращает [JSHandle].

Если функция, переданная в [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle), возвращает [Promise], то [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle) дождётся его выполнения и вернёт результат.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
a_window_handle = page.evaluate_handle("Promise.resolve(window)")
a_window_handle # handle для объекта window
```

</TabItem>
<TabItem value="async">

```py
a_window_handle = await page.evaluate_handle("Promise.resolve(window)")
a_window_handle # handle для объекта window
```

</TabItem>
</Tabs>

Вместо функции также можно передать строку:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
a_handle = page.evaluate_handle("document") # handle для "document"
```

</TabItem>
<TabItem value="async">

```py
a_handle = await page.evaluate_handle("document") # handle для "document"
```

</TabItem>
</Tabs>

Экземпляры [JSHandle] можно передавать как аргумент в [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
a_handle = page.evaluate_handle("document.body")
result_handle = page.evaluate_handle("body => body.innerHTML", a_handle)
print(result_handle.json_value())
result_handle.dispose()
```

</TabItem>
<TabItem value="async">

```py
a_handle = await page.evaluate_handle("document.body")
result_handle = await page.evaluate_handle("body => body.innerHTML", a_handle)
print(await result_handle.json_value())
await result_handle.dispose()
```

</TabItem>
</Tabs>

**Аргументы**
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-expression"/><a href="#page-evaluate-handle-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение, которое будет выполнено в контексте браузера. Если выражение вычисляется в функцию, эта функция будет автоматически вызвана.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-arg"/><a href="#page-evaluate-handle-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент, передаваемый в [expression](/api/class-page.mdx#page-evaluate-handle-option-expression).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-return"/><a href="#page-evaluate-handle-return" class="list-anchor">#</a>

---

### expect_console_message {#page-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_console_message</x-search>

Выполняет действие и ожидает, пока на странице будет залогировано сообщение [ConsoleMessage]. Если передан `predicate`, он получает значение [ConsoleMessage] и ожидание продолжается до тех пор, пока `predicate(message)` не вернёт истинное значение. Будет выброшена ошибка, если страница будет закрыта до возникновения события [page.on("console")](/api/class-page.mdx#page-event-console).

**Использование**

```python
page.expect_console_message()
page.expect_console_message(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[ConsoleMessage]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-predicate"/><a href="#page-wait-for-console-message-option-predicate" class="list-anchor">#</a>
  
  Получает объект [ConsoleMessage] и должно вернуть истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-timeout"/><a href="#page-wait-for-console-message-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[ConsoleMessage]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-return"/><a href="#page-wait-for-console-message-return" class="list-anchor">#</a>

---

### expect_download {#page-wait-for-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_download</x-search>

Выполняет действие и ожидает новый [Download]. Если передан `predicate`, он получает значение [Download] и ожидание продолжается до тех пор, пока `predicate(download)` не вернёт истинное значение. Будет выброшена ошибка, если страница будет закрыта до возникновения события загрузки.

**Использование**

```python
page.expect_download()
page.expect_download(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Download]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-predicate"/><a href="#page-wait-for-download-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Download] и должно вернуть истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-timeout"/><a href="#page-wait-for-download-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Download]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-return"/><a href="#page-wait-for-download-return" class="list-anchor">#</a>

---

### expect_event {#page-wait-for-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expect_event</x-search>

Ожидает срабатывания события и передаёт его данные в функцию-предикат. Возвращается, когда предикат возвращает истинное значение. Будет выброшена ошибка, если страница будет закрыта до срабатывания события. Возвращает значение данных события.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_event("framenavigated") as event_info:
    page.get_by_role("button")
frame = event_info.value
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_event("framenavigated") as event_info:
    await page.get_by_role("button")
frame = await event_info.value
```

</TabItem>
</Tabs>

**Аргументы**
- `event` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-option-event"/><a href="#page-wait-for-event-option-event" class="list-anchor">#</a>
  
  Имя события, такое же, какое обычно передаётся в `*.on(event)`.
- `predicate` [Callable] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-option-predicate"/><a href="#page-wait-for-event-option-predicate" class="list-anchor">#</a>
  
  Получает данные события и должно вернуть истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-option-timeout"/><a href="#page-wait-for-event-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-return"/><a href="#page-wait-for-event-return" class="list-anchor">#</a>

---

### expect_file_chooser {#page-wait-for-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_file_chooser</x-search>

Выполняет действие и ожидает создание нового [FileChooser]. Если передан `predicate`, он получает значение [FileChooser] и ожидание продолжается до тех пор, пока `predicate(fileChooser)` не вернёт истинное значение. Будет выброшена ошибка, если страница будет закрыта до открытия диалога выбора файла.

**Использование**

```python
page.expect_file_chooser()
page.expect_file_chooser(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[FileChooser]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-predicate"/><a href="#page-wait-for-file-chooser-option-predicate" class="list-anchor">#</a>
  
  Получает объект [FileChooser] и должно вернуть истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-timeout"/><a href="#page-wait-for-file-chooser-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[FileChooser]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-return"/><a href="#page-wait-for-file-chooser-return" class="list-anchor">#</a>

---

### expect_popup {#page-wait-for-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_popup</x-search>

Выполняет действие и ожидает появления всплывающего окна ([Page]). Если передан `predicate`, значение [Popup] передаётся в функцию `predicate`, и ожидание продолжается до тех пор, пока `predicate(page)` не вернёт истинное значение. Будет выброшена ошибка, если страница будет закрыта до того, как произойдёт событие появления всплывающего окна.

**Использование**

```python
page.expect_popup()
page.expect_popup(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Page]\]:[bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-predicate"/><a href="#page-wait-for-popup-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Page] и должна вернуть истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-timeout"/><a href="#page-wait-for-popup-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Page]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-return"/><a href="#page-wait-for-popup-return" class="list-anchor">#</a>

---

### expect_request {#page-wait-for-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expect_request</x-search>

Ожидает подходящий запрос и возвращает его. Подробнее о событиях см. в разделе [ожидание события](../events.mdx#waiting-for-event).

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_request("http://example.com/resource") as first:
    page.get_by_text("trigger request").click()
first_request = first.value

# или с использованием lambda
with page.expect_request(lambda request: request.url == "http://example.com" and request.method == "get") as second:
    page.get_by_text("trigger request").click()
second_request = second.value
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_request("http://example.com/resource") as first:
    await page.get_by_text("trigger request").click()
first_request = await first.value

# или с использованием lambda
async with page.expect_request(lambda request: request.url == "http://example.com" and request.method == "get") as second:
    await page.get_by_text("trigger request").click()
second_request = await second.value
```

</TabItem>
</Tabs>

**Аргументы**
- `url_or_predicate` [str] | [Pattern] | [Callable]\[[Request]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-url-or-predicate"/><a href="#page-wait-for-request-option-url-or-predicate" class="list-anchor">#</a>
  
  Строка URL запроса, регулярное выражение или предикат, принимающий объект [Request]. Если в параметрах контекста был указан [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) и переданный URL является путём, он будет объединён с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-timeout"/><a href="#page-wait-for-request-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью метода [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Request]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-return"/><a href="#page-wait-for-request-return" class="list-anchor">#</a>

---

### expect_request_finished {#page-wait-for-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>page.expect_request_finished</x-search>

Выполняет действие и ожидает завершения загрузки [Request]. Если передан `predicate`, значение [Request] передаётся в функцию `predicate`, и ожидание продолжается до тех пор, пока `predicate(request)` не вернёт истинное значение. Будет выброшена ошибка, если страница будет закрыта до того, как произойдёт событие [page.on("requestfinished")](/api/class-page.mdx#page-event-request-finished).

**Использование**

```python
page.expect_request_finished()
page.expect_request_finished(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Request]\]:[bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-predicate"/><a href="#page-wait-for-request-finished-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Request] и должна вернуть истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-timeout"/><a href="#page-wait-for-request-finished-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Request]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-return"/><a href="#page-wait-for-request-finished-return" class="list-anchor">#</a>

---

### expect_response {#page-wait-for-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expect_response</x-search>

Возвращает соответствующий ответ. Подробнее о событиях см. в разделе [ожидание события](../events.mdx#waiting-for-event).

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_response("https://example.com/resource") as response_info:
    page.get_by_text("trigger response").click()
response = response_info.value
return response.ok

# или с использованием lambda
with page.expect_response(lambda response: response.url == "https://example.com" and response.status == 200 and response.request.method == "get") as response_info:
    page.get_by_text("trigger response").click()
response = response_info.value
return response.ok
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_response("https://example.com/resource") as response_info:
    await page.get_by_text("trigger response").click()
response = await response_info.value
return response.ok

# или с использованием lambda
async with page.expect_response(lambda response: response.url == "https://example.com" and response.status == 200 and response.request.method == "get") as response_info:
    await page.get_by_text("trigger response").click()
response = await response_info.value
return response.ok
```

</TabItem>
</Tabs>

**Аргументы**
- `url_or_predicate` [str] | [Pattern] | [Callable]\[[Response]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-url-or-predicate"/><a href="#page-wait-for-response-option-url-or-predicate" class="list-anchor">#</a>
  
  Строка URL запроса, регулярное выражение или предикат, принимающий объект [Response]. Если в параметрах контекста был указан [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) и переданный URL является путём, он будет объединён с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-timeout"/><a href="#page-wait-for-response-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Response]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-return"/><a href="#page-wait-for-response-return" class="list-anchor">#</a>

---

### expect_websocket {#page-wait-for-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_websocket</x-search>

Выполняет действие и ожидает новый [WebSocket]. Если передан `predicate`, значение [WebSocket] передаётся в функцию `predicate`, и ожидание продолжается до тех пор, пока `predicate(webSocket)` не вернёт истинное значение. Будет выброшена ошибка, если страница будет закрыта до возникновения события WebSocket.

**Использование**

```python
page.expect_websocket()
page.expect_websocket(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[WebSocket]\]:[bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-predicate"/><a href="#page-wait-for-web-socket-option-predicate" class="list-anchor">#</a>
  
  Получает объект [WebSocket] и должна вернуть истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-timeout"/><a href="#page-wait-for-web-socket-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[WebSocket]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-return"/><a href="#page-wait-for-web-socket-return" class="list-anchor">#</a>

---

### expect_worker {#page-wait-for-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_worker</x-search>

Выполняет действие и ожидает новый [Worker]. Если передан `predicate`, значение [Worker] передаётся в функцию `predicate`, и ожидание продолжается до тех пор, пока `predicate(worker)` не вернёт истинное значение. Будет выброшена ошибка, если страница будет закрыта до возникновения события worker.

**Использование**

```python
page.expect_worker()
page.expect_worker(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Worker]\]:[bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-predicate"/><a href="#page-wait-for-worker-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Worker] и должна вернуть истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-timeout"/><a href="#page-wait-for-worker-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Worker]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-return"/><a href="#page-wait-for-worker-return" class="list-anchor">#</a>

---

### expose_binding {#page-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expose_binding</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-binding-option-name) в объект `window` каждого фрейма на странице. При вызове эта функция выполняет [callback](/api/class-page.mdx#page-expose-binding-option-callback) и возвращает [Promise], который резолвится в возвращаемое значение [callback](/api/class-page.mdx#page-expose-binding-option-callback). Если [callback] возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-page.mdx#page-expose-binding-option-callback) содержит информацию о вызывающей стороне: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

См. [browser_context.expose_binding()](/api/class-browsercontext.mdx#browser-context-expose-binding) для версии, действующей на уровне контекста.

:::note

Функции, установленные через [page.expose_binding()](/api/class-page.mdx#page-expose-binding), сохраняются при навигациях.
:::

**Использование**

Пример экспонирования URL страницы во все фреймы страницы:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch(headless=False)
    context = browser.new_context()
    page = context.new_page()
    page.expose_binding("pageURL", lambda source: source["page"].url)
    page.set_content("""
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
    """)
    page.click("button")

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    context = await browser.new_context()
    page = await context.new_page()
    await page.expose_binding("pageURL", lambda source: source["page"].url)
    await page.set_content("""
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
    """)
    await page.click("button")

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-name"/><a href="#page-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Callable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-callback"/><a href="#page-expose-binding-option-callback" class="list-anchor">#</a>
  
  Callback-функция, которая будет вызываться в контексте Playwright.
- `handle` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-handle"/><a href="#page-expose-binding-option-handle" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр будет удалён в будущем.
  :::
  

  Определяет, передавать ли аргумент как handle вместо передачи по значению. При передаче handle поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-return"/><a href="#page-expose-binding-return" class="list-anchor">#</a>

---

### expose_function {#page-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expose_function</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-function-option-name) в объект `window` каждого фрейма на странице. При вызове эта функция выполняет [callback](/api/class-page.mdx#page-expose-function-option-callback) и возвращает [Promise], который резолвится в возвращаемое значение [callback](/api/class-page.mdx#page-expose-function-option-callback).

Если [callback] возвращает [Promise], он будет ожидаться.

См. [browser_context.expose_function()](/api/class-browsercontext.mdx#browser-context-expose-function) для версии, действующей на уровне контекста.

:::note

Функции, установленные через [page.expose_function()](/api/class-page.mdx#page-expose-function), сохраняются при навигациях.
:::

**Использование**

Пример добавления функции `sha256` на страницу:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
import hashlib
from playwright.sync_api import sync_playwright, Playwright

def sha256(text):
    m = hashlib.sha256()
    m.update(bytes(text, "utf8"))
    return m.hexdigest()


def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch(headless=False)
    page = browser.new_page()
    page.expose_function("sha256", sha256)
    page.set_content("""
        <script>
          async function onClick() {
            document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
          }
        </script>
        <button onclick="onClick()">Click me</button>
        <div></div>
    """)
    page.click("button")

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
import hashlib
from playwright.async_api import async_playwright, Playwright

def sha256(text):
    m = hashlib.sha256()
    m.update(bytes(text, "utf8"))
    return m.hexdigest()


async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    page = await browser.new_page()
    await page.expose_function("sha256", sha256)
    await page.set_content("""
        <script>
          async function onClick() {
            document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
          }
        </script>
        <button onclick="onClick()">Click me</button>
        <div></div>
    """)
    await page.click("button")

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-name"/><a href="#page-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Callable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-callback"/><a href="#page-expose-function-option-callback" class="list-anchor">#</a>
  
  Callback-функция, которая будет вызываться в контексте Playwright.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-return"/><a href="#page-expose-function-return" class="list-anchor">#</a>

---

### frame {#page-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.frame</x-search>

Возвращает фрейм, соответствующий указанным критериям. Должен быть указан либо `name`, либо `url`.

**Использование**

```py
frame = page.frame(name="frame-name")
```

```py
frame = page.frame(url=r".*domain.*")
```

**Аргументы**
- `name` [str] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-option-name"/><a href="#page-frame-option-name" class="list-anchor">#</a>
  
  Имя фрейма, указанное в атрибуте `name` элемента `iframe`.
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-option-url"/><a href="#page-frame-option-url" class="list-anchor">#</a>
  
  Glob-паттерн, регулярное выражение или предикат, принимающий `url` фрейма в виде объекта [URL].

**Возвращает**
- [NoneType] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-return"/><a href="#page-frame-return" class="list-anchor">#</a>

---

### frame_locator {#page-frame-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.17</font><x-search>page.frame_locator</x-search>

При работе с iframe вы можете создать frame locator, который позволит войти во iframe и выбирать элементы внутри него.

**Использование**

Следующий пример находит элемент с текстом «Submit» внутри iframe с id `my-frame`, например `<iframe id="my-frame">`:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
locator = page.frame_locator("#my-iframe").get_by_text("Submit")
locator.click()
```

</TabItem>
<TabItem value="async">

```py
locator = page.frame_locator("#my-iframe").get_by_text("Submit")
await locator.click()
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-option-selector"/><a href="#page-frame-locator-option-selector" class="list-anchor">#</a>
  
  Селектор, используемый при разрешении DOM-элемента.

**Возвращает**
- [FrameLocator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-return"/><a href="#page-frame-locator-return" class="list-anchor">#</a>

---

### get_by_alt_text {#page-get-by-alt-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_alt_text</x-search>

Позволяет находить элементы по их alt-тексту.

**Использование**

Например, этот метод найдёт изображение по alt-тексту «Playwright logo»:

```html
<img alt='Playwright logo'>
```

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_alt_text("Playwright logo").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_alt_text("Playwright logo").click()
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-text"/><a href="#page-get-by-alt-text-option-text" class="list-anchor">#</a>
  
  Текст, по которому нужно найти элемент.
- `exact` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-exact"/><a href="#page-get-by-alt-text-option-exact" class="list-anchor">#</a>
  
  Определяет, требуется ли точное совпадение: с учётом регистра и всей строки целиком. По умолчанию `false`. Игнорируется при использовании регулярного выражения. Обратите внимание, что при точном совпадении пробелы по краям всё равно обрезаются.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-return"/><a href="#page-get-by-alt-text-return" class="list-anchor">#</a>

---

### get_by_label {#page-get-by-label}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_label</x-search>

Позволяет находить элементы ввода по тексту связанного элемента `<label>` или `aria-labelledby`, либо по атрибуту `aria-label`.

**Использование**

Например, этот метод найдёт поля ввода по меткам «Username» и «Password» в следующем DOM:

```html
<input aria-label="Username">
<label for="password-input">Password:</label>
<input id="password-input">
```

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_label("Username").fill("john")
page.get_by_label("Password").fill("secret")
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_label("Username").fill("john")
await page.get_by_label("Password").fill("secret")
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-text"/><a href="#page-get-by-label-option-text" class="list-anchor">#</a>
  
  Текст, по которому нужно найти элемент.
- `exact` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-exact"/><a href="#page-get-by-label-option-exact" class="list-anchor">#</a>
  
  Определяет, требуется ли точное совпадение: с учётом регистра и по всей строке. По умолчанию `false`. Игнорируется при поиске с использованием регулярного выражения. Обратите внимание, что при точном совпадении пробелы по краям всё равно обрезаются.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-return"/><a href="#page-get-by-label-return" class="list-anchor">#</a>

---

### get_by_placeholder {#page-get-by-placeholder}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_placeholder</x-search>

Позволяет находить элементы ввода по тексту плейсхолдера.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<input type="email" placeholder="name@example.com" />
```

Вы можете заполнить поле, найдя его по тексту плейсхолдера:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-text"/><a href="#page-get-by-placeholder-option-text" class="list-anchor">#</a>
  
  Текст, по которому нужно найти элемент.
- `exact` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-exact"/><a href="#page-get-by-placeholder-option-exact" class="list-anchor">#</a>
  
  Определяет, требуется ли точное совпадение: с учётом регистра и по всей строке. По умолчанию `false`. Игнорируется при поиске с использованием регулярного выражения. Обратите внимание, что при точном совпадении пробелы по краям всё равно обрезаются.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-return"/><a href="#page-get-by-placeholder-return" class="list-anchor">#</a>

---

### get_by_role {#page-get-by-role}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_role</x-search>

Позволяет находить элементы по их [ARIA‑роли](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA‑атрибутам](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) и [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name).

**Использование**

Рассмотрим следующую структуру DOM.

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```

Вы можете найти каждый элемент по его неявной роли:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_role("heading", name="Sign up")).to_be_visible()

page.get_by_role("checkbox", name="Subscribe").check()

page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_role("heading", name="Sign up")).to_be_visible()

await page.get_by_role("checkbox", name="Subscribe").check()

await page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
```

</TabItem>
</Tabs>

**Аргументы**
- `role` "alert" | "alertdialog" | "application" | "article" | "banner" | "blockquote" | "button" | "caption" | "cell" | "checkbox" | "code" | "columnheader" | "combobox" | "complementary" | "contentinfo" | "definition" | "deletion" | "dialog" | "directory" | "document" | "emphasis" | "feed" | "figure" | "form" | "generic" | "grid" | "gridcell" | "group" | "heading" | "img" | "insertion" | "link" | "list" | "listbox" | "listitem" | "log" | "main" | "marquee" | "math" | "meter" | "menu" | "menubar" | "menuitem" | "menuitemcheckbox" | "menuitemradio" | "navigation" | "none" | "note" | "option" | "paragraph" | "presentation" | "progressbar" | "radio" | "radiogroup" | "region" | "row" | "rowgroup" | "rowheader" | "scrollbar" | "search" | "searchbox" | "separator" | "slider" | "spinbutton" | "status" | "strong" | "subscript" | "superscript" | "switch" | "tab" | "table" | "tablist" | "tabpanel" | "term" | "textbox" | "time" | "timer" | "toolbar" | "tooltip" | "tree" | "treegrid" | "treeitem"<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-role"/><a href="#page-get-by-role-option-role" class="list-anchor">#</a>
  
  Обязательная ARIA‑роль.
- `checked` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-checked"/><a href="#page-get-by-role-option-checked" class="list-anchor">#</a>
  
  Атрибут, который обычно задаётся с помощью `aria-checked` или нативных элементов `<input type=checkbox>`.
  
  Подробнее см. [`aria-checked`](https://www.w3.org/TR/wai-aria-1.2/#aria-checked).
- `disabled` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-disabled"/><a href="#page-get-by-role-option-disabled" class="list-anchor">#</a>
  
  Атрибут, который обычно задаётся с помощью `aria-disabled` или `disabled`.
  
  :::note
  
  В отличие от большинства других атрибутов, `disabled` наследуется по иерархии DOM. Подробнее см. [`aria-disabled`](https://www.w3.org/TR/wai-aria-1.2/#aria-disabled).
  :::
  
- `exact` [bool] *(необязательно)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-exact"/><a href="#page-get-by-role-option-exact" class="list-anchor">#</a>
  
  Определяет, должно ли [name](/api/class-page.mdx#page-get-by-role-option-name) совпадать точно: с учётом регистра и по всей строке. По умолчанию `false`. Игнорируется, если [name](/api/class-page.mdx#page-get-by-role-option-name) является регулярным выражением. Обратите внимание, что при точном совпадении пробелы по краям всё равно обрезаются.
- `expanded` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-expanded"/><a href="#page-get-by-role-option-expanded" class="list-anchor">#</a>
  
  Атрибут, который обычно задаётся с помощью `aria-expanded`.
  
  Подробнее см. [`aria-expanded`](https://www.w3.org/TR/wai-aria-1.2/#aria-expanded).
- `include_hidden` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-include-hidden"/><a href="#page-get-by-role-option-include-hidden" class="list-anchor">#</a>
  
  Параметр, управляющий тем, учитываются ли скрытые элементы. По умолчанию по селектору ролей сопоставляются только нескрытые элементы, как [определено в ARIA](https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion).
  
  Подробнее см. [`aria-hidden`](https://www.w3.org/TR/wai-aria-1.2/#aria-hidden).
- `level` [int] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-level"/><a href="#page-get-by-role-option-level" class="list-anchor">#</a>
  
  Числовой атрибут, который обычно присутствует для ролей `heading`, `listitem`, `row`, `treeitem`, с значениями по умолчанию для элементов `<h1>-<h6>`.
  
  Подробнее см. [`aria-level`](https://www.w3.org/TR/wai-aria-1.2/#aria-level).
- `name` [str] | [Pattern] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-name"/><a href="#page-get-by-role-option-name" class="list-anchor">#</a>
  
  Параметр для сопоставления [доступного имени](https://w3c.github.io/accname/#dfn-accessible-name). По умолчанию сопоставление регистронезависимое и ищет подстроку; используйте [exact](/api/class-page.mdx#page-get-by-role-option-exact) для управления этим поведением.
  
  Подробнее см. [accessible name](https://w3c.github.io/accname/#dfn-accessible-name).
- `pressed` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-pressed"/><a href="#page-get-by-role-option-pressed" class="list-anchor">#</a>
  
  Атрибут, который обычно задаётся с помощью `aria-pressed`.
  
  Подробнее см. [`aria-pressed`](https://www.w3.org/TR/wai-aria-1.2/#aria-pressed).
- `selected` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-selected"/><a href="#page-get-by-role-option-selected" class="list-anchor">#</a>
  
  Атрибут, который обычно задаётся с помощью `aria-selected`.
  
  Подробнее см. [`aria-selected`](https://www.w3.org/TR/wai-aria-1.2/#aria-selected).

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-return"/><a href="#page-get-by-role-return" class="list-anchor">#</a>

**Подробности**

Селектор по роли **не заменяет** аудит доступности и тесты на соответствие стандартам, а лишь даёт раннюю обратную связь по соблюдению рекомендаций ARIA.

Многие HTML‑элементы имеют неявно [определённую роль](https://w3c.github.io/html-aam/#html-element-role-mappings), которая распознаётся селектором ролей. Все [поддерживаемые роли перечислены здесь](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). Рекомендации ARIA **не советуют** дублировать неявные роли и атрибуты, устанавливая `role` и/или `aria-*` со значениями по умолчанию.

---

### get_by_test_id {#page-get-by-test-id}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_test_id</x-search>

Находит элемент по тестовому идентификатору.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<button data-testid="directions">Itinéraire</button>
```

Вы можете найти элемент по его test id:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_test_id("directions").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_test_id("directions").click()
```

</TabItem>
</Tabs>

**Аргументы**
- `test_id` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-option-test-id"/><a href="#page-get-by-test-id-option-test-id" class="list-anchor">#</a>
  
  Идентификатор, по которому нужно найти элемент.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-return"/><a href="#page-get-by-test-id-return" class="list-anchor">#</a>

**Подробности**

По умолчанию в качестве test id используется атрибут `data-testid`. При необходимости вы можете настроить другой атрибут test id с помощью [selectors.set_test_id_attribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute).

---

### get_by_text {#page-get-by-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_text</x-search>

Позволяет находить элементы, содержащие заданный текст.

См. также [locator.filter()](/api/class-locator.mdx#locator-filter), который позволяет сначала сопоставлять по другим критериям, например по доступной роли, а затем фильтровать по текстовому содержимому.

**Использование**

Рассмотрим следующую структуру DOM:

```html
<div>Hello <span>world</span></div>
<div>Hello</div>
```

Вы можете искать по подстроке текста, точной строке или регулярному выражению:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Совпадает с <span>
page.get_by_text("world")

# Совпадает с первым <div>
page.get_by_text("Hello world")

# Совпадает со вторым <div>
page.get_by_text("Hello", exact=True)

# Совпадает с обоими <div>
page.get_by_text(re.compile("Hello"))

# Совпадает со вторым <div>
page.get_by_text(re.compile("^hello$", re.IGNORECASE))
```

</TabItem>
<TabItem value="async">

```py
# Совпадает с <span>
page.get_by_text("world")

# Совпадает с первым <div>
page.get_by_text("Hello world")

# Совпадает со вторым <div>
page.get_by_text("Hello", exact=True)

# Совпадает с обоими <div>
page.get_by_text(re.compile("Hello"))

# Совпадает со вторым <div>
page.get_by_text(re.compile("^hello$", re.IGNORECASE))
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-text"/><a href="#page-get-by-text-option-text" class="list-anchor">#</a>
  
  Текст, по которому нужно найти элемент.
- `exact` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-exact"/><a href="#page-get-by-text-option-exact" class="list-anchor">#</a>
  
  Определяет, требуется ли точное совпадение: с учётом регистра и по всей строке. По умолчанию `false`. Игнорируется при поиске с использованием регулярного выражения. Обратите внимание, что при точном совпадении пробелы по краям всё равно обрезаются.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-return"/><a href="#page-get-by-text-return" class="list-anchor">#</a>

**Подробности**

Сопоставление по тексту всегда нормализует пробелы, даже при точном совпадении. Например, несколько пробелов преобразуются в один, переносы строк заменяются пробелами, а начальные и конечные пробелы игнорируются.

Элементы ввода типов `button` и `submit` сопоставляются по их атрибуту `value`, а не по текстовому содержимому. Например, поиск по тексту `"Log in"` найдёт `<input type=button value="Log in">`.

---

### get_by_title {#page-get-by-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_title</x-search>

Позволяет находить элементы по их атрибуту `title`.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<span title='Issues count'>25 issues</span>
```

Вы можете проверить количество задач, найдя элемент по тексту заголовка:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_title("Issues count")).to_have_text("25 issues")
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_title("Issues count")).to_have_text("25 issues")
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-text"/><a href="#page-get-by-title-option-text" class="list-anchor">#</a>
  
  Текст, по которому нужно найти элемент.
- `exact` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-exact"/><a href="#page-get-by-title-option-exact" class="list-anchor">#</a>
  
  Определяет, требуется ли точное совпадение: с учётом регистра и по всей строке. По умолчанию `false`. Игнорируется при поиске с использованием регулярного выражения. Обратите внимание, что при точном совпадении пробелы по краям всё равно обрезаются.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-return"/><a href="#page-get-by-title-return" class="list-anchor">#</a>

---

### go_back {#page-go-back}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.go_back</x-search>

Возвращает ответ основного ресурса. В случае нескольких редиректов навигация завершится с ответом последнего редиректа. Если вернуться назад невозможно, возвращает `null`.

Переход на предыдущую страницу в истории.

**Использование**

```python
page.go_back()
page.go_back(**kwargs)
```

**Аргументы**
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-timeout"/><a href="#page-go-back-option-timeout" class="list-anchor">#</a>
  
  Максимальное время выполнения операции в миллисекундах, по умолчанию 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-wait-until"/><a href="#page-go-back-option-wait-until" class="list-anchor">#</a>
  
  Условие, при котором операция считается успешно завершённой, по умолчанию `load`. Возможные события:
  * `'domcontentloaded'` — операция считается завершённой при срабатывании события `DOMContentLoaded`.
  * `'load'` — операция считается завершённой при срабатывании события `load`.
  * `'networkidle'` — **НЕ РЕКОМЕНДУЕТСЯ**: операция считается завершённой, когда в течение как минимум `500` мс нет сетевых соединений. Не используйте этот режим для тестирования; вместо этого полагайтесь на веб‑ассерты.
  * `'commit'` — операция считается завершённой, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [NoneType] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-return"/><a href="#page-go-back-return" class="list-anchor">#</a>

---

### go_forward {#page-go-forward}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.go_forward</x-search>

Возвращает ответ основного ресурса. В случае нескольких редиректов навигация завершится с ответом последнего редиректа. Если перейти вперёд невозможно, возвращает `null`.

Переход на следующую страницу в истории.

**Использование**

```python
page.go_forward()
page.go_forward(**kwargs)
```

**Аргументы**
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-timeout"/><a href="#page-go-forward-option-timeout" class="list-anchor">#</a>
  
  Максимальное время выполнения операции в миллисекундах, по умолчанию 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-wait-until"/><a href="#page-go-forward-option-wait-until" class="list-anchor">#</a>
  
  Условие, при котором операция считается успешно завершённой, по умолчанию `load`. Возможные события:
  * `'domcontentloaded'` — операция считается завершённой при срабатывании события `DOMContentLoaded`.
  * `'load'` — операция считается завершённой при срабатывании события `load`.
  * `'networkidle'` — **НЕ РЕКОМЕНДУЕТСЯ**: операция считается завершённой, когда в течение как минимум `500` мс нет сетевых соединений. Не используйте этот режим для тестирования; вместо этого полагайтесь на веб‑ассерты.
  * `'commit'` — операция считается завершённой, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [NoneType] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-return"/><a href="#page-go-forward-return" class="list-anchor">#</a>

---

### goto {#page-goto}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.goto</x-search>

Возвращает ответ основного ресурса. В случае нескольких редиректов навигация завершится с первым ответом, который не является редиректом.

Метод выбрасывает ошибку, если:
* возникает ошибка SSL (например, при использовании самоподписанных сертификатов);
* целевой URL некорректен;
* превышен [timeout](/api/class-page.mdx#page-goto-option-timeout) во время навигации;
* удалённый сервер не отвечает или недоступен;
* основной ресурс не удалось загрузить.

Метод **не выбрасывает ошибку**, если удалённый сервер возвращает любой допустимый HTTP‑статус, включая 404 «Not Found» и 500 «Internal Server Error». Статус такого ответа можно получить с помощью [response.status](/api/class-response.mdx#response-status).

:::note

Метод либо выбрасывает ошибку, либо возвращает ответ основного ресурса. Единственные исключения — навигация на `about:blank` или навигация на тот же URL с другим хэшем: в этих случаях операция считается успешной и возвращает `null`.
:::

:::note
В режиме headless не поддерживается навигация к PDF‑документам. См. [вышестоящую задачу](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).
:::

**Использование**

```python
page.goto(url)
page.goto(url, **kwargs)
```

**Аргументы**
- `url` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-url"/><a href="#page-goto-option-url" class="list-anchor">#</a>
  
  URL, на который нужно перейти. URL должен включать схему, например `https://`. Если в параметрах контекста был задан [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) и переданный URL является путём, они объединяются с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `referer` [str] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-referer"/><a href="#page-goto-option-referer" class="list-anchor">#</a>
  
  Значение заголовка Referer. Если указано, оно имеет приоритет над заголовком Referer, заданным с помощью [page.set_extra_http_headers()](/api/class-page.mdx#page-set-extra-http-headers).
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-timeout"/><a href="#page-goto-option-timeout" class="list-anchor">#</a>
  
  Максимальное время выполнения операции в миллисекундах, по умолчанию 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-wait-until"/><a href="#page-goto-option-wait-until" class="list-anchor">#</a>
  
  Условие, при котором операция считается успешно завершённой, по умолчанию `load`. Возможные события:
  * `'domcontentloaded'` — операция считается завершённой при срабатывании события `DOMContentLoaded`.
  * `'load'` — операция считается завершённой при срабатывании события `load`.
  * `'networkidle'` — **НЕ РЕКОМЕНДУЕТСЯ**: операция считается завершённой, когда в течение как минимум `500` мс нет сетевых соединений. Не используйте этот режим для тестирования; вместо этого полагайтесь на веб‑ассерты.
  * `'commit'` — операция считается завершённой, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [NoneType] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-return"/><a href="#page-goto-return" class="list-anchor">#</a>

---

### locator {#page-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.14</font><x-search>page.locator</x-search>

Метод возвращает локатор элемента, который можно использовать для выполнения действий на этой странице / в этом фрейме. Локатор разрешается до элемента непосредственно перед выполнением действия, поэтому серия действий с одним и тем же локатором фактически может быть выполнена над разными DOM-элементами. Это происходит, если структура DOM между этими действиями изменилась.

[Подробнее о локаторах](../locators.mdx).

**Использование**

```python
page.locator(selector)
page.locator(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-selector"/><a href="#page-locator-option-selector" class="list-anchor">#</a>
  
  Селектор, используемый для поиска DOM-элемента.
- `has` [Locator] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has"/><a href="#page-locator-option-has" class="list-anchor">#</a>
  
  Сужает результаты метода до элементов, которые содержат элементы, соответствующие этому относительному локатору. Например, `article`, который содержит `text=Playwright`, соответствует `<article><div>Playwright</div></article>`.
  
  Внутренний локатор **должен быть относительным** к внешнему локатору и запрашивается, начиная с совпадения внешнего локатора, а не от корня документа. Например, вы можете найти `content`, который содержит `div`, в `<article><content><div>Playwright</div></content></article>`. Однако поиск `content`, который содержит `article div`, завершится неудачей, потому что внутренний локатор должен быть относительным и не должен использовать элементы вне `content`.
  
  Обратите внимание, что внешний и внутренний локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
- `has_not` [Locator] *(необязательно)* <font size="2">Добавлено в: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not"/><a href="#page-locator-option-has-not" class="list-anchor">#</a>
  
  Соответствует элементам, которые не содержат элемент, совпадающий с внутренним локатором. Внутренний локатор запрашивается относительно внешнего. Например, `article`, который не содержит `div`, соответствует `<article><span>Playwright</span></article>`.
  
  Обратите внимание, что внешний и внутренний локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
- `has_not_text` [str] | [Pattern] *(необязательно)* <font size="2">Добавлено в: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not-text"/><a href="#page-locator-option-has-not-text" class="list-anchor">#</a>
  
  Соответствует элементам, которые не содержат указанный текст где-либо внутри, возможно, в дочернем или вложенном элементе. При передаче [string] поиск нечувствителен к регистру и ищет подстроку.
- `has_text` [str] | [Pattern] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-text"/><a href="#page-locator-option-has-text" class="list-anchor">#</a>
  
  Соответствует элементам, содержащим указанный текст где-либо внутри, возможно, в дочернем или вложенном элементе. При передаче [string] поиск нечувствителен к регистру и ищет подстроку. Например, `"Playwright"` соответствует `<article><div>Playwright</div></article>`.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-return"/><a href="#page-locator-return" class="list-anchor">#</a>

---

### opener {#page-opener}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.opener</x-search>

Возвращает страницу-открыватель (opener) для всплывающих страниц и `null` для остальных. Если страница-открыватель уже была закрыта, также возвращается `null`.

**Использование**

```python
page.opener()
```

**Возвращает**
- [NoneType] | [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-opener-return"/><a href="#page-opener-return" class="list-anchor">#</a>

---

### page_errors {#page-page-errors}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.56</font><x-search>page.page_errors</x-search>

Возвращает до (в настоящее время) 200 последних ошибок страницы. Подробнее см. [page.on("pageerror")](/api/class-page.mdx#page-event-page-error).

**Использование**

```python
page.page_errors()
```

**Возвращает**
- [List]\[[Error]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-page-errors-return"/><a href="#page-page-errors-return" class="list-anchor">#</a>

---

### pause {#page-pause}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.pause</x-search>

Приостанавливает выполнение скрипта. Playwright прекращает выполнение скрипта и ждёт, пока пользователь либо нажмёт кнопку «Resume» в оверлее страницы, либо вызовет `playwright.resume()` в консоли DevTools.

Во время паузы пользователь может исследовать селекторы или выполнять ручные шаги. Возобновление продолжит выполнение исходного скрипта с места остановки.

:::note

Этот метод требует запуска Playwright в режиме с интерфейсом (headed mode) с ложным значением параметра [headless](/api/class-browsertype.mdx#browser-type-launch-option-headless).
:::

**Использование**

```python
page.pause()
```

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pause-return"/><a href="#page-pause-return" class="list-anchor">#</a>

---

### pdf {#page-pdf}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.pdf</x-search>

Возвращает буфер PDF.

`page.pdf()` генерирует PDF страницы с использованием CSS media `print`. Чтобы сгенерировать PDF с media `screen`, вызовите [page.emulate_media()](/api/class-page.mdx#page-emulate-media) перед вызовом `page.pdf()`:

:::note

По умолчанию `page.pdf()` генерирует PDF с изменёнными цветами для печати. Используйте свойство [`-webkit-print-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust), чтобы принудительно отрисовать точные цвета.
:::

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# генерирует PDF с типом media "screen".
page.emulate_media(media="screen")
page.pdf(path="page.pdf")
```

</TabItem>
<TabItem value="async">

```py
# генерирует PDF с типом media "screen".
await page.emulate_media(media="screen")
await page.pdf(path="page.pdf")
```

</TabItem>
</Tabs>

Параметры [width](/api/class-page.mdx#page-pdf-option-width), [height](/api/class-page.mdx#page-pdf-option-height) и [margin](/api/class-page.mdx#page-pdf-option-margin) принимают значения с указанием единиц измерения. Значения без указания единиц интерпретируются как пиксели.

Несколько примеров:
* `page.pdf({width: 100})` — печать с шириной 100 пикселей
* `page.pdf({width: '100px'})` — печать с шириной 100 пикселей
* `page.pdf({width: '10cm'})` — печать с шириной 10 сантиметров

Все возможные единицы измерения:
* `px` — пиксель
* `in` — дюйм
* `cm` — сантиметр
* `mm` — миллиметр

Параметры [format](/api/class-page.mdx#page-pdf-option-format):
* `Letter`: 8.5in x 11in
* `Legal`: 8.5in x 14in
* `Tabloid`: 11in x 17in
* `Ledger`: 17in x 11in
* `A0`: 33.1in x 46.8in
* `A1`: 23.4in x 33.1in
* `A2`: 16.54in x 23.4in
* `A3`: 11.7in x 16.54in
* `A4`: 8.27in x 11.7in
* `A5`: 5.83in x 8.27in
* `A6`: 4.13in x 5.83in

:::note

Разметка [header_template](/api/class-page.mdx#page-pdf-option-header-template) и [footer_template](/api/class-page.mdx#page-pdf-option-footer-template) имеет следующие ограничения: > 1. Теги `<script>` внутри шаблонов не выполняются. > 2. Стили страницы не видны внутри шаблонов.
:::

**Аргументы**
- `display_header_footer` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-display-header-footer"/><a href="#page-pdf-option-display-header-footer" class="list-anchor">#</a>
  
  Отображать колонтитулы. По умолчанию `false`.
- `footer_template` [str] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-footer-template"/><a href="#page-pdf-option-footer-template" class="list-anchor">#</a>
  
  HTML-шаблон нижнего колонтитула для печати. Должен использовать тот же формат, что и [header_template](/api/class-page.mdx#page-pdf-option-header-template).
- `format` [str] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-format"/><a href="#page-pdf-option-format" class="list-anchor">#</a>
  
  Формат бумаги. Если задан, имеет приоритет над параметрами [width](/api/class-page.mdx#page-pdf-option-width) и [height](/api/class-page.mdx#page-pdf-option-height). По умолчанию `'Letter'`.
- `header_template` [str] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-header-template"/><a href="#page-pdf-option-header-template" class="list-anchor">#</a>
  
  HTML-шаблон верхнего колонтитула для печати. Должен быть валидной HTML-разметкой со следующими классами для подстановки значений:
  * `'date'` — отформатированная дата печати
  * `'title'` — заголовок документа
  * `'url'` — адрес документа
  * `'pageNumber'` — номер текущей страницы
  * `'totalPages'` — общее количество страниц документа
- `height` [str] | [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-height"/><a href="#page-pdf-option-height" class="list-anchor">#</a>
  
  Высота бумаги, принимает значения с указанием единиц измерения.
- `landscape` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-landscape"/><a href="#page-pdf-option-landscape" class="list-anchor">#</a>
  
  Ориентация бумаги. По умолчанию `false`.
- `margin` [Dict] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-margin"/><a href="#page-pdf-option-margin" class="list-anchor">#</a>
  - `top` [str] | [float] *(необязательно)*
    
    Верхний отступ, принимает значения с указанием единиц. По умолчанию `0`.
  - `right` [str] | [float] *(необязательно)*
    
    Правый отступ, принимает значения с указанием единиц. По умолчанию `0`.
  - `bottom` [str] | [float] *(необязательно)*
    
    Нижний отступ, принимает значения с указанием единиц. По умолчанию `0`.
  - `left` [str] | [float] *(необязательно)*
    
    Левый отступ, принимает значения с указанием единиц. По умолчанию `0`.
  
  Отступы страницы, по умолчанию отсутствуют.
- `outline` [bool] *(необязательно)* <font size="2">Добавлено в: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-outline"/><a href="#page-pdf-option-outline" class="list-anchor">#</a>
  
  Встраивать ли структуру документа (outline) в PDF. По умолчанию `false`.
- `page_ranges` [str] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-page-ranges"/><a href="#page-pdf-option-page-ranges" class="list-anchor">#</a>
  
  Диапазоны страниц для печати, например `'1-5, 8, 11-13'`. По умолчанию пустая строка, что означает печать всех страниц.
- `path` [Union]\[[str], [pathlib.Path]\] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-path"/><a href="#page-pdf-option-path" class="list-anchor">#</a>
  
  Путь к файлу для сохранения PDF. Если путь относительный, он разрешается относительно текущего рабочего каталога. Если путь не указан, PDF не будет сохранён на диск.
- `prefer_css_page_size` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-prefer-css-page-size"/><a href="#page-pdf-option-prefer-css-page-size" class="list-anchor">#</a>
  
  Отдавать приоритет CSS-правилу `@page` над параметрами [width](/api/class-page.mdx#page-pdf-option-width), [height](/api/class-page.mdx#page-pdf-option-height) или [format](/api/class-page.mdx#page-pdf-option-format). По умолчанию `false`, при этом контент масштабируется под размер бумаги.
- `print_background` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-print-background"/><a href="#page-pdf-option-print-background" class="list-anchor">#</a>
  
  Печатать фоновые изображения. По умолчанию `false`.
- `scale` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-scale"/><a href="#page-pdf-option-scale" class="list-anchor">#</a>
  
  Масштаб рендеринга страницы. По умолчанию `1`. Значение должно быть в диапазоне от 0.1 до 2.
- `tagged` [bool] *(необязательно)* <font size="2">Добавлено в: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-tagged"/><a href="#page-pdf-option-tagged" class="list-anchor">#</a>
  
  Генерировать ли тегированный (доступный) PDF. По умолчанию `false`.
- `width` [str] | [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-width"/><a href="#page-pdf-option-width" class="list-anchor">#</a>
  
  Ширина бумаги, принимает значения с указанием единиц измерения.

**Возвращает**
- [bytes]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-return"/><a href="#page-pdf-return" class="list-anchor">#</a>

---

### reload {#page-reload}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.reload</x-search>

Этот метод перезагружает текущую страницу так же, как если бы пользователь инициировал обновление браузера. Возвращает ответ основного ресурса. В случае нескольких редиректов навигация завершится ответом последнего редиректа.

**Использование**

```python
page.reload()
page.reload(**kwargs)
```

**Аргументы**
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-timeout"/><a href="#page-reload-option-timeout" class="list-anchor">#</a>
  
  Максимальное время выполнения операции в миллисекундах, по умолчанию 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-wait-until"/><a href="#page-reload-option-wait-until" class="list-anchor">#</a>
  
  Когда считать операцию завершённой. По умолчанию `load`. Возможные события:
  * `'domcontentloaded'` — операция считается завершённой при срабатывании события `DOMContentLoaded`.
  * `'load'` — операция считается завершённой при срабатывании события `load`.
  * `'networkidle'` — **НЕ РЕКОМЕНДУЕТСЯ**: операция считается завершённой, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте для тестирования — вместо этого полагайтесь на веб-ассерты.
  * `'commit'` — операция считается завершённой при получении сетевого ответа и начале загрузки документа.

**Возвращает**
- [NoneType] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-return"/><a href="#page-reload-return" class="list-anchor">#</a>

---

### remove_locator_handler {#page-remove-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.44</font><x-search>page.remove_locator_handler</x-search>

Удаляет все обработчики локаторов, добавленные с помощью [page.add_locator_handler()](/api/class-page.mdx#page-add-locator-handler), для указанного локатора.

**Использование**

```python
page.remove_locator_handler(locator)
```

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-option-locator"/><a href="#page-remove-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, переданный в [page.add_locator_handler()](/api/class-page.mdx#page-add-locator-handler).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-return"/><a href="#page-remove-locator-handler-return" class="list-anchor">#</a>

---

### request_gc {#page-request-gc}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>page.request_gc</x-search>

Запрашивает выполнение сборки мусора на странице. Обратите внимание, что нет гарантии, что все недостижимые объекты будут собраны.

Это полезно для обнаружения утечек памяти. Например, если на странице есть большой объект `'suspect'`, который может утекать, вы можете проверить отсутствие утечки, используя [`WeakRef`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef).

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# 1. На странице сохраняем WeakRef для объекта "suspect".
page.evaluate("globalThis.suspectWeakRef = new WeakRef(suspect)")
# 2. Запрашиваем сборку мусора.
page.request_gc()
# 3. Проверяем, что weak ref больше не указывает на исходный объект.
assert page.evaluate("!globalThis.suspectWeakRef.deref()")
```

</TabItem>
<TabItem value="async">

```py
# 1. На странице сохраняем WeakRef для объекта "suspect".
await page.evaluate("globalThis.suspectWeakRef = new WeakRef(suspect)")
# 2. Запрашиваем сборку мусора.
await page.request_gc()
# 3. Проверяем, что weak ref больше не указывает на исходный объект.
assert await page.evaluate("!globalThis.suspectWeakRef.deref()")
```

</TabItem>
</Tabs>

**Использование**

```python
page.request_gc()
```

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-request-gc-return"/><a href="#page-request-gc-return" class="list-anchor">#</a>

---

### requests {#page-requests}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.56</font><x-search>page.requests</x-search>

Возвращает до (в настоящее время) 100 последних сетевых запросов с этой страницы. Подробнее см. [page.on("request")](/api/class-page.mdx#page-event-request).

Возвращённые запросы следует использовать сразу, иначе они могут быть собраны для предотвращения неограниченного роста памяти по мере поступления новых запросов. После сборки получение большей части информации о запросе становится невозможным.

Обратите внимание, что запросы, сообщаемые через [page.on("request")](/api/class-page.mdx#page-event-request), не собираются, поэтому существует компромисс между эффективным использованием памяти с [page.requests()](/api/class-page.mdx#page-requests) и объёмом доступной информации через [page.on("request")](/api/class-page.mdx#page-event-request).

**Использование**

```python
page.requests()
```

**Возвращает**
- [List]\[[Request]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-requests-return"/><a href="#page-requests-return" class="list-anchor">#</a>

---

### route {#page-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.route</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, выполняемые страницей.

После включения маршрутизации каждый запрос, соответствующий шаблону URL, будет приостановлен, пока он не будет продолжен, выполнен (fulfilled) или отменён (aborted).

:::note

Обработчик будет вызван только для первого URL, если ответ является редиректом.
:::

:::note
[page.route()](/api/class-page.mdx#page-route) не перехватывает запросы, обработанные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) задачу. Рекомендуется отключать Service Worker при использовании перехвата запросов, установив [service_workers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

:::note
[page.route()](/api/class-page.mdx#page-route) не перехватывает первый запрос всплывающей страницы. Используйте [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route).
:::

**Использование**

Пример наивного обработчика, который отменяет все запросы изображений:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page = browser.new_page()
page.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
page.goto("https://example.com")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
page = await browser.new_page()
await page.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
await page.goto("https://example.com")
await browser.close()
```

</TabItem>
</Tabs>

Или тот же пример с использованием регулярного выражения:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page = browser.new_page()
page.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
page.goto("https://example.com")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
page = await browser.new_page()
await page.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
await page.goto("https://example.com")
await browser.close()
```

</TabItem>
</Tabs>

Можно анализировать запрос, чтобы принять решение о действии маршрута. Например, подменять все запросы, содержащие определённые POST-данные, и пропускать остальные без изменений:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def handle_route(route: Route):
  if ("my-string" in route.request.post_data):
    route.fulfill(body="mocked-data")
  else:
    route.continue_()
page.route("/api/**", handle_route)
```

</TabItem>
<TabItem value="async">

```py
async def handle_route(route: Route):
  if ("my-string" in route.request.post_data):
    await route.fulfill(body="mocked-data")
  else:
    await route.continue_()
await page.route("/api/**", handle_route)
```

</TabItem>
</Tabs>

Маршруты страницы имеют приоритет над маршрутами контекста браузера (настроенными с помощью [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route)), если запрос соответствует обоим обработчикам.

Чтобы удалить маршрут вместе с обработчиком, используйте [page.unroute()](/api/class-page.mdx#page-unroute).

:::note

Включение маршрутизации отключает HTTP-кэш.
:::

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-url"/><a href="#page-route-option-url" class="list-anchor">#</a>
  
  Glob-шаблон, регулярное выражение или предикат, принимающий [URL] для сопоставления при маршрутизации. Если в параметрах контекста задан [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) и переданный URL — строка, не начинающаяся с `*`, он разрешается с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `handler` [Callable]\[[Route], [Request]\]:[Promise]\[[Any]\] | [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-handler"/><a href="#page-route-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации запроса.
- `times` [int] *(необязательно)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-times"/><a href="#page-route-option-times" class="list-anchor">#</a>
  
  Сколько раз должен использоваться маршрут. По умолчанию используется каждый раз.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-return"/><a href="#page-route-return" class="list-anchor">#</a>

---

### route_from_har {#page-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>page.route_from_har</x-search>

Если указано, сетевые запросы, выполняемые на странице, будут обслуживаться из HAR-файла. Подробнее см. [Воспроизведение из HAR](../mock.mdx#replaying-from-har).

Playwright не обслуживает из HAR-файла запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) задачу. Рекомендуется отключать Service Worker при использовании перехвата запросов, установив [service_workers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```python
page.route_from_har(har)
page.route_from_har(har, **kwargs)
```

**Аргументы**
- `har` [Union]\[[str], [pathlib.Path]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-har"/><a href="#page-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec)-файлу с заранее записанными сетевыми данными. Если путь относительный, он разрешается относительно текущего рабочего каталога.
- `not_found` "abort" | "fallback" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-not-found"/><a href="#page-route-from-har-option-not-found" class="list-anchor">#</a>
  * При значении `'abort'` любой запрос, отсутствующий в HAR-файле, будет отменён.
  * При значении `'fallback'` отсутствующие запросы будут отправлены в сеть.
  
  По умолчанию `'abort'`.
- `update` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update"/><a href="#page-route-from-har-option-update" class="list-anchor">#</a>
  
  Если указано, обновляет переданный HAR фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск при вызове [browser_context.close()](/api/class-browsercontext.mdx#browser-context-close).
- `update_content` "embed" | "attach" *(необязательно)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-content"/><a href="#page-route-from-har-option-update-content" class="list-anchor">#</a>
  
  Необязательная настройка управления контентом ресурсов. При значении `attach` ресурсы сохраняются как отдельные файлы или записи в ZIP-архиве. При значении `embed` контент сохраняется непосредственно внутри HAR-файла.
- `update_mode` "full" | "minimal" *(необязательно)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-mode"/><a href="#page-route-from-har-option-update-mode" class="list-anchor">#</a>
  
  При значении `minimal` записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, тайминги, страницы, cookies, безопасность и другие данные HAR, которые не используются при воспроизведении. По умолчанию `minimal`.
- `url` [str] | [Pattern] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-url"/><a href="#page-route-from-har-option-url" class="list-anchor">#</a>
  
  Glob-шаблон, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR-файла. Если не указано, все запросы обслуживаются из HAR-файла.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-return"/><a href="#page-route-from-har-return" class="list-anchor">#</a>

---

### route_web_socket {#page-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>page.route_web_socket</x-search>

Этот метод позволяет модифицировать WebSocket‑соединения, которые создаются страницей.

Обратите внимание, что маршрутизироваться будут только те `WebSocket`, которые созданы **после** вызова этого метода. Рекомендуется вызывать этот метод до навигации по странице.

**Использование**

Ниже приведён пример простого мока, который отвечает на одно сообщение. См. [WebSocketRoute] для получения дополнительных сведений и примеров.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  if message == "request":
    ws.send("response")

def handler(ws: WebSocketRoute):
  ws.on_message(lambda message: message_handler(ws, message))

page.route_web_socket("/ws", handler)
```

</TabItem>
<TabItem value="async">

```py
def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  if message == "request":
    ws.send("response")

def handler(ws: WebSocketRoute):
  ws.on_message(lambda message: message_handler(ws, message))

await page.route_web_socket("/ws", handler)
```

</TabItem>
</Tabs>

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-url"/><a href="#page-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket‑соединения с URL, соответствующим этому шаблону, будут маршрутизироваться. Строковый шаблон может быть относительным к параметру контекста [base_url](/api/class-browser.mdx#browser-new-context-option-base-url).
- `handler` [Callable]\[[WebSocketRoute]\]:[Promise]\[[Any]\] | [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-handler"/><a href="#page-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-return"/><a href="#page-route-web-socket-return" class="list-anchor">#</a>

---

### screenshot {#page-screenshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.screenshot</x-search>

Возвращает буфер с полученным снимком экрана.

**Использование**

```python
page.screenshot()
page.screenshot(**kwargs)
```

**Аргументы**
- `animations` "disabled" | "allow" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-animations"/><a href="#page-screenshot-option-animations" class="list-anchor">#</a>
  
  При значении `"disabled"` останавливаются CSS‑анимации, CSS‑переходы и Web Animations. Анимации обрабатываются по‑разному в зависимости от их длительности:
  * конечные анимации перематываются до завершения, поэтому будет сгенерировано событие `transitionend`;
  * бесконечные анимации отменяются и переводятся в начальное состояние, а затем возобновляются после снятия скриншота.
  
  По умолчанию используется `"allow"`, что оставляет анимации без изменений.
- `caret` "hide" | "initial" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-caret"/><a href="#page-screenshot-option-caret" class="list-anchor">#</a>
  
  При значении `"hide"` на скриншоте будет скрыт текстовый курсор. При значении `"initial"` поведение курсора не изменяется. По умолчанию используется `"hide"`.
- `clip` [Dict] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-clip"/><a href="#page-screenshot-option-clip" class="list-anchor">#</a>
  - `x` [float]
    
    x‑координата левого верхнего угла области обрезки
  - `y` [float]
    
    y‑координата левого верхнего угла области обрезки
  - `width` [float]
    
    ширина области обрезки
  - `height` [float]
    
    высота области обрезки
  
  Объект, задающий обрезку результирующего изображения.
- `full_page` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-full-page"/><a href="#page-screenshot-option-full-page" class="list-anchor">#</a>
  
  Если установлено в `true`, делается снимок всей прокручиваемой страницы, а не только текущего видимого viewport. По умолчанию `false`.
- `mask` [List]\[[Locator]\] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask"/><a href="#page-screenshot-option-mask" class="list-anchor">#</a>
  
  Указывает локаторы элементов, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут перекрыты розовым прямоугольником `#FF00FF` (настраивается с помощью [mask_color](/api/class-page.mdx#page-screenshot-option-mask-color)), полностью покрывающим их ограничивающий прямоугольник. Маска также применяется к невидимым элементам; см. [Соответствие только видимым элементам](../locators.mdx#matching-only-visible-elements), чтобы отключить это поведение.
- `mask_color` [str] *(необязательно)* <font size="2">Добавлено в: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask-color"/><a href="#page-screenshot-option-mask-color" class="list-anchor">#</a>
  
  Цвет перекрывающего прямоугольника для замаскированных элементов в [CSS‑формате цвета](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию — розовый `#FF00FF`.
- `omit_background` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-omit-background"/><a href="#page-screenshot-option-omit-background" class="list-anchor">#</a>
  
  Скрывает стандартный белый фон и позволяет получать скриншоты с прозрачностью. Не применяется к изображениям `jpeg`. По умолчанию `false`.
- `path` [Union]\[[str], [pathlib.Path]\] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-path"/><a href="#page-screenshot-option-path" class="list-anchor">#</a>
  
  Путь к файлу, в который будет сохранено изображение. Тип скриншота определяется по расширению файла. Если [path](/api/class-page.mdx#page-screenshot-option-path) является относительным, он разрешается относительно текущего рабочего каталога. Если путь не указан, изображение не будет сохранено на диск.
- `quality` [int] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-quality"/><a href="#page-screenshot-option-quality" class="list-anchor">#</a>
  
  Качество изображения в диапазоне 0–100. Не применяется к изображениям `png`.
- `scale` "css" | "device" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-scale"/><a href="#page-screenshot-option-scale" class="list-anchor">#</a>
  
  При значении `"css"` скриншот будет иметь один пиксель на каждый CSS‑пиксель страницы. Для устройств с высоким DPI это позволяет уменьшить размер скриншотов. Использование `"device"` создаёт один пиксель на каждый пиксель устройства, поэтому скриншоты на high‑DPI устройствах будут вдвое больше или даже больше.
  
  По умолчанию используется `"device"`.
- `style` [str] *(необязательно)* <font size="2">Добавлено в: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-style"/><a href="#page-screenshot-option-style" class="list-anchor">#</a>
  
  Текст таблицы стилей, которая применяется во время создания скриншота. Здесь можно скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы получить воспроизводимые скриншоты. Эта таблица стилей проникает в Shadow DOM и применяется к внутренним фреймам.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-timeout"/><a href="#page-screenshot-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `type` "png" | "jpeg" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-type"/><a href="#page-screenshot-option-type" class="list-anchor">#</a>
  
  Тип скриншота. По умолчанию `png`.

**Возвращает**
- [bytes]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-return"/><a href="#page-screenshot-return" class="list-anchor">#</a>

---

### set_content {#page-set-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.set_content</x-search>

Этот метод внутри себя вызывает [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), наследуя все его особенности и поведение.

**Использование**

```python
page.set_content(html)
page.set_content(html, **kwargs)
```

**Аргументы**
- `html` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-html"/><a href="#page-set-content-option-html" class="list-anchor">#</a>
  
  HTML‑разметка, которая будет назначена странице.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-timeout"/><a href="#page-set-content-option-timeout" class="list-anchor">#</a>
  
  Максимальное время выполнения операции в миллисекундах, по умолчанию 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-wait-until"/><a href="#page-set-content-option-wait-until" class="list-anchor">#</a>
  
  Когда считать операцию успешно завершённой. По умолчанию `load`. Возможные события:
  * `'domcontentloaded'` — считать операцию завершённой, когда срабатывает событие `DOMContentLoaded`;
  * `'load'` — считать операцию завершённой, когда срабатывает событие `load`;
  * `'networkidle'` — **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершённой, когда в течение как минимум `500` мс отсутствуют сетевые соединения. Не используйте этот метод для тестирования — вместо этого полагайтесь на веб‑проверки;
  * `'commit'` — считать операцию завершённой, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-return"/><a href="#page-set-content-return" class="list-anchor">#</a>

---

### set_default_navigation_timeout {#page-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.set_default_navigation_timeout</x-search>

Эта настройка изменяет максимальное время навигации по умолчанию для следующих методов и связанных с ними сокращений:
* [page.go_back()](/api/class-page.mdx#page-go-back)
* [page.go_forward()](/api/class-page.mdx#page-go-forward)
* [page.goto()](/api/class-page.mdx#page-goto)
* [page.reload()](/api/class-page.mdx#page-reload)
* [page.set_content()](/api/class-page.mdx#page-set-content)
* [page.expect_navigation()](/api/class-page.mdx#page-wait-for-navigation)
* [page.wait_for_url()](/api/class-page.mdx#page-wait-for-url)

:::note

[page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) и [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```python
page.set_default_navigation_timeout(timeout)
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-navigation-timeout-option-timeout"/><a href="#page-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### set_default_timeout {#page-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.set_default_timeout</x-search>

Эта настройка изменяет максимальное время по умолчанию для всех методов, принимающих параметр [timeout](/api/class-page.mdx#page-set-default-timeout-option-timeout).

:::note

[page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
:::

**Использование**

```python
page.set_default_timeout(timeout)
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-timeout-option-timeout"/><a href="#page-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить таймаут.

---

### set_extra_http_headers {#page-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.set_extra_http_headers</x-search>

Дополнительные HTTP‑заголовки будут отправляться с каждым запросом, который инициирует страница.

:::note

[page.set_extra_http_headers()](/api/class-page.mdx#page-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```python
page.set_extra_http_headers(headers)
```

**Аргументы**
- `headers` [Dict]\[[str], [str]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-option-headers"/><a href="#page-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP‑заголовки, которые будут отправляться с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-return"/><a href="#page-set-extra-http-headers-return" class="list-anchor">#</a>

---

### set_viewport_size {#page-set-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.set_viewport_size</x-search>

В случае нескольких страниц в одном браузере каждая страница может иметь собственный размер viewport. Однако [browser.new_context()](/api/class-browser.mdx#browser-new-context) позволяет задать размер viewport (и другие параметры) сразу для всех страниц в контексте.

[page.set_viewport_size()](/api/class-page.mdx#page-set-viewport-size) изменяет размер страницы. Многие сайты не ожидают, что размеры «телефона» будут меняться, поэтому рекомендуется задавать размер viewport до навигации на страницу. [page.set_viewport_size()](/api/class-page.mdx#page-set-viewport-size) также сбрасывает размер `screen`; используйте [browser.new_context()](/api/class-browser.mdx#browser-new-context) с параметрами `screen` и `viewport`, если вам нужен более точный контроль этих свойств.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page = browser.new_page()
page.set_viewport_size({"width": 640, "height": 480})
page.goto("https://example.com")
```

</TabItem>
<TabItem value="async">

```py
page = await browser.new_page()
await page.set_viewport_size({"width": 640, "height": 480})
await page.goto("https://example.com")
```

</TabItem>
</Tabs>

**Аргументы**
- `viewport_size` [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-option-viewport-size"/><a href="#page-set-viewport-size-option-viewport-size" class="list-anchor">#</a>
  - `width` [int]
    
    ширина страницы в пикселях
  - `height` [int]
    
    высота страницы в пикселях

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-return"/><a href="#page-set-viewport-size-return" class="list-anchor">#</a>

---

### title {#page-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.title</x-search>

Возвращает заголовок страницы.

**Использование**

```python
page.title()
```

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-title-return"/><a href="#page-title-return" class="list-anchor">#</a>

---

### unroute {#page-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.unroute</x-search>

Удаляет маршрут, созданный с помощью [page.route()](/api/class-page.mdx#page-route). Если [handler](/api/class-page.mdx#page-unroute-option-handler) не указан, удаляются все маршруты для указанного [url](/api/class-page.mdx#page-unroute-option-url).

**Использование**

```python
page.unroute(url)
page.unroute(url, **kwargs)
```

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-url"/><a href="#page-unroute-option-url" class="list-anchor">#</a>
  
  Glob‑шаблон, регулярное выражение или предикат, принимающий [URL], для сопоставления при маршрутизации.
- `handler` [Callable]\[[Route], [Request]\]:[Promise]\[[Any]\] | [Any] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-handler"/><a href="#page-unroute-option-handler" class="list-anchor">#</a>
  
  Необязательная функция‑обработчик для маршрутизации запроса.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-return"/><a href="#page-unroute-return" class="list-anchor">#</a>

---

### unroute_all {#page-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.41</font><x-search>page.unroute_all</x-search>

Удаляет все маршруты, созданные с помощью [page.route()](/api/class-page.mdx#page-route) и [page.route_from_har()](/api/class-page.mdx#page-route-from-har).

**Использование**

```python
page.unroute_all()
page.unroute_all(**kwargs)
```

**Аргументы**
- `behavior` "wait" | "ignoreErrors" | "default" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-option-behavior"/><a href="#page-unroute-all-option-behavior" class="list-anchor">#</a>
  
  Определяет, нужно ли ждать завершения уже выполняющихся обработчиков и как обрабатывать возникающие в них ошибки:
  * `'default'` — не ждать завершения текущих вызовов обработчиков (если они есть); если обработчик после удаления маршрута выбросит ошибку, это может привести к необработанному исключению;
  * `'wait'` — дождаться завершения текущих вызовов обработчиков (если они есть);
  * `'ignoreErrors'` — не ждать завершения текущих вызовов обработчиков (если они есть); все ошибки, выброшенные обработчиками после удаления маршрута, будут молча перехвачены.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-return"/><a href="#page-unroute-all-return" class="list-anchor">#</a>

---

### wait_for_event {#page-wait-for-event-2}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.wait_for_event</x-search>

:::note

В большинстве случаев следует использовать [page.expect_event()](/api/class-page.mdx#page-wait-for-event).
:::

Ожидает срабатывания указанного `event`. Если передан предикат, значение события передаётся в функцию `predicate`, и ожидание продолжается до тех пор, пока `predicate(event)` не вернёт истинное значение. Будет выброшена ошибка, если страница будет закрыта до срабатывания события.

**Использование**

```python
page.wait_for_event(event)
page.wait_for_event(event, **kwargs)
```

**Аргументы**
- `event` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-2-option-event"/><a href="#page-wait-for-event-2-option-event" class="list-anchor">#</a>
  
  Имя события — такое же, какое обычно передаётся в `*.on(event)`.
- `predicate` [Callable] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-2-option-predicate"/><a href="#page-wait-for-event-2-option-predicate" class="list-anchor">#</a>
  
  Получает данные события и должна вернуть истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-2-option-timeout"/><a href="#page-wait-for-event-2-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-2-return"/><a href="#page-wait-for-event-2-return" class="list-anchor">#</a>

---

### wait_for_function {#page-wait-for-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.wait_for_function</x-search>

Возвращает управление, когда [expression](/api/class-page.mdx#page-wait-for-function-option-expression) возвращает истинное значение. Метод резолвится в `JSHandle` этого истинного значения.

**Использование**

Метод [page.wait_for_function()](/api/class-page.mdx#page-wait-for-function) можно использовать для отслеживания изменения размера viewport:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch()
    page = browser.new_page()
    page.evaluate("window.x = 0; setTimeout(() => { window.x = 100 }, 1000);")
    page.wait_for_function("() => window.x > 0")
    browser.close()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch()
    page = await browser.new_page()
    await page.evaluate("window.x = 0; setTimeout(() => { window.x = 100 }, 1000);")
    await page.wait_for_function("() => window.x > 0")
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

Чтобы передать аргумент в предикат функции [page.wait_for_function()](/api/class-page.mdx#page-wait-for-function):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
selector = ".foo"
page.wait_for_function("selector => !!document.querySelector(selector)", selector)
```

</TabItem>
<TabItem value="async">

```py
selector = ".foo"
await page.wait_for_function("selector => !!document.querySelector(selector)", selector)
```

</TabItem>
</Tabs>

**Аргументы**
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-expression"/><a href="#page-wait-for-function-option-expression" class="list-anchor">#</a>
  
  JavaScript‑выражение, которое будет выполнено в контексте браузера. Если выражение вычисляется в функцию, она будет автоматически вызвана.
- `arg` [EvaluationArgument] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-arg"/><a href="#page-wait-for-function-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент, передаваемый в [expression](/api/class-page.mdx#page-wait-for-function-option-expression).
- `polling` [float] | "raf" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-polling"/><a href="#page-wait-for-function-option-polling" class="list-anchor">#</a>
  
  Если значение [polling](/api/class-page.mdx#page-wait-for-function-option-polling) равно `'raf'`, то [expression](/api/class-page.mdx#page-wait-for-function-option-expression) будет постоянно выполняться в колбэке `requestAnimationFrame`. Если [polling](/api/class-page.mdx#page-wait-for-function-option-polling) является числом, оно трактуется как интервал в миллисекундах, с которым будет выполняться функция. По умолчанию используется `raf`.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-timeout"/><a href="#page-wait-for-function-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-return"/><a href="#page-wait-for-function-return" class="list-anchor">#</a>

---

### wait_for_load_state {#page-wait-for-load-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.wait_for_load_state</x-search>

Возвращает управление, когда достигнуто требуемое состояние загрузки.

Метод завершается, когда страница достигает требуемого состояния загрузки — по умолчанию `load`. Навигация должна быть зафиксирована (committed) на момент вызова этого метода. Если текущий документ уже достиг требуемого состояния, метод завершается немедленно.

:::note

В большинстве случаев этот метод не требуется, так как Playwright [автоматически ожидает перед каждым действием](../actionability.mdx).
:::

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_role("button").click() # клик инициирует навигацию
page.wait_for_load_state() # промис завершается после события "load"
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("button").click() # клик инициирует навигацию
await page.wait_for_load_state() # промис завершается после события "load"
```

</TabItem>
</Tabs>

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_popup() as page_info:
    page.get_by_role("button").click() # click triggers a popup.
popup = page_info.value
# Wait for the "DOMContentLoaded" event.
popup.wait_for_load_state("domcontentloaded")
print(popup.title()) # popup is ready to use.
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_popup() as page_info:
    await page.get_by_role("button").click() # click triggers a popup.
popup = await page_info.value
# Wait for the "DOMContentLoaded" event.
await popup.wait_for_load_state("domcontentloaded")
print(await popup.title()) # popup is ready to use.
```

</TabItem>
</Tabs>

**Аргументы**
- `state` "load" | "domcontentloaded" | "networkidle" (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-state"/><a href="#page-wait-for-load-state-option-state" class="list-anchor">#</a>
  
  Необязательное состояние загрузки, ожидание которого нужно выполнить; по умолчанию `load`. Если указанное состояние уже было достигнуто во время загрузки текущего документа, метод завершается сразу. Возможные значения:
  * `'load'` — дождаться срабатывания события `load`.
  * `'domcontentloaded'` — дождаться срабатывания события `DOMContentLoaded`.
  * `'networkidle'` — **НЕ РЕКОМЕНДУЕТСЯ** ждать, пока в течение как минимум `500` мс не останется сетевых соединений. Не используйте этот метод для тестирования; вместо этого полагайтесь на веб-утверждения (assertions), чтобы оценить готовность.
- `timeout` [float] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-timeout"/><a href="#page-wait-for-load-state-option-timeout" class="list-anchor">#</a>
  
  Максимальное время выполнения операции в миллисекундах; по умолчанию 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-return"/><a href="#page-wait-for-load-state-return" class="list-anchor">#</a>

---

### wait_for_url {#page-wait-for-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>page.wait_for_url</x-search>

Ожидает, пока главный фрейм выполнит навигацию к указанному URL.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.click("a.delayed-navigation") # клик по ссылке косвенно вызовет навигацию
page.wait_for_url("**/target.html")
```

</TabItem>
<TabItem value="async">

```py
await page.click("a.delayed-navigation") # клик по ссылке косвенно вызовет навигацию
await page.wait_for_url("**/target.html")
```

</TabItem>
</Tabs>

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-url"/><a href="#page-wait-for-url-option-url" class="list-anchor">#</a>
  
  Glob‑шаблон, регулярное выражение или предикат, принимающий [URL], для сопоставления во время ожидания навигации. Обратите внимание: если параметр — строка без wildcard‑символов, метод будет ожидать навигацию к URL, который в точности равен этой строке.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-timeout"/><a href="#page-wait-for-url-option-timeout" class="list-anchor">#</a>
  
  Максимальное время выполнения операции в миллисекундах. По умолчанию — 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-wait-until"/><a href="#page-wait-for-url-option-wait-until" class="list-anchor">#</a>
  
  Указывает, когда считать операцию успешно завершённой. По умолчанию — `load`. Возможные события:
  * `'domcontentloaded'` — считать операцию завершённой при срабатывании события `DOMContentLoaded`.
  * `'load'` — считать операцию завершённой при срабатывании события `load`.
  * `'networkidle'` — **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершённой, когда отсутствуют сетевые соединения как минимум `500` мс. Не используйте этот метод для тестирования, вместо этого полагайтесь на веб‑проверки.
  * `'commit'` — считать операцию завершённой, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-return"/><a href="#page-wait-for-url-return" class="list-anchor">#</a>

---

## Свойства {#properties}

### clock {#page-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.45</font><x-search>page.clock</x-search>

Playwright предоставляет возможность подменять часы и ход времени.

**Использование**

```python
page.clock
```

**Тип**
- [Clock]

---

### context {#page-context}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.context</x-search>

Возвращает контекст браузера, к которому принадлежит страница.

**Использование**

```python
page.context
```

**Возвращает**
- [BrowserContext]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-context-return"/><a href="#page-context-return" class="list-anchor">#</a>

---

### frames {#page-frames}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.frames</x-search>

Массив всех фреймов, прикреплённых к странице.

**Использование**

```python
page.frames
```

**Возвращает**
- [List]\[[Frame]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frames-return"/><a href="#page-frames-return" class="list-anchor">#</a>

---

### is_closed {#page-is-closed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.is_closed</x-search>

Указывает, что страница была закрыта.

**Использование**

```python
page.is_closed()
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-closed-return"/><a href="#page-is-closed-return" class="list-anchor">#</a>

---

### keyboard {#page-keyboard}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.keyboard</x-search>

**Использование**

```python
page.keyboard
```

**Тип**
- [Keyboard]

---

### main_frame {#page-main-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.main_frame</x-search>

Главный фрейм страницы. У страницы всегда есть главный фрейм, который сохраняется при навигациях.

**Использование**

```python
page.main_frame
```

**Возвращает**
- [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-main-frame-return"/><a href="#page-main-frame-return" class="list-anchor">#</a>

---

### mouse {#page-mouse}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.mouse</x-search>

**Использование**

```python
page.mouse
```

**Тип**
- [Mouse]

---

### request {#page-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.16</font><x-search>page.request</x-search>

Вспомогательный API для тестирования запросов, связанный с этой страницей. Метод возвращает тот же экземпляр, что и [browser_context.request](/api/class-browsercontext.mdx#browser-context-request) в контексте страницы. Подробнее см. [browser_context.request](/api/class-browsercontext.mdx#browser-context-request).

**Использование**

```python
page.request
```

**Тип**
- [APIRequestContext]

---

### touchscreen {#page-touchscreen}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.touchscreen</x-search>

**Использование**

```python
page.touchscreen
```

**Тип**
- [Touchscreen]

---

### url {#page-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.url</x-search>

**Использование**

```python
page.url
```

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-url-return"/><a href="#page-url-return" class="list-anchor">#</a>

---

### video {#page-video}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.video</x-search>

Объект видео, связанный с этой страницей.

**Использование**

```python
page.video
```

**Возвращает**
- [NoneType] | [Video]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-video-return"/><a href="#page-video-return" class="list-anchor">#</a>

---

### viewport_size {#page-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.viewport_size</x-search>

**Использование**

```python
page.viewport_size
```

**Возвращает**
- [NoneType] | [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-viewport-size-return"/><a href="#page-viewport-size-return" class="list-anchor">#</a>
  - `width` [int]
    
    ширина страницы в пикселях.
  - `height` [int]
    
    высота страницы в пикселях.

---

### workers {#page-workers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.workers</x-search>

Метод возвращает все выделенные [WebWorkers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API), связанные со страницей.

:::note

ServiceWorker’ы сюда не входят
:::

**Использование**

```python
page.workers
```

**Возвращает**
- [List]\[[Worker]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-workers-return"/><a href="#page-workers-return" class="list-anchor">#</a>

---

## События {#events}

### on("close") {#page-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("close")</x-search>

Испускается, когда страница закрывается.

**Использование**

```python
page.on("close", handler)
```

**Данные события**
- [Page]

---

### on("console") {#page-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("console")</x-search>

Испускается, когда JavaScript на странице вызывает один из методов console API, например `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def print_args(msg):
    for arg in msg.args:
        print(arg.json_value())

page.on("console", print_args)
page.evaluate("console.log('hello', 5, { foo: 'bar' })")
```

</TabItem>
<TabItem value="async">

```py
async def print_args(msg):
    values = []
    for arg in msg.args:
        values.append(await arg.json_value())
    print(values)

page.on("console", print_args)
await page.evaluate("console.log('hello', 5, { foo: 'bar' })")
```

</TabItem>
</Tabs>

**Данные события**
- [ConsoleMessage]

---

### on("crash") {#page-event-crash}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("crash")</x-search>

Испускается при аварийном завершении страницы. Страницы браузера могут падать, если пытаются выделить слишком много памяти. После сбоя страницы текущие и последующие операции будут выбрасывать исключения.

Наиболее распространённый способ обработки сбоев — перехват исключения:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
try:
    # сбой может произойти во время клика.
    page.click("button")
    # или во время ожидания события.
    page.wait_for_event("popup")
except Error as e:
    pass
    # при сбое страницы сообщение исключения содержит "crash".
```

</TabItem>
<TabItem value="async">

```py
try:
    # сбой может произойти во время клика.
    await page.click("button")
    # или во время ожидания события.
    await page.wait_for_event("popup")
except Error as e:
    pass
    # при сбое страницы сообщение исключения содержит "crash".
```

</TabItem>
</Tabs>

**Использование**

```python
page.on("crash", handler)
```

**Данные события**
- [Page]

---

### on("dialog") {#page-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("dialog")</x-search>

Испускается при появлении JavaScript‑диалога, такого как `alert`, `prompt`, `confirm` или `beforeunload`. Обработчик **обязан** либо вызвать [dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) — иначе страница [зависнет](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking) в ожидании диалога, и такие действия, как клик, никогда не завершатся.

**Использование**

```python
page.on("dialog", lambda dialog: dialog.accept())
```

:::note
Если отсутствуют обработчики [page.on("dialog")](/api/class-page.mdx#page-event-dialog) или [browser_context.on("dialog")](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### on("domcontentloaded") {#page-event-dom-content-loaded}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("domcontentloaded")</x-search>

Испускается при отправке JavaScript‑события [`DOMContentLoaded`](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded).

**Использование**

```python
page.on("domcontentloaded", handler)
```

**Данные события**
- [Page]

---

### on("download") {#page-event-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("download")</x-search>

Испускается при начале загрузки вложения. Пользователь может выполнять базовые файловые операции с загруженным содержимым через переданный экземпляр [Download].

**Использование**

```python
page.on("download", handler)
```

**Данные события**
- [Download]

---

### on("filechooser") {#page-event-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("filechooser")</x-search>

Испускается, когда должен появиться диалог выбора файла, например после клика по `<input type=file>`. Playwright может обработать его, установив файлы для загрузки с помощью [file_chooser.set_files()](/api/class-filechooser.mdx#file-chooser-set-files).

```py
page.on("filechooser", lambda file_chooser: file_chooser.set_files("/tmp/myfile.pdf"))
```

**Использование**

```python
page.on("filechooser", handler)
```

**Данные события**
- [FileChooser]

---

### on("frameattached") {#page-event-frame-attached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("frameattached")</x-search>

Испускается при присоединении фрейма.

**Использование**

```python
page.on("frameattached", handler)
```

**Данные события**
- [Frame]

---

### on("framedetached") {#page-event-frame-detached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("framedetached")</x-search>

Срабатывает, когда фрейм был отсоединён.

**Использование**

```python
page.on("framedetached", handler)
```

**Данные события**
- [Frame]

---

### on("framenavigated") {#page-event-frame-navigated}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("framenavigated")</x-search>

Срабатывает, когда фрейм переходит на новый URL.

**Использование**

```python
page.on("framenavigated", handler)
```

**Данные события**
- [Frame]

---

### on("load") {#page-event-load}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("load")</x-search>

Срабатывает, когда происходит JavaScript‑событие [`load`](https://developer.mozilla.org/en-US/docs/Web/Events/load).

**Использование**

```python
page.on("load", handler)
```

**Данные события**
- [Page]

---

### on("pageerror") {#page-event-page-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("pageerror")</x-search>

Срабатывает, когда на странице происходит неперехваченное исключение.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Логируем все неперехваченные ошибки в терминал
page.on("pageerror", lambda exc: print(f"uncaught exception: {exc}"))

# Переходим на страницу с исключением.
page.goto("data:text/html,<script>throw new Error('test')</script>")
```

</TabItem>
<TabItem value="async">

```py
# Логируем все неперехваченные ошибки в терминал
page.on("pageerror", lambda exc: print(f"uncaught exception: {exc}"))

# Переходим на страницу с исключением.
await page.goto("data:text/html,<script>throw new Error('test')</script>")
```

</TabItem>
</Tabs>

**Использование**

```python
page.on("pageerror", handler)
```

**Данные события**
- [Error]

---

### on("popup") {#page-event-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("popup")</x-search>

Срабатывает, когда страница открывает новую вкладку или окно. Это событие генерируется в дополнение к [browser_context.on("page")](/api/class-browsercontext.mdx#browser-context-event-page), но только для всплывающих окон, относящихся к данной странице.

Самый ранний момент, когда страница доступна, — это момент, когда она перешла на начальный URL. Например, при открытии popup с помощью `window.open('http://example.com')` это событие будет сгенерировано, когда сетевой запрос к `"http://example.com"` завершится и его ответ начнёт загружаться во всплывающем окне. Если вы хотите маршрутизировать или отслеживать этот сетевой запрос, используйте [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) и [browser_context.on("request")](/api/class-browsercontext.mdx#browser-context-event-request) вместо аналогичных методов на уровне [Page].

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_event("popup") as page_info:
    page.get_by_text("open the popup").click()
popup = page_info.value
print(popup.evaluate("location.href"))
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_event("popup") as page_info:
    await page.get_by_text("open the popup").click()
popup = await page_info.value
print(await popup.evaluate("location.href"))
```

</TabItem>
</Tabs>

:::note

Используйте [page.wait_for_load_state()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определённого состояния загрузки (в большинстве случаев это не требуется).
:::

**Использование**

```python
page.on("popup", handler)
```

**Данные события**
- [Page]

---

### on("request") {#page-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("request")</x-search>

Срабатывает, когда страница отправляет запрос. Объект [request] доступен только для чтения. Чтобы перехватывать и изменять запросы, используйте [page.route()](/api/class-page.mdx#page-route) или [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route).

**Использование**

```python
page.on("request", handler)
```

**Данные события**
- [Request]

---

### on("requestfailed") {#page-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("requestfailed")</x-search>

Срабатывает, когда запрос завершается неудачно, например из‑за тайм‑аута.

```python
page.on("requestfailed", lambda request: print(request.url + " " + request.failure.error_text))
```

:::note
HTTP‑ответы с ошибками, такие как 404 или 503, с точки зрения HTTP считаются успешными ответами, поэтому запрос завершится событием [page.on("requestfinished")](/api/class-page.mdx#page-event-request-finished), а не [page.on("requestfailed")](/api/class-page.mdx#page-event-request-failed). Запрос считается неудачным только в том случае, если клиент не может получить HTTP‑ответ от сервера, например из‑за сетевой ошибки `net::ERR_FAILED`.
:::

**Использование**

```python
page.on("requestfailed", handler)
```

**Данные события**
- [Request]

---

### on("requestfinished") {#page-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("requestfinished")</x-search>

Срабатывает, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий выглядит так: `request`, `response`, `requestfinished`.

**Использование**

```python
page.on("requestfinished", handler)
```

**Данные события**
- [Request]

---

### on("response") {#page-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("response")</x-search>

Срабатывает, когда для запроса получены статус и заголовки [response]. Для успешного ответа последовательность событий выглядит так: `request`, `response`, `requestfinished`.

**Использование**

```python
page.on("response", handler)
```

**Данные события**
- [Response]

---

### on("websocket") {#page-event-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("websocket")</x-search>

Срабатывает, когда отправляется запрос [WebSocket].

**Использование**

```python
page.on("websocket", handler)
```

**Данные события**
- [WebSocket]

---

### on("worker") {#page-event-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.on("worker")</x-search>

Срабатывает, когда страница создаёт выделенный [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API).

**Использование**

```python
page.on("worker", handler)
```

**Данные события**
- [Worker]

---

## Устаревшее {#deprecated}

### check {#page-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.check</x-search>

:::warning[Не рекомендуется]

Используйте локатор‑ориентированный метод [locator.check()](/api/class-locator.mdx#locator-check). Подробнее см. про [локаторы](../locators.mdx).

:::


Этот метод отмечает элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector), выполняя следующие шаги:
1. Находит элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector). Если такого элемента нет, ожидает, пока соответствующий элемент будет добавлен в DOM.
1. Убеждается, что найденный элемент является чекбоксом или радиокнопкой. Если нет — метод выбрасывает исключение. Если элемент уже отмечен, метод сразу возвращается.
1. Выполняет проверки [actionability](../actionability.mdx) для найденного элемента, если не установлен параметр [force](/api/class-page.mdx#page-check-option-force). Если элемент отсоединяется во время проверок, всё действие повторяется.
1. При необходимости прокручивает элемент в область видимости.
1. Использует [page.mouse](/api/class-page.mdx#page-mouse), чтобы кликнуть по центру элемента.
1. Убеждается, что элемент теперь отмечен. Если нет — метод выбрасывает исключение.

Если все шаги не завершились в течение указанного [timeout](/api/class-page.mdx#page-check-option-timeout), метод выбрасывает [TimeoutError]. Передача тайм‑аута `0` отключает ограничение по времени.

**Использование**

```python
page.check(selector)
page.check(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-selector"/><a href="#page-check-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `force` [bool] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-force"/><a href="#page-check-option-force" class="list-anchor">#</a>
  
  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-no-wait-after"/><a href="#page-check-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Эта опция не влияет на поведение.
  :::
  
  
  Эта опция не влияет на поведение.
- `position` [Dict] (опционально) <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-position"/><a href="#page-check-option-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Точка относительно верхнего левого угла padding-box элемента. Если не указана, используется какая-то видимая точка элемента.
- `strict` [bool] (опционально) <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-strict"/><a href="#page-check-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор однозначно соответствовал одному элементу. Если селектор соответствует более чем одному элементу, вызов выбрасывает исключение.
- `timeout` [float] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-timeout"/><a href="#page-check-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] (опционально) <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-trial"/><a href="#page-check-option-trial" class="list-anchor">#</a>
  
  Если задано, метод выполняет только проверки [actionability](../actionability.mdx) и пропускает само действие. По умолчанию `false`. Полезно, чтобы дождаться готовности элемента к действию, не выполняя его.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-return"/><a href="#page-check-return" class="list-anchor">#</a>

---

### click {#page-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.click</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов: [locator.click()](/api/class-locator.mdx#locator-click). Подробнее о [локаторах](../locators.mdx).

:::


Этот метод кликает по элементу, соответствующему [selector](/api/class-page.mdx#page-click-option-selector), выполняя следующие шаги:
1. Находит элемент, соответствующий [selector](/api/class-page.mdx#page-click-option-selector). Если такого элемента нет, ждёт, пока соответствующий элемент будет добавлен в DOM.
1. Ожидает прохождения проверок [actionability](../actionability.mdx) для найденного элемента, если не задана опция [force](/api/class-page.mdx#page-click-option-force). Если во время проверок элемент будет удалён из DOM, всё действие будет повторено.
1. При необходимости прокручивает страницу так, чтобы элемент оказался в области видимости.
1. Использует [page.mouse](/api/class-page.mdx#page-mouse), чтобы кликнуть по центру элемента или по указанной [position](/api/class-page.mdx#page-click-option-position).
1. Ожидает, пока инициированные переходы (navigation) завершатся успехом или ошибкой, если не задана опция [no_wait_after](/api/class-page.mdx#page-click-option-no-wait-after).

Если все шаги в совокупности не завершились за указанное время [timeout](/api/class-page.mdx#page-click-option-timeout), метод выбрасывает [TimeoutError]. Передайте нулевой таймаут, чтобы отключить его.

**Использование**

```python
page.click(selector)
page.click(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-selector"/><a href="#page-click-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `button` "left" | "right" | "middle" (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-button"/><a href="#page-click-option-button" class="list-anchor">#</a>
  
  По умолчанию `left`.
- `click_count` [int] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-click-count"/><a href="#page-click-option-click-count" class="list-anchor">#</a>
  
  По умолчанию 1. См. [UIEvent.detail].
- `delay` [float] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-delay"/><a href="#page-click-option-delay" class="list-anchor">#</a>
  
  Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
- `force` [bool] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-force"/><a href="#page-click-option-force" class="list-anchor">#</a>
  
  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `modifiers` [List]\["Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"\] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-modifiers"/><a href="#page-click-option-modifiers" class="list-anchor">#</a>
  
  Модификаторы клавиш, которые нужно зажать. Гарантирует, что во время операции будут нажаты только эти модификаторы, а затем восстанавливает прежнее состояние модификаторов. Если не указано, используются модификаторы, нажатые в данный момент. "ControlOrMeta" соответствует "Control" в Windows и Linux и "Meta" в macOS.
- `no_wait_after` [bool] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-no-wait-after"/><a href="#page-click-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  В будущем значение этой опции по умолчанию станет `true`.
  :::
  
  
  Действия, которые инициируют переходы (navigation), ждут, пока эти переходы произойдут и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Обычно он нужен только в исключительных случаях, например при переходе на недоступные страницы. По умолчанию `false`.
- `position` [Dict] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-position"/><a href="#page-click-option-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Точка относительно верхнего левого угла padding-box элемента. Если не указана, используется какая-то видимая точка элемента.
- `strict` [bool] (опционально) <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-strict"/><a href="#page-click-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор однозначно соответствовал одному элементу. Если селектор соответствует более чем одному элементу, вызов выбрасывает исключение.
- `timeout` [float] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-timeout"/><a href="#page-click-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] (опционально) <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-trial"/><a href="#page-click-option-trial" class="list-anchor">#</a>
  
  Если задано, метод выполняет только проверки [actionability](../actionability.mdx) и пропускает само действие. По умолчанию `false`. Полезно, чтобы дождаться готовности элемента к действию, не выполняя его. Обратите внимание: модификаторы клавиатуры `modifiers` будут нажаты независимо от `trial`, чтобы можно было тестировать элементы, которые видимы только при нажатых этих клавишах.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-return"/><a href="#page-click-return" class="list-anchor">#</a>

---

### dblclick {#page-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.dblclick</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов: [locator.dblclick()](/api/class-locator.mdx#locator-dblclick). Подробнее о [локаторах](../locators.mdx).

:::


Этот метод делает двойной клик по элементу, соответствующему [selector](/api/class-page.mdx#page-dblclick-option-selector), выполняя следующие шаги:
1. Находит элемент, соответствующий [selector](/api/class-page.mdx#page-dblclick-option-selector). Если такого элемента нет, ждёт, пока соответствующий элемент будет добавлен в DOM.
1. Ожидает прохождения проверок [actionability](../actionability.mdx) для найденного элемента, если не задана опция [force](/api/class-page.mdx#page-dblclick-option-force). Если во время проверок элемент будет удалён из DOM, всё действие будет повторено.
1. При необходимости прокручивает страницу так, чтобы элемент оказался в области видимости.
1. Использует [page.mouse](/api/class-page.mdx#page-mouse), чтобы сделать двойной клик по центру элемента или по указанной [position](/api/class-page.mdx#page-dblclick-option-position).

Если все шаги в совокупности не завершились за указанное время [timeout](/api/class-page.mdx#page-dblclick-option-timeout), метод выбрасывает [TimeoutError]. Передайте нулевой таймаут, чтобы отключить его.

:::note

`page.dblclick()` отправляет два события `click` и одно событие `dblclick`.
:::

**Использование**

```python
page.dblclick(selector)
page.dblclick(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-selector"/><a href="#page-dblclick-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `button` "left" | "right" | "middle" (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-button"/><a href="#page-dblclick-option-button" class="list-anchor">#</a>
  
  По умолчанию `left`.
- `delay` [float] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-delay"/><a href="#page-dblclick-option-delay" class="list-anchor">#</a>
  
  Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
- `force` [bool] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-force"/><a href="#page-dblclick-option-force" class="list-anchor">#</a>
  
  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `modifiers` [List]\["Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"\] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-modifiers"/><a href="#page-dblclick-option-modifiers" class="list-anchor">#</a>
  
  Модификаторы клавиш, которые нужно зажать. Гарантирует, что во время операции будут нажаты только эти модификаторы, а затем восстанавливает прежнее состояние модификаторов. Если не указано, используются модификаторы, нажатые в данный момент. "ControlOrMeta" соответствует "Control" в Windows и Linux и "Meta" в macOS.
- `no_wait_after` [bool] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-no-wait-after"/><a href="#page-dblclick-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Эта опция не влияет на поведение.
  :::
  
  
  Эта опция не влияет на поведение.
- `position` [Dict] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-position"/><a href="#page-dblclick-option-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Точка относительно верхнего левого угла padding-box элемента. Если не указана, используется какая-то видимая точка элемента.
- `strict` [bool] (опционально) <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-strict"/><a href="#page-dblclick-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор однозначно соответствовал одному элементу. Если селектор соответствует более чем одному элементу, вызов выбрасывает исключение.
- `timeout` [float] (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-timeout"/><a href="#page-dblclick-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] (опционально) <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-trial"/><a href="#page-dblclick-option-trial" class="list-anchor">#</a>
  
  Если задано, метод выполняет только проверки [actionability](../actionability.mdx) и пропускает само действие. По умолчанию `false`. Полезно, чтобы дождаться готовности элемента к действию, не выполняя его. Обратите внимание: модификаторы клавиатуры `modifiers` будут нажаты независимо от `trial`, чтобы можно было тестировать элементы, которые видимы только при нажатых этих клавишах.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-return"/><a href="#page-dblclick-return" class="list-anchor">#</a>

---

### dispatch_event {#page-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.dispatch_event</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов: [locator.dispatch_event()](/api/class-locator.mdx#locator-dispatch-event). Подробнее о [локаторах](../locators.mdx).

:::


Фрагмент ниже отправляет событие `click` элементу. Независимо от того, видим элемент или нет, событие `click` будет отправлено. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.dispatch_event("button#submit", "click")
```

</TabItem>
<TabItem value="async">

```py
await page.dispatch_event("button#submit", "click")
```

</TabItem>
</Tabs>

Внутри метод создаёт экземпляр события на основе указанного [type](/api/class-page.mdx#page-dispatch-event-option-type), инициализирует его свойствами [event_init](/api/class-page.mdx#page-dispatch-event-option-event-init) и отправляет его на элемент. По умолчанию события являются `composed`, `cancelable` и всплывают (bubble).

Поскольку [event_init](/api/class-page.mdx#page-dispatch-event-option-event-init) зависит от конкретного события, список начальных свойств смотрите в документации по событиям:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Также вы можете указать `JSHandle` в качестве значения свойства, если хотите передать в событие «живые» объекты:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# обратите внимание: создать data_transfer можно только в Chromium и Firefox
data_transfer = page.evaluate_handle("new DataTransfer()")
page.dispatch_event("#source", "dragstart", { "dataTransfer": data_transfer })
```

</TabItem>
<TabItem value="async">

```py
# обратите внимание: создать data_transfer можно только в Chromium и Firefox
data_transfer = await page.evaluate_handle("new DataTransfer()")
await page.dispatch_event("#source", "dragstart", { "dataTransfer": data_transfer })
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-selector"/><a href="#page-dispatch-event-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `type` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-type"/><a href="#page-dispatch-event-option-type" class="list-anchor">#</a>
  
  Тип DOM‑события: `"click"`, `"dragstart"` и т. д.
- `event_init` [EvaluationArgument] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-event-init"/><a href="#page-dispatch-event-option-event-init" class="list-anchor">#</a>
  
  Необязательные свойства инициализации события, специфичные для конкретного события.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-strict"/><a href="#page-dispatch-event-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-timeout"/><a href="#page-dispatch-event-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-return"/><a href="#page-dispatch-event-return" class="list-anchor">#</a>

---

### eval_on_selector {#page-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.eval_on_selector</x-search>

:::warning[Не рекомендуется]

Этот метод не ожидает, пока элемент пройдет проверки пригодности к действию (actionability), и поэтому может приводить к нестабильным тестам. Вместо этого используйте [locator.evaluate()](/api/class-locator.mdx#locator-evaluate), другие вспомогательные методы [Locator] или web-first ассерты.

:::


Метод находит элемент на странице, соответствующий указанному селектору, и передает его в качестве первого аргумента в [expression](/api/class-page.mdx#page-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выбрасывает ошибку. Возвращает значение [expression](/api/class-page.mdx#page-eval-on-selector-option-expression).

Если [expression](/api/class-page.mdx#page-eval-on-selector-option-expression) возвращает [Promise], то [page.eval_on_selector()](/api/class-page.mdx#page-eval-on-selector) будет ожидать его разрешения и вернет результат.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
search_value = page.eval_on_selector("#search", "el => el.value")
preload_href = page.eval_on_selector("link[rel=preload]", "el => el.href")
html = page.eval_on_selector(".main-container", "(e, suffix) => e.outer_html + suffix", "hello")
```

</TabItem>
<TabItem value="async">

```py
search_value = await page.eval_on_selector("#search", "el => el.value")
preload_href = await page.eval_on_selector("link[rel=preload]", "el => el.href")
html = await page.eval_on_selector(".main-container", "(e, suffix) => e.outer_html + suffix", "hello")
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-selector"/><a href="#page-eval-on-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента.
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-expression"/><a href="#page-eval-on-selector-option-expression" class="list-anchor">#</a>
  
  JavaScript‑выражение, которое будет выполнено в контексте браузера. Если выражение вычисляется в функцию, функция будет автоматически вызвана.
- `arg` [EvaluationArgument] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-arg"/><a href="#page-eval-on-selector-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент, передаваемый в [expression](/api/class-page.mdx#page-eval-on-selector-option-expression).
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-strict"/><a href="#page-eval-on-selector-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.

**Возвращает**
- [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-return"/><a href="#page-eval-on-selector-return" class="list-anchor">#</a>

---

### eval_on_selector_all {#page-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.eval_on_selector_all</x-search>

:::warning[Не рекомендуется]

В большинстве случаев [locator.evaluate_all()](/api/class-locator.mdx#locator-evaluate-all), другие вспомогательные методы [Locator] и web-first ассерты работают лучше.

:::


Метод находит все элементы на странице, соответствующие указанному селектору, и передает массив найденных элементов в качестве первого аргумента в [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression). Возвращает результат вызова [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

Если [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression) возвращает [Promise], то [page.eval_on_selector_all()](/api/class-page.mdx#page-eval-on-selector-all) будет ожидать его разрешения и вернет результат.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
div_counts = page.eval_on_selector_all("div", "(divs, min) => divs.length >= min", 10)
```

</TabItem>
<TabItem value="async">

```py
div_counts = await page.eval_on_selector_all("div", "(divs, min) => divs.length >= min", 10)
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-selector"/><a href="#page-eval-on-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элементов.
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-expression"/><a href="#page-eval-on-selector-all-option-expression" class="list-anchor">#</a>
  
  JavaScript‑выражение, которое будет выполнено в контексте браузера. Если выражение вычисляется в функцию, функция будет автоматически вызвана.
- `arg` [EvaluationArgument] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-arg"/><a href="#page-eval-on-selector-all-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент, передаваемый в [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

**Возвращает**
- [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-return"/><a href="#page-eval-on-selector-all-return" class="list-anchor">#</a>

---

### expect_navigation {#page-wait-for-navigation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expect_navigation</x-search>

:::warning Устаревший

Этот метод по своей природе подвержен состояниям гонки. Пожалуйста, используйте [page.wait_for_url()](/api/class-page.mdx#page-wait-for-url) вместо него.

:::


Ожидает навигацию основного фрейма и возвращает ответ основного ресурса. В случае нескольких редиректов навигация завершится с ответом последнего редиректа. В случае навигации к другому якорю или навигации из‑за использования History API, навигация завершится со значением `null`.

**Использование**

Метод завершается, когда страница переходит на новый URL или перезагружается. Это полезно, когда вы выполняете код, который косвенно вызывает навигацию, например, клик по элементу с обработчиком `onclick`, который запускает навигацию через `setTimeout`. Рассмотрим пример:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_navigation():
    # Это действие запускает навигацию после тайм-аута.
    page.get_by_text("Navigate after timeout").click()
# Завершается после окончания навигации
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_navigation():
    # Это действие запускает навигацию после тайм-аута.
    await page.get_by_text("Navigate after timeout").click()
# Завершается после окончания навигации
```

</TabItem>
</Tabs>

:::note

Использование [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) для изменения URL считается навигацией.
:::

**Аргументы**
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-timeout"/><a href="#page-wait-for-navigation-option-timeout" class="list-anchor">#</a>
  
  Максимальное время выполнения операции в миллисекундах, по умолчанию 30 секунд. Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-url"/><a href="#page-wait-for-navigation-option-url" class="list-anchor">#</a>
  
  Glob‑шаблон, регулярное выражение или предикат, принимающий [URL], для сопоставления во время ожидания навигации. Обратите внимание: если параметр — строка без подстановочных символов, метод будет ожидать навигацию ровно к этому URL.
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-wait-until"/><a href="#page-wait-for-navigation-option-wait-until" class="list-anchor">#</a>
  
  Когда считать операцию успешно завершенной. По умолчанию `load`. Возможные события:
  * `'domcontentloaded'` — считать операцию завершенной, когда сработает событие `DOMContentLoaded`.
  * `'load'` — считать операцию завершенной, когда сработает событие `load`.
  * `'networkidle'` — **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений как минимум `500` мс. Не используйте это для тестирования, вместо этого полагайтесь на web‑ассерты.
  * `'commit'` — считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [EventContextManager]\[[Response]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-return"/><a href="#page-wait-for-navigation-return" class="list-anchor">#</a>

---

### fill {#page-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.fill</x-search>

:::warning[Не рекомендуется]

Используйте вариант на основе локаторов — [locator.fill()](/api/class-locator.mdx#locator-fill). Подробнее о [локаторах](../locators.mdx).

:::


Метод ожидает элемент, соответствующий [selector](/api/class-page.mdx#page-fill-option-selector), выполняет проверки [actionability](../actionability.mdx), фокусирует элемент, заполняет его и после заполнения инициирует событие `input`. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является `<input>`, `<textarea>` или `[contenteditable]`, метод выбрасывает ошибку. Однако если элемент находится внутри `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен именно этот control.

Для отправки более тонких событий клавиатуры используйте [locator.press_sequentially()](/api/class-locator.mdx#locator-press-sequentially).

**Использование**

```python
page.fill(selector, value)
page.fill(selector, value, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-selector"/><a href="#page-fill-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `value` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-value"/><a href="#page-fill-option-value" class="list-anchor">#</a>
  
  Значение для заполнения элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `force` [bool] *(необязательно)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-force"/><a href="#page-fill-option-force" class="list-anchor">#</a>
  
  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-no-wait-after"/><a href="#page-fill-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устаревший]
  Этот параметр не имеет эффекта.
  :::
  
  
  Этот параметр не имеет эффекта.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-strict"/><a href="#page-fill-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-timeout"/><a href="#page-fill-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-return"/><a href="#page-fill-return" class="list-anchor">#</a>

---

### focus {#page-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.focus</x-search>

:::warning[Не рекомендуется]

Используйте вариант на основе локаторов — [locator.focus()](/api/class-locator.mdx#locator-focus). Подробнее о [локаторах](../locators.mdx).

:::


Метод получает элемент по [selector](/api/class-page.mdx#page-focus-option-selector) и фокусирует его. Если элемент, соответствующий [selector](/api/class-page.mdx#page-focus-option-selector), отсутствует, метод будет ждать, пока такой элемент появится в DOM.

**Использование**

```python
page.focus(selector)
page.focus(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-selector"/><a href="#page-focus-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-strict"/><a href="#page-focus-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-timeout"/><a href="#page-focus-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-return"/><a href="#page-focus-return" class="list-anchor">#</a>

---

### get_attribute {#page-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.get_attribute</x-search>

:::warning[Не рекомендуется]

Используйте вариант на основе локаторов — [locator.get_attribute()](/api/class-locator.mdx#locator-get-attribute). Подробнее о [локаторах](../locators.mdx).

:::

Возвращает значение атрибута элемента.

**Использование**

```python
page.get_attribute(selector, name)
page.get_attribute(selector, name, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-selector"/><a href="#page-get-attribute-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-name"/><a href="#page-get-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута, значение которого нужно получить.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-strict"/><a href="#page-get-attribute-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-timeout"/><a href="#page-get-attribute-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType] | [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-return"/><a href="#page-get-attribute-return" class="list-anchor">#</a>

---

### hover {#page-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.hover</x-search>

:::warning[Не рекомендуется]

Используйте вариант на основе локаторов — [locator.hover()](/api/class-locator.mdx#locator-hover). Подробнее о [локаторах](../locators.mdx).

:::

Метод наводит курсор на элемент, соответствующий [selector](/api/class-page.mdx#page-hover-option-selector), выполняя следующие шаги:
1. Найти элемент, соответствующий [selector](/api/class-page.mdx#page-hover-option-selector). Если такого элемента нет, ожидать, пока он будет прикреплен к DOM.
1. Ожидать прохождения проверок [actionability](../actionability.mdx) для найденного элемента, если не установлен параметр [force](/api/class-page.mdx#page-hover-option-force). Если элемент будет отсоединен во время проверок, все действие будет повторено.
1. Прокрутить элемент в область видимости при необходимости.
1. Использовать [page.mouse](/api/class-page.mdx#page-mouse) для наведения курсора на центр элемента или в указанную [position](/api/class-page.mdx#page-hover-option-position).

Если все шаги в совокупности не завершатся в течение указанного [timeout](/api/class-page.mdx#page-hover-option-timeout), метод выбросит [TimeoutError]. Передача нулевого таймаута отключает это поведение.

**Использование**

```python
page.hover(selector)
page.hover(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-selector"/><a href="#page-hover-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `force` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-force"/><a href="#page-hover-option-force" class="list-anchor">#</a>
  
  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `modifiers` [List]\["Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"\] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-modifiers"/><a href="#page-hover-option-modifiers" class="list-anchor">#</a>
  
  Клавиши‑модификаторы, которые нужно зажать. Обеспечивает, что во время операции нажаты только эти модификаторы, а затем восстанавливает текущее состояние модификаторов. Если не указано, используются текущие нажатые модификаторы. `"ControlOrMeta"` соответствует `"Control"` на Windows и Linux и `"Meta"` на macOS.
- `no_wait_after` [bool] *(необязательно)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-no-wait-after"/><a href="#page-hover-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устаревший]
  Этот параметр не имеет эффекта.
  :::
  
  
  Этот параметр не имеет эффекта.
- `position` [Dict] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-position"/><a href="#page-hover-option-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Точка, используемая относительно верхнего левого угла padding‑бокса элемента. Если не указана, используется какая‑либо видимая точка элемента.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-strict"/><a href="#page-hover-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-timeout"/><a href="#page-hover-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(необязательно)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-trial"/><a href="#page-hover-option-trial" class="list-anchor">#</a>
  
  Если установлено, метод выполняет только проверки [actionability](../actionability.mdx) и пропускает само действие. По умолчанию `false`. Полезно для ожидания готовности элемента к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, видимые только при зажатых клавишах.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-return"/><a href="#page-hover-return" class="list-anchor">#</a>

---

### inner_html {#page-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.inner_html</x-search>

:::warning[Не рекомендуется]

Используйте вариант на основе локаторов — [locator.inner_html()](/api/class-locator.mdx#locator-inner-html). Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerHTML`.

**Использование**

```python
page.inner_html(selector)
page.inner_html(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-selector"/><a href="#page-inner-html-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-strict"/><a href="#page-inner-html-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-timeout"/><a href="#page-inner-html-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-return"/><a href="#page-inner-html-return" class="list-anchor">#</a>

---

### inner_text {#page-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.inner_text</x-search>

:::warning[Не рекомендуется]

Используйте вариант на основе локаторов — [locator.inner_text()](/api/class-locator.mdx#locator-inner-text). Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerText`.

**Использование**

```python
page.inner_text(selector)
page.inner_text(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-selector"/><a href="#page-inner-text-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-strict"/><a href="#page-inner-text-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-timeout"/><a href="#page-inner-text-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-return"/><a href="#page-inner-text-return" class="list-anchor">#</a>

---

### input_value {#page-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>page.input_value</x-search>

:::warning[Не рекомендуется]

Используйте вариант на основе локаторов — [locator.input_value()](/api/class-locator.mdx#locator-input-value). Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Для элементов, не являющихся полями ввода, метод выбрасывает исключение. Однако если элемент находится внутри `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращается значение этого control.

**Использование**

```python
page.input_value(selector)
page.input_value(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-selector"/><a href="#page-input-value-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-strict"/><a href="#page-input-value-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-timeout"/><a href="#page-input-value-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-return"/><a href="#page-input-value-return" class="list-anchor">#</a>

---

### is_checked {#page-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.is_checked</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.is_checked()](/api/class-locator.mdx#locator-is-checked). Подробнее о [локаторах](../locators.mdx).

:::


Возвращает, отмечен ли элемент. Генерирует исключение, если элемент не является чекбоксом или radio-инпутом.

**Использование**

```python
page.is_checked(selector)
page.is_checked(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-selector"/><a href="#page-is-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-strict"/><a href="#page-is-checked-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-timeout"/><a href="#page-is-checked-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-return"/><a href="#page-is-checked-return" class="list-anchor">#</a>

---

### is_disabled {#page-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.is_disabled</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.is_disabled()](/api/class-locator.mdx#locator-is-disabled). Подробнее о [локаторах](../locators.mdx).

:::


Возвращает, отключён ли элемент — противоположность состоянию [enabled](../actionability.mdx#enabled).

**Использование**

```python
page.is_disabled(selector)
page.is_disabled(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-selector"/><a href="#page-is-disabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-strict"/><a href="#page-is-disabled-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-timeout"/><a href="#page-is-disabled-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-return"/><a href="#page-is-disabled-return" class="list-anchor">#</a>

---

### is_editable {#page-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.is_editable</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.is_editable()](/api/class-locator.mdx#locator-is-editable). Подробнее о [локаторах](../locators.mdx).

:::


Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Использование**

```python
page.is_editable(selector)
page.is_editable(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-selector"/><a href="#page-is-editable-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-strict"/><a href="#page-is-editable-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-timeout"/><a href="#page-is-editable-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-return"/><a href="#page-is-editable-return" class="list-anchor">#</a>

---

### is_enabled {#page-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.is_enabled</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.is_enabled()](/api/class-locator.mdx#locator-is-enabled). Подробнее о [локаторах](../locators.mdx).

:::


Возвращает, находится ли элемент в состоянии [enabled](../actionability.mdx#enabled).

**Использование**

```python
page.is_enabled(selector)
page.is_enabled(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-selector"/><a href="#page-is-enabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-strict"/><a href="#page-is-enabled-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-timeout"/><a href="#page-is-enabled-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-return"/><a href="#page-is-enabled-return" class="list-anchor">#</a>

---

### is_hidden {#page-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.is_hidden</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.is_hidden()](/api/class-locator.mdx#locator-is-hidden). Подробнее о [локаторах](../locators.mdx).

:::


Возвращает, скрыт ли элемент — противоположность состоянию [visible](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-hidden-option-selector), который не соответствует ни одному элементу, считается скрытым.

**Использование**

```python
page.is_hidden(selector)
page.is_hidden(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-selector"/><a href="#page-is-hidden-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-strict"/><a href="#page-is-hidden-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-timeout"/><a href="#page-is-hidden-option-timeout" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр игнорируется. [page.is_hidden()](/api/class-page.mdx#page-is-hidden) не ожидает, пока элемент станет скрытым, и возвращает результат немедленно.
  :::
  

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-return"/><a href="#page-is-hidden-return" class="list-anchor">#</a>

---

### is_visible {#page-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.is_visible</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.is_visible()](/api/class-locator.mdx#locator-is-visible). Подробнее о [локаторах](../locators.mdx).

:::


Возвращает, является ли элемент [видимым](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-visible-option-selector), который не соответствует ни одному элементу, считается невидимым.

**Использование**

```python
page.is_visible(selector)
page.is_visible(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-selector"/><a href="#page-is-visible-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-strict"/><a href="#page-is-visible-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-timeout"/><a href="#page-is-visible-option-timeout" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр игнорируется. [page.is_visible()](/api/class-page.mdx#page-is-visible) не ожидает, пока элемент станет видимым, и возвращает результат немедленно.
  :::
  

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-return"/><a href="#page-is-visible-return" class="list-anchor">#</a>

---

### press {#page-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.press</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.press()](/api/class-locator.mdx#locator-press). Подробнее о [локаторах](../locators.mdx).

:::


Фокусирует элемент, а затем использует [keyboard.down()](/api/class-keyboard.mdx#keyboard-down) и [keyboard.up()](/api/class-keyboard.mdx#keyboard-up).

Параметр [key](/api/class-page.mdx#page-press-option-key) может задавать предполагаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или одиночный символ для генерации текста. Расширенный список допустимых значений [key](/api/class-page.mdx#page-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры клавиш:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются сочетания с модификаторами: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`. `ControlOrMeta` соответствует `Control` на Windows и Linux и `Meta` на macOS.

Удерживание `Shift` приведёт к вводу текста, соответствующего значению [key](/api/class-page.mdx#page-press-option-key) в верхнем регистре.

Если [key](/api/class-page.mdx#page-press-option-key) — это одиночный символ, регистр учитывается, поэтому значения `a` и `A` сгенерируют разный текст.

Также поддерживаются сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++"` или `key: "Control+Shift+T"`. При указании модификатора он нажимается и удерживается во время нажатия последующей клавиши.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page = browser.new_page()
page.goto("https://keycode.info")
page.press("body", "A")
page.screenshot(path="a.png")
page.press("body", "ArrowLeft")
page.screenshot(path="arrow_left.png")
page.press("body", "Shift+O")
page.screenshot(path="o.png")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
page = await browser.new_page()
await page.goto("https://keycode.info")
await page.press("body", "A")
await page.screenshot(path="a.png")
await page.press("body", "ArrowLeft")
await page.screenshot(path="arrow_left.png")
await page.press("body", "Shift+O")
await page.screenshot(path="o.png")
await browser.close()
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-selector"/><a href="#page-press-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `key` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-key"/><a href="#page-press-option-key" class="list-anchor">#</a>
  
  Имя клавиши для нажатия или символ для генерации, например `ArrowLeft` или `a`.
- `delay` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-delay"/><a href="#page-press-option-delay" class="list-anchor">#</a>
  
  Время ожидания между событиями `keydown` и `keyup` в миллисекундах. По умолчанию 0.
- `no_wait_after` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-no-wait-after"/><a href="#page-press-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  В будущем значение по умолчанию для этого параметра будет `true`.
  :::
  
  
  Действия, инициирующие навигацию, ожидают её завершения и начала загрузки страницы. Вы можете отключить ожидание, установив этот флаг. Обычно это требуется только в исключительных случаях, например при переходе на недоступные страницы. По умолчанию `false`.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-strict"/><a href="#page-press-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-timeout"/><a href="#page-press-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-return"/><a href="#page-press-return" class="list-anchor">#</a>

---

### query_selector {#page-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.query_selector</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [page.locator()](/api/class-page.mdx#page-locator). Подробнее о [локаторах](../locators.mdx).

:::


Метод находит элемент на странице, соответствующий указанному селектору. Если ни один элемент не соответствует селектору, возвращаемое значение будет `null`. Чтобы ожидать появления элемента на странице, используйте [locator.wait_for()](/api/class-locator.mdx#locator-wait-for).

**Использование**

```python
page.query_selector(selector)
page.query_selector(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-selector"/><a href="#page-query-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-strict"/><a href="#page-query-selector-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.

**Возвращает**
- [NoneType] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-return"/><a href="#page-query-selector-return" class="list-anchor">#</a>

---

### query_selector_all {#page-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.query_selector_all</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [page.locator()](/api/class-page.mdx#page-locator). Подробнее о [локаторах](../locators.mdx).

:::


Метод находит все элементы на странице, соответствующие указанному селектору. Если ни один элемент не соответствует селектору, возвращаемое значение будет `[]`.

**Использование**

```python
page.query_selector_all(selector)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-option-selector"/><a href="#page-query-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.

**Возвращает**
- [List]\[[ElementHandle]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-return"/><a href="#page-query-selector-all-return" class="list-anchor">#</a>

---

### select_option {#page-select-option}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.select_option</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.select_option()](/api/class-locator.mdx#locator-select-option). Подробнее о [локаторах](../locators.mdx).

:::


Метод ожидает появления элемента, соответствующего [selector](/api/class-page.mdx#page-select-option-option-selector), выполняет проверки [actionability](../actionability.mdx), ожидает, пока все указанные опции появятся в элементе `<select>`, и выбирает эти опции.

Если целевой элемент не является `<select>`, метод выбрасывает ошибку. Однако если элемент находится внутри элемента `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), вместо него будет использован соответствующий control.

Возвращает массив значений опций, которые были успешно выбраны.

После выбора всех переданных опций инициирует события `change` и `input`.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Одиночный выбор по значению или метке
page.select_option("select#colors", "blue")
# одиночный выбор по метке
page.select_option("select#colors", label="blue")
# множественный выбор
page.select_option("select#colors", value=["red", "green", "blue"])
```

</TabItem>
<TabItem value="async">

```py
# Одиночный выбор по значению или метке
await page.select_option("select#colors", "blue")
# одиночный выбор по метке
await page.select_option("select#colors", label="blue")
# множественный выбор
await page.select_option("select#colors", value=["red", "green", "blue"])
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-selector"/><a href="#page-select-option-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `force` [bool] *(необязательно)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-force"/><a href="#page-select-option-option-force" class="list-anchor">#</a>
  
  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-no-wait-after"/><a href="#page-select-option-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::
  
  
  Этот параметр не имеет эффекта.
- `strict` [bool] *(необязательно)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-strict"/><a href="#page-select-option-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-timeout"/><a href="#page-select-option-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `element` [ElementHandle] | [List]\[[ElementHandle]\] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-element"/><a href="#page-select-option-option-element" class="list-anchor">#</a>
  
  Элементы опций для выбора. Необязательно.
- `index` [int] | [List]\[[int]\] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-index"/><a href="#page-select-option-option-index" class="list-anchor">#</a>
  
  Опции для выбора по индексу. Необязательно.
- `value` [str] | [List]\[[str]\] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-value"/><a href="#page-select-option-option-value" class="list-anchor">#</a>
  
  Опции для выбора по значению. Если `<select>` имеет атрибут `multiple`, будут выбраны все переданные опции, иначе будет выбрана только первая опция, соответствующая одному из переданных значений. Необязательно.
- `label` [str] | [List]\[[str]\] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-label"/><a href="#page-select-option-option-label" class="list-anchor">#</a>
  
  Опции для выбора по метке. Если `<select>` имеет атрибут `multiple`, будут выбраны все переданные опции, иначе будет выбрана только первая опция, соответствующая одной из переданных меток. Необязательно.

**Возвращает**
- [List]\[[str]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-return"/><a href="#page-select-option-return" class="list-anchor">#</a>

---

### set_checked {#page-set-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.15</font><x-search>page.set_checked</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.set_checked()](/api/class-locator.mdx#locator-set-checked). Подробнее о [локаторах](../locators.mdx).

:::


Метод отмечает или снимает отметку с элемента, соответствующего [selector](/api/class-page.mdx#page-set-checked-option-selector), выполняя следующие шаги:
1. Находит элемент, соответствующий [selector](/api/class-page.mdx#page-set-checked-option-selector). Если такого элемента нет, ожидает, пока подходящий элемент будет добавлен в DOM.
1. Убеждается, что найденный элемент является чекбоксом или radio-инпутом. В противном случае метод выбрасывает ошибку.
1. Если элемент уже находится в требуемом состоянии (отмечен или не отмечен), метод немедленно возвращает управление.
1. Ожидает прохождения проверок [actionability](../actionability.mdx) для найденного элемента, если не задан параметр [force](/api/class-page.mdx#page-set-checked-option-force). Если элемент будет отсоединён во время проверок, всё действие будет повторено.
1. Прокручивает элемент в область видимости при необходимости.
1. Использует [page.mouse](/api/class-page.mdx#page-mouse) для клика в центр элемента.
1. Убеждается, что элемент теперь отмечен или не отмечен. В противном случае метод выбрасывает ошибку.

Если все шаги не были завершены в течение указанного [timeout](/api/class-page.mdx#page-set-checked-option-timeout), метод выбрасывает [TimeoutError]. Передача таймаута `0` отключает это поведение.

**Использование**

```python
page.set_checked(selector, checked)
page.set_checked(selector, checked, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-selector"/><a href="#page-set-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `checked` [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-checked"/><a href="#page-set-checked-option-checked" class="list-anchor">#</a>
  
  Нужно ли установить или снять отметку с чекбокса.
- `force` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-force"/><a href="#page-set-checked-option-force" class="list-anchor">#</a>
  
  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-no-wait-after"/><a href="#page-set-checked-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::
  
  
  Этот параметр не имеет эффекта.
- `position` [Dict] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-position"/><a href="#page-set-checked-option-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Точка относительно левого верхнего угла области padding элемента. Если не указано, используется некоторая видимая точка элемента.
- `strict` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-strict"/><a href="#page-set-checked-option-strict" class="list-anchor">#</a>
  
  Если `true`, вызов требует, чтобы селектор разрешался ровно в один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-timeout"/><a href="#page-set-checked-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-trial"/><a href="#page-set-checked-option-trial" class="list-anchor">#</a>
  
  Если задано, метод выполняет только проверки [actionability](../actionability.mdx) и пропускает само действие. По умолчанию `false`. Полезно для ожидания готовности элемента к действию без его выполнения.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-return"/><a href="#page-set-checked-return" class="list-anchor">#</a>

---

### set_input_files {#page-set-input-files}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.set_input_files</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.set_input_files()](/api/class-locator.mdx#locator-set-input-files). Подробнее о [локаторах](../locators.mdx).

:::


Устанавливает значение поля ввода файлов в указанные пути к файлам или файлы. Если некоторые из `filePaths` являются относительными путями, они будут разрешены относительно текущего рабочего каталога. Для пустого массива очищает выбранные файлы. Для полей ввода с атрибутом `[webkitdirectory]` поддерживается только один путь к каталогу.

Этот метод ожидает, что [selector](/api/class-page.mdx#page-set-input-files-option-selector) указывает на [элемент input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Однако если элемент находится внутри элемента `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), в качестве цели используется именно control.

**Использование**

```python
page.set_input_files(selector, files)
page.set_input_files(selector, files, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-selector"/><a href="#page-set-input-files-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `files` [Union]\[[str], [pathlib.Path]\] | [List]\[[Union]\[[str], [pathlib.Path]\]\] | [Dict] | [List]\[[Dict]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-files"/><a href="#page-set-input-files-option-files" class="list-anchor">#</a>
  - `name` [str]
    
    Имя файла
  - `mimeType` [str]
    
    Тип файла
  - `buffer` [bytes]
    
    Содержимое файла
- `no_wait_after` [bool] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-no-wait-after"/><a href="#page-set-input-files-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::
  
  
  Этот параметр не имеет эффекта.
- `strict` [bool] *(необязательный)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-strict"/><a href="#page-set-input-files-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор однозначно указывал на один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-timeout"/><a href="#page-set-input-files-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-return"/><a href="#page-set-input-files-return" class="list-anchor">#</a>

---

### tap {#page-tap}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.tap</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.tap()](/api/class-locator.mdx#locator-tap). Подробнее о [локаторах](../locators.mdx).

:::


Этот метод выполняет касание (tap) элемента, соответствующего [selector](/api/class-page.mdx#page-tap-option-selector), выполняя следующие шаги:
1. Находит элемент, соответствующий [selector](/api/class-page.mdx#page-tap-option-selector). Если такого элемента нет, ожидает, пока соответствующий элемент будет добавлен в DOM.
1. Ожидает прохождения проверок [actionability](../actionability.mdx) для найденного элемента, если не установлен параметр [force](/api/class-page.mdx#page-tap-option-force). Если элемент будет отсоединён во время проверок, вся операция будет повторена.
1. Прокручивает элемент в область видимости при необходимости.
1. Использует [page.touchscreen](/api/class-page.mdx#page-touchscreen) для касания центра элемента или указанной [position](/api/class-page.mdx#page-tap-option-position).

Если все шаги не завершатся в течение указанного [timeout](/api/class-page.mdx#page-tap-option-timeout), метод выбросит [TimeoutError]. Передача таймаута `0` отключает ограничение по времени.

:::note

Метод [page.tap()](/api/class-page.mdx#page-tap) выбросит исключение, если параметр [has_touch](/api/class-browser.mdx#browser-new-context-option-has-touch) контекста браузера равен `false`.
:::

**Использование**

```python
page.tap(selector)
page.tap(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-selector"/><a href="#page-tap-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `force` [bool] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-force"/><a href="#page-tap-option-force" class="list-anchor">#</a>
  
  Следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `modifiers` [List]\["Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"\] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-modifiers"/><a href="#page-tap-option-modifiers" class="list-anchor">#</a>
  
  Клавиши-модификаторы, которые нужно зажать. Гарантирует, что во время операции будут нажаты только эти модификаторы, а затем восстановит текущее состояние. Если не указано, используются уже нажатые модификаторы. `"ControlOrMeta"` соответствует `"Control"` на Windows и Linux и `"Meta"` на macOS.
- `no_wait_after` [bool] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-no-wait-after"/><a href="#page-tap-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::
  
  
  Этот параметр не имеет эффекта.
- `position` [Dict] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-position"/><a href="#page-tap-option-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Точка относительно левого верхнего угла области padding элемента. Если не указано, используется некоторая видимая точка элемента.
- `strict` [bool] *(необязательный)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-strict"/><a href="#page-tap-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор однозначно указывал на один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-timeout"/><a href="#page-tap-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(необязательный)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-trial"/><a href="#page-tap-option-trial" class="list-anchor">#</a>
  
  Если установлено, метод выполняет только проверки [actionability](../actionability.mdx) и пропускает само действие. По умолчанию `false`. Полезно для ожидания готовности элемента к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от значения `trial`, чтобы позволить тестировать элементы, которые видимы только при нажатых клавишах.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-return"/><a href="#page-tap-return" class="list-anchor">#</a>

---

### text_content {#page-text-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.text_content</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.text_content()](/api/class-locator.mdx#locator-text-content). Подробнее о [локаторах](../locators.mdx).

:::


Возвращает `element.textContent`.

**Использование**

```python
page.text_content(selector)
page.text_content(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-selector"/><a href="#page-text-content-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `strict` [bool] *(необязательный)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-strict"/><a href="#page-text-content-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор однозначно указывал на один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-timeout"/><a href="#page-text-content-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType] | [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-return"/><a href="#page-text-content-return" class="list-anchor">#</a>

---

### type {#page-type}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.type</x-search>

:::warning Устарело

В большинстве случаев следует использовать [locator.fill()](/api/class-locator.mdx#locator-fill). Нажимать клавиши по одной нужно только при наличии специальной обработки клавиатуры на странице — в этом случае используйте [locator.press_sequentially()](/api/class-locator.mdx#locator-press-sequentially).

:::


Отправляет события `keydown`, `keypress`/`input` и `keyup` для каждого символа в тексте. `page.type` можно использовать для отправки детализированных событий клавиатуры. Для заполнения значений в полях формы используйте [page.fill()](/api/class-page.mdx#page-fill).

Чтобы нажать специальную клавишу, такую как `Control` или `ArrowDown`, используйте [keyboard.press()](/api/class-keyboard.mdx#keyboard-press).

**Использование**

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-selector"/><a href="#page-type-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `text` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-text"/><a href="#page-type-option-text" class="list-anchor">#</a>
  
  Текст, который нужно ввести в сфокусированный элемент.
- `delay` [float] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-delay"/><a href="#page-type-option-delay" class="list-anchor">#</a>
  
  Время ожидания между нажатиями клавиш в миллисекундах. По умолчанию 0.
- `no_wait_after` [bool] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-no-wait-after"/><a href="#page-type-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::
  
  
  Этот параметр не имеет эффекта.
- `strict` [bool] *(необязательный)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-strict"/><a href="#page-type-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор однозначно указывал на один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-timeout"/><a href="#page-type-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-return"/><a href="#page-type-return" class="list-anchor">#</a>

---

### uncheck {#page-uncheck}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.uncheck</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте вариант на основе локаторов — [locator.uncheck()](/api/class-locator.mdx#locator-uncheck). Подробнее о [локаторах](../locators.mdx).

:::


Этот метод снимает отметку с элемента, соответствующего [selector](/api/class-page.mdx#page-uncheck-option-selector), выполняя следующие шаги:
1. Находит элемент, соответствующий [selector](/api/class-page.mdx#page-uncheck-option-selector). Если такого элемента нет, ожидает, пока соответствующий элемент будет добавлен в DOM.
1. Убеждается, что найденный элемент является чекбоксом или radio-кнопкой. Если это не так, метод выбросит исключение. Если элемент уже не отмечен, метод сразу возвращается.
1. Ожидает прохождения проверок [actionability](../actionability.mdx) для найденного элемента, если не установлен параметр [force](/api/class-page.mdx#page-uncheck-option-force). Если элемент будет отсоединён во время проверок, вся операция будет повторена.
1. Прокручивает элемент в область видимости при необходимости.
1. Использует [page.mouse](/api/class-page.mdx#page-mouse) для клика по центру элемента.
1. Убеждается, что элемент теперь не отмечен. Если это не так, метод выбросит исключение.

Если все шаги не завершатся в течение указанного [timeout](/api/class-page.mdx#page-uncheck-option-timeout), метод выбросит [TimeoutError]. Передача таймаута `0` отключает ограничение по времени.

**Использование**

```python
page.uncheck(selector)
page.uncheck(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-selector"/><a href="#page-uncheck-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если селектору соответствует несколько элементов, будет использован первый.
- `force` [bool] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-force"/><a href="#page-uncheck-option-force" class="list-anchor">#</a>
  
  Следует ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-no-wait-after"/><a href="#page-uncheck-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::
  
  
  Этот параметр не имеет эффекта.
- `position` [Dict] *(необязательный)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-position"/><a href="#page-uncheck-option-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Точка относительно левого верхнего угла области padding элемента. Если не указано, используется некоторая видимая точка элемента.
- `strict` [bool] *(необязательный)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-strict"/><a href="#page-uncheck-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор однозначно указывал на один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-timeout"/><a href="#page-uncheck-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(необязательный)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-trial"/><a href="#page-uncheck-option-trial" class="list-anchor">#</a>
  
  Если установлено, метод выполняет только проверки [actionability](../actionability.mdx) и пропускает само действие. По умолчанию `false`. Полезно для ожидания готовности элемента к действию без его выполнения.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-return"/><a href="#page-uncheck-return" class="list-anchor">#</a>

---

### wait_for_selector {#page-wait-for-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.wait_for_selector</x-search>

:::warning[Не рекомендуется]

Вместо этого используйте веб-ассерты, проверяющие видимость, или вариант на основе локаторов — [locator.wait_for()](/api/class-locator.mdx#locator-wait-for). Подробнее о [локаторах](../locators.mdx).

:::


Возвращается, когда элемент, указанный селектором, удовлетворяет параметру [state](/api/class-page.mdx#page-wait-for-selector-option-state). Возвращает `null` при ожидании состояний `hidden` или `detached`.

:::note

Playwright автоматически ожидает готовности элемента перед выполнением действия. Использование объектов [Locator] и web-first ассертов позволяет обходиться без `wait_for_selector`.
:::

Ожидает, пока [selector](/api/class-page.mdx#page-wait-for-selector-option-selector) удовлетворит параметру [state](/api/class-page.mdx#page-wait-for-selector-option-state) (появится/исчезнет из DOM или станет видимым/скрытым). Если на момент вызова метода селектор уже удовлетворяет условию, метод вернётся сразу. Если селектор не удовлетворит условию в течение [timeout](/api/class-page.mdx#page-wait-for-selector-option-timeout) миллисекунд, будет выброшено исключение.

**Использование**

Этот метод работает между навигациями:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    chromium = playwright.chromium
    browser = chromium.launch()
    page = browser.new_page()
    for current_url in ["https://google.com", "https://bbc.com"]:
        page.goto(current_url, wait_until="domcontentloaded")
        element = page.wait_for_selector("img")
        print("Loaded image: " + str(element.get_attribute("src")))
    browser.close()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    chromium = playwright.chromium
    browser = await chromium.launch()
    page = await browser.new_page()
    for current_url in ["https://google.com", "https://bbc.com"]:
        await page.goto(current_url, wait_until="domcontentloaded")
        element = await page.wait_for_selector("img")
        print("Loaded image: " + str(await element.get_attribute("src")))
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-selector"/><a href="#page-wait-for-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.
- `state` "attached" | "detached" | "visible" | "hidden" *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-state"/><a href="#page-wait-for-selector-option-state" class="list-anchor">#</a>
  
  По умолчанию `'visible'`. Возможные значения:
  * `'attached'` — ожидать, пока элемент появится в DOM.
  * `'detached'` — ожидать, пока элемент исчезнет из DOM.
  * `'visible'` — ожидать, пока элемент будет иметь ненулевой bounding box и не будет иметь `visibility:hidden`. Обратите внимание, что элемент без содержимого или с `display:none` имеет пустой bounding box и не считается видимым.
  * `'hidden'` — ожидать, пока элемент будет либо отсоединён от DOM, либо иметь пустой bounding box, либо `visibility:hidden`. Это противоположно значению `'visible'`.
- `strict` [bool] *(необязательный)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-strict"/><a href="#page-wait-for-selector-option-strict" class="list-anchor">#</a>
  
  Если установлено в `true`, вызов требует, чтобы селектор однозначно указывал на один элемент. Если селектор соответствует более чем одному элементу, будет выброшено исключение.
- `timeout` [float] *(необязательный)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-timeout"/><a href="#page-wait-for-selector-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить с помощью методов [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-return"/><a href="#page-wait-for-selector-return" class="list-anchor">#</a>

---

### wait_for_timeout {#page-wait-for-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.wait_for_timeout</x-search>

:::warning[Не рекомендуется]

Никогда не используйте ожидание по таймауту в продакшене. Тесты, которые ждут фиксированное время, по своей природе нестабильны. Используйте действия [Locator] и веб-ассерты, которые ожидают автоматически.

:::


Ожидает указанный [timeout](/api/class-page.mdx#page-wait-for-timeout-option-timeout) в миллисекундах.

Обратите внимание, что `page.waitForTimeout()` следует использовать только для отладки. Тесты, использующие таймер в продакшене, будут нестабильными. Вместо этого используйте сигналы, такие как сетевые события, появление элементов и другие.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# ждать 1 секунду
page.wait_for_timeout(1000)
```

</TabItem>
<TabItem value="async">

```py
# ждать 1 секунду
await page.wait_for_timeout(1000)
```

</TabItem>
</Tabs>

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-option-timeout"/><a href="#page-wait-for-timeout-option-timeout" class="list-anchor">#</a>
  
  Таймаут, который нужно ожидать

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-return"/><a href="#page-wait-for-timeout-return" class="list-anchor">#</a>


[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[Error]: /api/class-error.mdx "Error"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Any]: https://docs.python.org/3/library/typing.html#typing.Any "Any"
[bool]: https://docs.python.org/3/library/stdtypes.html "bool"
[bytes]: https://docs.python.org/3/library/stdtypes.html#bytes "bytes"
[Callable]: https://docs.python.org/3/library/typing.html#typing.Callable "Callable"
[EventContextManager]: https://docs.python.org/3/reference/datamodel.html#context-managers "Event context manager"
[EventEmitter]: https://pyee.readthedocs.io/en/latest/#pyee.BaseEventEmitter "EventEmitter"
[Exception]: https://docs.python.org/3/library/exceptions.html#Exception "Exception"
[Dict]: https://docs.python.org/3/library/typing.html#typing.Dict "Dict"
[float]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "float"
[int]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "int"
[List]: https://docs.python.org/3/library/typing.html#typing.List "List"
[NoneType]: https://docs.python.org/3/library/constants.html#None "None"
[Pattern]: https://docs.python.org/3/library/re.html "Pattern"
[URL]: https://en.wikipedia.org/wiki/URL "URL"
[pathlib.Path]: https://realpython.com/python-pathlib/ "pathlib.Path"
[str]: https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str "str"
[Union]: https://docs.python.org/3/library/typing.html#typing.Union "Union"
[datetime]: https://docs.python.org/3/library/datetime.html#datetime.datetime "datetime"

[все доступные теги образов]: https://mcr.microsoft.com/en-us/product/playwright/python/about "все доступные теги образов"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/python/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-python/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
