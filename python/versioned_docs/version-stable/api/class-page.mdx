---
id: class-page
title: "Page"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

Класс Page предоставляет методы для взаимодействия с одной вкладкой в [Browser] или с [фоновыми страницами расширений](https://developer.chrome.com/extensions/background_pages) в Chromium. Один экземпляр [Browser] может иметь несколько экземпляров [Page].

Этот пример создает страницу, переходит на URL и затем сохраняет скриншот:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch()
    context = browser.new_context()
    page = context.new_page()
    page.goto("https://example.com")
    page.screenshot(path="screenshot.png")
    browser.close()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch()
    context = await browser.new_context()
    page = await context.new_page()
    await page.goto("https://example.com")
    await page.screenshot(path="screenshot.png")
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

Класс Page генерирует различные события (описанные ниже), которые могут быть обработаны с использованием любых методов нативного [`EventEmitter`](https://nodejs.org/api/events.html#events_class_eventemitter) в Node, таких как `on`, `once` или `removeListener`.

Этот пример выводит сообщение для одного события `load` страницы:

```py
page.once("load", lambda: print("page loaded!"))
```

Чтобы отписаться от событий, используйте метод `removeListener`:

```py
def log_request(intercepted_request):
    print("a request was made:", intercepted_request.url)
page.on("request", log_request)
# позже...
page.remove_listener("request", log_request)
```

---

## Методы

### add_init_script {#page-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.add_init_script</x-search>

Добавляет скрипт, который будет выполнен в одном из следующих случаев:
* Каждый раз, когда страница переходит на новый URL.
* Каждый раз, когда дочерний фрейм присоединяется или переходит на новый URL. В этом случае скрипт выполняется в контексте вновь присоединенного фрейма.

Скрипт выполняется после создания документа, но до выполнения любых его скриптов. Это полезно для изменения среды JavaScript, например, для задания начального значения `Math.random`.

**Использование**

Пример переопределения `Math.random` перед загрузкой страницы:

```js
// preload.js
Math.random = () => 42;
```

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# в вашем скрипте playwright, предполагая, что файл preload.js находится в той же директории
page.add_init_script(path="./preload.js")
```

</TabItem>
<TabItem value="async">

```py
# в вашем скрипте playwright, предполагая, что файл preload.js находится в той же директории
await page.add_init_script(path="./preload.js")
```

</TabItem>
</Tabs>

:::note

Порядок выполнения нескольких скриптов, установленных через [browser_context.add_init_script()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [page.add_init_script()](/api/class-page.mdx#page-add-init-script), не определен.
:::

**Аргументы**
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-option-path"/><a href="#page-add-init-script-option-path" class="list-anchor">#</a>
  
  Путь к файлу JavaScript. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории. Опционально.
- `script` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-option-script"/><a href="#page-add-init-script-option-script" class="list-anchor">#</a>
  
  Скрипт, который будет выполнен на всех страницах в контексте браузера. Опционально.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-return"/><a href="#page-add-init-script-return" class="list-anchor">#</a>

---

### add_locator_handler {#page-add-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.42</font><x-search>page.add_locator_handler</x-search>

При тестировании веб-страницы иногда появляются неожиданные наложения, такие как диалог "Зарегистрироваться", которые блокируют действия, которые вы хотите автоматизировать, например, нажатие кнопки. Эти наложения не всегда появляются одинаково или в одно и то же время, что делает их сложными для обработки в автоматизированных тестах.

Этот метод позволяет вам настроить специальную функцию, называемую обработчиком, которая активируется, когда обнаруживает, что наложение видно. Задача обработчика - удалить наложение, позволяя вашему тесту продолжаться так, как будто наложения не было.

Вещи, которые нужно учитывать:
* Когда наложение показывается предсказуемо, мы рекомендуем явно ожидать его в вашем тесте и закрывать его как часть вашего обычного тестового потока, вместо использования [page.add_locator_handler()](/api/class-page.mdx#page-add-locator-handler).
* Playwright проверяет наличие наложения каждый раз перед выполнением или повторной попыткой действия, требующего [проверки возможности действия](../actionability.mdx), или перед выполнением проверки с автоматическим ожиданием. Когда наложение видно, Playwright сначала вызывает обработчик, а затем продолжает с действием/проверкой. Обратите внимание, что обработчик вызывается только тогда, когда вы выполняете действие/проверку - если наложение становится видимым, но вы не выполняете никаких действий, обработчик не будет вызван.
* После выполнения обработчика Playwright убедится, что наложение, вызвавшее обработчик, больше не видно. Вы можете отказаться от этого поведения с помощью [no_wait_after](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after).
* Время выполнения обработчика учитывается в тайм-ауте действия/проверки, которое вызвало обработчик. Если ваш обработчик занимает слишком много времени, это может вызвать тайм-ауты.
* Вы можете зарегистрировать несколько обработчиков. Однако в любой момент времени будет выполняться только один обработчик. Убедитесь, что действия внутри обработчика не зависят от другого обработчика.

:::warning

Выполнение обработчика изменит состояние вашей страницы в середине теста. Например, это изменит текущий фокус элемента и переместит мышь. Убедитесь, что действия, выполняемые после обработчика, являются автономными и не зависят от неизменности состояния фокуса и мыши.

Например, рассмотрим тест, который вызывает [locator.focus()](/api/class-locator.mdx#locator-focus) с последующим [keyboard.press()](/api/class-keyboard.mdx#keyboard-press). Если ваш обработчик нажимает кнопку между этими двумя действиями, скорее всего, фокусированный элемент будет неправильным, и нажатие клавиши произойдет на неожиданном элементе. Используйте [locator.press()](/api/class-locator.mdx#locator-press) вместо этого, чтобы избежать этой проблемы.

Другой пример - серия действий с мышью, где [mouse.move()](/api/class-mouse.mdx#mouse-move) следует за [mouse.down()](/api/class-mouse.mdx#mouse-down). Опять же, когда обработчик выполняется между этими двумя действиями, позиция мыши будет неправильной во время нажатия мыши. Предпочитайте автономные действия, такие как [locator.click()](/api/class-locator.mdx#locator-click), которые не зависят от состояния, измененного обработчиком.
:::

**Использование**

Пример, который закрывает диалог "Подписаться на рассылку", когда он появляется:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Настройка обработчика.
def handler():
  page.get_by_role("button", name="No thanks").click()
page.add_locator_handler(page.get_by_text("Sign up to the newsletter"), handler)

# Напишите тест как обычно.
page.goto("https://example.com")
page.get_by_role("button", name="Start here").click()
```

</TabItem>
<TabItem value="async">

```py
# Настройка обработчика.
def handler():
  await page.get_by_role("button", name="No thanks").click()
await page.add_locator_handler(page.get_by_text("Sign up to the newsletter"), handler)

# Напишите тест как обычно.
await page.goto("https://example.com")
await page.get_by_role("button", name="Start here").click()
```

</TabItem>
</Tabs>

Пример, который пропускает страницу "Подтвердите свои данные безопасности", когда она показывается:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Настройка обработчика.
def handler():
  page.get_by_role("button", name="Remind me later").click()
page.add_locator_handler(page.get_by_text("Confirm your security details"), handler)

# Напишите тест как обычно.
page.goto("https://example.com")
page.get_by_role("button", name="Start here").click()
```

</TabItem>
<TabItem value="async">

```py
# Настройка обработчика.
def handler():
  await page.get_by_role("button", name="Remind me later").click()
await page.add_locator_handler(page.get_by_text("Confirm your security details"), handler)

# Напишите тест как обычно.
await page.goto("https://example.com")
await page.get_by_role("button", name="Start here").click()
```

</TabItem>
</Tabs>

Пример с пользовательским обратным вызовом на каждую проверку возможности действия. Он использует локатор `<body>`, который всегда виден, поэтому обработчик вызывается перед каждой проверкой возможности действия. Важно указать [no_wait_after](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after), потому что обработчик не скрывает элемент `<body>`.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Настройка обработчика.
def handler():
  page.evaluate("window.removeObstructionsForTestIfNeeded()")
page.add_locator_handler(page.locator("body"), handler, no_wait_after=True)

# Напишите тест как обычно.
page.goto("https://example.com")
page.get_by_role("button", name="Start here").click()
```

</TabItem>
<TabItem value="async">

```py
# Настройка обработчика.
def handler():
  await page.evaluate("window.removeObstructionsForTestIfNeeded()")
await page.add_locator_handler(page.locator("body"), handler, no_wait_after=True)

# Напишите тест как обычно.
await page.goto("https://example.com")
await page.get_by_role("button", name="Start here").click()
```

</TabItem>
</Tabs>

Обработчик принимает оригинальный локатор в качестве аргумента. Вы также можете автоматически удалить обработчик после определенного количества вызовов, установив [times](/api/class-page.mdx#page-add-locator-handler-option-times):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def handler(locator):
  locator.click()
page.add_locator_handler(page.get_by_label("Close"), handler, times=1)
```

</TabItem>
<TabItem value="async">

```py
def handler(locator):
  await locator.click()
await page.add_locator_handler(page.get_by_label("Close"), handler, times=1)
```

</TabItem>
</Tabs>

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-locator"/><a href="#page-add-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, который вызывает обработчик.
- `handler` [Callable]\[[Locator]\]:[Promise]\[[Any]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-handler"/><a href="#page-add-locator-handler-option-handler" class="list-anchor">#</a>
  
  Функция, которая должна быть выполнена, когда [локатор](/api/class-page.mdx#page-add-locator-handler-option-locator) появляется. Эта функция должна избавиться от элемента, который блокирует действия, такие как клик.
- `no_wait_after` [bool] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-no-wait-after"/><a href="#page-add-locator-handler-option-no-wait-after" class="list-anchor">#</a>
  
  По умолчанию, после вызова обработчика Playwright будет ждать, пока наложение не станет скрытым, и только затем продолжит с действием/проверкой, которое вызвало обработчик. Эта опция позволяет отказаться от этого поведения, чтобы наложение могло оставаться видимым после выполнения обработчика.
- `times` [int] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-times"/><a href="#page-add-locator-handler-option-times" class="list-anchor">#</a>
  
  Указывает максимальное количество раз, которое этот обработчик должен быть вызван. По умолчанию не ограничено.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-return"/><a href="#page-add-locator-handler-return" class="list-anchor">#</a>

---

### add_script_tag {#page-add-script-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.add_script_tag</x-search>

Добавляет тег `<script>` на страницу с желаемым URL или содержимым. Возвращает добавленный тег, когда срабатывает событие onload скрипта или когда содержимое скрипта было внедрено в фрейм.

**Использование**

```python
page.add_script_tag()
page.add_script_tag(**kwargs)
```

**Аргументы**
- `content` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-content"/><a href="#page-add-script-tag-option-content" class="list-anchor">#</a>
  
  Сырой JavaScript-контент, который будет внедрен в фрейм.
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-path"/><a href="#page-add-script-tag-option-path" class="list-anchor">#</a>
  
  Путь к файлу JavaScript, который будет внедрен в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `type` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-type"/><a href="#page-add-script-tag-option-type" class="list-anchor">#</a>
  
  Тип скрипта. Используйте 'module', чтобы загрузить модуль JavaScript ES6. См. [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) для получения более подробной информации.
- `url` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-url"/><a href="#page-add-script-tag-option-url" class="list-anchor">#</a>
  
  URL скрипта, который будет добавлен.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-return"/><a href="#page-add-script-tag-return" class="list-anchor">#</a>

---

### add_style_tag {#page-add-style-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.add_style_tag</x-search>

Добавляет тег `<link rel="stylesheet">` на страницу с указанным URL или тег `<style type="text/css">` с содержимым. Возвращает добавленный тег, когда срабатывает событие onload таблицы стилей или когда CSS-контент был внедрен в фрейм.

**Использование**

```python
page.add_style_tag()
page.add_style_tag(**kwargs)
```

**Аргументы**
- `content` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-content"/><a href="#page-add-style-tag-option-content" class="list-anchor">#</a>
  
  Сырой CSS-контент для внедрения в фрейм.
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-path"/><a href="#page-add-style-tag-option-path" class="list-anchor">#</a>
  
  Путь к CSS-файлу для внедрения в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `url` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-url"/><a href="#page-add-style-tag-option-url" class="list-anchor">#</a>
  
  URL тега `<link>`.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-return"/><a href="#page-add-style-tag-return" class="list-anchor">#</a>

---

### bring_to_front {#page-bring-to-front}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.bring_to_front</x-search>

Выводит страницу на передний план (активирует вкладку).

**Использование**

```python
page.bring_to_front()
```

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-bring-to-front-return"/><a href="#page-bring-to-front-return" class="list-anchor">#</a>

---

### close {#page-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.close</x-search>

Если [run_before_unload](/api/class-page.mdx#page-close-option-run-before-unload) равен `false`, не выполняет обработчики выгрузки и ждет закрытия страницы. Если [run_before_unload](/api/class-page.mdx#page-close-option-run-before-unload) равен `true`, метод выполнит обработчики выгрузки, но **не** будет ждать закрытия страницы.

По умолчанию, `page.close()` **не** выполняет обработчики `beforeunload`.

:::note

если [run_before_unload](/api/class-page.mdx#page-close-option-run-before-unload) передан как true, может быть вызван диалог `beforeunload`, который должен быть обработан вручную через событие [page.on("dialog")](/api/class-page.mdx#page-event-dialog).
:::

**Использование**

```python
page.close()
page.close(**kwargs)
```

**Аргументы**
- `reason` [str] *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-reason"/><a href="#page-close-option-reason" class="list-anchor">#</a>
  
  Причина, которая будет сообщена операциям, прерванным закрытием страницы.
- `run_before_unload` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-run-before-unload"/><a href="#page-close-option-run-before-unload" class="list-anchor">#</a>
  
  По умолчанию `false`. Выполнять ли обработчики страницы [before unload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-return"/><a href="#page-close-return" class="list-anchor">#</a>

---

### content {#page-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.content</x-search>

Получает полный HTML-контент страницы, включая doctype.

**Использование**

```python
page.content()
```

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-content-return"/><a href="#page-content-return" class="list-anchor">#</a>

---

### drag_and_drop {#page-drag-and-drop}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>page.drag_and_drop</x-search>

Этот метод перетаскивает исходный элемент на целевой элемент. Сначала он перемещается к исходному элементу, выполняет `mousedown`, затем перемещается к целевому элементу и выполняет `mouseup`.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.drag_and_drop("#source", "#target")
# или укажите точные позиции относительно верхнего левого угла элементов:
page.drag_and_drop(
  "#source",
  "#target",
  source_position={"x": 34, "y": 7},
  target_position={"x": 10, "y": 20}
)
```

</TabItem>
<TabItem value="async">

```py
await page.drag_and_drop("#source", "#target")
# или укажите точные позиции относительно верхнего левого угла элементов:
await page.drag_and_drop(
  "#source",
  "#target",
  source_position={"x": 34, "y": 7},
  target_position={"x": 10, "y": 20}
)
```

</TabItem>
</Tabs>

**Аргументы**
- `source` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source"/><a href="#page-drag-and-drop-option-source" class="list-anchor">#</a>
  
  Селектор для поиска элемента, который нужно перетащить. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `target` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target"/><a href="#page-drag-and-drop-option-target" class="list-anchor">#</a>
  
  Селектор для поиска элемента, на который нужно сбросить. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `force` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-force"/><a href="#page-drag-and-drop-option-force" class="list-anchor">#</a>
  
  Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-no-wait-after"/><a href="#page-drag-and-drop-option-no-wait-after" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Эта опция не имеет эффекта.
  :::
  
  Эта опция не имеет эффекта.
- `source_position` [Dict] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source-position"/><a href="#page-drag-and-drop-option-source-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Кликает на исходный элемент в этой точке относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-strict"/><a href="#page-drag-and-drop-option-strict" class="list-anchor">#</a>
  
  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `target_position` [Dict] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target-position"/><a href="#page-drag-and-drop-option-target-position" class="list-anchor">#</a>
  - `x` [float]
    
    
  - `y` [float]
    
    
  Сбрасывает на целевой элемент в этой точке относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-timeout"/><a href="#page-drag-and-drop-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-trial"/><a href="#page-drag-and-drop-option-trial" class="list-anchor">#</a>
  
  Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-return"/><a href="#page-drag-and-drop-return" class="list-anchor">#</a>

---

### emulate_media {#page-emulate-media}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.emulate_media</x-search>

Этот метод изменяет `CSS media type` через аргумент `media` и/или медиа-функцию `'prefers-colors-scheme'`, используя аргумент `colorScheme`.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.evaluate("matchMedia('screen').matches")
# → True
page.evaluate("matchMedia('print').matches")
# → False

page.emulate_media(media="print")
page.evaluate("matchMedia('screen').matches")
# → False
page.evaluate("matchMedia('print').matches")
# → True

page.emulate_media()
page.evaluate("matchMedia('screen').matches")
# → True
page.evaluate("matchMedia('print').matches")
# → False
```

</TabItem>
<TabItem value="async">

```py
await page.evaluate("matchMedia('screen').matches")
# → True
await page.evaluate("matchMedia('print').matches")
# → False

await page.emulate_media(media="print")
await page.evaluate("matchMedia('screen').matches")
# → False
await page.evaluate("matchMedia('print').matches")
# → True

await page.emulate_media()
await page.evaluate("matchMedia('screen').matches")
# → True
await page.evaluate("matchMedia('print').matches")
# → False
```

</TabItem>
</Tabs>

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.emulate_media(color_scheme="dark")
page.evaluate("matchMedia('(prefers-color-scheme: dark)').matches")
# → True
page.evaluate("matchMedia('(prefers-color-scheme: light)').matches")
# → False
```

</TabItem>
<TabItem value="async">

```py
await page.emulate_media(color_scheme="dark")
await page.evaluate("matchMedia('(prefers-color-scheme: dark)').matches")
# → True
await page.evaluate("matchMedia('(prefers-color-scheme: light)').matches")
# → False
```

</TabItem>
</Tabs>

**Аргументы**
- `color_scheme` "light" | "dark" | "no-preference" | "null" *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-color-scheme"/><a href="#page-emulate-media-option-color-scheme" class="list-anchor">#</a>
  
  Эмулирует медиа-функцию [prefers-colors-scheme](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme), поддерживаемые значения: `'light'` и `'dark'`. Передача `'Null'` отключает эмуляцию цветовой схемы. `'no-preference'` устарело.
- `contrast` "no-preference" | "more" | "null" *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-contrast"/><a href="#page-emulate-media-option-contrast" class="list-anchor">#</a>
- `forced_colors` "active" | "none" | "null" *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-forced-colors"/><a href="#page-emulate-media-option-forced-colors" class="list-anchor">#</a>
- `media` "screen" | "print" | "null" *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-media"/><a href="#page-emulate-media-option-media" class="list-anchor">#</a>
  
  Изменяет тип CSS media страницы. Единственные допустимые значения: `'Screen'`, `'Print'` и `'Null'`. Передача `'Null'` отключает эмуляцию CSS media.
- `reduced_motion` "reduce" | "no-preference" | "null" *(опционально)* <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-reduced-motion"/><a href="#page-emulate-media-option-reduced-motion" class="list-anchor">#</a>
  
  Эмулирует медиа-функцию `'prefers-reduced-motion'`, поддерживаемые значения: `'reduce'`, `'no-preference'`. Передача `null` отключает эмуляцию уменьшенного движения.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-return"/><a href="#page-emulate-media-return" class="list-anchor">#</a>

---

### evaluate {#page-evaluate}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.evaluate</x-search>

Возвращает значение вызова [выражения](/api/class-page.mdx#page-evaluate-option-expression).

Если функция, переданная в [page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает [Promise], то [page.evaluate()](/api/class-page.mdx#page-evaluate) будет ждать разрешения промиса и вернет его значение.

Если функция, переданная в [page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает значение, не являющееся [Serializable], то [page.evaluate()](/api/class-page.mdx#page-evaluate) разрешается в `undefined`. Playwright также поддерживает передачу некоторых дополнительных значений, которые не сериализуются через `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.

**Использование**

Передача аргумента в [выражение](/api/class-page.mdx#page-evaluate-option-expression):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
result = page.evaluate("([x, y]) => Promise.resolve(x * y)", [7, 8])
print(result) # выводит "56"
```

</TabItem>
<TabItem value="async">

```py
result = await page.evaluate("([x, y]) => Promise.resolve(x * y)", [7, 8])
print(result) # выводит "56"
```

</TabItem>
</Tabs>

Вместо функции также можно передать строку:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
print(page.evaluate("1 + 2")) # выводит "3"
x = 10
print(page.evaluate(f"1 + {x}")) # выводит "11"
```

</TabItem>
<TabItem value="async">

```py
print(await page.evaluate("1 + 2")) # выводит "3"
x = 10
print(await page.evaluate(f"1 + {x}")) # выводит "11"
```

</TabItem>
</Tabs>

Экземпляры [ElementHandle] могут быть переданы в качестве аргумента в [page.evaluate()](/api/class-page.mdx#page-evaluate):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
body_handle = page.evaluate("document.body")
html = page.evaluate("([body, suffix]) => body.innerHTML + suffix", [body_handle, "hello"])
body_handle.dispose()
```

</TabItem>
<TabItem value="async">

```py
body_handle = await page.evaluate("document.body")
html = await page.evaluate("([body, suffix]) => body.innerHTML + suffix", [body_handle, "hello"])
await body_handle.dispose()
```

</TabItem>
</Tabs>

**Аргументы**
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-expression"/><a href="#page-evaluate-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-arg"/><a href="#page-evaluate-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [выражение](/api/class-page.mdx#page-evaluate-option-expression).

**Возвращает**
- [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-return"/><a href="#page-evaluate-return" class="list-anchor">#</a>

---

### evaluate_handle {#page-evaluate-handle}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.evaluate_handle</x-search>

Возвращает значение вызова [expression](/api/class-page.mdx#page-evaluate-handle-option-expression) в виде [JSHandle].

Единственное отличие между [page.evaluate()](/api/class-page.mdx#page-evaluate) и [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle) заключается в том, что [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle) возвращает [JSHandle].

Если функция, переданная в [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle), возвращает [Promise], то [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle) будет ожидать разрешения промиса и вернет его значение.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
a_window_handle = page.evaluate_handle("Promise.resolve(window)")
a_window_handle # handle для объекта window.
```

</TabItem>
<TabItem value="async">

```py
a_window_handle = await page.evaluate_handle("Promise.resolve(window)")
a_window_handle # handle для объекта window.
```

</TabItem>
</Tabs>

Вместо функции также можно передать строку:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
a_handle = page.evaluate_handle("document") # handle для "document"
```

</TabItem>
<TabItem value="async">

```py
a_handle = await page.evaluate_handle("document") # handle для "document"
```

</TabItem>
</Tabs>

Экземпляры [JSHandle] могут быть переданы в качестве аргумента в [page.evaluate_handle()](/api/class-page.mdx#page-evaluate-handle):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
a_handle = page.evaluate_handle("document.body")
result_handle = page.evaluate_handle("body => body.innerHTML", a_handle)
print(result_handle.json_value())
result_handle.dispose()
```

</TabItem>
<TabItem value="async">

```py
a_handle = await page.evaluate_handle("document.body")
result_handle = await page.evaluate_handle("body => body.innerHTML", a_handle)
print(await result_handle.json_value())
await result_handle.dispose()
```

</TabItem>
</Tabs>

**Аргументы**
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-expression"/><a href="#page-evaluate-handle-option-expression" class="list-anchor">#</a>
  
  JavaScript выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-arg"/><a href="#page-evaluate-handle-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-evaluate-handle-option-expression).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-return"/><a href="#page-evaluate-handle-return" class="list-anchor">#</a>

---

### expect_console_message {#page-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_console_message</x-search>

Выполняет действие и ожидает, пока [ConsoleMessage] не будет зарегистрировано на странице. Если предоставлен предикат, он передает значение [ConsoleMessage] в функцию `predicate` и ожидает, пока `predicate(message)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [page.on("console")](/api/class-page.mdx#page-event-console) будет вызвано.

**Использование**

```python
page.expect_console_message()
page.expect_console_message(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[ConsoleMessage]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-predicate"/><a href="#page-wait-for-console-message-option-predicate" class="list-anchor">#</a>
  
  Получает объект [ConsoleMessage] и разрешается в истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-timeout"/><a href="#page-wait-for-console-message-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[ConsoleMessage]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-return"/><a href="#page-wait-for-console-message-return" class="list-anchor">#</a>

---

### expect_download {#page-wait-for-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_download</x-search>

Выполняет действие и ожидает нового [Download]. Если предоставлен предикат, он передает значение [Download] в функцию `predicate` и ожидает, пока `predicate(download)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие загрузки будет вызвано.

**Использование**

```python
page.expect_download()
page.expect_download(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Download]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-predicate"/><a href="#page-wait-for-download-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Download] и разрешается в истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-timeout"/><a href="#page-wait-for-download-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Download]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-return"/><a href="#page-wait-for-download-return" class="list-anchor">#</a>

---

### expect_event {#page-wait-for-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expect_event</x-search>

Ожидает, пока событие не будет вызвано, и передает его значение в функцию предиката. Возвращает, когда предикат возвращает истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие будет вызвано. Возвращает значение данных события.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_event("framenavigated") as event_info:
    page.get_by_role("button")
frame = event_info.value
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_event("framenavigated") as event_info:
    await page.get_by_role("button")
frame = await event_info.value
```

</TabItem>
</Tabs>

**Аргументы**
- `event` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-option-event"/><a href="#page-wait-for-event-option-event" class="list-anchor">#</a>
  
  Имя события, то же самое, которое обычно передается в `*.on(event)`.
- `predicate` [Callable] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-option-predicate"/><a href="#page-wait-for-event-option-predicate" class="list-anchor">#</a>
  
  Получает данные события и разрешается в истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-option-timeout"/><a href="#page-wait-for-event-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-return"/><a href="#page-wait-for-event-return" class="list-anchor">#</a>

---

### expect_file_chooser {#page-wait-for-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_file_chooser</x-search>

Выполняет действие и ожидает, пока не будет создан новый [FileChooser]. Если предоставлен предикат, он передает значение [FileChooser] в функцию `predicate` и ожидает, пока `predicate(fileChooser)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как будет открыт выбор файла.

**Использование**

```python
page.expect_file_chooser()
page.expect_file_chooser(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[FileChooser]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-predicate"/><a href="#page-wait-for-file-chooser-option-predicate" class="list-anchor">#</a>
  
  Получает объект [FileChooser] и разрешается в истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-timeout"/><a href="#page-wait-for-file-chooser-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[FileChooser]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-return"/><a href="#page-wait-for-file-chooser-return" class="list-anchor">#</a>

---

### expect_popup {#page-wait-for-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_popup</x-search>

Выполняет действие и ожидает всплывающую [Page]. Если предоставлен предикат, он передает значение [Popup] в функцию `predicate` и ожидает, пока `predicate(page)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие всплывающего окна будет вызвано.

**Использование**

```python
page.expect_popup()
page.expect_popup(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Page]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-predicate"/><a href="#page-wait-for-popup-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Page] и разрешается в истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-timeout"/><a href="#page-wait-for-popup-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Page]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-return"/><a href="#page-wait-for-popup-return" class="list-anchor">#</a>

---

### expect_request {#page-wait-for-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expect_request</x-search>

Ожидает совпадающий запрос и возвращает его. См. [ожидание события](../events.mdx#waiting-for-event) для получения более подробной информации о событиях.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_request("http://example.com/resource") as first:
    page.get_by_text("trigger request").click()
first_request = first.value

# или с использованием лямбда-функции
with page.expect_request(lambda request: request.url == "http://example.com" and request.method == "get") as second:
    page.get_by_text("trigger request").click()
second_request = second.value
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_request("http://example.com/resource") as first:
    await page.get_by_text("trigger request").click()
first_request = await first.value

# или с использованием лямбда-функции
async with page.expect_request(lambda request: request.url == "http://example.com" and request.method == "get") as second:
    await page.get_by_text("trigger request").click()
second_request = await second.value
```

</TabItem>
</Tabs>

**Аргументы**
- `url_or_predicate` [str] | [Pattern] | [Callable]\[[Request]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-url-or-predicate"/><a href="#page-wait-for-request-option-url-or-predicate" class="list-anchor">#</a>
  
  URL запроса в виде строки, регулярного выражения или предиката, получающего объект [Request]. Когда [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-timeout"/><a href="#page-wait-for-request-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Request]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-return"/><a href="#page-wait-for-request-return" class="list-anchor">#</a>

---

### expect_request_finished {#page-wait-for-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>page.expect_request_finished</x-search>

Выполняет действие и ожидает, пока [Request] не завершит загрузку. Если предоставлен предикат, он передает значение [Request] в функцию `predicate` и ожидает, пока `predicate(request)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [page.on("requestfinished")](/api/class-page.mdx#page-event-request-finished) будет вызвано.

**Использование**

```python
page.expect_request_finished()
page.expect_request_finished(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Request]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-predicate"/><a href="#page-wait-for-request-finished-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Request] и разрешается в истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-timeout"/><a href="#page-wait-for-request-finished-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Request]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-return"/><a href="#page-wait-for-request-finished-return" class="list-anchor">#</a>

---

### expect_response {#page-wait-for-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expect_response</x-search>

Возвращает совпадающий ответ. См. [ожидание события](../events.mdx#waiting-for-event) для получения более подробной информации о событиях.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_response("https://example.com/resource") as response_info:
    page.get_by_text("trigger response").click()
response = response_info.value
return response.ok
```

# или с использованием лямбда-функции
with page.expect_response(lambda response: response.url == "https://example.com" and response.status == 200 and response.request.method == "get") as response_info:
    page.get_by_text("trigger response").click()
response = response_info.value
return response.ok
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_response("https://example.com/resource") as response_info:
    await page.get_by_text("trigger response").click()
response = await response_info.value
return response.ok

# или с использованием лямбда-функции
async with page.expect_response(lambda response: response.url == "https://example.com" and response.status == 200 and response.request.method == "get") as response_info:
    await page.get_by_text("trigger response").click()
response = await response_info.value
return response.ok
```

</TabItem>
</Tabs>

**Аргументы**
- `url_or_predicate` [str] | [Pattern] | [Callable]\[[Response]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-url-or-predicate"/><a href="#page-wait-for-response-option-url-or-predicate" class="list-anchor">#</a>
  
  URL запроса в виде строки, регулярного выражения или предиката, принимающего объект [Response]. Если через параметры контекста был предоставлен [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) и переданный URL является путем, он будет объединен с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-timeout"/><a href="#page-wait-for-response-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Response]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-return"/><a href="#page-wait-for-response-return" class="list-anchor">#</a>

---

### expect_websocket {#page-wait-for-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_websocket</x-search>

Выполняет действие и ожидает нового [WebSocket]. Если предикат предоставлен, он передает значение [WebSocket] в функцию `predicate` и ожидает, пока `predicate(webSocket)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие WebSocket будет вызвано.

**Использование**

```python
page.expect_websocket()
page.expect_websocket(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[WebSocket]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-predicate"/><a href="#page-wait-for-web-socket-option-predicate" class="list-anchor">#</a>
  
  Получает объект [WebSocket] и разрешает в истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-timeout"/><a href="#page-wait-for-web-socket-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[WebSocket]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-return"/><a href="#page-wait-for-web-socket-return" class="list-anchor">#</a>

---

### expect_worker {#page-wait-for-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.expect_worker</x-search>

Выполняет действие и ожидает нового [Worker]. Если предикат предоставлен, он передает значение [Worker] в функцию `predicate` и ожидает, пока `predicate(worker)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие worker будет вызвано.

**Использование**

```python
page.expect_worker()
page.expect_worker(**kwargs)
```

**Аргументы**
- `predicate` [Callable]\[[Worker]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-predicate"/><a href="#page-wait-for-worker-option-predicate" class="list-anchor">#</a>
  
  Получает объект [Worker] и разрешает в истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-timeout"/><a href="#page-wait-for-worker-option-timeout" class="list-anchor">#</a>
  
  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [EventContextManager]\[[Worker]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-return"/><a href="#page-wait-for-worker-return" class="list-anchor">#</a>

---

### expose_binding {#page-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expose_binding</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-binding-option-name) в объект `window` каждого фрейма на этой странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-binding-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-binding-option-callback). Если [callback](/api/class-page.mdx#page-expose-binding-option-callback) возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-page.mdx#page-expose-binding-option-callback) содержит информацию о вызывающем: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

Смотрите [browser_context.expose_binding()](/api/class-browsercontext.mdx#browser-context-expose-binding) для версии, охватывающей весь контекст.

:::note

Функции, установленные через [page.expose_binding()](/api/class-page.mdx#page-expose-binding), сохраняются при навигации.
:::

**Использование**

Пример предоставления URL страницы всем фреймам на странице:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch(headless=False)
    context = browser.new_context()
    page = context.new_page()
    page.expose_binding("pageURL", lambda source: source["page"].url)
    page.set_content("""
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
    """)
    page.click("button")

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    context = await browser.new_context()
    page = await context.new_page()
    await page.expose_binding("pageURL", lambda source: source["page"].url)
    await page.set_content("""
    <script>
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    </script>
    <button onclick="onClick()">Click me</button>
    <div></div>
    """)
    await page.click("button")

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-name"/><a href="#page-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Callable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-callback"/><a href="#page-expose-binding-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.
- `handle` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-handle"/><a href="#page-expose-binding-option-handle" class="list-anchor">#</a>
  
  :::warning[Устарело]
  Эта опция будет удалена в будущем.
  :::
  
  Передавать ли аргумент как handle, вместо передачи по значению. При передаче handle поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-return"/><a href="#page-expose-binding-return" class="list-anchor">#</a>

---

### expose_function {#page-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expose_function</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-function-option-name) в объект `window` каждого фрейма на странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-function-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-function-option-callback).

Если [callback](/api/class-page.mdx#page-expose-function-option-callback) возвращает [Promise], он будет ожидаться.

Смотрите [browser_context.expose_function()](/api/class-browsercontext.mdx#browser-context-expose-function) для версии, охватывающей весь контекст.

:::note

Функции, установленные через [page.expose_function()](/api/class-page.mdx#page-expose-function), сохраняются при навигации.
:::

**Использование**

Пример добавления функции `sha256` на страницу:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
import hashlib
from playwright.sync_api import sync_playwright, Playwright

def sha256(text):
    m = hashlib.sha256()
    m.update(bytes(text, "utf8"))
    return m.hexdigest()


def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch(headless=False)
    page = browser.new_page()
    page.expose_function("sha256", sha256)
    page.set_content("""
        <script>
          async function onClick() {
            document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
          }
        </script>
        <button onclick="onClick()">Click me</button>
        <div></div>
    """)
    page.click("button")

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
import hashlib
from playwright.async_api import async_playwright, Playwright

def sha256(text):
    m = hashlib.sha256()
    m.update(bytes(text, "utf8"))
    return m.hexdigest()


async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    page = await browser.new_page()
    await page.expose_function("sha256", sha256)
    await page.set_content("""
        <script>
          async function onClick() {
            document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');
          }
        </script>
        <button onclick="onClick()">Click me</button>
        <div></div>
    """)
    await page.click("button")

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-name"/><a href="#page-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window
- `callback` [Callable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-callback"/><a href="#page-expose-function-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-return"/><a href="#page-expose-function-return" class="list-anchor">#</a>

---

### frame {#page-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.frame</x-search>

Возвращает фрейм, соответствующий указанным критериям. Должно быть указано либо `name`, либо `url`.

**Использование**

```py
frame = page.frame(name="frame-name")
```

```py
frame = page.frame(url=r".*domain.*")
```

**Аргументы**
- `name` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-option-name"/><a href="#page-frame-option-name" class="list-anchor">#</a>
  
  Имя фрейма, указанное в атрибуте `name` тега `iframe`. Опционально.
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-option-url"/><a href="#page-frame-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, принимающий URL фрейма как объект [URL]. Опционально.

**Возвращает**
- [NoneType] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-return"/><a href="#page-frame-return" class="list-anchor">#</a>

---

### frame_locator {#page-frame-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.17</font><x-search>page.frame_locator</x-search>

При работе с iframes вы можете создать локатор фрейма, который войдет в iframe и позволит выбирать элементы в этом iframe.

**Использование**

Следующий фрагмент кода находит элемент с текстом "Submit" в iframe с id `my-frame`, например, `<iframe id="my-frame">`:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
locator = page.frame_locator("#my-iframe").get_by_text("Submit")
locator.click()
```

</TabItem>
<TabItem value="async">

```py
locator = page.frame_locator("#my-iframe").get_by_text("Submit")
await locator.click()
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-option-selector"/><a href="#page-frame-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении DOM элемента.

**Возвращает**
- [FrameLocator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-return"/><a href="#page-frame-locator-return" class="list-anchor">#</a>

---

### get_by_alt_text {#page-get-by-alt-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_alt_text</x-search>

Позволяет находить элементы по их alt-тексту.

**Использование**

Например, этот метод найдет изображение по alt-тексту "Playwright logo":

```html
<img alt='Playwright logo'>
```

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_alt_text("Playwright logo").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_alt_text("Playwright logo").click()
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-text"/><a href="#page-get-by-alt-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `exact` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-exact"/><a href="#page-get-by-alt-text-option-exact" class="list-anchor">#</a>
  
  Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-return"/><a href="#page-get-by-alt-text-return" class="list-anchor">#</a>

---

### get_by_label {#page-get-by-label}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_label</x-search>

Позволяет находить элементы ввода по тексту связанного элемента `<label>` или `aria-labelledby`, или по атрибуту `aria-label`.

**Использование**

Например, этот метод найдет поля ввода по меткам "Username" и "Password" в следующем DOM:

```html
<input aria-label="Username">
<label for="password-input">Password:</label>
<input id="password-input">
```

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_label("Username").fill("john")
page.get_by_label("Password").fill("secret")
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_label("Username").fill("john")
await page.get_by_label("Password").fill("secret")
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-text"/><a href="#page-get-by-label-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `exact` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-exact"/><a href="#page-get-by-label-option-exact" class="list-anchor">#</a>
  
  Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-return"/><a href="#page-get-by-label-return" class="list-anchor">#</a>

---

### get_by_placeholder {#page-get-by-placeholder}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_placeholder</x-search>

Позволяет находить элементы ввода по тексту-заполнителю.

**Использование**

Например, рассмотрим следующую структуру DOM.

```html
<input type="email" placeholder="name@example.com" />
```

Вы можете заполнить поле ввода, найдя его по тексту-заполнителю:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_placeholder("name@example.com").fill("playwright@microsoft.com")
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-text"/><a href="#page-get-by-placeholder-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `exact` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-exact"/><a href="#page-get-by-placeholder-option-exact" class="list-anchor">#</a>
  
  Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-return"/><a href="#page-get-by-placeholder-return" class="list-anchor">#</a>

---

### get_by_role {#page-get-by-role}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_role</x-search>

Позволяет находить элементы по их [ARIA роли](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA атрибутам](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) и [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name).

**Использование**

Рассмотрим следующую структуру DOM.

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```

Вы можете найти каждый элемент по его неявной роли:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_role("heading", name="Sign up")).to_be_visible()

page.get_by_role("checkbox", name="Subscribe").check()

page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_role("heading", name="Sign up")).to_be_visible()

await page.get_by_role("checkbox", name="Subscribe").check()

await page.get_by_role("button", name=re.compile("submit", re.IGNORECASE)).click()
```

</TabItem>
</Tabs>

**Аргументы**
- `role` "alert" | "alertdialog" | "application" | "article" | "banner" | "blockquote" | "button" | "caption" | "cell" | "checkbox" | "code" | "columnheader" | "combobox" | "complementary" | "contentinfo" | "definition" | "deletion" | "dialog" | "directory" | "document" | "emphasis" | "feed" | "figure" | "form" | "generic" | "grid" | "gridcell" | "group" | "heading" | "img" | "insertion" | "link" | "list" | "listbox" | "listitem" | "log" | "main" | "marquee" | "math" | "meter" | "menu" | "menubar" | "menuitem" | "menuitemcheckbox" | "menuitemradio" | "navigation" | "none" | "note" | "option" | "paragraph" | "presentation" | "progressbar" | "radio" | "radiogroup" | "region" | "row" | "rowgroup" | "rowheader" | "scrollbar" | "search" | "searchbox" | "separator" | "slider" | "spinbutton" | "status" | "strong" | "subscript" | "superscript" | "switch" | "tab" | "table" | "tablist" | "tabpanel" | "term" | "textbox" | "time" | "timer" | "toolbar" | "tooltip" | "tree" | "treegrid" | "treeitem"<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-role"/><a href="#page-get-by-role-option-role" class="list-anchor">#</a>
  
  Требуемая ARIA роль.
- `checked` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-checked"/><a href="#page-get-by-role-option-checked" class="list-anchor">#</a>
  
  Атрибут, который обычно устанавливается с помощью `aria-checked` или нативных `<input type=checkbox>` контролов.
  
  Узнайте больше о [`aria-checked`](https://www.w3.org/TR/wai-aria-1.2/#aria-checked).
- `disabled` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-disabled"/><a href="#page-get-by-role-option-disabled" class="list-anchor">#</a>
  
  Атрибут, который обычно устанавливается с помощью `aria-disabled` или `disabled`.
  
  :::note
  
  В отличие от большинства других атрибутов, `disabled` наследуется через иерархию DOM. Узнайте больше о [`aria-disabled`](https://www.w3.org/TR/wai-aria-1.2/#aria-disabled).
  :::
  
- `exact` [bool] *(опционально)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-exact"/><a href="#page-get-by-role-option-exact" class="list-anchor">#</a>
  
  Совпадает ли [name](/api/class-page.mdx#page-get-by-role-option-name) точно: с учетом регистра и всей строки. По умолчанию false. Игнорируется, когда [name](/api/class-page.mdx#page-get-by-role-option-name) является регулярным выражением. Обратите внимание, что точное совпадение все равно обрезает пробелы.
- `expanded` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-expanded"/><a href="#page-get-by-role-option-expanded" class="list-anchor">#</a>
  
  Атрибут, который обычно устанавливается с помощью `aria-expanded`.
  
  Узнайте больше о [`aria-expanded`](https://www.w3.org/TR/wai-aria-1.2/#aria-expanded).
- `include_hidden` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-include-hidden"/><a href="#page-get-by-role-option-include-hidden" class="list-anchor">#</a>
  
  Опция, которая контролирует, будут ли скрытые элементы соответствовать. По умолчанию, только не скрытые элементы, как [определено ARIA](https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion), соответствуют селектору роли.
  
  Узнайте больше о [`aria-hidden`](https://www.w3.org/TR/wai-aria-1.2/#aria-hidden).
- `level` [int] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-level"/><a href="#page-get-by-role-option-level" class="list-anchor">#</a>
  
  Числовой атрибут, который обычно присутствует для ролей `heading`, `listitem`, `row`, `treeitem`, с значениями по умолчанию для элементов `<h1>-<h6>`.
  
  Узнайте больше о [`aria-level`](https://www.w3.org/TR/wai-aria-1.2/#aria-level).
- `name` [str] | [Pattern] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-name"/><a href="#page-get-by-role-option-name" class="list-anchor">#</a>
  
  Опция для соответствия [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name). По умолчанию, соответствие не учитывает регистр и ищет подстроку, используйте [exact](/api/class-page.mdx#page-get-by-role-option-exact) для управления этим поведением.
  
  Узнайте больше о [доступном имени](https://w3c.github.io/accname/#dfn-accessible-name).
- `pressed` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-pressed"/><a href="#page-get-by-role-option-pressed" class="list-anchor">#</a>
  
  Атрибут, который обычно устанавливается с помощью `aria-pressed`.
  
  Узнайте больше о [`aria-pressed`](https://www.w3.org/TR/wai-aria-1.2/#aria-pressed).
- `selected` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-selected"/><a href="#page-get-by-role-option-selected" class="list-anchor">#</a>
  
  Атрибут, который обычно устанавливается с помощью `aria-selected`.
  
  Узнайте больше о [`aria-selected`](https://www.w3.org/TR/wai-aria-1.2/#aria-selected).

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-return"/><a href="#page-get-by-role-return" class="list-anchor">#</a>

**Детали**

Селектор роли **не заменяет** аудиты доступности и тесты на соответствие, но дает раннюю обратную связь о руководствах ARIA.

Многие HTML-элементы имеют неявно [определенную роль](https://w3c.github.io/html-aam/#html-element-role-mappings), которая распознается селектором роли. Вы можете найти все [поддерживаемые роли здесь](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). Руководства ARIA **не рекомендуют** дублировать неявные роли и атрибуты, устанавливая `role` и/или `aria-*` атрибуты на значения по умолчанию.

---

### get_by_test_id {#page-get-by-test-id}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_test_id</x-search>

Находит элемент по тестовому идентификатору.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<button data-testid="directions">Itinéraire</button>
```

Вы можете найти элемент по его тестовому идентификатору:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.get_by_test_id("directions").click()
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_test_id("directions").click()
```

</TabItem>
</Tabs>

**Аргументы**
- `test_id` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-option-test-id"/><a href="#page-get-by-test-id-option-test-id" class="list-anchor">#</a>
  
  Идентификатор для поиска элемента.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-return"/><a href="#page-get-by-test-id-return" class="list-anchor">#</a>

**Детали**

По умолчанию, атрибут `data-testid` используется как тестовый идентификатор. Используйте [selectors.set_test_id_attribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute) для настройки другого атрибута тестового идентификатора, если это необходимо.

---

### get_by_text {#page-get-by-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_text</x-search>

Позволяет находить элементы, содержащие заданный текст.

Смотрите также [locator.filter()](/api/class-locator.mdx#locator-filter), который позволяет сопоставлять по другим критериям, таким как доступная роль, а затем фильтровать по содержимому текста.

**Использование**

Рассмотрим следующую структуру DOM:

```html
<div>Hello <span>world</span></div>
<div>Hello</div>
```

Вы можете найти по подстроке текста, точной строке или регулярному выражению:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Совпадает с <span>
page.get_by_text("world")

# Совпадает с первым <div>
page.get_by_text("Hello world")

# Совпадает со вторым <div>
page.get_by_text("Hello", exact=True)

# Совпадает с обоими <div>
page.get_by_text(re.compile("Hello"))

# Совпадает со вторым <div>
page.get_by_text(re.compile("^hello$", re.IGNORECASE))
```

</TabItem>
<TabItem value="async">

```py
# Совпадает с <span>
page.get_by_text("world")

# Совпадает с первым <div>
page.get_by_text("Hello world")

# Совпадает со вторым <div>
page.get_by_text("Hello", exact=True)

# Совпадает с обоими <div>
page.get_by_text(re.compile("Hello"))

# Совпадает со вторым <div>
page.get_by_text(re.compile("^hello$", re.IGNORECASE))
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-text"/><a href="#page-get-by-text-option-text" class="list-anchor">#</a>

  Текст для поиска элемента.
- `exact` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-exact"/><a href="#page-get-by-text-option-exact" class="list-anchor">#</a>

  Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-return"/><a href="#page-get-by-text-return" class="list-anchor">#</a>

**Детали**

Поиск по тексту всегда нормализует пробелы, даже при точном совпадении. Например, он превращает несколько пробелов в один, заменяет разрывы строк на пробелы и игнорирует начальные и конечные пробелы.

Элементы ввода типа `button` и `submit` сопоставляются по их `value`, а не по текстовому содержимому. Например, поиск по тексту `"Log in"` совпадает с `<input type=button value="Log in">`.

---

### get_by_title {#page-get-by-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.get_by_title</x-search>

Позволяет находить элементы по их атрибуту title.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<span title='Issues count'>25 issues</span>
```

Вы можете проверить количество проблем, найдя его по тексту заголовка:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
expect(page.get_by_title("Issues count")).to_have_text("25 issues")
```

</TabItem>
<TabItem value="async">

```py
await expect(page.get_by_title("Issues count")).to_have_text("25 issues")
```

</TabItem>
</Tabs>

**Аргументы**
- `text` [str] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-text"/><a href="#page-get-by-title-option-text" class="list-anchor">#</a>

  Текст для поиска элемента.
- `exact` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-exact"/><a href="#page-get-by-title-option-exact" class="list-anchor">#</a>

  Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-return"/><a href="#page-get-by-title-return" class="list-anchor">#</a>

---

### go_back {#page-go-back}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.go_back</x-search>

Возвращает основной ответ ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. Если невозможно вернуться назад, возвращает `null`.

Переход на предыдущую страницу в истории.

**Использование**

```python
page.go_back()
page.go_back(**kwargs)
```

**Аргументы**
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-timeout"/><a href="#page-go-back-option-timeout" class="list-anchor">#</a>

  Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-wait-until"/><a href="#page-go-back-option-wait-until" class="list-anchor">#</a>

  Когда считать операцию успешной, по умолчанию `load`. События могут быть:
  * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
  * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
  * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [NoneType] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-return"/><a href="#page-go-back-return" class="list-anchor">#</a>

---

### go_forward {#page-go-forward}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.go_forward</x-search>

Возвращает основной ответ ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. Если невозможно перейти вперед, возвращает `null`.

Переход на следующую страницу в истории.

**Использование**

```python
page.go_forward()
page.go_forward(**kwargs)
```

**Аргументы**
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-timeout"/><a href="#page-go-forward-option-timeout" class="list-anchor">#</a>

  Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-wait-until"/><a href="#page-go-forward-option-wait-until" class="list-anchor">#</a>

  Когда считать операцию успешной, по умолчанию `load`. События могут быть:
  * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
  * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
  * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [NoneType] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-return"/><a href="#page-go-forward-return" class="list-anchor">#</a>

---

### goto {#page-goto}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.goto</x-search>

Возвращает основной ответ ресурса. В случае нескольких перенаправлений навигация будет разрешена с первым не перенаправленным ответом.

Метод вызовет ошибку, если:
* произошла ошибка SSL (например, в случае самоподписанных сертификатов).
* целевой URL недействителен.
* [timeout](/api/class-page.mdx#page-goto-option-timeout) превышен во время навигации.
* удаленный сервер не отвечает или недоступен.
* основной ресурс не удалось загрузить.

Метод не вызовет ошибку, если удаленный сервер вернет любой действительный код состояния HTTP, включая 404 "Not Found" и 500 "Internal Server Error". Код состояния для таких ответов можно получить, вызвав [response.status](/api/class-response.mdx#response-status).

:::note

Метод либо вызывает ошибку, либо возвращает основной ответ ресурса. Единственные исключения - это навигация на `about:blank` или навигация на тот же URL с другим хэшем, которые будут успешными и вернут `null`.
:::

:::note
Режим без головы не поддерживает навигацию к PDF-документу. См. [проблему в исходном коде](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).
:::

**Использование**

```python
page.goto(url)
page.goto(url, **kwargs)
```

**Аргументы**
- `url` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-url"/><a href="#page-goto-option-url" class="list-anchor">#</a>

  URL для перехода на страницу. URL должен включать схему, например, `https://`. Когда [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `referer` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-referer"/><a href="#page-goto-option-referer" class="list-anchor">#</a>

  Значение заголовка Referer. Если предоставлено, оно будет иметь приоритет над значением заголовка referer, установленным с помощью [page.set_extra_http_headers()](/api/class-page.mdx#page-set-extra-http-headers).
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-timeout"/><a href="#page-goto-option-timeout" class="list-anchor">#</a>

  Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-wait-until"/><a href="#page-goto-option-wait-until" class="list-anchor">#</a>

  Когда считать операцию успешной, по умолчанию `load`. События могут быть:
  * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
  * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
  * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [NoneType] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-return"/><a href="#page-goto-return" class="list-anchor">#</a>

---

### locator {#page-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.14</font><x-search>page.locator</x-search>

Метод возвращает локатор элемента, который можно использовать для выполнения действий на этой странице/фрейме. Локатор разрешается в элемент непосредственно перед выполнением действия, поэтому серия действий на одном и том же локаторе может фактически выполняться на разных элементах DOM. Это произойдет, если структура DOM между этими действиями изменилась.

[Узнайте больше о локаторах](../locators.mdx).

**Использование**

```python
page.locator(selector)
page.locator(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-selector"/><a href="#page-locator-option-selector" class="list-anchor">#</a>

  Селектор для использования при разрешении элемента DOM.
- `has` [Locator] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has"/><a href="#page-locator-option-has" class="list-anchor">#</a>

  Сужает результаты метода до тех, которые содержат элементы, соответствующие этому относительному локатору. Например, `article`, который имеет `text=Playwright`, совпадает с `<article><div>Playwright</div></article>`.

  Внутренний локатор **должен быть относительным** к внешнему локатору и запрашивается, начиная с совпадения внешнего локатора, а не с корня документа. Например, вы можете найти `content`, который имеет `div` в `<article><content><div>Playwright</div></content></article>`. Однако поиск `content`, который имеет `article div`, не удастся, потому что внутренний локатор должен быть относительным и не должен использовать элементы за пределами `content`.

  Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
- `has_not` [Locator] *(опционально)* <font size="2">Добавлено в: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not"/><a href="#page-locator-option-has-not" class="list-anchor">#</a>

  Совпадает с элементами, которые не содержат элемент, соответствующий внутреннему локатору. Внутренний локатор запрашивается относительно внешнего. Например, `article`, который не имеет `div`, совпадает с `<article><span>Playwright</span></article>`.

  Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
- `has_not_text` [str] | [Pattern] *(опционально)* <font size="2">Добавлено в: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not-text"/><a href="#page-locator-option-has-not-text" class="list-anchor">#</a>

  Совпадает с элементами, которые не содержат указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [строки] совпадение не учитывает регистр и ищет подстроку.
- `has_text` [str] | [Pattern] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-text"/><a href="#page-locator-option-has-text" class="list-anchor">#</a>

  Совпадает с элементами, содержащими указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [строки] совпадение не учитывает регистр и ищет подстроку. Например, `"Playwright"` совпадает с `<article><div>Playwright</div></article>`.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-return"/><a href="#page-locator-return" class="list-anchor">#</a>

---

### opener {#page-opener}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.opener</x-search>

Возвращает открыватель для всплывающих страниц и `null` для других. Если открыватель уже был закрыт, возвращает `null`.

**Использование**

```python
page.opener()
```

**Возвращает**
- [NoneType] | [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-opener-return"/><a href="#page-opener-return" class="list-anchor">#</a>

---

### pause {#page-pause}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.pause</x-search>

Приостанавливает выполнение скрипта. Playwright остановит выполнение скрипта и будет ждать, пока пользователь не нажмет кнопку 'Resume' в оверлее страницы или не вызовет `playwright.resume()` в консоли DevTools.

Пользователь может исследовать селекторы или выполнять ручные шаги во время паузы. Возобновление продолжит выполнение оригинального скрипта с того места, где он был приостановлен.

:::note

Этот метод требует, чтобы Playwright был запущен в режиме с интерфейсом, с ложным значением [headless](/api/class-browsertype.mdx#browser-type-launch-option-headless).
:::

**Использование**

```python
page.pause()
```

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pause-return"/><a href="#page-pause-return" class="list-anchor">#</a>

---

### pdf {#page-pdf}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.pdf</x-search>

Возвращает буфер PDF.

`page.pdf()` генерирует PDF страницы с `print` css media. Чтобы сгенерировать PDF с `screen` media, вызовите [page.emulate_media()](/api/class-page.mdx#page-emulate-media) перед вызовом `page.pdf()`:

:::note

По умолчанию `page.pdf()` генерирует PDF с измененными цветами для печати. Используйте свойство [`-webkit-print-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust), чтобы принудительно отобразить точные цвета.
:::

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# генерирует PDF с типом медиа "screen".
page.emulate_media(media="screen")
page.pdf(path="page.pdf")
```

</TabItem>
<TabItem value="async">

```py
# генерирует PDF с типом медиа "screen".
await page.emulate_media(media="screen")
await page.pdf(path="page.pdf")
```

</TabItem>
</Tabs>

Опции [width](/api/class-page.mdx#page-pdf-option-width), [height](/api/class-page.mdx#page-pdf-option-height) и [margin](/api/class-page.mdx#page-pdf-option-margin) принимают значения с указанием единиц измерения. Значения без указания единиц измерения считаются пикселями.

Несколько примеров:
* `page.pdf({width: 100})` - печатает с шириной, установленной в 100 пикселей
* `page.pdf({width: '100px'})` - печатает с шириной, установленной в 100 пикселей
* `page.pdf({width: '10cm'})` - печатает с шириной, установленной в 10 сантиметров.

Все возможные единицы измерения:
* `px` - пиксель
* `in` - дюйм
* `cm` - сантиметр
* `mm` - миллиметр

Опции [format](/api/class-page.mdx#page-pdf-option-format) включают:
* `Letter`: 8.5in x 11in
* `Legal`: 8.5in x 14in
* `Tabloid`: 11in x 17in
* `Ledger`: 17in x 11in
* `A0`: 33.1in x 46.8in
* `A1`: 23.4in x 33.1in
* `A2`: 16.54in x 23.4in
* `A3`: 11.7in x 16.54in
* `A4`: 8.27in x 11.7in
* `A5`: 5.83in x 8.27in
* `A6`: 4.13in x 5.83in

:::note

Разметка [header_template](/api/class-page.mdx#page-pdf-option-header-template) и [footer_template](/api/class-page.mdx#page-pdf-option-footer-template) имеет следующие ограничения: > 1. Теги скриптов внутри шаблонов не оцениваются. > 2. Стили страницы не видны внутри шаблонов.
:::

**Аргументы**
- `display_header_footer` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-display-header-footer"/><a href="#page-pdf-option-display-header-footer" class="list-anchor">#</a>

  Отображать заголовок и нижний колонтитул. По умолчанию `false`.
- `footer_template` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-footer-template"/><a href="#page-pdf-option-footer-template" class="list-anchor">#</a>

  HTML-шаблон для печатного нижнего колонтитула. Должен использовать тот же формат, что и [header_template](/api/class-page.mdx#page-pdf-option-header-template).
- `format` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-format"/><a href="#page-pdf-option-format" class="list-anchor">#</a>

  Формат бумаги. Если установлен, имеет приоритет над опциями [width](/api/class-page.mdx#page-pdf-option-width) или [height](/api/class-page.mdx#page-pdf-option-height). По умолчанию 'Letter'.
- `header_template` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-header-template"/><a href="#page-pdf-option-header-template" class="list-anchor">#</a>

  HTML-шаблон для печатного заголовка. Должен быть действительным HTML-разметкой с использованием следующих классов для вставки значений печати:
  * `'date'` отформатированная дата печати
  * `'title'` заголовок документа
  * `'url'` местоположение документа
  * `'pageNumber'` текущий номер страницы
  * `'totalPages'` общее количество страниц в документе
- `height` [str] | [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-height"/><a href="#page-pdf-option-height" class="list-anchor">#</a>

  Высота бумаги, принимает значения с указанием единиц измерения.
- `landscape` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-landscape"/><a href="#page-pdf-option-landscape" class="list-anchor">#</a>

  Ориентация бумаги. По умолчанию `false`.
- `margin` [Dict] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-margin"/><a href="#page-pdf-option-margin" class="list-anchor">#</a>
  - `top` [str] | [float] *(опционально)*

    Верхнее поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
  - `right` [str] | [float] *(опционально)*

    Правое поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
  - `bottom` [str] | [float] *(опционально)*

    Нижнее поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
  - `left` [str] | [float] *(опционально)*

    Левое поле, принимает значения с указанием единиц измерения. По умолчанию `0`.

  Поля бумаги, по умолчанию отсутствуют.
- `outline` [bool] *(опционально)* <font size="2">Добавлено в: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-outline"/><a href="#page-pdf-option-outline" class="list-anchor">#</a>

  Встраивать ли контур документа в PDF. По умолчанию `false`.
- `page_ranges` [str] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-page-ranges"/><a href="#page-pdf-option-page-ranges" class="list-anchor">#</a>

  Диапазоны страниц для печати, например, '1-5, 8, 11-13'. По умолчанию пустая строка, что означает печать всех страниц.
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-path"/><a href="#page-pdf-option-path" class="list-anchor">#</a>

  Путь к файлу для сохранения PDF. Если [path](/api/class-page.mdx#page-pdf-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не предоставлен, PDF не будет сохранен на диск.
- `prefer_css_page_size` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-prefer-css-page-size"/><a href="#page-pdf-option-prefer-css-page-size" class="list-anchor">#</a>

  Предпочитать ли любой размер страницы CSS `@page`, объявленный на странице, над тем, что объявлено в опциях [width](/api/class-page.mdx#page-pdf-option-width) и [height](/api/class-page.mdx#page-pdf-option-height) или [format](/api/class-page.mdx#page-pdf-option-format). По умолчанию `false`, что будет масштабировать содержимое, чтобы оно соответствовало размеру бумаги.
- `print_background` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-print-background"/><a href="#page-pdf-option-print-background" class="list-anchor">#</a>

  Печать фоновой графики. По умолчанию `false`.
- `scale` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-scale"/><a href="#page-pdf-option-scale" class="list-anchor">#</a>

  Масштаб рендеринга веб-страницы. По умолчанию `1`. Масштаб должен быть между 0.1 и 2.
- `tagged` [bool] *(опционально)* <font size="2">Добавлено в: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-tagged"/><a href="#page-pdf-option-tagged" class="list-anchor">#</a>

  Генерировать ли тегированный (доступный) PDF. По умолчанию `false`.
- `width` [str] | [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-width"/><a href="#page-pdf-option-width" class="list-anchor">#</a>

  Ширина бумаги, принимает значения с указанием единиц измерения.

**Возвращает**
- [bytes]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-return"/><a href="#page-pdf-return" class="list-anchor">#</a>

---

### перезагрузка {#page-reload}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.reload</x-search>

Этот метод перезагружает текущую страницу так же, как если бы пользователь инициировал обновление браузера. Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация завершится с ответом последнего перенаправления.

**Использование**

```python
page.reload()
page.reload(**kwargs)
```

**Аргументы**
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-timeout"/><a href="#page-reload-option-timeout" class="list-anchor">#</a>

  Максимальное время выполнения операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-wait-until"/><a href="#page-reload-option-wait-until" class="list-anchor">#</a>

  Когда считать операцию успешной, по умолчанию `load`. События могут быть:
  * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
  * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
  * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [NoneType] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-return"/><a href="#page-reload-return" class="list-anchor">#</a>

---

### remove_locator_handler {#page-remove-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.44</font><x-search>page.remove_locator_handler</x-search>

Удаляет все обработчики локаторов, добавленные с помощью [page.add_locator_handler()](/api/class-page.mdx#page-add-locator-handler) для конкретного локатора.

**Использование**

```python
page.remove_locator_handler(locator)
```

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-option-locator"/><a href="#page-remove-locator-handler-option-locator" class="list-anchor">#</a>

  Локатор, переданный в [page.add_locator_handler()](/api/class-page.mdx#page-add-locator-handler).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-return"/><a href="#page-remove-locator-handler-return" class="list-anchor">#</a>

---

### request_gc {#page-request-gc}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>page.request_gc</x-search>

Запрашивает выполнение сборки мусора на странице. Обратите внимание, что нет гарантии, что все недоступные объекты будут собраны.

Это полезно для обнаружения утечек памяти. Например, если на вашей странице есть большой объект `'suspect'`, который может утекать, вы можете проверить, что он не утек, используя [`WeakRef`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef).

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# 1. На вашей странице сохраните WeakRef для "suspect".
page.evaluate("globalThis.suspectWeakRef = new WeakRef(suspect)")
# 2. Запросите сборку мусора.
page.request_gc()
# 3. Проверьте, что слабая ссылка не ссылается на оригинальный объект.
assert page.evaluate("!globalThis.suspectWeakRef.deref()")
```

</TabItem>
<TabItem value="async">

```py
# 1. На вашей странице сохраните WeakRef для "suspect".
await page.evaluate("globalThis.suspectWeakRef = new WeakRef(suspect)")
# 2. Запросите сборку мусора.
await page.request_gc()
# 3. Проверьте, что слабая ссылка не ссылается на оригинальный объект.
assert await page.evaluate("!globalThis.suspectWeakRef.deref()")
```

</TabItem>
</Tabs>

**Использование**

```python
page.request_gc()
```

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-request-gc-return"/><a href="#page-request-gc-return" class="list-anchor">#</a>

---

### route {#page-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.route</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются страницей.

Как только маршрутизация включена, каждый запрос, соответствующий шаблону URL, будет приостановлен, если он не будет продолжен, выполнен или прерван.

:::note

Обработчик будет вызван только для первого URL, если ответ является перенаправлением.
:::

:::note
[page.route()](/api/class-page.mdx#page-route) не будет перехватывать запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [service_workers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

:::note
[page.route()](/api/class-page.mdx#page-route) не будет перехватывать первый запрос всплывающей страницы. Используйте [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) вместо этого.
:::

**Использование**

Пример простого обработчика, который прерывает все запросы изображений:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page = browser.new_page()
page.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
page.goto("https://example.com")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
page = await browser.new_page()
await page.route("**/*.{png,jpg,jpeg}", lambda route: route.abort())
await page.goto("https://example.com")
await browser.close()
```

</TabItem>
</Tabs>

или тот же фрагмент кода, использующий регулярное выражение:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page = browser.new_page()
page.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
page.goto("https://example.com")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
page = await browser.new_page()
await page.route(re.compile(r"(\.png$)|(\.jpg$)"), lambda route: route.abort())
await page.goto("https://example.com")
await browser.close()
```

</TabItem>
</Tabs>

Возможно исследовать запрос, чтобы решить, какое действие предпринять. Например, имитировать все запросы, содержащие некоторые данные POST, и оставлять все остальные запросы без изменений:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def handle_route(route: Route):
  if ("my-string" in route.request.post_data):
    route.fulfill(body="mocked-data")
  else:
    route.continue_()
page.route("/api/**", handle_route)
```

</TabItem>
<TabItem value="async">

```py
async def handle_route(route: Route):
  if ("my-string" in route.request.post_data):
    await route.fulfill(body="mocked-data")
  else:
    await route.continue_()
await page.route("/api/**", handle_route)
```

</TabItem>
</Tabs>

Маршруты страницы имеют приоритет над маршрутами контекста браузера (установленными с помощью [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route)), когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [page.unroute()](/api/class-page.mdx#page-unroute).

:::note

Включение маршрутизации отключает HTTP-кэш.
:::

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-url"/><a href="#page-route-option-url" class="list-anchor">#</a>

  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для сопоставления при маршрутизации. Когда [base_url](/api/class-browser.mdx#browser-new-context-option-base-url) через параметры контекста был предоставлен и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `handler` [Callable]\[[Route], [Request]\]:[Promise]\[[Any]\] | [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-handler"/><a href="#page-route-option-handler" class="list-anchor">#</a>

  Функция-обработчик для маршрутизации запроса.
- `times` [int] *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-times"/><a href="#page-route-option-times" class="list-anchor">#</a>

  Сколько раз маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-return"/><a href="#page-route-return" class="list-anchor">#</a>

---

### route_from_har {#page-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>page.route_from_har</x-search>

Если указано, сетевые запросы, выполняемые на странице, будут обслуживаться из HAR-файла. Подробнее о [Воспроизведении из HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из HAR-файла. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [service_workers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```python
page.route_from_har(har)
page.route_from_har(har, **kwargs)
```

**Аргументы**
- `har` [Union]\[[str], [pathlib.Path]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-har"/><a href="#page-route-from-har-option-har" class="list-anchor">#</a>

  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec) файлу с предварительно записанными сетевыми данными. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `not_found` "abort" | "fallback" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-not-found"/><a href="#page-route-from-har-option-not-found" class="list-anchor">#</a>
  * Если установлено значение 'abort', любой запрос, не найденный в HAR-файле, будет прерван.
  * Если установлено значение 'fallback', отсутствующие запросы будут отправлены в сеть.

  По умолчанию `abort`.
- `update` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update"/><a href="#page-route-from-har-option-update" class="list-anchor">#</a>

  Если указано, обновляет данный HAR с фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск, когда [browser_context.close()](/api/class-browsercontext.mdx#browser-context-close) вызывается.
- `update_content` "embed" | "attach" *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-content"/><a href="#page-route-from-har-option-update-content" class="list-anchor">#</a>

  Опциональная настройка для управления содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP-архиве. Если указано `embed`, содержимое сохраняется в HAR-файле.
- `update_mode` "full" | "minimal" *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-mode"/><a href="#page-route-from-har-option-update-mode" class="list-anchor">#</a>

  Когда установлено значение `minimal`, записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницу, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию `minimal`.
- `url` [str] | [Pattern] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-url"/><a href="#page-route-from-har-option-url" class="list-anchor">#</a>

  Глобальный шаблон, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR-файла. Если не указано, все запросы обслуживаются из HAR-файла.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-return"/><a href="#page-route-from-har-return" class="list-anchor">#</a>

---

### route_web_socket {#page-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>page.route_web_socket</x-search>

Этот метод позволяет изменять соединения WebSocket, которые создаются страницей.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизированы. Рекомендуется вызывать этот метод перед навигацией по странице.

**Использование**

Ниже приведен пример простого мока, который отвечает на одно сообщение. См. [WebSocketRoute] для получения более подробной информации и примеров.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  if message == "request":
    ws.send("response")

def handler(ws: WebSocketRoute):
  ws.on_message(lambda message: message_handler(ws, message))

page.route_web_socket("/ws", handler)
```

</TabItem>
<TabItem value="async">

```py
def message_handler(ws: WebSocketRoute, message: Union[str, bytes]):
  if message == "request":
    ws.send("response")

def handler(ws: WebSocketRoute):
  ws.on_message(lambda message: message_handler(ws, message))

await page.route_web_socket("/ws", handler)
```

</TabItem>
</Tabs>

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-url"/><a href="#page-route-web-socket-option-url" class="list-anchor">#</a>

  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизированы. Строковый шаблон может быть относительным к параметру контекста [base_url](/api/class-browser.mdx#browser-new-context-option-base-url).
- `handler` [Callable]\[[WebSocketRoute]\]:[Promise]\[[Any]\] | [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-handler"/><a href="#page-route-web-socket-option-handler" class="list-anchor">#</a>

  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-return"/><a href="#page-route-web-socket-return" class="list-anchor">#</a>

---

### скриншот {#page-screenshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.screenshot</x-search>

Возвращает буфер с захваченным скриншотом.

**Использование**

```python
page.screenshot()
page.screenshot(**kwargs)
```

**Аргументы**
- `animations` "disabled" | "allow" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-animations"/><a href="#page-screenshot-option-animations" class="list-anchor">#</a>

  При установке в `"disabled"`, останавливает CSS-анимации, CSS-переходы и веб-анимации. Анимации получают разное обращение в зависимости от их продолжительности:
  * конечные анимации быстро перематываются до завершения, так что они вызовут событие `transitionend`.
  * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся после скриншота.

  По умолчанию `"allow"`, что оставляет анимации нетронутыми.
- `caret` "hide" | "initial" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-caret"/><a href="#page-screenshot-option-caret" class="list-anchor">#</a>

  При установке в `"hide"`, скриншот скроет текстовый курсор. При установке в `"initial"`, поведение текстового курсора не будет изменено. По умолчанию `"hide"`.
- `clip` [Dict] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-clip"/><a href="#page-screenshot-option-clip" class="list-anchor">#</a>
  - `x` [float]

    x-координата верхнего левого угла области обрезки
  - `y` [float]

    y-координата верхнего левого угла области обрезки
  - `width` [float]

    ширина области обрезки
  - `height` [float]

    высота области обрезки

  Объект, который указывает обрезку результирующего изображения.
- `full_page` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-full-page"/><a href="#page-screenshot-option-full-page" class="list-anchor">#</a>

  Если установлено в `true`, делает скриншот всей прокручиваемой страницы, вместо текущей видимой области. По умолчанию `false`.
- `mask` [List]\[[Locator]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask"/><a href="#page-screenshot-option-mask" class="list-anchor">#</a>

  Укажите локаторы, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут покрыты розовым прямоугольником `#FF00FF` (настраивается с помощью [mask_color](/api/class-page.mdx#page-screenshot-option-mask-color)), который полностью покрывает их ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Сопоставление только видимых элементов](../locators.mdx#matching-only-visible-elements), чтобы отключить это.
- `mask_color` [str] *(опционально)* <font size="2">Добавлено в: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask-color"/><a href="#page-screenshot-option-mask-color" class="list-anchor">#</a>

  Укажите цвет наложения для замаскированных элементов в [CSS-формате цвета](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию - розовый `#FF00FF`.
- `omit_background` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-omit-background"/><a href="#page-screenshot-option-omit-background" class="list-anchor">#</a>

  Скрывает белый фон по умолчанию и позволяет делать скриншоты с прозрачностью. Не применимо к изображениям `jpeg`. По умолчанию `false`.
- `path` [Union]\[[str], [pathlib.Path]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-path"/><a href="#page-screenshot-option-path" class="list-anchor">#</a>

  Путь к файлу для сохранения изображения. Тип скриншота будет определен по расширению файла. Если [path](/api/class-page.mdx#page-screenshot-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, изображение не будет сохранено на диск.
- `quality` [int] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-quality"/><a href="#page-screenshot-option-quality" class="list-anchor">#</a>

  Качество изображения, от 0 до 100. Не применимо к изображениям `png`.
- `scale` "css" | "device" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-scale"/><a href="#page-screenshot-option-scale" class="list-anchor">#</a>

  При установке в `"css"`, скриншот будет иметь один пиксель на каждый css-пиксель на странице. Для устройств с высоким разрешением это позволит сохранить скриншоты небольшими. Использование опции `"device"` создаст один пиксель на каждый пиксель устройства, так что скриншоты устройств с высоким разрешением будут в два раза больше или даже больше.

  По умолчанию `"device"`.
- `style` [str] *(опционально)* <font size="2">Добавлено в: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-style"/><a href="#page-screenshot-option-style" class="list-anchor">#</a>

  Текст стиля, который будет применен при создании скриншота. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создать повторяемые скриншоты. Этот стиль проникает в Shadow DOM и применяется к внутренним фреймам.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-timeout"/><a href="#page-screenshot-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `type` "png" | "jpeg" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-type"/><a href="#page-screenshot-option-type" class="list-anchor">#</a>

  Укажите тип скриншота, по умолчанию `png`.

**Возвращает**
- [bytes]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-return"/><a href="#page-screenshot-return" class="list-anchor">#</a>

---

### set_content {#page-set-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.set_content</x-search>

Этот метод внутренне вызывает [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), наследуя все его специфические характеристики и поведение.

**Использование**

```python
page.set_content(html)
page.set_content(html, **kwargs)
```

**Аргументы**
- `html` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-html"/><a href="#page-set-content-option-html" class="list-anchor">#</a>

  HTML-разметка, которую нужно назначить странице.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-timeout"/><a href="#page-set-content-option-timeout" class="list-anchor">#</a>

  Максимальное время выполнения операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-wait-until"/><a href="#page-set-content-option-wait-until" class="list-anchor">#</a>

  Когда считать операцию успешной, по умолчанию `load`. События могут быть:
  * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
  * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
  * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-return"/><a href="#page-set-content-return" class="list-anchor">#</a>

---

### set_default_navigation_timeout {#page-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.set_default_navigation_timeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных с ними ярлыков:
* [page.go_back()](/api/class-page.mdx#page-go-back)
* [page.go_forward()](/api/class-page.mdx#page-go-forward)
* [page.goto()](/api/class-page.mdx#page-goto)
* [page.reload()](/api/class-page.mdx#page-reload)
* [page.set_content()](/api/class-page.mdx#page-set-content)
* [page.expect_navigation()](/api/class-page.mdx#page-wait-for-navigation)
* [page.wait_for_url()](/api/class-page.mdx#page-wait-for-url)

:::note

[page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) и [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```python
page.set_default_navigation_timeout(timeout)
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-navigation-timeout-option-timeout"/><a href="#page-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>

  Максимальное время навигации в миллисекундах

---

### set_default_timeout {#page-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.set_default_timeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих опцию [timeout](/api/class-page.mdx#page-set-default-timeout-option-timeout).

:::note

[page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
:::

**Использование**

```python
page.set_default_timeout(timeout)
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-timeout-option-timeout"/><a href="#page-set-default-timeout-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### set_extra_http_headers {#page-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.set_extra_http_headers</x-search>

Дополнительные HTTP-заголовки будут отправляться с каждым запросом, инициированным страницей.

:::note

[page.set_extra_http_headers()](/api/class-page.mdx#page-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```python
page.set_extra_http_headers(headers)
```

**Аргументы**
- `headers` [Dict]\[[str], [str]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-option-headers"/><a href="#page-set-extra-http-headers-option-headers" class="list-anchor">#</a>

  Объект, содержащий дополнительные HTTP-заголовки, которые будут отправляться с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-return"/><a href="#page-set-extra-http-headers-return" class="list-anchor">#</a>

---

### set_viewport_size {#page-set-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.set_viewport_size</x-search>

В случае нескольких страниц в одном браузере каждая страница может иметь свой собственный размер области просмотра. Однако [browser.new_context()](/api/class-browser.mdx#browser-new-context) позволяет установить размер области просмотра (и не только) для всех страниц в контексте сразу.

[page.set_viewport_size()](/api/class-page.mdx#page-set-viewport-size) изменит размер страницы. Многие веб-сайты не ожидают, что телефоны будут менять размер, поэтому вы должны установить размер области просмотра перед переходом на страницу. [page.set_viewport_size()](/api/class-page.mdx#page-set-viewport-size) также сбросит размер `screen`, используйте [browser.new_context()](/api/class-browser.mdx#browser-new-context) с параметрами `screen` и `viewport`, если вам нужен более точный контроль над этими свойствами.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page = browser.new_page()
page.set_viewport_size({"width": 640, "height": 480})
page.goto("https://example.com")
```

</TabItem>
<TabItem value="async">

```py
page = await browser.new_page()
await page.set_viewport_size({"width": 640, "height": 480})
await page.goto("https://example.com")
```

</TabItem>
</Tabs>

**Аргументы**
- `viewport_size` [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-option-viewport-size"/><a href="#page-set-viewport-size-option-viewport-size" class="list-anchor">#</a>
  - `width` [int]

    ширина страницы в пикселях.
  - `height` [int]

    высота страницы в пикселях.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-return"/><a href="#page-set-viewport-size-return" class="list-anchor">#</a>

---

### title {#page-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.title</x-search>

Возвращает заголовок страницы.

**Использование**

```python
page.title()
```

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-title-return"/><a href="#page-title-return" class="list-anchor">#</a>

---

### unroute {#page-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.unroute</x-search>

Удаляет маршрут, созданный с помощью [page.route()](/api/class-page.mdx#page-route). Когда [handler](/api/class-page.mdx#page-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-page.mdx#page-unroute-option-url).

**Использование**

```python
page.unroute(url)
page.unroute(url, **kwargs)
```

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-url"/><a href="#page-unroute-option-url" class="list-anchor">#</a>

  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для сопоставления при маршрутизации.
- `handler` [Callable]\[[Route], [Request]\]:[Promise]\[[Any]\] | [Any] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-handler"/><a href="#page-unroute-option-handler" class="list-anchor">#</a>

  Опциональная функция-обработчик для маршрутизации запроса.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-return"/><a href="#page-unroute-return" class="list-anchor">#</a>

---

### unroute_all {#page-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.41</font><x-search>page.unroute_all</x-search>

Удаляет все маршруты, созданные с помощью [page.route()](/api/class-page.mdx#page-route) и [page.route_from_har()](/api/class-page.mdx#page-route-from-har).

**Использование**

```python
page.unroute_all()
page.unroute_all(**kwargs)
```

**Аргументы**
- `behavior` "wait" | "ignoreErrors" | "default" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-option-behavior"/><a href="#page-unroute-all-option-behavior" class="list-anchor">#</a>

  Указывает, следует ли ждать уже выполняющихся обработчиков и что делать, если они вызывают ошибки:
  * `'default'` - не ждать завершения текущих вызовов обработчиков (если есть), если удаленный обработчик вызывает ошибку, это может привести к необработанной ошибке
  * `'wait'` - ждать завершения текущих вызовов обработчиков (если есть)
  * `'ignoreErrors'` - не ждать завершения текущих вызовов обработчиков (если есть), все ошибки, вызванные обработчиками после удаления маршрута, будут тихо пойманы

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-return"/><a href="#page-unroute-all-return" class="list-anchor">#</a>

---

### wait_for_event {#page-wait-for-event-2}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.wait_for_event</x-search>

:::note

В большинстве случаев следует использовать [page.expect_event()](/api/class-page.mdx#page-wait-for-event).
:::

Ожидает, пока заданное `событие` не будет вызвано. Если предикат предоставлен, он передает значение события в функцию `predicate` и ждет, пока `predicate(event)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до вызова `события`.

**Использование**

```python
page.wait_for_event(event)
page.wait_for_event(event, **kwargs)
```

**Аргументы**
- `event` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-2-option-event"/><a href="#page-wait-for-event-2-option-event" class="list-anchor">#</a>

  Имя события, то же самое, которое обычно передается в `*.on(event)`.
- `predicate` [Callable] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-2-option-predicate"/><a href="#page-wait-for-event-2-option-predicate" class="list-anchor">#</a>

  Получает данные события и разрешает истинное значение, когда ожидание должно завершиться.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-2-option-timeout"/><a href="#page-wait-for-event-2-option-timeout" class="list-anchor">#</a>

  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Any]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-event-2-return"/><a href="#page-wait-for-event-2-return" class="list-anchor">#</a>

---

### wait_for_function {#page-wait-for-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.wait_for_function</x-search>

Возвращает, когда [выражение](/api/class-page.mdx#page-wait-for-function-option-expression) возвращает истинное значение. Разрешается в JSHandle истинного значения.

**Использование**

[page.wait_for_function()](/api/class-page.mdx#page-wait-for-function) может быть использован для наблюдения за изменением размера области просмотра:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = webkit.launch()
    page = browser.new_page()
    page.evaluate("window.x = 0; setTimeout(() => { window.x = 100 }, 1000);")
    page.wait_for_function("() => window.x > 0")
    browser.close()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    webkit = playwright.webkit
    browser = await webkit.launch()
    page = await browser.new_page()
    await page.evaluate("window.x = 0; setTimeout(() => { window.x = 100 }, 1000);")
    await page.wait_for_function("() => window.x > 0")
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

Чтобы передать аргумент в предикат функции [page.wait_for_function()](/api/class-page.mdx#page-wait-for-function):

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
selector = ".foo"
page.wait_for_function("selector => !!document.querySelector(selector)", selector)
```

</TabItem>
<TabItem value="async">

```py
selector = ".foo"
await page.wait_for_function("selector => !!document.querySelector(selector)", selector)
```

</TabItem>
</Tabs>

**Аргументы**
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-expression"/><a href="#page-wait-for-function-option-expression" class="list-anchor">#</a>

  JavaScript-выражение, которое будет выполнено в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-arg"/><a href="#page-wait-for-function-option-arg" class="list-anchor">#</a>

  Опциональный аргумент для передачи в [выражение](/api/class-page.mdx#page-wait-for-function-option-expression).
- `polling` [float] | "raf" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-polling"/><a href="#page-wait-for-function-option-polling" class="list-anchor">#</a>

  Если [polling](/api/class-page.mdx#page-wait-for-function-option-polling) равно `'raf'`, то [выражение](/api/class-page.mdx#page-wait-for-function-option-expression) постоянно выполняется в `requestAnimationFrame` callback. Если [polling](/api/class-page.mdx#page-wait-for-function-option-polling) является числом, то оно рассматривается как интервал в миллисекундах, с которым функция будет выполняться. По умолчанию `raf`.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-timeout"/><a href="#page-wait-for-function-option-timeout" class="list-anchor">#</a>

  Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-return"/><a href="#page-wait-for-function-return" class="list-anchor">#</a>

---

### wait_for_load_state {#page-wait-for-load-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.wait_for_load_state</x-search>

Возвращает, когда достигнуто требуемое состояние загрузки.

Этот метод завершается, когда страница достигает требуемого состояния загрузки, по умолчанию `load`. Навигация должна быть завершена, когда вызывается этот метод. Если текущий документ уже достиг требуемого состояния, метод завершается немедленно.

:::note

В большинстве случаев этот метод не требуется, так как Playwright [автоматически ожидает перед каждым действием](../actionability.mdx).
:::

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]}
>
<TabItem value="sync">

```py
page.get_by_role("button").click() # клик вызывает навигацию.
page.wait_for_load_state() # обещание завершается после события "load".
```

</TabItem>
<TabItem value="async">

```py
await page.get_by_role("button").click() # клик вызывает навигацию.
await page.wait_for_load_state() # обещание завершается после события "load".
```

</TabItem>
</Tabs>

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]}
>
<TabItem value="sync">

```py
with page.expect_popup() as page_info:
    page.get_by_role("button").click() # клик вызывает всплывающее окно.
popup = page_info.value
# Ожидание события "DOMContentLoaded".
popup.wait_for_load_state("domcontentloaded")
print(popup.title()) # всплывающее окно готово к использованию.
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_popup() as page_info:
    await page.get_by_role("button").click() # клик вызывает всплывающее окно.
popup = await page_info.value
# Ожидание события "DOMContentLoaded".
await popup.wait_for_load_state("domcontentloaded")
print(await popup.title()) # всплывающее окно готово к использованию.
```

</TabItem>
</Tabs>

**Аргументы**
- `state` "load" | "domcontentloaded" | "networkidle" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-state"/><a href="#page-wait-for-load-state-option-state" class="list-anchor">#</a>

  Необязательное состояние загрузки для ожидания, по умолчанию `load`. Если состояние уже было достигнуто при загрузке текущего документа, метод завершается немедленно. Может быть одним из:
  * `'load'` - ожидание события `load`.
  * `'domcontentloaded'` - ожидание события `DOMContentLoaded`.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** ожидание, пока не будет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-timeout"/><a href="#page-wait-for-load-state-option-timeout" class="list-anchor">#</a>

  Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-return"/><a href="#page-wait-for-load-state-return" class="list-anchor">#</a>

---

### wait_for_url {#page-wait-for-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>page.wait_for_url</x-search>

Ожидает, пока основной фрейм перейдет на указанный URL.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]}
>
<TabItem value="sync">

```py
page.click("a.delayed-navigation") # клик по ссылке косвенно вызывает навигацию
page.wait_for_url("**/target.html")
```

</TabItem>
<TabItem value="async">

```py
await page.click("a.delayed-navigation") # клик по ссылке косвенно вызывает навигацию
await page.wait_for_url("**/target.html")
```

</TabItem>
</Tabs>

**Аргументы**
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-url"/><a href="#page-wait-for-url-option-url" class="list-anchor">#</a>

  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для сопоставления во время ожидания навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации на URL, который точно равен строке.
- `timeout` [float] *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-timeout"/><a href="#page-wait-for-url-option-timeout" class="list-anchor">#</a>

  Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-wait-until"/><a href="#page-wait-for-url-option-wait-until" class="list-anchor">#</a>

  Когда считать операцию успешной, по умолчанию `load`. События могут быть:
  * `'domcontentloaded'` - считать операцию завершенной, когда срабатывает событие `DOMContentLoaded`.
  * `'load'` - считать операцию завершенной, когда срабатывает событие `load`.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
  * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-return"/><a href="#page-wait-for-url-return" class="list-anchor">#</a>

---

## Свойства

### clock {#page-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.45</font><x-search>page.clock</x-search>

Playwright имеет возможность имитировать часы и ход времени.

**Использование**

```python
page.clock
```

**Тип**
- [Clock]

---

### context {#page-context}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.context</x-search>

Получить контекст браузера, к которому принадлежит страница.

**Использование**

```python
page.context
```

**Возвращает**
- [BrowserContext]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-context-return"/><a href="#page-context-return" class="list-anchor">#</a>

---

### frames {#page-frames}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.frames</x-search>

Массив всех фреймов, прикрепленных к странице.

**Использование**

```python
page.frames
```

**Возвращает**
- [List]\[[Frame]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frames-return"/><a href="#page-frames-return" class="list-anchor">#</a>

---

### is_closed {#page-is-closed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.is_closed</x-search>

Указывает, что страница была закрыта.

**Использование**

```python
page.is_closed()
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-closed-return"/><a href="#page-is-closed-return" class="list-anchor">#</a>

---

### keyboard {#page-keyboard}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.keyboard</x-search>

**Использование**

```python
page.keyboard
```

**Тип**
- [Keyboard]

---

### main_frame {#page-main-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.main_frame</x-search>

Основной фрейм страницы. Страница гарантированно имеет основной фрейм, который сохраняется во время навигации.

**Использование**

```python
page.main_frame
```

**Возвращает**
- [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-main-frame-return"/><a href="#page-main-frame-return" class="list-anchor">#</a>

---

### mouse {#page-mouse}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.mouse</x-search>

**Использование**

```python
page.mouse
```

**Тип**
- [Mouse]

---

### request {#page-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.16</font><x-search>page.request</x-search>

Помощник для тестирования API, связанный с этой страницей. Этот метод возвращает тот же экземпляр, что и [browser_context.request](/api/class-browsercontext.mdx#browser-context-request) в контексте страницы. Подробнее см. в [browser_context.request](/api/class-browsercontext.mdx#browser-context-request).

**Использование**

```python
page.request
```

**Тип**
- [APIRequestContext]

---

### touchscreen {#page-touchscreen}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.touchscreen</x-search>

**Использование**

```python
page.touchscreen
```

**Тип**
- [Touchscreen]

---

### url {#page-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.url</x-search>

**Использование**

```python
page.url
```

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-url-return"/><a href="#page-url-return" class="list-anchor">#</a>

---

### video {#page-video}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.video</x-search>

Объект видео, связанный с этой страницей.

**Использование**

```python
page.video
```

**Возвращает**
- [NoneType] | [Video]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-video-return"/><a href="#page-video-return" class="list-anchor">#</a>

---

### viewport_size {#page-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.viewport_size</x-search>

**Использование**

```python
page.viewport_size
```

**Возвращает**
- [NoneType] | [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-viewport-size-return"/><a href="#page-viewport-size-return" class="list-anchor">#</a>
  - `width` [int]

    ширина страницы в пикселях.
  - `height` [int]

    высота страницы в пикселях.

---

### workers {#page-workers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.workers</x-search>

Этот метод возвращает все выделенные [WebWorkers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API), связанные со страницей.

:::note

Это не включает ServiceWorkers
:::

**Использование**

```python
page.workers
```

**Возвращает**
- [List]\[[Worker]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-workers-return"/><a href="#page-workers-return" class="list-anchor">#</a>

---

## События

### on("close") {#page-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("close")</x-search>

Вызывается, когда страница закрывается.

**Использование**

```python
page.on("close", handler)
```

**Данные события**
- [Page]

---

### on("console") {#page-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("console")</x-search>

Вызывается, когда JavaScript на странице вызывает один из методов консольного API, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
def print_args(msg):
    for arg in msg.args:
        print(arg.json_value())

page.on("console", print_args)
page.evaluate("console.log('hello', 5, { foo: 'bar' })")
```

</TabItem>
<TabItem value="async">

```py
async def print_args(msg):
    values = []
    for arg in msg.args:
        values.append(await arg.json_value())
    print(values)

page.on("console", print_args)
await page.evaluate("console.log('hello', 5, { foo: 'bar' })")
```

</TabItem>
</Tabs>

**Данные события**
- [ConsoleMessage]

---

### on("crash") {#page-event-crash}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("crash")</x-search>

Вызывается, когда страница падает. Страницы браузера могут падать, если они пытаются выделить слишком много памяти. Когда страница падает, текущие и последующие операции будут вызывать исключения.

Наиболее распространенный способ справиться с падениями - поймать исключение:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
try:
    # Падение может произойти во время клика.
    page.click("button")
    # Или во время ожидания события.
    page.wait_for_event("popup")
except Error as e:
    pass
    # Когда страница падает, сообщение об исключении содержит "crash".
```

</TabItem>
<TabItem value="async">

```py
try:
    # Падение может произойти во время клика.
    await page.click("button")
    # Или во время ожидания события.
    await page.wait_for_event("popup")
except Error as e:
    pass
    # Когда страница падает, сообщение об исключении содержит "crash".
```

</TabItem>
</Tabs>

**Использование**

```python
page.on("crash", handler)
```

**Данные события**
- [Page]

---

### on("dialog") {#page-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("dialog")</x-search>

Вызывается, когда появляется JavaScript-диалог, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Слушатель **должен** либо [dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница [заморозится](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалога, и действия, такие как клик, никогда не завершатся.

**Использование**

```python
page.on("dialog", lambda dialog: dialog.accept())
```

:::note
Когда нет слушателей [page.on("dialog")](/api/class-page.mdx#page-event-dialog) или [browser_context.on("dialog")](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### on("domcontentloaded") {#page-event-dom-content-loaded}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.on("domcontentloaded")</x-search>

Вызывается, когда JavaScript-событие [`DOMContentLoaded`](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded) отправляется.

**Использование**

```python
page.on("domcontentloaded", handler)
```

**Данные события**
- [Page]

---

### on("download") {#page-event-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("download")</x-search>

Вызывается, когда начинается загрузка вложения. Пользователь может получить доступ к основным операциям с файлами на загруженном контенте через переданный экземпляр [Download].

**Использование**

```python
page.on("download", handler)
```

**Данные события**
- [Download]

---

### on("filechooser") {#page-event-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.on("filechooser")</x-search>

Вызывается, когда предполагается появление выбора файла, например, после нажатия на `<input type=file>`. Playwright может ответить на это, установив файлы ввода с помощью [file_chooser.set_files()](/api/class-filechooser.mdx#file-chooser-set-files), которые могут быть загружены после этого.

```py
page.on("filechooser", lambda file_chooser: file_chooser.set_files("/tmp/myfile.pdf"))
```

**Использование**

```python
page.on("filechooser", handler)
```

**Данные события**
- [FileChooser]

---

### on("frameattached") {#page-event-frame-attached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.on("frameattached")</x-search>

Вызывается, когда фрейм присоединяется.

**Использование**

```python
page.on("frameattached", handler)
```

**Данные события**
- [Frame]

---

### on("framedetached") {#page-event-frame-detached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.on("framedetached")</x-search>

Вызывается, когда фрейм отсоединяется.

**Использование**

```python
page.on("framedetached", handler)
```

**Данные события**
- [Frame]

---

### on("framenavigated") {#page-event-frame-navigated}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.on("framenavigated")</x-search>

Вызывается, когда фрейм переходит на новый URL.

**Использование**

```python
page.on("framenavigated", handler)
```

**Данные события**
- [Frame]

---

### on("load") {#page-event-load}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("load")</x-search>

Вызывается, когда JavaScript-событие [`load`](https://developer.mozilla.org/en-US/docs/Web/Events/load) отправляется.

**Использование**

```python
page.on("load", handler)
```

**Данные события**
- [Page]

---

### on("pageerror") {#page-event-page-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в версии: v1.9</font><x-search>page.on("pageerror")</x-search>

Вызывается, когда на странице происходит необработанное исключение.

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Логировать все необработанные ошибки в терминал
page.on("pageerror", lambda exc: print(f"uncaught exception: {exc}"))

# Перейти на страницу с исключением.
page.goto("data:text/html,<script>throw new Error('test')</script>")
```

</TabItem>
<TabItem value="async">

```py
# Логировать все необработанные ошибки в терминал
page.on("pageerror", lambda exc: print(f"uncaught exception: {exc}"))

# Перейти на страницу с исключением.
await page.goto("data:text/html,<script>throw new Error('test')</script>")
```

</TabItem>
</Tabs>

**Использование**

```python
page.on("pageerror", handler)
```

**Данные события**
- [Error]

---

### on("popup") {#page-event-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("popup")</x-search>

Вызывается, когда страница открывает новую вкладку или окно. Это событие вызывается в дополнение к [browser_context.on("page")](/api/class-browsercontext.mdx#browser-context-event-page), но только для всплывающих окон, относящихся к этой странице.

Самый ранний момент, когда страница доступна, это когда она перешла на начальный URL. Например, при открытии всплывающего окна с `window.open('http://example.com')`, это событие сработает, когда сетевой запрос к "http://example.com" будет выполнен и его ответ начнет загружаться во всплывающем окне. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route) и [browser_context.on("request")](/api/class-browsercontext.mdx#browser-context-event-request) соответственно, вместо аналогичных методов на [Page].

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_event("popup") as page_info:
    page.get_by_text("open the popup").click()
popup = page_info.value
print(popup.evaluate("location.href"))
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_event("popup") as page_info:
    await page.get_by_text("open the popup").click()
popup = await page_info.value
print(await popup.evaluate("location.href"))
```

</TabItem>
</Tabs>

:::note

Используйте [page.wait_for_load_state()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев это не потребуется).
:::

**Использование**

```python
page.on("popup", handler)
```

**Данные события**
- [Page]

---

### on("request") {#page-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("request")</x-search>

Вызывается, когда страница отправляет запрос. Объект [request] доступен только для чтения. Чтобы перехватывать и изменять запросы, см. [page.route()](/api/class-page.mdx#page-route) или [browser_context.route()](/api/class-browsercontext.mdx#browser-context-route).

**Использование**

```python
page.on("request", handler)
```

**Данные события**
- [Request]

---

### on("requestfailed") {#page-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("requestfailed")</x-search>

Вызывается, когда запрос не удается выполнить, например, из-за истечения времени ожидания.

```python
page.on("requestfailed", lambda request: print(request.url + " " + request.failure.error_text))
```

:::note
Ответы с HTTP ошибками, такие как 404 или 503, все равно считаются успешными с точки зрения HTTP, поэтому запрос завершится событием [page.on("requestfinished")](/api/class-page.mdx#page-event-request-finished), а не [page.on("requestfailed")](/api/class-page.mdx#page-event-request-failed). Запрос будет считаться неудачным только в случае, если клиент не может получить HTTP ответ от сервера, например, из-за сетевой ошибки net::ERR_FAILED.
:::

**Использование**

```python
page.on("requestfailed", handler)
```

**Данные события**
- [Request]

---

### on("requestfinished") {#page-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("requestfinished")</x-search>

Вызывается, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```python
page.on("requestfinished", handler)
```

**Данные события**
- [Request]

---

### on("response") {#page-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("response")</x-search>

Вызывается, когда получены статус и заголовки [response] для запроса. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```python
page.on("response", handler)
```

**Данные события**
- [Response]

---

### on("websocket") {#page-event-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.on("websocket")</x-search>

Вызывается, когда отправляется запрос [WebSocket].

**Использование**

```python
page.on("websocket", handler)
```

**Данные события**
- [WebSocket]

---

### on("worker") {#page-event-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.on("worker")</x-search>

Вызывается, когда страница порождает выделенный [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API).

**Использование**

```python
page.on("worker", handler)
```

**Данные события**
- [Worker]

---

## Устаревшие

### accessibility {#page-accessibility}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.accessibility</x-search>

:::warning Устарело

Это свойство не рекомендуется использовать. Пожалуйста, используйте другие библиотеки, такие как [Axe](https://www.deque.com/axe/), если вам нужно тестировать доступность страницы. См. наш [руководство](https://playwright.dev/docs/accessibility-testing) по интеграции с Axe для Node.js.

:::

**Использование**

```python
page.accessibility
```

**Тип**
- [Accessibility]

---

### check {#page-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.check</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.check()](/api/class-locator.mdx#locator-check) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод отмечает элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже отмечен, этот метод возвращается немедленно.
3. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [force](/api/class-page.mdx#page-check-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
4. Прокрутите элемент в видимую область, если это необходимо.
5. Используйте [page.mouse](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента.
6. Убедитесь, что элемент теперь отмечен. Если нет, этот метод выбрасывает исключение.

Если все шаги в совокупности не завершились в течение указанного [timeout](/api/class-page.mdx#page-check-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```python
page.check(selector)
page.check(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-selector"/><a href="#page-check-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `force` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-force"/><a href="#page-check-option-force" class="list-anchor">#</a>

  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-no-wait-after"/><a href="#page-check-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Эта опция не имеет эффекта.
  :::

  Эта опция не имеет эффекта.
- `position` [Dict] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-position"/><a href="#page-check-option-position" class="list-anchor">#</a>
  - `x` [float]


  - `y` [float]


  Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-strict"/><a href="#page-check-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-timeout"/><a href="#page-check-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-trial"/><a href="#page-check-option-trial" class="list-anchor">#</a>

  Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-return"/><a href="#page-check-return" class="list-anchor">#</a>

---

### click {#page-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.click</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.click()](/api/class-locator.mdx#locator-click) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод щелкает по элементу, соответствующему [selector](/api/class-page.mdx#page-click-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-click-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [force](/api/class-page.mdx#page-click-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
3. Прокрутите элемент в видимую область, если это необходимо.
4. Используйте [page.mouse](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента или в указанной [position](/api/class-page.mdx#page-click-option-position).
5. Подождите, пока инициированные навигации не завершатся успешно или не завершатся с ошибкой, если только не установлена опция [no_wait_after](/api/class-page.mdx#page-click-option-no-wait-after).

Если все шаги в совокупности не завершились в течение указанного [timeout](/api/class-page.mdx#page-click-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```python
page.click(selector)
page.click(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-selector"/><a href="#page-click-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `button` "left" | "right" | "middle" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-button"/><a href="#page-click-option-button" class="list-anchor">#</a>

  По умолчанию `left`.
- `click_count` [int] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-click-count"/><a href="#page-click-option-click-count" class="list-anchor">#</a>

  По умолчанию 1. См. [UIEvent.detail].
- `delay` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-delay"/><a href="#page-click-option-delay" class="list-anchor">#</a>

  Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
- `force` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-force"/><a href="#page-click-option-force" class="list-anchor">#</a>

  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `modifiers` [List]\["Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-modifiers"/><a href="#page-click-option-modifiers" class="list-anchor">#</a>

  Модификаторы клавиш для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-no-wait-after"/><a href="#page-click-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Эта опция по умолчанию будет `true` в будущем.
  :::

  Действия, инициирующие навигации, ожидают, пока эти навигации не произойдут и страницы не начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится эта опция только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
- `position` [Dict] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-position"/><a href="#page-click-option-position" class="list-anchor">#</a>
  - `x` [float]


  - `y` [float]


  Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-strict"/><a href="#page-click-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-timeout"/><a href="#page-click-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-trial"/><a href="#page-click-option-trial" class="list-anchor">#</a>

  Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-return"/><a href="#page-click-return" class="list-anchor">#</a>

---

### dblclick {#page-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.dblclick</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.dblclick()](/api/class-locator.mdx#locator-dblclick) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет двойной щелчок по элементу, соответствующему [selector](/api/class-page.mdx#page-dblclick-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-dblclick-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [force](/api/class-page.mdx#page-dblclick-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
3. Прокрутите элемент в видимую область, если это необходимо.
4. Используйте [page.mouse](/api/class-page.mdx#page-mouse), чтобы выполнить двойной щелчок в центре элемента или в указанной [position](/api/class-page.mdx#page-dblclick-option-position).

Если все шаги в совокупности не завершились в течение указанного [timeout](/api/class-page.mdx#page-dblclick-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

:::note

`page.dblclick()` генерирует два события `click` и одно событие `dblclick`.
:::

**Использование**

```python
page.dblclick(selector)
page.dblclick(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-selector"/><a href="#page-dblclick-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `button` "left" | "right" | "middle" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-button"/><a href="#page-dblclick-option-button" class="list-anchor">#</a>

  По умолчанию `left`.
- `delay` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-delay"/><a href="#page-dblclick-option-delay" class="list-anchor">#</a>

  Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
- `force` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-force"/><a href="#page-dblclick-option-force" class="list-anchor">#</a>

  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `modifiers` [List]\["Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-modifiers"/><a href="#page-dblclick-option-modifiers" class="list-anchor">#</a>

  Модификаторы клавиш для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-no-wait-after"/><a href="#page-dblclick-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Эта опция не имеет эффекта.
  :::

  Эта опция не имеет эффекта.
- `position` [Dict] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-position"/><a href="#page-dblclick-option-position" class="list-anchor">#</a>
  - `x` [float]


  - `y` [float]


  Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-strict"/><a href="#page-dblclick-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-timeout"/><a href="#page-dblclick-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-trial"/><a href="#page-dblclick-option-trial" class="list-anchor">#</a>

  Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-return"/><a href="#page-dblclick-return" class="list-anchor">#</a>

---

### dispatch_event {#page-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.dispatch_event</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.dispatch_event()](/api/class-locator.mdx#locator-dispatch-event) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Пример ниже генерирует событие `click` на элементе. Независимо от состояния видимости элемента, `click` генерируется. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page.dispatch_event("button#submit", "click")
```

</TabItem>
<TabItem value="async">

```py
await page.dispatch_event("button#submit", "click")
```

</TabItem>
</Tabs>

Внутри создается экземпляр события на основе указанного [type](/api/class-page.mdx#page-dispatch-event-option-type), инициализируется с помощью свойств [event_init](/api/class-page.mdx#page-dispatch-event-option-event-init) и генерируется на элементе. События по умолчанию `composed`, `cancelable` и всплывают.

Поскольку [event_init](/api/class-page.mdx#page-dispatch-event-option-event-init) специфичен для события, пожалуйста, обратитесь к документации по событиям для списков начальных свойств:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Вы также можете указать `JSHandle` в качестве значения свойства, если хотите, чтобы живые объекты передавались в событие:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Sync', value: 'sync'},
    {label: 'Async', value: 'async'}
  ]
}>
<TabItem value="sync">

```py

# обратите внимание, что вы можете создать data_transfer только в chromium и firefox
data_transfer = page.evaluate_handle("new DataTransfer()")
page.dispatch_event("#source", "dragstart", { "dataTransfer": data_transfer })
```

</TabItem>
<TabItem value="async">

```py
# обратите внимание, что вы можете создать data_transfer только в chromium и firefox
data_transfer = await page.evaluate_handle("new DataTransfer()")
await page.dispatch_event("#source", "dragstart", { "dataTransfer": data_transfer })
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-selector"/><a href="#page-dispatch-event-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `type` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-type"/><a href="#page-dispatch-event-option-type" class="list-anchor">#</a>

  Тип DOM события: `"click"`, `"dragstart"` и т.д.
- `event_init` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-event-init"/><a href="#page-dispatch-event-option-event-init" class="list-anchor">#</a>

  Опциональные свойства инициализации, специфичные для события.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-strict"/><a href="#page-dispatch-event-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-timeout"/><a href="#page-dispatch-event-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-return"/><a href="#page-dispatch-event-return" class="list-anchor">#</a>

---

### eval_on_selector {#page-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.eval_on_selector</x-search>

:::warning[Не рекомендуется]

Этот метод не ожидает, пока элемент пройдет проверки на возможность действия, и поэтому может привести к нестабильным тестам. Вместо этого используйте [locator.evaluate()](/api/class-locator.mdx#locator-evaluate), другие вспомогательные методы [Locator] или утверждения, ориентированные на веб.

:::

Метод находит элемент, соответствующий указанному селектору на странице, и передает его в качестве первого аргумента в [expression](/api/class-page.mdx#page-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выбрасывает ошибку. Возвращает значение [expression](/api/class-page.mdx#page-eval-on-selector-option-expression).

Если [expression](/api/class-page.mdx#page-eval-on-selector-option-expression) возвращает [Promise], то [page.eval_on_selector()](/api/class-page.mdx#page-eval-on-selector) будет ожидать разрешения промиса и вернет его значение.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
search_value = page.eval_on_selector("#search", "el => el.value")
preload_href = page.eval_on_selector("link[rel=preload]", "el => el.href")
html = page.eval_on_selector(".main-container", "(e, suffix) => e.outer_html + suffix", "hello")
```

</TabItem>
<TabItem value="async">

```py
search_value = await page.eval_on_selector("#search", "el => el.value")
preload_href = await page.eval_on_selector("link[rel=preload]", "el => el.href")
html = await page.eval_on_selector(".main-container", "(e, suffix) => e.outer_html + suffix", "hello")
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-selector"/><a href="#page-eval-on-selector-option-selector" class="list-anchor">#</a>

  Селектор для запроса.
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-expression"/><a href="#page-eval-on-selector-option-expression" class="list-anchor">#</a>

  JavaScript выражение, которое будет выполнено в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-arg"/><a href="#page-eval-on-selector-option-arg" class="list-anchor">#</a>

  Опциональный аргумент для передачи в [expression](/api/class-page.mdx#page-eval-on-selector-option-expression).
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-strict"/><a href="#page-eval-on-selector-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Возвращает**
- [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-return"/><a href="#page-eval-on-selector-return" class="list-anchor">#</a>

---

### eval_on_selector_all {#page-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.eval_on_selector_all</x-search>

:::warning[Не рекомендуется]

В большинстве случаев [locator.evaluate_all()](/api/class-locator.mdx#locator-evaluate-all), другие вспомогательные методы [Locator] и утверждения, ориентированные на веб, выполняют работу лучше.

:::

Метод находит все элементы, соответствующие указанному селектору на странице, и передает массив найденных элементов в качестве первого аргумента в [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression). Возвращает результат вызова [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

Если [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression) возвращает [Promise], то [page.eval_on_selector_all()](/api/class-page.mdx#page-eval-on-selector-all) будет ожидать разрешения промиса и вернет его значение.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
div_counts = page.eval_on_selector_all("div", "(divs, min) => divs.length >= min", 10)
```

</TabItem>
<TabItem value="async">

```py
div_counts = await page.eval_on_selector_all("div", "(divs, min) => divs.length >= min", 10)
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-selector"/><a href="#page-eval-on-selector-all-option-selector" class="list-anchor">#</a>

  Селектор для запроса.
- `expression` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-expression"/><a href="#page-eval-on-selector-all-option-expression" class="list-anchor">#</a>

  JavaScript выражение, которое будет выполнено в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-arg"/><a href="#page-eval-on-selector-all-option-arg" class="list-anchor">#</a>

  Опциональный аргумент для передачи в [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

**Возвращает**
- [Dict]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-return"/><a href="#page-eval-on-selector-all-return" class="list-anchor">#</a>

---

### expect_navigation {#page-wait-for-navigation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.expect_navigation</x-search>

:::warning Устарело

Этот метод по своей природе является гонкой, пожалуйста, используйте [page.wait_for_url()](/api/class-page.mdx#page-wait-for-url) вместо него.

:::

Ожидает навигации основного фрейма и возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация разрешится с ответом последнего перенаправления. В случае навигации к другому якорю или навигации из-за использования History API, навигация разрешится с `null`.

**Использование**

Это разрешается, когда страница переходит на новый URL или перезагружается. Это полезно, когда вы выполняете код, который косвенно вызывает навигацию страницы. Например, цель клика имеет обработчик `onclick`, который вызывает навигацию из `setTimeout`. Рассмотрим этот пример:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
with page.expect_navigation():
    # Это действие вызывает навигацию после тайм-аута.
    page.get_by_text("Navigate after timeout").click()
# Разрешается после завершения навигации
```

</TabItem>
<TabItem value="async">

```py
async with page.expect_navigation():
    # Это действие вызывает навигацию после тайм-аута.
    await page.get_by_text("Navigate after timeout").click()
# Разрешается после завершения навигации
```

</TabItem>
</Tabs>

:::note

Использование [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) для изменения URL считается навигацией.
:::

**Аргументы**
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-timeout"/><a href="#page-wait-for-navigation-option-timeout" class="list-anchor">#</a>

  Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_navigation_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [page.set_default_navigation_timeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `url` [str] | [Pattern] | [Callable]\[[URL]\]:[bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-url"/><a href="#page-wait-for-navigation-option-url" class="list-anchor">#</a>

  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для совпадения при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
- `wait_until` "load" | "domcontentloaded" | "networkidle" | "commit" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-wait-until"/><a href="#page-wait-for-navigation-option-wait-until" class="list-anchor">#</a>

  Когда считать операцию успешной, по умолчанию `load`. События могут быть:
  * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
  * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
  * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [EventContextManager]\[[Response]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-return"/><a href="#page-wait-for-navigation-return" class="list-anchor">#</a>

---

### fill {#page-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.fill</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.fill()](/api/class-locator.mdx#locator-fill) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [selector](/api/class-page.mdx#page-fill-option-selector), ожидает проверки [actionability](../actionability.mdx), фокусируется на элементе, заполняет его и вызывает событие `input` после заполнения. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является `<input>`, `<textarea>` или `[contenteditable]` элементом, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен именно этот элемент управления.

Для отправки более детализированных событий клавиатуры используйте [locator.press_sequentially()](/api/class-locator.mdx#locator-press-sequentially).

**Использование**

```python
page.fill(selector, value)
page.fill(selector, value, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-selector"/><a href="#page-fill-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `value` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-value"/><a href="#page-fill-option-value" class="list-anchor">#</a>

  Значение для заполнения элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `force` [bool] *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-force"/><a href="#page-fill-option-force" class="list-anchor">#</a>

  Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-no-wait-after"/><a href="#page-fill-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::

  Этот параметр не имеет эффекта.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-strict"/><a href="#page-fill-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-timeout"/><a href="#page-fill-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-return"/><a href="#page-fill-return" class="list-anchor">#</a>

---

### focus {#page-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.focus</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.focus()](/api/class-locator.mdx#locator-focus) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод извлекает элемент с [selector](/api/class-page.mdx#page-focus-option-selector) и фокусируется на нем. Если нет элемента, соответствующего [selector](/api/class-page.mdx#page-focus-option-selector), метод ждет, пока соответствующий элемент не появится в DOM.

**Использование**

```python
page.focus(selector)
page.focus(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-selector"/><a href="#page-focus-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-strict"/><a href="#page-focus-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-timeout"/><a href="#page-focus-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-return"/><a href="#page-focus-return" class="list-anchor">#</a>

---

### get_attribute {#page-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.get_attribute</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [locator.get_attribute()](/api/class-locator.mdx#locator-get-attribute) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает значение атрибута элемента.

**Использование**

```python
page.get_attribute(selector, name)
page.get_attribute(selector, name, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-selector"/><a href="#page-get-attribute-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `name` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-name"/><a href="#page-get-attribute-option-name" class="list-anchor">#</a>

  Имя атрибута, для которого нужно получить значение.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-strict"/><a href="#page-get-attribute-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-timeout"/><a href="#page-get-attribute-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [NoneType] | [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-return"/><a href="#page-get-attribute-return" class="list-anchor">#</a>

---

### hover {#page-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.hover</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.hover()](/api/class-locator.mdx#locator-hover) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод наводит курсор на элемент, соответствующий [селектору](/api/class-page.mdx#page-hover-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-hover-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если не установлена опция [force](/api/class-page.mdx#page-hover-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
3. Прокрутите элемент в видимую область, если это необходимо.
4. Используйте [page.mouse](/api/class-page.mdx#page-mouse) для наведения курсора на центр элемента или указанную [позицию](/api/class-page.mdx#page-hover-option-position).

Если все шаги в совокупности не завершились в течение указанного [таймаута](/api/class-page.mdx#page-hover-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого таймаута отключает это.

**Использование**

```python
page.hover(selector)
page.hover(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-selector"/><a href="#page-hover-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `force` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-force"/><a href="#page-hover-option-force" class="list-anchor">#</a>

  Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
- `modifiers` [List]\["Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-modifiers"/><a href="#page-hover-option-modifiers" class="list-anchor">#</a>

  Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается как "Control" на Windows и Linux и как "Meta" на macOS.
- `no_wait_after` [bool] *(опционально)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-no-wait-after"/><a href="#page-hover-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Эта опция не имеет эффекта.
  :::

  Эта опция не имеет эффекта.
- `position` [Dict] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-position"/><a href="#page-hover-option-position" class="list-anchor">#</a>
  - `x` [float]


  - `y` [float]


  Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-strict"/><a href="#page-hover-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-timeout"/><a href="#page-hover-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-trial"/><a href="#page-hover-option-trial" class="list-anchor">#</a>

  Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-return"/><a href="#page-hover-return" class="list-anchor">#</a>

---

### inner_html {#page-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.inner_html</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.inner_html()](/api/class-locator.mdx#locator-inner-html) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerHTML`.

**Использование**

```python
page.inner_html(selector)
page.inner_html(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-selector"/><a href="#page-inner-html-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-strict"/><a href="#page-inner-html-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-timeout"/><a href="#page-inner-html-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-return"/><a href="#page-inner-html-return" class="list-anchor">#</a>

---

### inner_text {#page-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.inner_text</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.inner_text()](/api/class-locator.mdx#locator-inner-text) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerText`.

**Использование**

```python
page.inner_text(selector)
page.inner_text(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-selector"/><a href="#page-inner-text-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-strict"/><a href="#page-inner-text-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-timeout"/><a href="#page-inner-text-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-return"/><a href="#page-inner-text-return" class="list-anchor">#</a>

---

### input_value {#page-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>page.input_value</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.input_value()](/api/class-locator.mdx#locator-input-value) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Выбрасывает исключение для не-вводных элементов. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращает значение контрола.

**Использование**

```python
page.input_value(selector)
page.input_value(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-selector"/><a href="#page-input-value-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-strict"/><a href="#page-input-value-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-timeout"/><a href="#page-input-value-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-return"/><a href="#page-input-value-return" class="list-anchor">#</a>

---

### is_checked {#page-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.is_checked</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.is_checked()](/api/class-locator.mdx#locator-is-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отмечен ли элемент. Выбрасывает исключение, если элемент не является флажком или радиокнопкой.

**Использование**

```python
page.is_checked(selector)
page.is_checked(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-selector"/><a href="#page-is-checked-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-strict"/><a href="#page-is-checked-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-timeout"/><a href="#page-is-checked-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-return"/><a href="#page-is-checked-return" class="list-anchor">#</a>

---

### is_disabled {#page-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.is_disabled</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.is_disabled()](/api/class-locator.mdx#locator-is-disabled) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отключен ли элемент, противоположность [включенному](../actionability.mdx#enabled).

**Использование**

```python
page.is_disabled(selector)
page.is_disabled(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-selector"/><a href="#page-is-disabled-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-strict"/><a href="#page-is-disabled-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-timeout"/><a href="#page-is-disabled-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-return"/><a href="#page-is-disabled-return" class="list-anchor">#</a>

---

### is_editable {#page-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.is_editable</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.is_editable()](/api/class-locator.mdx#locator-is-editable) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Использование**

```python
page.is_editable(selector)
page.is_editable(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-selector"/><a href="#page-is-editable-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-strict"/><a href="#page-is-editable-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-timeout"/><a href="#page-is-editable-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-return"/><a href="#page-is-editable-return" class="list-anchor">#</a>

---

### is_enabled {#page-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.is_enabled</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.is_enabled()](/api/class-locator.mdx#locator-is-enabled) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [включенным](../actionability.mdx#enabled).

**Использование**

```python
page.is_enabled(selector)
page.is_enabled(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-selector"/><a href="#page-is-enabled-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-strict"/><a href="#page-is-enabled-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-timeout"/><a href="#page-is-enabled-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-return"/><a href="#page-is-enabled-return" class="list-anchor">#</a>

---

### is_hidden {#page-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.is_hidden</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.is_hidden()](/api/class-locator.mdx#locator-is-hidden) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, скрыт ли элемент, противоположность [видимому](../actionability.mdx#visible). [Селектор](/api/class-page.mdx#page-is-hidden-option-selector), который не соответствует ни одному элементу, считается скрытым.

**Использование**

```python
page.is_hidden(selector)
page.is_hidden(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-selector"/><a href="#page-is-hidden-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-strict"/><a href="#page-is-hidden-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-timeout"/><a href="#page-is-hidden-option-timeout" class="list-anchor">#</a>

  :::warning[Устарело]
  Эта опция игнорируется. [page.is_hidden()](/api/class-page.mdx#page-is-hidden) не ждет, пока элемент станет скрытым, и возвращает результат немедленно.
  :::

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-return"/><a href="#page-is-hidden-return" class="list-anchor">#</a>

---

### is_visible {#page-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.is_visible</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.is_visible()](/api/class-locator.mdx#locator-is-visible) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [видимым](../actionability.mdx#visible). [Селектор](/api/class-page.mdx#page-is-visible-option-selector), который не соответствует ни одному элементу, считается невидимым.

**Использование**

```python
page.is_visible(selector)
page.is_visible(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-selector"/><a href="#page-is-visible-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-strict"/><a href="#page-is-visible-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-timeout"/><a href="#page-is-visible-option-timeout" class="list-anchor">#</a>

  :::warning[Устарело]
  Этот параметр игнорируется. [page.is_visible()](/api/class-page.mdx#page-is-visible) не ждет, пока элемент станет видимым, и возвращает результат немедленно.
  :::

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-return"/><a href="#page-is-visible-return" class="list-anchor">#</a>

---

### press {#page-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.press</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.press()](/api/class-locator.mdx#locator-press) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Фокусирует элемент, а затем использует [keyboard.down()](/api/class-keyboard.mdx#keyboard-down) и [keyboard.up()](/api/class-keyboard.mdx#keyboard-up).

[key](/api/class-page.mdx#page-press-option-key) может указывать желаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или один символ для генерации текста. Расширенный набор значений [key](/api/class-page.mdx#page-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры клавиш:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются следующие модификационные сочетания: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`. `ControlOrMeta` разрешается в `Control` на Windows и Linux и в `Meta` на macOS.

Удержание `Shift` напечатает текст, соответствующий [key](/api/class-page.mdx#page-press-option-key) в верхнем регистре.

Если [key](/api/class-page.mdx#page-press-option-key) является одним символом, он чувствителен к регистру, поэтому значения `a` и `A` будут генерировать разные тексты.

Также поддерживаются сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++` или `key: "Control+Shift+T"`. При указании с модификатором, модификатор нажимается и удерживается, пока не будет нажата последующая клавиша.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
page = browser.new_page()
page.goto("https://keycode.info")
page.press("body", "A")
page.screenshot(path="a.png")
page.press("body", "ArrowLeft")
page.screenshot(path="arrow_left.png")
page.press("body", "Shift+O")
page.screenshot(path="o.png")
browser.close()
```

</TabItem>
<TabItem value="async">

```py
page = await browser.new_page()
await page.goto("https://keycode.info")
await page.press("body", "A")
await page.screenshot(path="a.png")
await page.press("body", "ArrowLeft")
await page.screenshot(path="arrow_left.png")
await page.press("body", "Shift+O")
await page.screenshot(path="o.png")
await browser.close()
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-selector"/><a href="#page-press-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `key` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-key"/><a href="#page-press-option-key" class="list-anchor">#</a>

  Название клавиши для нажатия или символ для генерации, например, `ArrowLeft` или `a`.
- `delay` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-delay"/><a href="#page-press-option-delay" class="list-anchor">#</a>

  Время ожидания между `keydown` и `keyup` в миллисекундах. По умолчанию 0.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-no-wait-after"/><a href="#page-press-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Этот параметр по умолчанию будет `true` в будущем.
  :::

  Действия, инициирующие навигацию, ожидают, пока эти навигации произойдут и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится этот параметр только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-strict"/><a href="#page-press-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-timeout"/><a href="#page-press-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-return"/><a href="#page-press-return" class="list-anchor">#</a>

---

### query_selector {#page-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.query_selector</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [page.locator()](/api/class-page.mdx#page-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Метод находит элемент, соответствующий указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение разрешается в `null`. Чтобы дождаться элемента на странице, используйте [locator.wait_for()](/api/class-locator.mdx#locator-wait-for).

**Использование**

```python
page.query_selector(selector)
page.query_selector(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-selector"/><a href="#page-query-selector-option-selector" class="list-anchor">#</a>

  Селектор для запроса.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-strict"/><a href="#page-query-selector-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Возвращает**
- [NoneType] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-return"/><a href="#page-query-selector-return" class="list-anchor">#</a>

---

### query_selector_all {#page-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.query_selector_all</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [page.locator()](/api/class-page.mdx#page-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Метод находит все элементы, соответствующие указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение разрешается в `[]`.

**Использование**

```python
page.query_selector_all(selector)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-option-selector"/><a href="#page-query-selector-all-option-selector" class="list-anchor">#</a>

  Селектор для запроса.

**Возвращает**
- [List]\[[ElementHandle]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-return"/><a href="#page-query-selector-all-return" class="list-anchor">#</a>

---

### select_option {#page-select-option}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.select_option</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.select_option()](/api/class-locator.mdx#locator-select-option) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [селектору](/api/class-page.mdx#page-select-option-option-selector), ожидает проверки [действительности](../actionability.mdx), ждет, пока все указанные опции будут присутствовать в элементе `<select>`, и выбирает эти опции.

Если целевой элемент не является элементом `<select>`, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контрол.

Возвращает массив значений опций, которые были успешно выбраны.

Вызывает событие `change` и `input`, как только все предоставленные опции были выбраны.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
# Одиночный выбор, соответствующий значению или метке
page.select_option("select#colors", "blue")
# одиночный выбор, соответствующий метке
page.select_option("select#colors", label="blue")
# множественный выбор
page.select_option("select#colors", value=["red", "green", "blue"])
```

</TabItem>
<TabItem value="async">

```py
# Одиночный выбор, соответствующий значению или метке
await page.select_option("select#colors", "blue")
# одиночный выбор, соответствующий метке
await page.select_option("select#colors", label="blue")
# множественный выбор
await page.select_option("select#colors", value=["red", "green", "blue"])
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-selector"/><a href="#page-select-option-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `force` [bool] *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-force"/><a href="#page-select-option-option-force" class="list-anchor">#</a>

  Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-no-wait-after"/><a href="#page-select-option-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::

  Этот параметр не имеет эффекта.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-strict"/><a href="#page-select-option-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-timeout"/><a href="#page-select-option-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `element` [ElementHandle] | [List]\[[ElementHandle]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-element"/><a href="#page-select-option-option-element" class="list-anchor">#</a>

  Элементы опций для выбора. Опционально.
- `index` [int] | [List]\[[int]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-index"/><a href="#page-select-option-option-index" class="list-anchor">#</a>

  Опции для выбора по индексу. Опционально.
- `value` [str] | [List]\[[str]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-value"/><a href="#page-select-option-option-value" class="list-anchor">#</a>

  Опции для выбора по значению. Если `<select>` имеет атрибут `multiple`, все указанные опции выбираются, в противном случае выбирается только первая опция, соответствующая одному из переданных значений. Опционально.
- `label` [str] | [List]\[[str]\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-label"/><a href="#page-select-option-option-label" class="list-anchor">#</a>

  Опции для выбора по метке. Если `<select>` имеет атрибут `multiple`, все указанные опции выбираются, в противном случае выбирается только первая опция, соответствующая одной из переданных меток. Опционально.

**Возвращает**
- [List]\[[str]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-return"/><a href="#page-select-option-return" class="list-anchor">#</a>

---

### set_checked {#page-set-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.15</font><x-search>page.set_checked</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.set_checked()](/api/class-locator.mdx#locator-set-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод отмечает или снимает отметку с элемента, соответствующего [селектору](/api/class-page.mdx#page-set-checked-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-set-checked-option-selector). Если его нет, дождитесь, пока соответствующий элемент не будет добавлен в DOM.
2. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение.
3. Если элемент уже имеет правильное состояние отметки, этот метод возвращает результат немедленно.
4. Дождитесь проверки [действительности](../actionability.mdx) на найденном элементе, если только не установлен параметр [force](/api/class-page.mdx#page-set-checked-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
5. Прокрутите элемент в видимую область, если это необходимо.
6. Используйте [page.mouse](/api/class-page.mdx#page-mouse) для нажатия в центр элемента.
7. Убедитесь, что элемент теперь отмечен или снят с отметки. Если нет, этот метод выбрасывает исключение.

Если все шаги в совокупности не завершились в течение указанного [тайм-аута](/api/class-page.mdx#page-set-checked-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```python
page.set_checked(selector, checked)
page.set_checked(selector, checked, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-selector"/><a href="#page-set-checked-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `checked` [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-checked"/><a href="#page-set-checked-option-checked" class="list-anchor">#</a>

  Нужно ли отметить или снять отметку с флажка.
- `force` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-force"/><a href="#page-set-checked-option-force" class="list-anchor">#</a>

  Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-no-wait-after"/><a href="#page-set-checked-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::

  Этот параметр не имеет эффекта.
- `position` [Dict] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-position"/><a href="#page-set-checked-option-position" class="list-anchor">#</a>
  - `x` [float]


  - `y` [float]


  Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
- `strict` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-strict"/><a href="#page-set-checked-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-timeout"/><a href="#page-set-checked-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-trial"/><a href="#page-set-checked-option-trial" class="list-anchor">#</a>

  Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-return"/><a href="#page-set-checked-return" class="list-anchor">#</a>

---

### set_input_files {#page-set-input-files}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.set_input_files</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.set_input_files()](/api/class-locator.mdx#locator-set-input-files) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Устанавливает значение файлового ввода в указанные пути к файлам или файлы. Если некоторые из `filePaths` являются относительными путями, они разрешаются относительно текущей рабочей директории. Для пустого массива очищает выбранные файлы. Для входных данных с атрибутом `[webkitdirectory]` поддерживается только один путь к директории.

Этот метод ожидает, что [селектор](/api/class-page.mdx#page-set-input-files-option-selector) указывает на [элемент ввода](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контроль](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), он будет нацелен на контроль.

**Использование**

```python
page.set_input_files(selector, files)
page.set_input_files(selector, files, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-selector"/><a href="#page-set-input-files-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `files` [Union]\[[str], [pathlib.Path]\] | [List]\[[Union]\[[str], [pathlib.Path]\]\] | [Dict] | [List]\[[Dict]\]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-files"/><a href="#page-set-input-files-option-files" class="list-anchor">#</a>
  - `name` [str]

    Имя файла
  - `mimeType` [str]

    Тип файла
  - `buffer` [bytes]

    Содержимое файла
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-no-wait-after"/><a href="#page-set-input-files-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::

  Этот параметр не имеет эффекта.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-strict"/><a href="#page-set-input-files-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-timeout"/><a href="#page-set-input-files-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-return"/><a href="#page-set-input-files-return" class="list-anchor">#</a>

---

### tap {#page-tap}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.tap</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.tap()](/api/class-locator.mdx#locator-tap) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет нажатие на элемент, соответствующий [селектору](/api/class-page.mdx#page-tap-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-tap-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на соответствующем элементе, если только не установлена опция [force](/api/class-page.mdx#page-tap-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
3. Прокрутите элемент в видимую область, если это необходимо.
4. Используйте [page.touchscreen](/api/class-page.mdx#page-touchscreen) для нажатия в центр элемента или указанную [позицию](/api/class-page.mdx#page-tap-option-position).

Если все шаги в совокупности не завершились в течение указанного [тайм-аута](/api/class-page.mdx#page-tap-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

Метод [page.tap()](/api/class-page.mdx#page-tap) выбросит исключение, если опция [has_touch](/api/class-browser.mdx#browser-new-context-option-has-touch) контекста браузера равна false.
:::

**Использование**

```python
page.tap(selector)
page.tap(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-selector"/><a href="#page-tap-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `force` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-force"/><a href="#page-tap-option-force" class="list-anchor">#</a>

  Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
- `modifiers` [List]\["Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift"\] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-modifiers"/><a href="#page-tap-option-modifiers" class="list-anchor">#</a>

  Модификаторы клавиш для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-no-wait-after"/><a href="#page-tap-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::

  Этот параметр не имеет эффекта.
- `position` [Dict] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-position"/><a href="#page-tap-option-position" class="list-anchor">#</a>
  - `x` [float]


  - `y` [float]


  Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-strict"/><a href="#page-tap-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-timeout"/><a href="#page-tap-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout).
- `trial` [bool] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-trial"/><a href="#page-tap-option-trial" class="list-anchor">#</a>

  Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент не будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-return"/><a href="#page-tap-return" class="list-anchor">#</a>

---

### text_content {#page-text-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.text_content</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.text_content()](/api/class-locator.mdx#locator-text-content) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.textContent`.

**Использование**

```python
page.text_content(selector)
page.text_content(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-selector"/><a href="#page-text-content-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-strict"/><a href="#page-text-content-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-timeout"/><a href="#page-text-content-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [NoneType] | [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-return"/><a href="#page-text-content-return" class="list-anchor">#</a>

---

### type {#page-type}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.type</x-search>

:::warning Устарело

В большинстве случаев следует использовать [locator.fill()](/api/class-locator.mdx#locator-fill) вместо этого. Вам нужно нажимать клавиши по одной, только если на странице есть специальная обработка клавиатуры - в этом случае используйте [locator.press_sequentially()](/api/class-locator.mdx#locator-press-sequentially).

:::

Отправляет события `keydown`, `keypress`/`input` и `keyup` для каждого символа в тексте. `page.type` может использоваться для отправки детализированных событий клавиатуры. Для заполнения значений в полях формы используйте [page.fill()](/api/class-page.mdx#page-fill).

Чтобы нажать специальную клавишу, такую как `Control` или `ArrowDown`, используйте [keyboard.press()](/api/class-keyboard.mdx#keyboard-press).

**Использование**

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-selector"/><a href="#page-type-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `text` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-text"/><a href="#page-type-option-text" class="list-anchor">#</a>

  Текст для ввода в фокусированный элемент.
- `delay` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-delay"/><a href="#page-type-option-delay" class="list-anchor">#</a>

  Время ожидания между нажатиями клавиш в миллисекундах. По умолчанию 0.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-no-wait-after"/><a href="#page-type-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::

  Этот параметр не имеет эффекта.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-strict"/><a href="#page-type-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-timeout"/><a href="#page-type-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-return"/><a href="#page-type-return" class="list-anchor">#</a>

---

### uncheck {#page-uncheck}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.uncheck</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [locator.uncheck()](/api/class-locator.mdx#locator-uncheck) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод снимает отметку с элемента, соответствующего [селектору](/api/class-page.mdx#page-uncheck-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-uncheck-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Убедитесь, что соответствующий элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже снят с отметки, этот метод возвращается немедленно.
3. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на соответствующем элементе, если только не установлена опция [force](/api/class-page.mdx#page-uncheck-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
4. Прокрутите элемент в видимую область, если это необходимо.
5. Используйте [page.mouse](/api/class-page.mdx#page-mouse) для нажатия в центр элемента.
6. Убедитесь, что элемент теперь снят с отметки. Если нет, этот метод выбрасывает исключение.

Если все шаги в совокупности не завершились в течение указанного [тайм-аута](/api/class-page.mdx#page-uncheck-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```python
page.uncheck(selector)
page.uncheck(selector, **kwargs)
```

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-selector"/><a href="#page-uncheck-option-selector" class="list-anchor">#</a>

  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `force` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-force"/><a href="#page-uncheck-option-force" class="list-anchor">#</a>

  Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
- `no_wait_after` [bool] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-no-wait-after"/><a href="#page-uncheck-option-no-wait-after" class="list-anchor">#</a>

  :::warning[Устарело]
  Этот параметр не имеет эффекта.
  :::

  Этот параметр не имеет эффекта.
- `position` [Dict] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-position"/><a href="#page-uncheck-option-position" class="list-anchor">#</a>
  - `x` [float]


  - `y` [float]


  Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-strict"/><a href="#page-uncheck-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-timeout"/><a href="#page-uncheck-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout) методы.
- `trial` [bool] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-trial"/><a href="#page-uncheck-option-trial" class="list-anchor">#</a>

  Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент не будет готов к действию без его выполнения.

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-return"/><a href="#page-uncheck-return" class="list-anchor">#</a>

---

### wait_for_selector {#page-wait-for-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.wait_for_selector</x-search>

:::warning[Не рекомендуется]

Используйте веб-утверждения, которые утверждают видимость, или основанный на локаторах метод [locator.wait_for()](/api/class-locator.mdx#locator-wait-for) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, когда элемент, указанный селектором, удовлетворяет опции [state](/api/class-page.mdx#page-wait-for-selector-option-state). Возвращает `null`, если ожидание для `hidden` или `detached`.

:::note

Playwright автоматически ожидает, пока элемент не будет готов перед выполнением действия. Использование объектов [Locator] и веб-первых утверждений делает код свободным от ожидания селектора.
:::

Ожидайте, пока [селектор](/api/class-page.mdx#page-wait-for-selector-option-selector) не удовлетворит опцию [state](/api/class-page.mdx#page-wait-for-selector-option-state) (либо появится/исчезнет из DOM, либо станет видимым/скрытым). Если на момент вызова метода [селектор](/api/class-page.mdx#page-wait-for-selector-option-selector) уже удовлетворяет условию, метод вернется немедленно. Если селектор не удовлетворяет условию в течение [тайм-аута](/api/class-page.mdx#page-wait-for-selector-option-timeout) в миллисекундах, функция выбросит исключение.

**Использование**

Этот метод работает через навигации:

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]
}>
<TabItem value="sync">

```py
from playwright.sync_api import sync_playwright, Playwright

def run(playwright: Playwright):
    chromium = playwright.chromium
    browser = chromium.launch()
    page = browser.new_page()
    for current_url in ["https://google.com", "https://bbc.com"]:
        page.goto(current_url, wait_until="domcontentloaded")
        element = page.wait_for_selector("img")
        print("Загружено изображение: " + str(element.get_attribute("src")))
    browser.close()

with sync_playwright() as playwright:
    run(playwright)
```

</TabItem>
<TabItem value="async">

```py
import asyncio
from playwright.async_api import async_playwright, Playwright

async def run(playwright: Playwright):
    chromium = playwright.chromium
    browser = await chromium.launch()
    page = await browser.new_page()
    for current_url in ["https://google.com", "https://bbc.com"]:
        await page.goto(current_url, wait_until="domcontentloaded")
        element = await page.wait_for_selector("img")
        print("Загружено изображение: " + str(await element.get_attribute("src")))
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
```

</TabItem>
</Tabs>

**Аргументы**
- `selector` [str]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-selector"/><a href="#page-wait-for-selector-option-selector" class="list-anchor">#</a>

  Селектор для запроса.
- `state` "attached" | "detached" | "visible" | "hidden" *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-state"/><a href="#page-wait-for-selector-option-state" class="list-anchor">#</a>

  По умолчанию `'visible'`. Может быть:
  * `'attached'` - ожидание, пока элемент будет присутствовать в DOM.
  * `'detached'` - ожидание, пока элемент не будет присутствовать в DOM.
  * `'visible'` - ожидание, пока элемент не будет иметь пустую рамку и не будет `visibility:hidden`. Обратите внимание, что элемент без содержимого или с `display:none` имеет пустую рамку и не считается видимым.
  * `'hidden'` - ожидание, пока элемент не будет отсоединен от DOM, или не будет иметь пустую рамку или `visibility:hidden`. Это противоположно опции `'visible'`.
- `strict` [bool] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-strict"/><a href="#page-wait-for-selector-option-strict" class="list-anchor">#</a>

  Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
- `timeout` [float] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-timeout"/><a href="#page-wait-for-selector-option-timeout" class="list-anchor">#</a>

  Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [browser_context.set_default_timeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [page.set_default_timeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [NoneType] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-return"/><a href="#page-wait-for-selector-return" class="list-anchor">#</a>

---

### wait_for_timeout {#page-wait-for-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.wait_for_timeout</x-search>

:::warning[Не рекомендуется]

Никогда не используйте ожидание по времени в производственной среде. Тесты, которые зависят от времени ожидания, по своей природе ненадежны. Используйте действия [Locator] и веб-утверждения, которые ожидают автоматически.

:::

Ожидает заданное [время ожидания](/api/class-page.mdx#page-wait-for-timeout-option-timeout) в миллисекундах.

Обратите внимание, что `page.waitForTimeout()` следует использовать только для отладки. Тесты, использующие таймер в производственной среде, будут ненадежными. Вместо этого используйте сигналы, такие как сетевые события, появление селекторов и другие.

**Использование**

<Tabs
  groupId="python-flavor"
  defaultValue="sync"
  values={[
    {label: 'Синхронный', value: 'sync'},
    {label: 'Асинхронный', value: 'async'}
  ]}
>
<TabItem value="sync">

```py
# ожидание 1 секунду
page.wait_for_timeout(1000)
```

</TabItem>
<TabItem value="async">

```py
# ожидание 1 секунду
await page.wait_for_timeout(1000)
```

</TabItem>
</Tabs>

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-option-timeout"/><a href="#page-wait-for-timeout-option-timeout" class="list-anchor">#</a>

  Время ожидания

**Возвращает**
- [NoneType]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-return"/><a href="#page-wait-for-timeout-return" class="list-anchor">#</a>

[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[Error]: /api/class-error.mdx "Error"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[Any]: https://docs.python.org/3/library/typing.html#typing.Any "Any"
[bool]: https://docs.python.org/3/library/stdtypes.html "bool"
[bytes]: https://docs.python.org/3/library/stdtypes.html#bytes "bytes"
[Callable]: https://docs.python.org/3/library/typing.html#typing.Callable "Callable"
[EventContextManager]: https://docs.python.org/3/reference/datamodel.html#context-managers "Event context manager"
[EventEmitter]: https://pyee.readthedocs.io/en/latest/#pyee.BaseEventEmitter "EventEmitter"
[Exception]: https://docs.python.org/3/library/exceptions.html#Exception "Exception"
[Dict]: https://docs.python.org/3/library/typing.html#typing.Dict "Dict"
[float]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "float"
[int]: https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex "int"
[List]: https://docs.python.org/3/library/typing.html#typing.List "List"
[NoneType]: https://docs.python.org/3/library/constants.html#None "None"
[Pattern]: https://docs.python.org/3/library/re.html "Pattern"
[URL]: https://en.wikipedia.org/wiki/URL "URL"
[pathlib.Path]: https://realpython.com/python-pathlib/ "pathlib.Path"
[str]: https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str "str"
[Union]: https://docs.python.org/3/library/typing.html#typing.Union "Union"
[datetime]: https://docs.python.org/3/library/datetime.html#datetime.datetime "datetime"

[все доступные теги изображений]: https://mcr.microsoft.com/en-us/product/playwright/python/about "все доступные теги изображений"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/python/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-python/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
