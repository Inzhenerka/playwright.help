---
id: class-page
title: "Page"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

Page предоставляет методы для взаимодействия с одной вкладкой в [Browser] или [фоновая страница расширения](https://developer.chrome.com/extensions/background_pages) в Chromium. Один экземпляр [Browser] может иметь несколько экземпляров [Page].

Этот пример создает страницу, переходит на URL и затем сохраняет скриншот:

```csharp
using Microsoft.Playwright;
using System.Threading.Tasks;

class PageExamples
{
    public static async Task Run()
    {
        using var playwright = await Playwright.CreateAsync();
        await using var browser = await playwright.Webkit.LaunchAsync();
        var page = await browser.NewPageAsync();
        await page.GotoAsync("https://www.theverge.com");
        await page.ScreenshotAsync(new() { Path = "theverge.png" });
    }
}
```

Класс Page генерирует различные события (описанные ниже), которые могут быть обработаны с использованием любых методов нативного [`EventEmitter`](https://nodejs.org/api/events.html#events_class_eventemitter) Node, таких как `on`, `once` или `removeListener`.

Этот пример выводит сообщение для одного события загрузки страницы `load`:

```csharp
page.Load += (_, _) => Console.WriteLine("Page loaded!");
```

Чтобы отписаться от событий, используйте метод `removeListener`:

```csharp
void PageLoadHandler(object _, IPage p) {
    Console.WriteLine("Page loaded!");
};

page.Load += PageLoadHandler;
// Выполните некоторую работу...
page.Load -= PageLoadHandler;
```

---

## Методы

### AddInitScriptAsync {#page-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.AddInitScriptAsync</x-search>

Добавляет скрипт, который будет выполнен в одном из следующих сценариев:
* Каждый раз, когда страница переходит на новый URL.
* Каждый раз, когда дочерний фрейм присоединяется или переходит на новый URL. В этом случае скрипт выполняется в контексте вновь присоединенного фрейма.

Скрипт выполняется после создания документа, но до выполнения любых его скриптов. Это полезно для изменения среды JavaScript, например, для установки начального значения `Math.random`.

**Использование**

Пример переопределения `Math.random` перед загрузкой страницы:

```js
// preload.js
Math.random = () => 42;
```

```csharp
await Page.AddInitScriptAsync(scriptPath: "./preload.js");
```

:::note
Порядок выполнения нескольких скриптов, установленных через [BrowserContext.AddInitScriptAsync()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [Page.AddInitScriptAsync()](/api/class-page.mdx#page-add-init-script), не определен.
:::

**Аргументы**
- `script` [string] | [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-option-script"/><a href="#page-add-init-script-option-script" class="list-anchor">#</a>
  
  Скрипт, который будет выполнен на всех страницах в контексте браузера.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-return"/><a href="#page-add-init-script-return" class="list-anchor">#</a>

---

### AddLocatorHandlerAsync {#page-add-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.42</font><x-search>page.AddLocatorHandlerAsync</x-search>

При тестировании веб-страницы иногда появляются неожиданные наложения, такие как диалог "Зарегистрироваться", которые блокируют действия, которые вы хотите автоматизировать, например, нажатие кнопки. Эти наложения не всегда появляются одинаково или в одно и то же время, что делает их сложными для обработки в автоматизированных тестах.

Этот метод позволяет вам настроить специальную функцию, называемую обработчиком, которая активируется, когда обнаруживает, что наложение видно. Задача обработчика - удалить наложение, позволяя вашему тесту продолжаться так, как будто наложения не было.

Вещи, которые нужно учитывать:
* Когда наложение показывается предсказуемо, мы рекомендуем явно ожидать его в вашем тесте и отклонять его как часть вашего обычного тестового потока, вместо использования [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler).
* Playwright проверяет наличие наложения каждый раз перед выполнением или повторной попыткой действия, требующего [проверки возможности действия](../actionability.mdx), или перед выполнением проверки с автоматическим ожиданием. Когда наложение видно, Playwright сначала вызывает обработчик, а затем продолжает действие/проверку. Обратите внимание, что обработчик вызывается только при выполнении действия/проверки - если наложение становится видимым, но вы не выполняете никаких действий, обработчик не будет вызван.
* После выполнения обработчика Playwright убедится, что наложение, вызвавшее обработчик, больше не видно. Вы можете отказаться от этого поведения с помощью [NoWaitAfter](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after).
* Время выполнения обработчика учитывается в тайм-ауте действия/проверки, которое вызвало обработчик. Если ваш обработчик занимает слишком много времени, это может вызвать тайм-ауты.
* Вы можете зарегистрировать несколько обработчиков. Однако в любой момент времени будет выполняться только один обработчик. Убедитесь, что действия внутри обработчика не зависят от другого обработчика.

:::warning

Выполнение обработчика изменит состояние вашей страницы в середине теста. Например, это изменит текущий фокус элемента и переместит мышь. Убедитесь, что действия, выполняемые после обработчика, являются автономными и не зависят от неизменности состояния фокуса и мыши.

Например, рассмотрим тест, который вызывает [Locator.FocusAsync()](/api/class-locator.mdx#locator-focus) с последующим [Keyboard.PressAsync()](/api/class-keyboard.mdx#keyboard-press). Если ваш обработчик нажимает кнопку между этими двумя действиями, фокусированный элемент, скорее всего, будет неправильным, и нажатие клавиши произойдет на неожиданном элементе. Используйте [Locator.PressAsync()](/api/class-locator.mdx#locator-press), чтобы избежать этой проблемы.

Другой пример - серия действий с мышью, где [Mouse.MoveAsync()](/api/class-mouse.mdx#mouse-move) следует за [Mouse.DownAsync()](/api/class-mouse.mdx#mouse-down). Опять же, когда обработчик выполняется между этими двумя действиями, позиция мыши будет неправильной во время нажатия мыши. Предпочитайте автономные действия, такие как [Locator.ClickAsync()](/api/class-locator.mdx#locator-click), которые не зависят от неизменности состояния, измененного обработчиком.
:::

**Использование**

Пример, который закрывает диалог "Подписаться на рассылку", когда он появляется:

```csharp
// Настройте обработчик.
await page.AddLocatorHandlerAsync(page.GetByText("Sign up to the newsletter"), async () => {
  await page.GetByRole(AriaRole.Button, new() { Name = "No thanks" }).ClickAsync();
});

// Напишите тест как обычно.
await page.GotoAsync("https://example.com");
await page.GetByRole("button", new() { Name = "Start here" }).ClickAsync();
```

Пример, который пропускает страницу "Подтвердите свои данные безопасности", когда она отображается:

```csharp
// Настройте обработчик.
await page.AddLocatorHandlerAsync(page.GetByText("Confirm your security details"), async () => {
  await page.GetByRole(AriaRole.Button, new() { Name = "Remind me later" }).ClickAsync();
});

// Напишите тест как обычно.
await page.GotoAsync("https://example.com");
await page.GetByRole("button", new() { Name = "Start here" }).ClickAsync();
```

Пример с пользовательским обратным вызовом на каждой проверке возможности действия. Он использует локатор `<body>`, который всегда виден, поэтому обработчик вызывается перед каждой проверкой возможности действия. Важно указать [NoWaitAfter](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after), потому что обработчик не скрывает элемент `<body>`.

```csharp
// Настройте обработчик.
await page.AddLocatorHandlerAsync(page.Locator("body"), async () => {
  await page.EvaluateAsync("window.removeObstructionsForTestIfNeeded()");
}, new() { NoWaitAfter = true });

// Напишите тест как обычно.
await page.GotoAsync("https://example.com");
await page.GetByRole("button", new() { Name = "Start here" }).ClickAsync();
```

Обработчик принимает оригинальный локатор в качестве аргумента. Вы также можете автоматически удалить обработчик после определенного количества вызовов, установив [Times](/api/class-page.mdx#page-add-locator-handler-option-times):

```csharp
await page.AddLocatorHandlerAsync(page.GetByText("Sign up to the newsletter"), async locator => {
  await locator.ClickAsync();
}, new() { Times = 1 });
```

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-locator"/><a href="#page-add-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, который вызывает обработчик.
- `handler` [Func]&lt;[Locator], [Task]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-handler"/><a href="#page-add-locator-handler-option-handler" class="list-anchor">#</a>
  
  Функция, которая должна быть выполнена, как только [локатор](/api/class-page.mdx#page-add-locator-handler-option-locator) появится. Эта функция должна избавиться от элемента, который блокирует действия, такие как клик.
- `options` `PageAddLocatorHandlerOptions?` *(опционально)*
  - `NoWaitAfter` [bool]? *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-no-wait-after"/><a href="#page-add-locator-handler-option-no-wait-after" class="list-anchor">#</a>
    
    По умолчанию, после вызова обработчика Playwright будет ждать, пока наложение не станет скрытым, и только затем продолжит действие/проверку, вызвавшую обработчик. Эта опция позволяет отказаться от этого поведения, чтобы наложение могло оставаться видимым после выполнения обработчика.
  - `Times` [int]? *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-times"/><a href="#page-add-locator-handler-option-times" class="list-anchor">#</a>
    
    Указывает максимальное количество раз, которое этот обработчик должен быть вызван. По умолчанию не ограничено.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-return"/><a href="#page-add-locator-handler-return" class="list-anchor">#</a>

---

### AddScriptTagAsync {#page-add-script-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.AddScriptTagAsync</x-search>

Добавляет тег `<script>` на страницу с желаемым URL или содержимым. Возвращает добавленный тег, когда срабатывает событие onload скрипта или когда содержимое скрипта было внедрено в фрейм.

**Использование**

```csharp
await Page.AddScriptTagAsync(options);
```

**Аргументы**
- `options` `PageAddScriptTagOptions?` *(опционально)*
  - `Content` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-content"/><a href="#page-add-script-tag-option-content" class="list-anchor">#</a>
    
    Сырой JavaScript-контент для внедрения в фрейм.
  - `Path` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-path"/><a href="#page-add-script-tag-option-path" class="list-anchor">#</a>
    
    Путь к JavaScript-файлу для внедрения в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `Type` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-type"/><a href="#page-add-script-tag-option-type" class="list-anchor">#</a>
    
    Тип скрипта. Используйте 'module', чтобы загрузить JavaScript ES6 модуль. Подробнее см. [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script).
  - `Url` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-url"/><a href="#page-add-script-tag-option-url" class="list-anchor">#</a>
    
    URL скрипта, который нужно добавить.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-return"/><a href="#page-add-script-tag-return" class="list-anchor">#</a>

---

### AddStyleTagAsync {#page-add-style-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.AddStyleTagAsync</x-search>

Добавляет тег `<link rel="stylesheet">` на страницу с желаемым URL или тег `<style type="text/css">` с содержимым. Возвращает добавленный тег, когда срабатывает событие onload таблицы стилей или когда CSS-контент был внедрен в фрейм.

**Использование**

```csharp
await Page.AddStyleTagAsync(options);
```

**Аргументы**
- `options` `PageAddStyleTagOptions?` *(опционально)*
  - `Content` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-content"/><a href="#page-add-style-tag-option-content" class="list-anchor">#</a>
    
    Сырой CSS-контент для внедрения в фрейм.
  - `Path` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-path"/><a href="#page-add-style-tag-option-path" class="list-anchor">#</a>
    
    Путь к CSS-файлу для внедрения в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `Url` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-url"/><a href="#page-add-style-tag-option-url" class="list-anchor">#</a>
    
    URL тега `<link>`.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-return"/><a href="#page-add-style-tag-return" class="list-anchor">#</a>

---

### BringToFrontAsync {#page-bring-to-front}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.BringToFrontAsync</x-search>

Выводит страницу на передний план (активирует вкладку).

**Использование**

```csharp
await Page.BringToFrontAsync();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-bring-to-front-return"/><a href="#page-bring-to-front-return" class="list-anchor">#</a>

---

### CloseAsync {#page-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.CloseAsync</x-search>

Если [RunBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) равен `false`, не выполняет никакие обработчики выгрузки и ждет, пока страница не будет закрыта. Если [RunBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) равен `true`, метод выполнит обработчики выгрузки, но **не** будет ждать закрытия страницы.

По умолчанию, `page.close()` **не** выполняет обработчики `beforeunload`.

:::note

если [RunBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) передан как true, может быть вызван диалог `beforeunload`, который должен быть обработан вручную через событие [Page.Dialog](/api/class-page.mdx#page-event-dialog).
:::

**Использование**

```csharp
await Page.CloseAsync(options);
```

**Аргументы**
- `options` `PageCloseOptions?` *(опционально)*
  - `Reason` [string]? *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-reason"/><a href="#page-close-option-reason" class="list-anchor">#</a>
    
    Причина, которая будет сообщена операциям, прерванным закрытием страницы.
  - `RunBeforeUnload` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-run-before-unload"/><a href="#page-close-option-run-before-unload" class="list-anchor">#</a>
    
    По умолчанию `false`. Выполнять ли обработчики страницы [before unload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-return"/><a href="#page-close-return" class="list-anchor">#</a>

---

### ConsoleMessagesAsync {#page-console-messages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.56</font><x-search>page.ConsoleMessagesAsync</x-search>

Returns up to (currently) 200 last console messages from this page. See [Page.Console](/api/class-page.mdx#page-event-console) for more details.

**Usage**

```csharp
await Page.ConsoleMessagesAsync();
```

**Returns**
- [IReadOnlyList]&lt;[ConsoleMessage]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-console-messages-return"/><a href="#page-console-messages-return" class="list-anchor">#</a>

---

### ContentAsync {#page-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.ContentAsync</x-search>

Получает полный HTML-контент страницы, включая doctype.

**Использование**

```csharp
await Page.ContentAsync();
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-content-return"/><a href="#page-content-return" class="list-anchor">#</a>

---

### Context {#page-context}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.Context</x-search>

Получает контекст браузера, к которому принадлежит страница.

**Использование**

```csharp
Page.Context
```

**Возвращает**
- [BrowserContext]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-context-return"/><a href="#page-context-return" class="list-anchor">#</a>

---

### DragAndDropAsync {#page-drag-and-drop}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>page.DragAndDropAsync</x-search>

Этот метод перетаскивает исходный элемент на целевой элемент. Сначала он перемещается к исходному элементу, выполняет `mousedown`, затем перемещается к целевому элементу и выполняет `mouseup`.

**Использование**

```csharp
await Page.DragAndDropAsync("#source", "#target");
// или укажите точные позиции относительно верхнего левого угла элементов:
await Page.DragAndDropAsync("#source", "#target", new()
{
    SourcePosition = new() { X = 34, Y = 7 },
    TargetPosition = new() { X = 10, Y = 20 },
});
```

**Аргументы**
- `source` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source"/><a href="#page-drag-and-drop-option-source" class="list-anchor">#</a>
  
  Селектор для поиска элемента для перетаскивания. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `target` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target"/><a href="#page-drag-and-drop-option-target" class="list-anchor">#</a>
  
  Селектор для поиска элемента, на который нужно сбросить. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageDragAndDropOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-force"/><a href="#page-drag-and-drop-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [возможности действия](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-no-wait-after"/><a href="#page-drag-and-drop-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `SourcePosition` SourcePosition? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source-position"/><a href="#page-drag-and-drop-option-source-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Clicks on the source element at this point relative to the top-left corner of the element's padding box. If not specified, some visible point of the element is used.
  - `Steps` [int]? *(optional)* <font size="2">Добавлено в: v1.57</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-steps"/><a href="#page-drag-and-drop-option-steps" class="list-anchor">#</a>
    
    Defaults to 1. Sends `n` interpolated `mousemove` events to represent travel between the `mousedown` and `mouseup` of the drag. When set to 1, emits a single `mousemove` event at the destination location.
  - `Strict` [bool]? *(optional)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-strict"/><a href="#page-drag-and-drop-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `TargetPosition` TargetPosition? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target-position"/><a href="#page-drag-and-drop-option-target-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Сбрасывает на целевой элемент в этой точке относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-timeout"/><a href="#page-drag-and-drop-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-trial"/><a href="#page-drag-and-drop-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [возможности действия](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-return"/><a href="#page-drag-and-drop-return" class="list-anchor">#</a>

---

### EmulateMediaAsync {#page-emulate-media}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.EmulateMediaAsync</x-search>

Этот метод изменяет `CSS media type` через аргумент `media` и/или медиа-функцию `'prefers-colors-scheme'`, используя аргумент `colorScheme`.

**Использование**

```csharp
await page.EvaluateAsync("() => matchMedia('screen').matches");
// → true
await page.EvaluateAsync("() => matchMedia('print').matches");
// → false

await page.EmulateMediaAsync(new() { Media = Media.Print });
await page.EvaluateAsync("() => matchMedia('screen').matches");
// → false
await page.EvaluateAsync("() => matchMedia('print').matches");
// → true

await page.EmulateMediaAsync(new() { Media = Media.Screen });
await page.EvaluateAsync("() => matchMedia('screen').matches");
// → true
await page.EvaluateAsync("() => matchMedia('print').matches");
// → false
```

```csharp
await page.EmulateMediaAsync(new() { ColorScheme = ColorScheme.Dark });
await page.EvaluateAsync("matchMedia('(prefers-color-scheme: dark)').matches");
// → true
await page.EvaluateAsync("matchMedia('(prefers-color-scheme: light)').matches");
// → false
```

**Аргументы**
- `options` `PageEmulateMediaOptions?` *(опционально)*
  - `ColorScheme` `enum ColorScheme { Light, Dark, NoPreference, Null }?` *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-color-scheme"/><a href="#page-emulate-media-option-color-scheme" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию [prefers-colors-scheme](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme), поддерживаемые значения: `'light'` и `'dark'`. Передача `'Null'` отключает эмуляцию цветовой схемы. `'no-preference'` устарело.
  - `Contrast` `enum Contrast { NoPreference, More, Null }?` *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-contrast"/><a href="#page-emulate-media-option-contrast" class="list-anchor">#</a>
  - `ForcedColors` `enum ForcedColors { Active, None, Null }?` *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-forced-colors"/><a href="#page-emulate-media-option-forced-colors" class="list-anchor">#</a>
  - `Media` `enum Media { Screen, Print, Null }?` *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-media"/><a href="#page-emulate-media-option-media" class="list-anchor">#</a>
    
    Изменяет CSS media type страницы. Единственные допустимые значения: `'Screen'`, `'Print'` и `'Null'`. Передача `'Null'` отключает эмуляцию CSS media.
  - `ReducedMotion` `enum ReducedMotion { Reduce, NoPreference, Null }?` *(опционально)* <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-reduced-motion"/><a href="#page-emulate-media-option-reduced-motion" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'prefers-reduced-motion'`, поддерживаемые значения: `'reduce'`, `'no-preference'`. Передача `null` отключает эмуляцию уменьшенного движения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-return"/><a href="#page-emulate-media-return" class="list-anchor">#</a>

---

### EvaluateAsync {#page-evaluate}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.EvaluateAsync</x-search>

Возвращает значение вызова [выражения](/api/class-page.mdx#page-evaluate-option-expression).

Если функция, переданная в [Page.EvaluateAsync()](/api/class-page.mdx#page-evaluate), возвращает [Promise], то [Page.EvaluateAsync()](/api/class-page.mdx#page-evaluate) будет ждать разрешения промиса и вернет его значение.

Если функция, переданная в [Page.EvaluateAsync()](/api/class-page.mdx#page-evaluate), возвращает не-[Serializable] значение, то [Page.EvaluateAsync()](/api/class-page.mdx#page-evaluate) разрешается в `undefined`. Playwright также поддерживает передачу некоторых дополнительных значений, которые не сериализуются через `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.

**Использование**

Передача аргумента в [выражение](/api/class-page.mdx#page-evaluate-option-expression):

```csharp
var result = await page.EvaluateAsync<int>("([x, y]) => Promise.resolve(x * y)", new[] { 7, 8 });
Console.WriteLine(result);
```

Также можно передать строку вместо функции:

```csharp
Console.WriteLine(await page.EvaluateAsync<int>("1 + 2")); // выводит "3"
```

Экземпляры [ElementHandle] могут быть переданы в качестве аргумента в [Page.EvaluateAsync()](/api/class-page.mdx#page-evaluate):

```csharp
var bodyHandle = await page.EvaluateAsync("document.body");
var html = await page.EvaluateAsync<string>("([body, suffix]) => body.innerHTML + suffix", new object [] { bodyHandle, "hello" });
await bodyHandle.DisposeAsync();
```

**Аргументы**
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-expression"/><a href="#page-evaluate-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-arg"/><a href="#page-evaluate-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [выражение](/api/class-page.mdx#page-evaluate-option-expression).

**Возвращает**
- [object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-return"/><a href="#page-evaluate-return" class="list-anchor">#</a>

---

### EvaluateHandleAsync {#page-evaluate-handle}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.EvaluateHandleAsync</x-search>

Возвращает значение вызова [выражения](/api/class-page.mdx#page-evaluate-handle-option-expression) в виде [JSHandle].

Единственное отличие между [Page.EvaluateAsync()](/api/class-page.mdx#page-evaluate) и [Page.EvaluateHandleAsync()](/api/class-page.mdx#page-evaluate-handle) заключается в том, что [Page.EvaluateHandleAsync()](/api/class-page.mdx#page-evaluate-handle) возвращает [JSHandle].

Если функция, переданная в [Page.EvaluateHandleAsync()](/api/class-page.mdx#page-evaluate-handle), возвращает [Promise], то [Page.EvaluateHandleAsync()](/api/class-page.mdx#page-evaluate-handle) будет ждать разрешения промиса и вернет его значение.

**Использование**

```csharp
// Обработчик для объекта window.
var aWindowHandle = await page.EvaluateHandleAsync("() => Promise.resolve(window)");
```

Также можно передать строку вместо функции:

```csharp
var docHandle = await page.EvaluateHandleAsync("document"); // Обработчик для `document`
```

Экземпляры [JSHandle] могут быть переданы в качестве аргумента в [Page.EvaluateHandleAsync()](/api/class-page.mdx#page-evaluate-handle):

```csharp
var handle = await page.EvaluateHandleAsync("() => document.body");
var resultHandle = await page.EvaluateHandleAsync("([body, suffix]) => body.innerHTML + suffix", new object[] { handle, "hello" });
Console.WriteLine(await resultHandle.JsonValueAsync<string>());
await resultHandle.DisposeAsync();
```

**Аргументы**
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-expression"/><a href="#page-evaluate-handle-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-arg"/><a href="#page-evaluate-handle-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [выражение](/api/class-page.mdx#page-evaluate-handle-option-expression).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-return"/><a href="#page-evaluate-handle-return" class="list-anchor">#</a>

---

### ExposeBindingAsync {#page-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.ExposeBindingAsync</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-binding-option-name) в объект `window` каждого фрейма на этой странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-binding-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-binding-option-callback). Если [callback](/api/class-page.mdx#page-expose-binding-option-callback) возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-page.mdx#page-expose-binding-option-callback) содержит информацию о вызывающем: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

Смотрите [BrowserContext.ExposeBindingAsync()](/api/class-browsercontext.mdx#browser-context-expose-binding) для версии, охватывающей весь контекст.

:::note

Функции, установленные через [Page.ExposeBindingAsync()](/api/class-page.mdx#page-expose-binding), сохраняются при навигации.
:::

**Использование**

Пример предоставления URL страницы всем фреймам на странице:

```csharp
using Microsoft.Playwright;
using System.Threading.Tasks;

class PageExamples
{
    public static async Task Main()
    {
        using var playwright = await Playwright.CreateAsync();
        await using var browser = await playwright.Webkit.LaunchAsync(new()
        {
            Headless = false,
        });
        var page = await browser.NewPageAsync();

        await page.ExposeBindingAsync("pageUrl", (source) => source.Page.Url);
        await page.SetContentAsync("<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.pageURL();\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>");

        await page.ClickAsync("button");
    }
}
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-name"/><a href="#page-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Action]&lt;BindingSource, T, [TResult]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-callback"/><a href="#page-expose-binding-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.
- `options` `PageExposeBindingOptions?` *(опционально)*
  - `Handle` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-handle"/><a href="#page-expose-binding-option-handle" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция будет удалена в будущем.
    :::
    
    Передавать ли аргумент как ссылку, вместо передачи по значению. При передаче ссылки поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-return"/><a href="#page-expose-binding-return" class="list-anchor">#</a>

---

### ExposeFunctionAsync {#page-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.ExposeFunctionAsync</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-function-option-name) в объект `window` каждого фрейма на странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-function-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-function-option-callback).

Если [callback](/api/class-page.mdx#page-expose-function-option-callback) возвращает [Promise], он будет ожидаться.

Смотрите [BrowserContext.ExposeFunctionAsync()](/api/class-browsercontext.mdx#browser-context-expose-function) для функции, охватывающей весь контекст.

:::note

Функции, установленные через [Page.ExposeFunctionAsync()](/api/class-page.mdx#page-expose-function), сохраняются при навигации.
:::

**Использование**

Пример добавления функции `sha256` на страницу:

```csharp
using Microsoft.Playwright;
using System;
using System.Security.Cryptography;
using System.Threading.Tasks;

class PageExamples
{
    public static async Task Main()
    {
        using var playwright = await Playwright.CreateAsync();
        await using var browser = await playwright.Webkit.LaunchAsync(new()
        {
            Headless = false
        });
        var page = await browser.NewPageAsync();

        await page.ExposeFunctionAsync("sha256", (string input) =>
        {
            return Convert.ToBase64String(
                SHA256.Create().ComputeHash(System.Text.Encoding.UTF8.GetBytes(input)));
        });

        await page.SetContentAsync("<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>");

        await page.ClickAsync("button");
        Console.WriteLine(await page.TextContentAsync("div"));
    }
}
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-name"/><a href="#page-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Action]&lt;T, [TResult]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-callback"/><a href="#page-expose-function-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-return"/><a href="#page-expose-function-return" class="list-anchor">#</a>

---

### Frame {#page-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.Frame</x-search>

Возвращает фрейм, соответствующий указанным критериям. Должно быть указано либо `name`, либо `url`.

**Использование**

```csharp
var frame = page.Frame("frame-name");
```

```csharp
var frame = page.FrameByUrl(".*domain.*");
```

**Аргументы**
- `name` [string] <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-option-name"/><a href="#page-frame-option-name" class="list-anchor">#</a>
  
  Имя фрейма, указанное в атрибуте `name` тега `iframe`.

**Возвращает**
- [Frame]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-return"/><a href="#page-frame-return" class="list-anchor">#</a>

---

### FrameByUrl {#page-frame-by-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.FrameByUrl</x-search>

Возвращает фрейм с соответствующим URL.

**Использование**

```csharp
Page.FrameByUrl(url);
```

**Аргументы**
- `url` [string] | [Regex] | [Func]&lt;[string], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-by-url-option-url"/><a href="#page-frame-by-url-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий `url` фрейма как объект [URL].

**Возвращает**
- [Frame]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-by-url-return"/><a href="#page-frame-by-url-return" class="list-anchor">#</a>

---

### FrameLocator {#page-frame-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.17</font><x-search>page.FrameLocator</x-search>

При работе с iframes вы можете создать локатор фрейма, который войдет в iframe и позволит выбирать элементы в этом iframe.

**Использование**

Следующий фрагмент кода находит элемент с текстом "Submit" в iframe с id `my-frame`, например, `<iframe id="my-frame">`:

```csharp
var locator = page.FrameLocator("#my-iframe").GetByText("Submit");
await locator.ClickAsync();
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-option-selector"/><a href="#page-frame-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении DOM элемента.

**Возвращает**
- [FrameLocator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-return"/><a href="#page-frame-locator-return" class="list-anchor">#</a>

---

### Frames {#page-frames}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.Frames</x-search>

Массив всех фреймов, прикрепленных к странице.

**Использование**

```csharp
Page.Frames
```

**Возвращает**
- [IReadOnlyList]&lt;[Frame]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frames-return"/><a href="#page-frames-return" class="list-anchor">#</a>

---

### GetByAltText {#page-get-by-alt-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.GetByAltText</x-search>

Позволяет находить элементы по их alt-тексту.

**Использование**

Например, этот метод найдет изображение по alt-тексту "Playwright logo":

```html
<img alt='Playwright logo'>
```

```csharp
await page.GetByAltText("Playwright logo").ClickAsync();
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-text"/><a href="#page-get-by-alt-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `PageGetByAltTextOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-exact"/><a href="#page-get-by-alt-text-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-return"/><a href="#page-get-by-alt-text-return" class="list-anchor">#</a>

---

### GetByLabel {#page-get-by-label}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.GetByLabel</x-search>

Позволяет находить элементы ввода по тексту связанного `<label>` или элемента `aria-labelledby`, или по атрибуту `aria-label`.

**Использование**

Например, этот метод найдет поля ввода по меткам "Username" и "Password" в следующем DOM:

```html
<input aria-label="Username">
<label for="password-input">Password:</label>
<input id="password-input">
```

```csharp
await page.GetByLabel("Username").FillAsync("john");
await page.GetByLabel("Password").FillAsync("secret");
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-text"/><a href="#page-get-by-label-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `PageGetByLabelOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-exact"/><a href="#page-get-by-label-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-return"/><a href="#page-get-by-label-return" class="list-anchor">#</a>

---

### GetByPlaceholder {#page-get-by-placeholder}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.GetByPlaceholder</x-search>

Позволяет находить элементы ввода по тексту-заполнителю.

**Использование**

Например, рассмотрим следующую структуру DOM.

```html
<input type="email" placeholder="name@example.com" />
```

Вы можете заполнить поле ввода, найдя его по тексту-заполнителю:

```csharp
await page
    .GetByPlaceholder("name@example.com")
    .FillAsync("playwright@microsoft.com");
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-text"/><a href="#page-get-by-placeholder-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `PageGetByPlaceholderOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-exact"/><a href="#page-get-by-placeholder-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-return"/><a href="#page-get-by-placeholder-return" class="list-anchor">#</a>

---

### GetByRole {#page-get-by-role}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.GetByRole</x-search>

Позволяет находить элементы по их [ARIA роли](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA атрибутам](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) и [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name).

**Использование**

Рассмотрим следующую структуру DOM.

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```

Вы можете найти каждый элемент по его неявной роли:

```csharp
await Expect(Page
    .GetByRole(AriaRole.Heading, new() { Name = "Sign up" }))
    .ToBeVisibleAsync();

await page
    .GetByRole(AriaRole.Checkbox, new() { Name = "Subscribe" })
    .CheckAsync();

await page
    .GetByRole(AriaRole.Button, new() {
        NameRegex = new Regex("submit", RegexOptions.IgnoreCase)
    })
    .ClickAsync();
```

**Аргументы**
- `role` `enum AriaRole { Alert, Alertdialog, Application, Article, Banner, Blockquote, Button, Caption, Cell, Checkbox, Code, Columnheader, Combobox, Complementary, Contentinfo, Definition, Deletion, Dialog, Directory, Document, Emphasis, Feed, Figure, Form, Generic, Grid, Gridcell, Group, Heading, Img, Insertion, Link, List, Listbox, Listitem, Log, Main, Marquee, Math, Meter, Menu, Menubar, Menuitem, Menuitemcheckbox, Menuitemradio, Navigation, None, Note, Option, Paragraph, Presentation, Progressbar, Radio, Radiogroup, Region, Row, Rowgroup, Rowheader, Scrollbar, Search, Searchbox, Separator, Slider, Spinbutton, Status, Strong, Subscript, Superscript, Switch, Tab, Table, Tablist, Tabpanel, Term, Textbox, Time, Timer, Toolbar, Tooltip, Tree, Treegrid, Treeitem }`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-role"/><a href="#page-get-by-role-option-role" class="list-anchor">#</a>
  
  Требуемая ARIA роль.
- `options` `PageGetByRoleOptions?` *(опционально)*
  - `Checked` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-checked"/><a href="#page-get-by-role-option-checked" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-checked` или нативными элементами `<input type=checkbox>`.
    
    Узнайте больше о [`aria-checked`](https://www.w3.org/TR/wai-aria-1.2/#aria-checked).
  - `Disabled` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-disabled"/><a href="#page-get-by-role-option-disabled" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-disabled` или `disabled`.
    
    :::note
    
    В отличие от большинства других атрибутов, `disabled` наследуется через иерархию DOM. Узнайте больше о [`aria-disabled`](https://www.w3.org/TR/wai-aria-1.2/#aria-disabled).
    :::
    
  - `Exact` [bool]? *(опционально)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-exact"/><a href="#page-get-by-role-option-exact" class="list-anchor">#</a>
    
    Совпадает ли [Name|NameRegex](/api/class-page.mdx#page-get-by-role-option-name) точно: с учетом регистра и всей строки. По умолчанию false. Игнорируется, когда [Name|NameRegex](/api/class-page.mdx#page-get-by-role-option-name) является регулярным выражением. Обратите внимание, что точное совпадение все равно обрезает пробелы.
  - `Expanded` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-expanded"/><a href="#page-get-by-role-option-expanded" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-expanded`.
    
    Узнайте больше о [`aria-expanded`](https://www.w3.org/TR/wai-aria-1.2/#aria-expanded).
  - `IncludeHidden` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-include-hidden"/><a href="#page-get-by-role-option-include-hidden" class="list-anchor">#</a>
    
    Опция, которая контролирует, будут ли скрытые элементы соответствовать. По умолчанию, только не скрытые элементы, как [определено ARIA](https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion), соответствуют селектору роли.
    
    Узнайте больше о [`aria-hidden`](https://www.w3.org/TR/wai-aria-1.2/#aria-hidden).
  - `Level` [int]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-level"/><a href="#page-get-by-role-option-level" class="list-anchor">#</a>
    
    Числовой атрибут, который обычно присутствует для ролей `heading`, `listitem`, `row`, `treeitem`, с значениями по умолчанию для элементов `<h1>-<h6>`.
    
    Узнайте больше о [`aria-level`](https://www.w3.org/TR/wai-aria-1.2/#aria-level).
  - `Name|NameRegex` [string]? | [Regex]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-name"/><a href="#page-get-by-role-option-name" class="list-anchor">#</a>
    
    Опция для соответствия [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name). По умолчанию, соответствие не учитывает регистр и ищет подстроку, используйте [Exact](/api/class-page.mdx#page-get-by-role-option-exact) для управления этим поведением.
    
    Узнайте больше о [доступном имени](https://w3c.github.io/accname/#dfn-accessible-name).
  - `Pressed` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-pressed"/><a href="#page-get-by-role-option-pressed" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-pressed`.
    
    Узнайте больше о [`aria-pressed`](https://www.w3.org/TR/wai-aria-1.2/#aria-pressed).
  - `Selected` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-selected"/><a href="#page-get-by-role-option-selected" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-selected`.
    
    Узнайте больше о [`aria-selected`](https://www.w3.org/TR/wai-aria-1.2/#aria-selected).

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-return"/><a href="#page-get-by-role-return" class="list-anchor">#</a>

**Детали**

Селектор роли **не заменяет** аудиты доступности и тесты на соответствие, но дает раннюю обратную связь о руководствах ARIA.

Многие HTML элементы имеют неявно [определенную роль](https://w3c.github.io/html-aam/#html-element-role-mappings), которая распознается селектором роли. Вы можете найти все [поддерживаемые роли здесь](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). Руководства ARIA **не рекомендуют** дублировать неявные роли и атрибуты, устанавливая `role` и/или `aria-*` атрибуты на значения по умолчанию.

---

### GetByTestId {#page-get-by-test-id}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.GetByTestId</x-search>

Находит элемент по тестовому идентификатору.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<button data-testid="directions">Itinéraire</button>
```

Вы можете найти элемент по его тестовому идентификатору:

```csharp
await page.GetByTestId("directions").ClickAsync();
```

**Аргументы**
- `testId` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-option-test-id"/><a href="#page-get-by-test-id-option-test-id" class="list-anchor">#</a>
  
  Идентификатор для поиска элемента.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-return"/><a href="#page-get-by-test-id-return" class="list-anchor">#</a>

**Детали**

По умолчанию используется атрибут `data-testid` в качестве тестового идентификатора. Используйте [Selectors.SetTestIdAttribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute) для настройки другого атрибута тестового идентификатора, если это необходимо.

---

### GetByText {#page-get-by-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.GetByText</x-search>

Позволяет находить элементы, содержащие заданный текст.

Смотрите также [Locator.Filter()](/api/class-locator.mdx#locator-filter), который позволяет сопоставлять по другим критериям, таким как доступная роль, а затем фильтровать по текстовому содержимому.

**Использование**

Рассмотрим следующую структуру DOM:

```html
<div>Hello <span>world</span></div>
<div>Hello</div>
```

Вы можете найти по подстроке текста, точной строке или регулярному выражению:

```csharp
// Соответствует <span>
page.GetByText("world");

// Соответствует первому <div>
page.GetByText("Hello world");

// Соответствует второму <div>
page.GetByText("Hello", new() { Exact = true });

// Соответствует обоим <div>
page.GetByText(new Regex("Hello"));

// Соответствует второму <div>
page.GetByText(new Regex("^hello$", RegexOptions.IgnoreCase));
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-text"/><a href="#page-get-by-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `PageGetByTextOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-exact"/><a href="#page-get-by-text-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-return"/><a href="#page-get-by-text-return" class="list-anchor">#</a>

**Детали**

Сопоставление по тексту всегда нормализует пробелы, даже при точном совпадении. Например, оно превращает несколько пробелов в один, превращает разрывы строк в пробелы и игнорирует начальные и конечные пробелы.

Элементы ввода типа `button` и `submit` сопоставляются по их `value`, а не по текстовому содержимому. Например, поиск по тексту `"Log in"` соответствует `<input type=button value="Log in">`.

---

### GetByTitle {#page-get-by-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>page.GetByTitle</x-search>

Позволяет находить элементы по их атрибуту title.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<span title='Issues count'>25 issues</span>
```

Вы можете проверить количество проблем, найдя его по тексту заголовка:

```csharp
await Expect(Page.GetByTitle("Issues count")).toHaveText("25 issues");
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-text"/><a href="#page-get-by-title-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `PageGetByTitleOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-exact"/><a href="#page-get-by-title-option-exact" class="list-anchor">#</a>
    
    Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-return"/><a href="#page-get-by-title-return" class="list-anchor">#</a>

---

### GoBackAsync {#page-go-back}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.GoBackAsync</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация завершится с ответом последнего перенаправления. Если невозможно вернуться назад, возвращает `null`.

Переход на предыдущую страницу в истории.

**Использование**

```csharp
await Page.GoBackAsync(options);
```

**Аргументы**
- `options` `PageGoBackOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-timeout"/><a href="#page-go-back-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить с помощью методов [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-wait-until"/><a href="#page-go-back-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Response]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-return"/><a href="#page-go-back-return" class="list-anchor">#</a>

---

### GoForwardAsync {#page-go-forward}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.GoForwardAsync</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация завершится с ответом последнего перенаправления. Если невозможно перейти вперед, возвращает `null`.

Переход на следующую страницу в истории.

**Использование**

```csharp
await Page.GoForwardAsync(options);
```

**Аргументы**
- `options` `PageGoForwardOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-timeout"/><a href="#page-go-forward-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить с помощью методов [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-wait-until"/><a href="#page-go-forward-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Response]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-return"/><a href="#page-go-forward-return" class="list-anchor">#</a>

---

### GotoAsync {#page-goto}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.GotoAsync</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация завершится с первым не перенаправленным ответом.

Метод вызовет ошибку, если:
* произошла ошибка SSL (например, в случае самоподписанных сертификатов).
* целевой URL недействителен.
* [Timeout](/api/class-page.mdx#page-goto-option-timeout) превышен во время навигации.
* удаленный сервер не отвечает или недоступен.
* основной ресурс не удалось загрузить.

Метод не вызовет ошибку, если удаленный сервер вернет любой допустимый HTTP-код состояния, включая 404 "Не найдено" и 500 "Внутренняя ошибка сервера". Код состояния для таких ответов можно получить, вызвав [Response.Status](/api/class-response.mdx#response-status).

:::note

Метод либо вызывает ошибку, либо возвращает ответ основного ресурса. Единственные исключения - это навигация на `about:blank` или навигация на тот же URL с другим хэшем, которые будут успешными и вернут `null`.
:::

:::note
Режим без головы не поддерживает навигацию к PDF-документу. См. [проблему](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).
:::

**Использование**

```csharp
await Page.GotoAsync(url, options);
```

**Аргументы**
- `url` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-url"/><a href="#page-goto-option-url" class="list-anchor">#</a>
  
  URL для перехода на страницу. URL должен включать схему, например, `https://`. Когда [BaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `PageGotoOptions?` *(опционально)*
  - `Referer` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-referer"/><a href="#page-goto-option-referer" class="list-anchor">#</a>
    
    Значение заголовка Referer. Если предоставлено, оно будет иметь приоритет над значением заголовка referer, установленным с помощью [Page.SetExtraHTTPHeadersAsync()](/api/class-page.mdx#page-set-extra-http-headers).
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-timeout"/><a href="#page-goto-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить с помощью методов [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-wait-until"/><a href="#page-goto-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Response]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-return"/><a href="#page-goto-return" class="list-anchor">#</a>

---

### IsClosed {#page-is-closed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.IsClosed</x-search>

Указывает, что страница была закрыта.

**Использование**

```csharp
Page.IsClosed
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-closed-return"/><a href="#page-is-closed-return" class="list-anchor">#</a>

---

### Locator {#page-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.14</font><x-search>page.Locator</x-search>

Метод возвращает локатор элемента, который можно использовать для выполнения действий на этой странице/фрейме. Локатор разрешается в элемент непосредственно перед выполнением действия, поэтому серия действий на одном и том же локаторе может фактически выполняться на разных элементах DOM. Это произойдет, если структура DOM между этими действиями изменилась.

[Узнайте больше о локаторах](../locators.mdx).

**Использование**

```csharp
Page.Locator(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-selector"/><a href="#page-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении элемента DOM.
- `options` `PageLocatorOptions?` *(опционально)*
  - `Has` [Locator]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has"/><a href="#page-locator-option-has" class="list-anchor">#</a>
    
    Сужает результаты метода до тех, которые содержат элементы, соответствующие этому относительному локатору. Например, `article`, который имеет `text=Playwright`, соответствует `<article><div>Playwright</div></article>`.
    
    Внутренний локатор **должен быть относительным** к внешнему локатору и запрашивается, начиная с совпадения внешнего локатора, а не с корня документа. Например, вы можете найти `content`, который имеет `div` в `<article><content><div>Playwright</div></content></article>`. Однако поиск `content`, который имеет `article div`, не удастся, потому что внутренний локатор должен быть относительным и не должен использовать элементы за пределами `content`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `HasNot` [Locator]? *(опционально)* <font size="2">Добавлено в: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not"/><a href="#page-locator-option-has-not" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат элемент, соответствующий внутреннему локатору. Внутренний локатор запрашивается относительно внешнего. Например, `article`, который не имеет `div`, соответствует `<article><span>Playwright</span></article>`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `HasNotText|HasNotTextRegex` [string]? | [Regex]? *(опционально)* <font size="2">Добавлено в: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not-text"/><a href="#page-locator-option-has-not-text" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [string] совпадение не учитывает регистр и ищет подстроку.
  - `HasText|HasTextRegex` [string]? | [Regex]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-text"/><a href="#page-locator-option-has-text" class="list-anchor">#</a>
    
    Соответствует элементам, содержащим указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [string] совпадение не учитывает регистр и ищет подстроку. Например, `"Playwright"` соответствует `<article><div>Playwright</div></article>`.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-return"/><a href="#page-locator-return" class="list-anchor">#</a>

---

### MainFrame {#page-main-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.MainFrame</x-search>

Основной фрейм страницы. Страница гарантированно имеет основной фрейм, который сохраняется во время навигации.

**Использование**

```csharp
Page.MainFrame
```

**Возвращает**
- [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-main-frame-return"/><a href="#page-main-frame-return" class="list-anchor">#</a>

---

### OpenerAsync {#page-opener}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.OpenerAsync</x-search>

Возвращает открыватель для всплывающих страниц и `null` для других. Если открыватель уже был закрыт, возвращает `null`.

**Использование**

```csharp
await Page.OpenerAsync();
```

**Возвращает**
- [Page]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-opener-return"/><a href="#page-opener-return" class="list-anchor">#</a>

---

### PageErrorsAsync {#page-page-errors}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.56</font><x-search>page.PageErrorsAsync</x-search>

Returns up to (currently) 200 last page errors from this page. See [Page.PageError](/api/class-page.mdx#page-event-page-error) for more details.

**Usage**

```csharp
await Page.PageErrorsAsync();
```

**Returns**
- [IReadOnlyList]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-page-errors-return"/><a href="#page-page-errors-return" class="list-anchor">#</a>

---

### PauseAsync {#page-pause}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.PauseAsync</x-search>

Приостанавливает выполнение скрипта. Playwright перестанет выполнять скрипт и будет ждать, пока пользователь либо нажмёт кнопку **Resume** в оверлее страницы, либо вызовет `playwright.resume()` в консоли DevTools.

Пользователь может исследовать селекторы или выполнять ручные действия во время паузы. Возобновление продолжит выполнение оригинального скрипта с того места, где он был приостановлен.

:::note

Этот метод требует, чтобы Playwright был запущен в режиме с интерфейсом, с ложным значением опции [Headless](/api/class-browsertype.mdx#browser-type-launch-option-headless).
:::

**Использование**

```csharp
await Page.PauseAsync();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pause-return"/><a href="#page-pause-return" class="list-anchor">#</a>

---

### PdfAsync {#page-pdf}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.PdfAsync</x-search>

Возвращает буфер PDF.

`page.pdf()` генерирует PDF страницы с использованием CSS медиа `print`. Чтобы сгенерировать PDF с медиа `screen`, вызовите [Page.EmulateMediaAsync()](/api/class-page.mdx#page-emulate-media) перед вызовом `page.pdf()`:

:::note

По умолчанию `page.pdf()` генерирует PDF с измененными цветами для печати. Используйте свойство [`-webkit-print-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust), чтобы принудительно отобразить точные цвета.
:::

**Использование**

```csharp
// Генерирует PDF с медиа-типом 'screen'
await page.EmulateMediaAsync(new() { Media = Media.Screen });
await page.PdfAsync(new() { Path = "page.pdf" });
```

Опции [Width](/api/class-page.mdx#page-pdf-option-width), [Height](/api/class-page.mdx#page-pdf-option-height) и [Margin](/api/class-page.mdx#page-pdf-option-margin) принимают значения с указанием единиц измерения. Значения без указания единиц измерения считаются пикселями.

Несколько примеров:
* `page.pdf({width: 100})` - печатает с шириной, установленной в 100 пикселей
* `page.pdf({width: '100px'})` - печатает с шириной, установленной в 100 пикселей
* `page.pdf({width: '10cm'})` - печатает с шириной, установленной в 10 сантиметров.

Все возможные единицы измерения:
* `px` - пиксель
* `in` - дюйм
* `cm` - сантиметр
* `mm` - миллиметр

Опции [Format](/api/class-page.mdx#page-pdf-option-format):
* `Letter`: 8.5in x 11in
* `Legal`: 8.5in x 14in
* `Tabloid`: 11in x 17in
* `Ledger`: 17in x 11in
* `A0`: 33.1in x 46.8in
* `A1`: 23.4in x 33.1in
* `A2`: 16.54in x 23.4in
* `A3`: 11.7in x 16.54in
* `A4`: 8.27in x 11.7in
* `A5`: 5.83in x 8.27in
* `A6`: 4.13in x 5.83in

:::note

Разметка [HeaderTemplate](/api/class-page.mdx#page-pdf-option-header-template) и [FooterTemplate](/api/class-page.mdx#page-pdf-option-footer-template) имеет следующие ограничения: > 1. Теги скриптов внутри шаблонов не выполняются. > 2. Стили страницы не видны внутри шаблонов.
:::

**Аргументы**
- `options` `PagePdfOptions?` *(опционально)*
  - `DisplayHeaderFooter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-display-header-footer"/><a href="#page-pdf-option-display-header-footer" class="list-anchor">#</a>
    
    Отображать заголовок и нижний колонтитул. По умолчанию `false`.
  - `FooterTemplate` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-footer-template"/><a href="#page-pdf-option-footer-template" class="list-anchor">#</a>
    
    HTML-шаблон для нижнего колонтитула печати. Должен использовать тот же формат, что и [HeaderTemplate](/api/class-page.mdx#page-pdf-option-header-template).
  - `Format` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-format"/><a href="#page-pdf-option-format" class="list-anchor">#</a>
    
    Формат бумаги. Если установлен, имеет приоритет над опциями [Width](/api/class-page.mdx#page-pdf-option-width) или [Height](/api/class-page.mdx#page-pdf-option-height). По умолчанию 'Letter'.
  - `HeaderTemplate` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-header-template"/><a href="#page-pdf-option-header-template" class="list-anchor">#</a>
    
    HTML-шаблон для заголовка печати. Должен быть допустимой HTML-разметкой с использованием следующих классов для вставки значений печати:
    * `'date'` отформатированная дата печати
    * `'title'` заголовок документа
    * `'url'` местоположение документа
    * `'pageNumber'` номер текущей страницы
    * `'totalPages'` общее количество страниц в документе
  - `Height` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-height"/><a href="#page-pdf-option-height" class="list-anchor">#</a>
    
    Высота бумаги, принимает значения с указанием единиц измерения.
  - `Landscape` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-landscape"/><a href="#page-pdf-option-landscape" class="list-anchor">#</a>
    
    Ориентация бумаги. По умолчанию `false`.
  - `Margin` Margin? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-margin"/><a href="#page-pdf-option-margin" class="list-anchor">#</a>
    - `Top` [string]? *(опционально)*
      
      Верхнее поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    - `Right` [string]? *(опционально)*
      
      Правое поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    - `Bottom` [string]? *(опционально)*
      
      Нижнее поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    - `Left` [string]? *(опционально)*
      
      Левое поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    
    Поля бумаги, по умолчанию отсутствуют.
  - `Outline` [bool]? *(опционально)* <font size="2">Добавлено в: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-outline"/><a href="#page-pdf-option-outline" class="list-anchor">#</a>
    
    Включать ли контур документа в PDF. По умолчанию `false`.
  - `PageRanges` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-page-ranges"/><a href="#page-pdf-option-page-ranges" class="list-anchor">#</a>
    
    Диапазоны страниц для печати, например, '1-5, 8, 11-13'. По умолчанию пустая строка, что означает печать всех страниц.
  - `Path` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-path"/><a href="#page-pdf-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения PDF. Если [Path](/api/class-page.mdx#page-pdf-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, PDF не будет сохранен на диск.
  - `PreferCSSPageSize` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-prefer-css-page-size"/><a href="#page-pdf-option-prefer-css-page-size" class="list-anchor">#</a>
    
    Давать приоритет любому размеру `@page`, объявленному в CSS страницы, над тем, что указано в опциях [Width](/api/class-page.mdx#page-pdf-option-width) и [Height](/api/class-page.mdx#page-pdf-option-height) или [Format](/api/class-page.mdx#page-pdf-option-format). По умолчанию `false`, что будет масштабировать содержимое, чтобы оно соответствовало размеру бумаги.
  - `PrintBackground` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-print-background"/><a href="#page-pdf-option-print-background" class="list-anchor">#</a>
    
    Печать фоновой графики. По умолчанию `false`.
  - `Scale` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-scale"/><a href="#page-pdf-option-scale" class="list-anchor">#</a>
    
    Масштаб рендеринга веб-страницы. По умолчанию `1`. Масштаб должен быть между 0.1 и 2.
  - `Tagged` [bool]? *(опционально)* <font size="2">Добавлено в: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-tagged"/><a href="#page-pdf-option-tagged" class="list-anchor">#</a>
    
    Генерировать ли тегированный (доступный) PDF. По умолчанию `false`.
  - `Width` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-width"/><a href="#page-pdf-option-width" class="list-anchor">#</a>
    
    Ширина бумаги, принимает значения с указанием единиц измерения.

**Возвращает**
- [byte]&#91;&#93;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-return"/><a href="#page-pdf-return" class="list-anchor">#</a>

---

### ReloadAsync {#page-reload}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.ReloadAsync</x-search>

Этот метод перезагружает текущую страницу так же, как если бы пользователь инициировал обновление браузера. Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация завершится с ответом последнего перенаправления.

**Использование**

```csharp
await Page.ReloadAsync(options);
```

**Аргументы**
- `options` `PageReloadOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-timeout"/><a href="#page-reload-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить с помощью методов [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-wait-until"/><a href="#page-reload-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Response]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-return"/><a href="#page-reload-return" class="list-anchor">#</a>

---

### RemoveLocatorHandlerAsync {#page-remove-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.44</font><x-search>page.RemoveLocatorHandlerAsync</x-search>

Удаляет все обработчики локаторов, добавленные с помощью [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler) для конкретного локатора.

**Использование**

```csharp
await Page.RemoveLocatorHandlerAsync(locator);
```

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-option-locator"/><a href="#page-remove-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, переданный в [Page.AddLocatorHandlerAsync()](/api/class-page.mdx#page-add-locator-handler).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-return"/><a href="#page-remove-locator-handler-return" class="list-anchor">#</a>

---

### RequestGCAsync {#page-request-gc}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>page.RequestGCAsync</x-search>

Запрашивает у страницы выполнение сборки мусора. Обратите внимание, что нет гарантии, что все недоступные объекты будут собраны.

Это полезно для обнаружения утечек памяти. Например, если на вашей странице есть большой объект `'suspect'`, который может утекать, вы можете проверить, что он не утек, используя [`WeakRef`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef).

```csharp
// 1. На вашей странице сохраните WeakRef для "suspect".
await Page.EvaluateAsync("globalThis.suspectWeakRef = new WeakRef(suspect)");
// 2. Запросите сборку мусора.
await Page.RequestGCAsync();
// 3. Убедитесь, что weak ref не ссылается на оригинальный объект.
Assert.True(await Page.EvaluateAsync("!globalThis.suspectWeakRef.deref()"));
```

**Использование**

```csharp
await Page.RequestGCAsync();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-request-gc-return"/><a href="#page-request-gc-return" class="list-anchor">#</a>

---

### RequestsAsync {#page-requests}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.56</font><x-search>page.RequestsAsync</x-search>

Returns up to (currently) 100 last network request from this page. See [Page.Request](/api/class-page.mdx#page-event-request) for more details.

Returned requests should be accessed immediately, otherwise they might be collected to prevent unbounded memory growth as new requests come in. Once collected, retrieving most information about the request is impossible.

Note that requests reported through the [Page.Request](/api/class-page.mdx#page-event-request) request are not collected, so there is a trade off between efficient memory usage with [Page.RequestsAsync()](/api/class-page.mdx#page-requests) and the amount of available information reported through [Page.Request](/api/class-page.mdx#page-event-request).

**Usage**

```csharp
await Page.RequestsAsync();
```

**Returns**
- [IReadOnlyList]&lt;[Request]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-requests-return"/><a href="#page-requests-return" class="list-anchor">#</a>

---

### RouteAsync {#page-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.RouteAsync</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются страницей.

После включения маршрутизации каждый запрос, соответствующий шаблону URL, будет приостановлен, если он не будет продолжен, выполнен или прерван.

:::note

Обработчик будет вызван только для первого URL, если ответ является перенаправлением.
:::

:::note
[Page.RouteAsync()](/api/class-page.mdx#page-route) не будет перехватывать запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [ServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

:::note
[Page.RouteAsync()](/api/class-page.mdx#page-route) не будет перехватывать первый запрос всплывающей страницы. Используйте [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) вместо этого.
:::

**Использование**

Пример простого обработчика, который прерывает все запросы изображений:

```csharp
var page = await browser.NewPageAsync();
await page.RouteAsync("**/*.{png,jpg,jpeg}", async r => await r.AbortAsync());
await page.GotoAsync("https://www.microsoft.com");
```

или тот же фрагмент кода, используя шаблон регулярного выражения:

```csharp
var page = await browser.NewPageAsync();
await page.RouteAsync(new Regex("(\\.png$)|(\\.jpg$)"), async r => await r.AbortAsync());
await page.GotoAsync("https://www.microsoft.com");
```

Возможно исследовать запрос, чтобы решить, какое действие маршрута выполнить. Например, имитировать все запросы, содержащие некоторые данные POST, и оставлять все остальные запросы как есть:

```csharp
await page.RouteAsync("/api/**", async r =>
{
  if (r.Request.PostData.Contains("my-string"))
      await r.FulfillAsync(new() { Body = "mocked-data" });
  else
      await r.ContinueAsync();
});
```

Маршруты страницы имеют приоритет над маршрутами контекста браузера (установленными с помощью [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route)), когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [Page.UnrouteAsync()](/api/class-page.mdx#page-unroute).

:::note

Включение маршрутизации отключает HTTP-кэш.
:::

**Аргументы**
- `url` [string] | [Regex] | [Func]&lt;[string], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-url"/><a href="#page-route-option-url" class="list-anchor">#</a>
  
  Шаблон glob, регулярное выражение или предикат, который получает [URL] для сопоставления при маршрутизации. Если в параметрах контекста задан [BaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) и переданный URL является строкой, не начинающейся с `*`, он будет разрешён с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `handler` [Action]&lt;[Route]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-handler"/><a href="#page-route-option-handler" class="list-anchor">#</a>
  
  функция обработчика для маршрутизации запроса.
- `options` `PageRouteOptions?` *(опционально)*
  - `Times` [int]? *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-times"/><a href="#page-route-option-times" class="list-anchor">#</a>
    
    Сколько раз маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-return"/><a href="#page-route-return" class="list-anchor">#</a>

---

### RouteFromHARAsync {#page-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>page.RouteFromHARAsync</x-search>

Если указано, сетевые запросы, сделанные на странице, будут обслуживаться из HAR-файла. Подробнее читайте в разделе [Воспроизведение из HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из HAR-файла. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [ServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```csharp
await Page.RouteFromHARAsync(har, options);
```

**Аргументы**
- `har` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-har"/><a href="#page-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec) файлу с предварительно записанными сетевыми данными. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `options` `PageRouteFromHAROptions?` *(опционально)*
  - `NotFound` `enum HarNotFound { Abort, Fallback }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-not-found"/><a href="#page-route-from-har-option-not-found" class="list-anchor">#</a>
    * Если установлено значение 'abort', любой запрос, не найденный в HAR-файле, будет прерван.
    * Если установлено значение 'fallback', отсутствующие запросы будут отправлены в сеть.
    
    По умолчанию - abort.
  - `Update` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update"/><a href="#page-route-from-har-option-update" class="list-anchor">#</a>
    
    Если указано, обновляет данный HAR с фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск, когда вызывается [BrowserContext.CloseAsync()](/api/class-browsercontext.mdx#browser-context-close).
  - `UpdateContent` `enum RouteFromHarUpdateContentPolicy { Embed, Attach }?` *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-content"/><a href="#page-route-from-har-option-update-content" class="list-anchor">#</a>
    
    Опциональная настройка для управления содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP-архиве. Если указано `embed`, содержимое хранится встроенным в HAR-файл.
  - `UpdateMode` `enum HarMode { Full, Minimal }?` *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-mode"/><a href="#page-route-from-har-option-update-mode" class="list-anchor">#</a>
    
    Когда установлено значение `minimal`, записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницу, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию - `minimal`.
  - `Url|UrlRegex` [string]? | [Regex]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-url"/><a href="#page-route-from-har-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR-файла. Если не указано, все запросы обслуживаются из HAR-файла.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-return"/><a href="#page-route-from-har-return" class="list-anchor">#</a>

---

### RouteWebSocketAsync {#page-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>page.RouteWebSocketAsync</x-search>

Этот метод позволяет модифицировать WebSocket-соединения, которые создаются страницей.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизированы. Рекомендуется вызывать этот метод перед навигацией по странице.

**Использование**

Ниже приведен пример простого мока, который отвечает на одно сообщение. Подробнее и примеры смотрите в [WebSocketRoute].

```csharp
await page.RouteWebSocketAsync("/ws", ws => {
  ws.OnMessage(frame => {
    if (frame.Text == "request")
      ws.Send("response");
  });
});
```

**Аргументы**
- `url` [string] | [Regex] | [Func]&lt;[string], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-url"/><a href="#page-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизированы. Строковый шаблон может быть относительным к [BaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) в контексте.
- `handler` [Action]&lt;[WebSocketRoute]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-handler"/><a href="#page-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-return"/><a href="#page-route-web-socket-return" class="list-anchor">#</a>

---

### RunAndWaitForConsoleMessageAsync {#page-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.RunAndWaitForConsoleMessageAsync</x-search>

Выполняет действие и ждет, пока [ConsoleMessage] не будет зарегистрировано на странице. Если предикат предоставлен, он передает значение [ConsoleMessage] в функцию `predicate` и ждет, пока `predicate(message)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [Page.Console](/api/class-page.mdx#page-event-console) будет вызвано.

**Использование**

```csharp
await Page.RunAndWaitForConsoleMessageAsync(action, options);
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-action"/><a href="#page-wait-for-console-message-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `PageRunAndWaitForConsoleMessageOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[ConsoleMessage]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-predicate"/><a href="#page-wait-for-console-message-option-predicate" class="list-anchor">#</a>
    
    Получает объект [ConsoleMessage] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-timeout"/><a href="#page-wait-for-console-message-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [ConsoleMessage]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-return"/><a href="#page-wait-for-console-message-return" class="list-anchor">#</a>

---

### WaitForConsoleMessageAsync {#page-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.WaitForConsoleMessageAsync</x-search>

Выполняет действие и ждет, пока [ConsoleMessage] не будет зарегистрировано на странице. Если предикат предоставлен, он передает значение [ConsoleMessage] в функцию `predicate` и ждет, пока `predicate(message)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [Page.Console](/api/class-page.mdx#page-event-console) будет вызвано.

**Использование**

```csharp
await Page.WaitForConsoleMessageAsync(action, options);
```

**Аргументы**
- `options` `PageRunAndWaitForConsoleMessageOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[ConsoleMessage]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-predicate"/><a href="#page-wait-for-console-message-option-predicate" class="list-anchor">#</a>
    
    Получает объект [ConsoleMessage] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-timeout"/><a href="#page-wait-for-console-message-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [ConsoleMessage]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-return"/><a href="#page-wait-for-console-message-return" class="list-anchor">#</a>

---

### RunAndWaitForDownloadAsync {#page-wait-for-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.RunAndWaitForDownloadAsync</x-search>

Выполняет действие и ждет нового [Download]. Если предикат предоставлен, он передает значение [Download] в функцию `predicate` и ждет, пока `predicate(download)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие загрузки будет вызвано.

**Использование**

```csharp
await Page.RunAndWaitForDownloadAsync(action, options);
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-action"/><a href="#page-wait-for-download-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `PageRunAndWaitForDownloadOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Download]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-predicate"/><a href="#page-wait-for-download-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Download] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-timeout"/><a href="#page-wait-for-download-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Download]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-return"/><a href="#page-wait-for-download-return" class="list-anchor">#</a>

---

### WaitForDownloadAsync {#page-wait-for-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.WaitForDownloadAsync</x-search>

Выполняет действие и ждет нового [Download]. Если предикат предоставлен, он передает значение [Download] в функцию `predicate` и ждет, пока `predicate(download)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие загрузки будет вызвано.

**Использование**

```csharp
await Page.WaitForDownloadAsync(action, options);
```

**Аргументы**
- `options` `PageRunAndWaitForDownloadOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Download]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-predicate"/><a href="#page-wait-for-download-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Download] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-timeout"/><a href="#page-wait-for-download-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Download]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-return"/><a href="#page-wait-for-download-return" class="list-anchor">#</a>

---

### RunAndWaitForFileChooserAsync {#page-wait-for-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.RunAndWaitForFileChooserAsync</x-search>

Выполняет действие и ждет, пока не будет создан новый [FileChooser]. Если предикат предоставлен, он передает значение [FileChooser] в функцию `predicate` и ждет, пока `predicate(fileChooser)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как откроется выбор файла.

**Использование**

```csharp
await Page.RunAndWaitForFileChooserAsync(action, options);
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-action"/><a href="#page-wait-for-file-chooser-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `PageRunAndWaitForFileChooserOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[FileChooser]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-predicate"/><a href="#page-wait-for-file-chooser-option-predicate" class="list-anchor">#</a>
    
    Получает объект [FileChooser] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-timeout"/><a href="#page-wait-for-file-chooser-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [FileChooser]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-return"/><a href="#page-wait-for-file-chooser-return" class="list-anchor">#</a>

---

### WaitForFileChooserAsync {#page-wait-for-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.WaitForFileChooserAsync</x-search>

Выполняет действие и ждет, пока не будет создан новый [FileChooser]. Если предикат предоставлен, он передает значение [FileChooser] в функцию `predicate` и ждет, пока `predicate(fileChooser)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как откроется выбор файла.

**Использование**

```csharp
await Page.WaitForFileChooserAsync(action, options);
```

**Аргументы**
- `options` `PageRunAndWaitForFileChooserOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[FileChooser]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-predicate"/><a href="#page-wait-for-file-chooser-option-predicate" class="list-anchor">#</a>
    
    Получает объект [FileChooser] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-timeout"/><a href="#page-wait-for-file-chooser-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [FileChooser]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-return"/><a href="#page-wait-for-file-chooser-return" class="list-anchor">#</a>

---

### RunAndWaitForPopupAsync {#page-wait-for-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.RunAndWaitForPopupAsync</x-search>

Выполняет действие и ждет всплывающую [Page]. Если предикат предоставлен, он передает значение [Popup] в функцию `predicate` и ждет, пока `predicate(page)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие всплывающего окна будет вызвано.

**Использование**

```csharp
await Page.RunAndWaitForPopupAsync(action, options);
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-action"/><a href="#page-wait-for-popup-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `PageRunAndWaitForPopupOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Page]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-predicate"/><a href="#page-wait-for-popup-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Page] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-timeout"/><a href="#page-wait-for-popup-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-return"/><a href="#page-wait-for-popup-return" class="list-anchor">#</a>

---

### WaitForPopupAsync {#page-wait-for-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.WaitForPopupAsync</x-search>

Выполняет действие и ждет всплывающую [Page]. Если предикат предоставлен, он передает значение [Popup] в функцию `predicate` и ждет, пока `predicate(page)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие всплывающего окна будет вызвано.

**Использование**

```csharp
await Page.WaitForPopupAsync(action, options);
```

**Аргументы**
- `options` `PageRunAndWaitForPopupOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Page]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-predicate"/><a href="#page-wait-for-popup-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Page] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-timeout"/><a href="#page-wait-for-popup-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-return"/><a href="#page-wait-for-popup-return" class="list-anchor">#</a>

---

### RunAndWaitForRequestAsync {#page-wait-for-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.RunAndWaitForRequestAsync</x-search>

Ожидает совпадения запроса и возвращает его. Подробнее о событиях читайте в разделе [ожидание события](../events.mdx#waiting-for-event).

**Использование**

```csharp
// Ожидает следующего запроса с указанным URL.
await page.RunAndWaitForRequestAsync(async () =>
{
    await page.GetByText("trigger request").ClickAsync();
}, "http://example.com/resource");

// Альтернативный способ с предикатом.
await page.RunAndWaitForRequestAsync(async () =>
{
    await page.GetByText("trigger request").ClickAsync();
}, request => request.Url == "https://example.com" && request.Method == "GET");
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-action"/><a href="#page-wait-for-request-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `urlOrPredicate` [string] | [Regex] | [Func]&lt;[Request], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-url-or-predicate"/><a href="#page-wait-for-request-option-url-or-predicate" class="list-anchor">#</a>
  
  Строка URL запроса, регулярное выражение или предикат, получающий объект [Request]. Когда [BaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `PageRunAndWaitForRequestOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-timeout"/><a href="#page-wait-for-request-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Request]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-return"/><a href="#page-wait-for-request-return" class="list-anchor">#</a>

---

### WaitForRequestAsync {#page-wait-for-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.WaitForRequestAsync</x-search>

Ожидает совпадения запроса и возвращает его. Подробнее о событиях читайте в разделе [ожидание события](../events.mdx#waiting-for-event).

**Использование**

```csharp
// Ожидает следующего запроса с указанным URL.
await page.RunAndWaitForRequestAsync(async () =>
{
    await page.GetByText("trigger request").ClickAsync();
}, "http://example.com/resource");

// Альтернативный способ с предикатом.
await page.RunAndWaitForRequestAsync(async () =>
{
    await page.GetByText("trigger request").ClickAsync();
}, request => request.Url == "https://example.com" && request.Method == "GET");
```

**Аргументы**
- `urlOrPredicate` [string] | [Regex] | [Func]&lt;[Request], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-url-or-predicate"/><a href="#page-wait-for-request-option-url-or-predicate" class="list-anchor">#</a>
  
  Строка URL запроса, регулярное выражение или предикат, получающий объект [Request]. Когда [BaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `PageRunAndWaitForRequestOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-timeout"/><a href="#page-wait-for-request-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [Request]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-return"/><a href="#page-wait-for-request-return" class="list-anchor">#</a>

---

### RunAndWaitForRequestFinishedAsync {#page-wait-for-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>page.RunAndWaitForRequestFinishedAsync</x-search>

Выполняет действие и ждет, пока [Request] не завершит загрузку. Если предикат предоставлен, он передает значение [Request] в функцию `predicate` и ждет, пока `predicate(request)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [Page.RequestFinished](/api/class-page.mdx#page-event-request-finished) будет вызвано.

**Использование**

```csharp
await Page.RunAndWaitForRequestFinishedAsync(action, options);
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-action"/><a href="#page-wait-for-request-finished-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `PageRunAndWaitForRequestFinishedOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Request]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-predicate"/><a href="#page-wait-for-request-finished-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Request] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-timeout"/><a href="#page-wait-for-request-finished-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Request]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-return"/><a href="#page-wait-for-request-finished-return" class="list-anchor">#</a>

---

### WaitForRequestFinishedAsync {#page-wait-for-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>page.WaitForRequestFinishedAsync</x-search>

Выполняет действие и ждет, пока [Request] не завершит загрузку. Если предикат предоставлен, он передает значение [Request] в функцию `predicate` и ждет, пока `predicate(request)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [Page.RequestFinished](/api/class-page.mdx#page-event-request-finished) будет вызвано.

**Использование**

```csharp
await Page.WaitForRequestFinishedAsync(action, options);
```

**Аргументы**
- `options` `PageRunAndWaitForRequestFinishedOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Request]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-predicate"/><a href="#page-wait-for-request-finished-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Request] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-timeout"/><a href="#page-wait-for-request-finished-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Request]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-return"/><a href="#page-wait-for-request-finished-return" class="list-anchor">#</a>

---

### RunAndWaitForResponseAsync {#page-wait-for-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.RunAndWaitForResponseAsync</x-search>

Возвращает совпавший ответ. Подробнее о событиях читайте в разделе [ожидание события](../events.mdx#waiting-for-event).

**Использование**

```csharp
// Ожидает следующего ответа с указанным URL.
await page.RunAndWaitForResponseAsync(async () =>
{
    await page.GetByText("trigger response").ClickAsync();
}, "http://example.com/resource");

// Альтернативный способ с предикатом.
await page.RunAndWaitForResponseAsync(async () =>
{
    await page.GetByText("trigger response").ClickAsync();
}, response => response.Url == "https://example.com" && response.Status == 200 && response.Request.Method == "GET");
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-action"/><a href="#page-wait-for-response-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `urlOrPredicate` [string] | [Regex] | [Func]&lt;[Response], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-url-or-predicate"/><a href="#page-wait-for-response-option-url-or-predicate" class="list-anchor">#</a>
  
  Строка URL запроса, регулярное выражение или предикат, получающий объект [Response]. Когда [BaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `PageRunAndWaitForResponseOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-timeout"/><a href="#page-wait-for-response-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-return"/><a href="#page-wait-for-response-return" class="list-anchor">#</a>

---

### WaitForResponseAsync {#page-wait-for-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.WaitForResponseAsync</x-search>

Возвращает совпавший ответ. Подробнее о событиях читайте в разделе [ожидание события](../events.mdx#waiting-for-event).

**Использование**

```csharp
// Ожидает следующего ответа с указанным URL.
await page.RunAndWaitForResponseAsync(async () =>
{
    await page.GetByText("trigger response").ClickAsync();
}, "http://example.com/resource");

// Альтернативный способ с предикатом.
await page.RunAndWaitForResponseAsync(async () =>
{
    await page.GetByText("trigger response").ClickAsync();
}, response => response.Url == "https://example.com" && response.Status == 200 && response.Request.Method == "GET");
```

**Аргументы**
- `urlOrPredicate` [string] | [Regex] | [Func]&lt;[Response], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-url-or-predicate"/><a href="#page-wait-for-response-option-url-or-predicate" class="list-anchor">#</a>
  
  Строка URL запроса, регулярное выражение или предикат, получающий объект [Response]. Когда [BaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `PageRunAndWaitForResponseOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-timeout"/><a href="#page-wait-for-response-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-return"/><a href="#page-wait-for-response-return" class="list-anchor">#</a>

---

### RunAndWaitForWebSocketAsync {#page-wait-for-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.RunAndWaitForWebSocketAsync</x-search>

Выполняет действие и ждет нового [WebSocket]. Если предикат предоставлен, он передает значение [WebSocket] в функцию `predicate` и ждет, пока `predicate(webSocket)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие WebSocket будет вызвано.

**Использование**

```csharp
await Page.RunAndWaitForWebSocketAsync(action, options);
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-action"/><a href="#page-wait-for-web-socket-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `PageRunAndWaitForWebSocketOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[WebSocket]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-predicate"/><a href="#page-wait-for-web-socket-option-predicate" class="list-anchor">#</a>
    
    Получает объект [WebSocket] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-timeout"/><a href="#page-wait-for-web-socket-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [WebSocket]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-return"/><a href="#page-wait-for-web-socket-return" class="list-anchor">#</a>

---

### WaitForWebSocketAsync {#page-wait-for-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.WaitForWebSocketAsync</x-search>

Выполняет действие и ожидает нового [WebSocket]. Если предоставлен предикат, он передает значение [WebSocket] в функцию `predicate` и ожидает, пока `predicate(webSocket)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие WebSocket будет вызвано.

**Использование**

```csharp
await Page.WaitForWebSocketAsync(action, options);
```

**Аргументы**
- `options` `PageRunAndWaitForWebSocketOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[WebSocket]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-predicate"/><a href="#page-wait-for-web-socket-option-predicate" class="list-anchor">#</a>
    
    Получает объект [WebSocket] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-timeout"/><a href="#page-wait-for-web-socket-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [WebSocket]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-return"/><a href="#page-wait-for-web-socket-return" class="list-anchor">#</a>

---

### RunAndWaitForWorkerAsync {#page-wait-for-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.RunAndWaitForWorkerAsync</x-search>

Выполняет действие и ожидает нового [Worker]. Если предоставлен предикат, он передает значение [Worker] в функцию `predicate` и ожидает, пока `predicate(worker)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие worker будет вызвано.

**Использование**

```csharp
await Page.RunAndWaitForWorkerAsync(action, options);
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-action"/><a href="#page-wait-for-worker-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `PageRunAndWaitForWorkerOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Worker]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-predicate"/><a href="#page-wait-for-worker-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Worker] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-timeout"/><a href="#page-wait-for-worker-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Worker]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-return"/><a href="#page-wait-for-worker-return" class="list-anchor">#</a>

---

### WaitForWorkerAsync {#page-wait-for-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.WaitForWorkerAsync</x-search>

Выполняет действие и ожидает нового [Worker]. Если предоставлен предикат, он передает значение [Worker] в функцию `predicate` и ожидает, пока `predicate(worker)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие worker будет вызвано.

**Использование**

```csharp
await Page.WaitForWorkerAsync(action, options);
```

**Аргументы**
- `options` `PageRunAndWaitForWorkerOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Worker]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-predicate"/><a href="#page-wait-for-worker-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Worker] и разрешает в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-timeout"/><a href="#page-wait-for-worker-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Worker]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-return"/><a href="#page-wait-for-worker-return" class="list-anchor">#</a>

---

### ScreenshotAsync {#page-screenshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.ScreenshotAsync</x-search>

Возвращает буфер с захваченным скриншотом.

**Использование**

```csharp
await Page.ScreenshotAsync(options);
```

**Аргументы**
- `options` `PageScreenshotOptions?` *(опционально)*
  - `Animations` `enum ScreenshotAnimations { Disabled, Allow }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-animations"/><a href="#page-screenshot-option-animations" class="list-anchor">#</a>
    
    При установке в `"disabled"`, останавливает CSS-анимации, CSS-переходы и веб-анимации. Анимации получают разное обращение в зависимости от их продолжительности:
    * конечные анимации быстро перематываются до завершения, чтобы они вызвали событие `transitionend`.
    * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся после скриншота.
    
    По умолчанию `"allow"`, что оставляет анимации нетронутыми.
  - `Caret` `enum ScreenshotCaret { Hide, Initial }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-caret"/><a href="#page-screenshot-option-caret" class="list-anchor">#</a>
    
    При установке в `"hide"`, скриншот скроет текстовый курсор. При установке в `"initial"`, поведение текстового курсора не будет изменено. По умолчанию `"hide"`.
  - `Clip` Clip? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-clip"/><a href="#page-screenshot-option-clip" class="list-anchor">#</a>
    - `X` [float]
      
      x-координата верхнего левого угла области обрезки
    - `Y` [float]
      
      y-координата верхнего левого угла области обрезки
    - `Width` [float]
      
      ширина области обрезки
    - `Height` [float]
      
      высота области обрезки
    
    Объект, который указывает обрезку результирующего изображения.
  - `FullPage` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-full-page"/><a href="#page-screenshot-option-full-page" class="list-anchor">#</a>
    
    Если true, делает скриншот всей прокручиваемой страницы, вместо текущего видимого окна. По умолчанию `false`.
  - `Mask` [IEnumerable]?&lt;[Locator]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask"/><a href="#page-screenshot-option-mask" class="list-anchor">#</a>
    
    Укажите локаторы, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут покрыты розовым прямоугольником `#FF00FF` (настраивается с помощью [MaskColor](/api/class-page.mdx#page-screenshot-option-mask-color)), который полностью покрывает их ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Совпадение только с видимыми элементами](../locators.mdx#matching-only-visible-elements), чтобы отключить это.
  - `MaskColor` [string]? *(опционально)* <font size="2">Добавлено в: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask-color"/><a href="#page-screenshot-option-mask-color" class="list-anchor">#</a>
    
    Укажите цвет наложения для замаскированных элементов в [формате цвета CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию - розовый `#FF00FF`.
  - `OmitBackground` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-omit-background"/><a href="#page-screenshot-option-omit-background" class="list-anchor">#</a>
    
    Скрывает белый фон по умолчанию и позволяет делать скриншоты с прозрачностью. Не применимо к изображениям `jpeg`. По умолчанию `false`.
  - `Path` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-path"/><a href="#page-screenshot-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения изображения. Тип скриншота будет определен по расширению файла. Если [Path](/api/class-page.mdx#page-screenshot-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, изображение не будет сохранено на диск.
  - `Quality` [int]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-quality"/><a href="#page-screenshot-option-quality" class="list-anchor">#</a>
    
    Качество изображения, от 0 до 100. Не применимо к изображениям `png`.
  - `Scale` `enum ScreenshotScale { Css, Device }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-scale"/><a href="#page-screenshot-option-scale" class="list-anchor">#</a>
    
    При установке в `"css"`, скриншот будет иметь один пиксель на каждый css пиксель на странице. Для устройств с высоким разрешением это позволит уменьшить размер скриншотов. Использование опции `"device"` создаст один пиксель на каждый пиксель устройства, так что скриншоты устройств с высоким разрешением будут в два раза больше или даже больше.
    
    По умолчанию `"device"`.
  - `Style` [string]? *(опционально)* <font size="2">Добавлено в: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-style"/><a href="#page-screenshot-option-style" class="list-anchor">#</a>
    
    Текст стиля, который будет применен при создании скриншота. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создавать повторяемые скриншоты. Этот стиль проникает в Shadow DOM и применяется к внутренним фреймам.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-timeout"/><a href="#page-screenshot-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Type` `enum ScreenshotType { Png, Jpeg }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-type"/><a href="#page-screenshot-option-type" class="list-anchor">#</a>
    
    Укажите тип скриншота, по умолчанию `png`.

**Возвращает**
- [byte]&#91;&#93;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-return"/><a href="#page-screenshot-return" class="list-anchor">#</a>

---

### SetContentAsync {#page-set-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.SetContentAsync</x-search>

Этот метод внутренне вызывает [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), наследуя все его специфические характеристики и поведение.

**Использование**

```csharp
await Page.SetContentAsync(html, options);
```

**Аргументы**
- `html` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-html"/><a href="#page-set-content-option-html" class="list-anchor">#</a>
  
  HTML-разметка для назначения странице.
- `options` `PageSetContentOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-timeout"/><a href="#page-set-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-wait-until"/><a href="#page-set-content-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-return"/><a href="#page-set-content-return" class="list-anchor">#</a>

---

### SetDefaultNavigationTimeout {#page-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.SetDefaultNavigationTimeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных с ними ярлыков:
* [Page.GoBackAsync()](/api/class-page.mdx#page-go-back)
* [Page.GoForwardAsync()](/api/class-page.mdx#page-go-forward)
* [Page.GotoAsync()](/api/class-page.mdx#page-goto)
* [Page.ReloadAsync()](/api/class-page.mdx#page-reload)
* [Page.SetContentAsync()](/api/class-page.mdx#page-set-content)
* [Page.RunAndWaitForNavigationAsync()](/api/class-page.mdx#page-wait-for-navigation)
* [Page.WaitForURLAsync()](/api/class-page.mdx#page-wait-for-url)

:::note

[Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) и [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```csharp
Page.SetDefaultNavigationTimeout(timeout);
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-navigation-timeout-option-timeout"/><a href="#page-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### SetDefaultTimeout {#page-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.SetDefaultTimeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих опцию [timeout](/api/class-page.mdx#page-set-default-timeout-option-timeout).

:::note

[Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
:::

**Использование**

```csharp
Page.SetDefaultTimeout(timeout);
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-timeout-option-timeout"/><a href="#page-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### SetExtraHTTPHeadersAsync {#page-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.SetExtraHTTPHeadersAsync</x-search>

Дополнительные HTTP-заголовки будут отправлены с каждым запросом, инициированным страницей.

:::note

[Page.SetExtraHTTPHeadersAsync()](/api/class-page.mdx#page-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```csharp
await Page.SetExtraHTTPHeadersAsync(headers);
```

**Аргументы**
- `headers` [IDictionary]&lt;[string], [string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-option-headers"/><a href="#page-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP-заголовки, которые будут отправлены с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-return"/><a href="#page-set-extra-http-headers-return" class="list-anchor">#</a>

---

### SetViewportSizeAsync {#page-set-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.SetViewportSizeAsync</x-search>

В случае нескольких страниц в одном браузере каждая страница может иметь свой собственный размер окна просмотра. Однако [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) позволяет установить размер окна просмотра (и многое другое) для всех страниц в контексте сразу.

[Page.SetViewportSizeAsync()](/api/class-page.mdx#page-set-viewport-size) изменит размер страницы. Многие веб-сайты не ожидают, что телефоны изменят размер, поэтому вы должны установить размер окна просмотра перед навигацией на страницу. [Page.SetViewportSizeAsync()](/api/class-page.mdx#page-set-viewport-size) также сбросит размер `screen`, используйте [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context) с параметрами `screen` и `viewport`, если вам нужен лучший контроль над этими свойствами.

**Использование**

```csharp
var page = await browser.NewPageAsync();
await page.SetViewportSizeAsync(640, 480);
await page.GotoAsync("https://www.microsoft.com");
```

**Аргументы**
- `width` [int] <font size="2">Добавлено в: v1.10</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-option-width"/><a href="#page-set-viewport-size-option-width" class="list-anchor">#</a>
  
  Ширина страницы в пикселях.
- `height` [int] <font size="2">Добавлено в: v1.10</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-option-height"/><a href="#page-set-viewport-size-option-height" class="list-anchor">#</a>
  
  Высота страницы в пикселях.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-return"/><a href="#page-set-viewport-size-return" class="list-anchor">#</a>

---

### TitleAsync {#page-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.TitleAsync</x-search>

Возвращает заголовок страницы.

**Использование**

```csharp
await Page.TitleAsync();
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-title-return"/><a href="#page-title-return" class="list-anchor">#</a>

---

### UnrouteAsync {#page-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.UnrouteAsync</x-search>

Удаляет маршрут, созданный с помощью [Page.RouteAsync()](/api/class-page.mdx#page-route). Когда [handler](/api/class-page.mdx#page-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-page.mdx#page-unroute-option-url).

**Использование**

```csharp
await Page.UnrouteAsync(url, handler);
```

**Аргументы**
- `url` [string] | [Regex] | [Func]&lt;[string], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-url"/><a href="#page-unroute-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для сопоставления при маршрутизации.
- `handler` [Action]&lt;[Route]?&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-handler"/><a href="#page-unroute-option-handler" class="list-anchor">#</a>
  
  Опциональная функция-обработчик для маршрутизации запроса.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-return"/><a href="#page-unroute-return" class="list-anchor">#</a>

---

### UnrouteAllAsync {#page-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.41</font><x-search>page.UnrouteAllAsync</x-search>

Удаляет все маршруты, созданные с помощью [Page.RouteAsync()](/api/class-page.mdx#page-route) и [Page.RouteFromHARAsync()](/api/class-page.mdx#page-route-from-har).

**Использование**

```csharp
await Page.UnrouteAllAsync(options);
```

**Аргументы**
- `options` `PageUnrouteAllOptions?` *(опционально)*
  - `Behavior` `enum UnrouteBehavior { Wait, IgnoreErrors, Default }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-option-behavior"/><a href="#page-unroute-all-option-behavior" class="list-anchor">#</a>
    
    Указывает, следует ли ждать уже выполняющихся обработчиков и что делать, если они вызывают ошибки:
    * `'default'` - не ждать завершения текущих вызовов обработчиков (если есть), если обработчик, который был удален, вызывает ошибку, это может привести к необработанной ошибке
    * `'wait'` - ждать завершения текущих вызовов обработчиков (если есть)
    * `'ignoreErrors'` - не ждать завершения текущих вызовов обработчиков (если есть), все ошибки, вызванные обработчиками после удаления маршрута, будут тихо пойманы

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-return"/><a href="#page-unroute-all-return" class="list-anchor">#</a>

---

### Url {#page-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.Url</x-search>

**Использование**

```csharp
Page.Url
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-url-return"/><a href="#page-url-return" class="list-anchor">#</a>

---

### Video {#page-video}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.Video</x-search>

Объект видео, связанный с этой страницей.

**Использование**

```csharp
Page.Video
```

**Возвращает**
- [Video]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-video-return"/><a href="#page-video-return" class="list-anchor">#</a>

---

### ViewportSize {#page-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.ViewportSize</x-search>

**Использование**

```csharp
Page.ViewportSize
```

**Возвращает**
- ViewportSize?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-viewport-size-return"/><a href="#page-viewport-size-return" class="list-anchor">#</a>
  - `width` [int]
    
    ширина страницы в пикселях.
  - `height` [int]
    
    высота страницы в пикселях.

---

### WaitForFunctionAsync {#page-wait-for-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.WaitForFunctionAsync</x-search>

Возвращает, когда [выражение](/api/class-page.mdx#page-wait-for-function-option-expression) возвращает истинное значение. Разрешается в JSHandle истинного значения.

**Использование**

[Page.WaitForFunctionAsync()](/api/class-page.mdx#page-wait-for-function) может быть использован для наблюдения за изменением размера окна просмотра:

```csharp
using Microsoft.Playwright;
using System.Threading.Tasks;

class FrameExamples
{
  public static async Task WaitForFunction()
  {
    using var playwright = await Playwright.CreateAsync();
    await using var browser = await playwright.Webkit.LaunchAsync();
    var page = await browser.NewPageAsync();
    await page.SetViewportSizeAsync(50, 50);
    await page.MainFrame.WaitForFunctionAsync("window.innerWidth < 100");
  }
}
```

Чтобы передать аргумент в предикат функции [Page.WaitForFunctionAsync()](/api/class-page.mdx#page-wait-for-function):

```csharp
var selector = ".foo";
await page.WaitForFunctionAsync("selector => !!document.querySelector(selector)", selector);
```

**Аргументы**
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-expression"/><a href="#page-wait-for-function-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-arg"/><a href="#page-wait-for-function-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [выражение](/api/class-page.mdx#page-wait-for-function-option-expression).
- `options` `PageWaitForFunctionOptions?` *(опционально)*
  - `PollingInterval` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-polling-interval"/><a href="#page-wait-for-function-option-polling-interval" class="list-anchor">#</a>
    
    Если указано, то это интервал в миллисекундах, с которым функция будет выполняться. По умолчанию, если опция не указана, [выражение](/api/class-page.mdx#page-wait-for-function-option-expression) выполняется в `requestAnimationFrame` обратном вызове.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-timeout"/><a href="#page-wait-for-function-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-return"/><a href="#page-wait-for-function-return" class="list-anchor">#</a>

---

### WaitForLoadStateAsync {#page-wait-for-load-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.WaitForLoadStateAsync</x-search>

Возвращает, когда достигнуто требуемое состояние загрузки.

Это разрешается, когда страница достигает требуемого состояния загрузки, по умолчанию `load`. Навигация должна быть завершена, когда этот метод вызывается. Если текущий документ уже достиг требуемого состояния, разрешается немедленно.

:::note

Большую часть времени этот метод не нужен, потому что Playwright [автоматически ожидает перед каждым действием](../actionability.mdx).
:::

**Использование**

```csharp
await page.GetByRole(AriaRole.Button).ClickAsync(); // Клик вызывает навигацию.
await page.WaitForLoadStateAsync(); // Обещание разрешается после события 'load'.
```

```csharp
var popup = await page.RunAndWaitForPopupAsync(async () =>
{
    await page.GetByRole(AriaRole.Button).ClickAsync(); // клик вызывает всплывающее окно
});
// Ожидание события "DOMContentLoaded".
await popup.WaitForLoadStateAsync(LoadState.DOMContentLoaded);
Console.WriteLine(await popup.TitleAsync()); // всплывающее окно готово к использованию.
```

**Аргументы**
- `state` `enum LoadState { Load, DOMContentLoaded, NetworkIdle }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-state"/><a href="#page-wait-for-load-state-option-state" class="list-anchor">#</a>
  
  Опциональное состояние загрузки для ожидания, по умолчанию `load`. Если состояние уже достигнуто при загрузке текущего документа, метод разрешается немедленно. Может быть одним из:
  * `'load'` - ожидание, пока событие `load` не будет вызвано.
  * `'domcontentloaded'` - ожидание, пока событие `DOMContentLoaded` не будет вызвано.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** ожидание, пока не будет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
- `options` `PageWaitForLoadStateOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-timeout"/><a href="#page-wait-for-load-state-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-return"/><a href="#page-wait-for-load-state-return" class="list-anchor">#</a>

---

### WaitForURLAsync {#page-wait-for-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>page.WaitForURLAsync</x-search>

Ожидает, пока основной фрейм перейдет на указанный URL.

**Использование**

```csharp
await page.ClickAsync("a.delayed-navigation"); // нажатие на ссылку косвенно вызовет навигацию
await page.WaitForURLAsync("**/target.html");
```

**Аргументы**
- `url` [string] | [Regex] | [Func]&lt;[string], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-url"/><a href="#page-wait-for-url-option-url" class="list-anchor">#</a>
  
  Шаблон с глобами, регулярное выражение или предикат, принимающий [URL] для сопоставления во время ожидания навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
- `options` `PageWaitForURLOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-timeout"/><a href="#page-wait-for-url-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить с помощью методов [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-wait-until"/><a href="#page-wait-for-url-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-return"/><a href="#page-wait-for-url-return" class="list-anchor">#</a>

---

### Workers {#page-workers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.Workers</x-search>

Этот метод возвращает всех выделенных [WebWorkers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API), связанных со страницей.

:::note

Это не включает ServiceWorkers
:::

**Использование**

```csharp
Page.Workers
```

**Возвращает**
- [IReadOnlyList]&lt;[Worker]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-workers-return"/><a href="#page-workers-return" class="list-anchor">#</a>

---

## Свойства

### APIRequest {#page-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.16</font><x-search>page.APIRequest</x-search>

Помощник для тестирования API, связанный с этой страницей. Этот метод возвращает тот же экземпляр, что и [BrowserContext.APIRequest](/api/class-browsercontext.mdx#browser-context-request) в контексте страницы. Подробнее см. в [BrowserContext.APIRequest](/api/class-browsercontext.mdx#browser-context-request).

**Использование**

```csharp
Page.APIRequest
```

**Тип**
- [APIRequestContext]

---

### Clock {#page-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.45</font><x-search>page.Clock</x-search>

Playwright имеет возможность имитировать часы и ход времени.

**Использование**

```csharp
Page.Clock
```

**Тип**
- [Clock]

---

### Keyboard {#page-keyboard}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.Keyboard</x-search>

**Использование**

```csharp
Page.Keyboard
```

**Тип**
- [Keyboard]

---

### Mouse {#page-mouse}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.Mouse</x-search>

**Использование**

```csharp
Page.Mouse
```

**Тип**
- [Mouse]

---

### Touchscreen {#page-touchscreen}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.Touchscreen</x-search>

**Использование**

```csharp
Page.Touchscreen
```

**Тип**
- [Touchscreen]

---

## События

### event Close {#page-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Close</x-search>

Вызывается, когда страница закрывается.

**Использование**

```csharp
Page.Close += async (_, page) => {};
```

**Данные события**
- [Page]

---

### event Console {#page-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Console</x-search>

Вызывается, когда JavaScript на странице вызывает один из методов консоли, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

```csharp
page.Console += async (_, msg) =>
{
    foreach (var arg in msg.Args)
        Console.WriteLine(await arg.JsonValueAsync<object>());
};

await page.EvaluateAsync("console.log('hello', 5, { foo: 'bar' })");
```

**Данные события**
- [ConsoleMessage]

---

### event Crash {#page-event-crash}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Crash</x-search>

Вызывается, когда страница падает. Страницы браузера могут падать, если они пытаются выделить слишком много памяти. Когда страница падает, текущие и последующие операции будут вызывать исключения.

Наиболее распространенный способ справиться с падениями - поймать исключение:

```csharp
try {
  // Падение может произойти во время клика.
  await page.ClickAsync("button");
  // Или во время ожидания события.
  await page.WaitForPopup();
} catch (PlaywrightException e) {
  // Когда страница падает, сообщение об исключении содержит "crash".
}
```

**Использование**

```csharp
Page.Crash += async (_, page) => {};
```

**Данные события**
- [Page]

---

### event Dialog {#page-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Dialog</x-search>

Вызывается, когда появляется диалог JavaScript, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Слушатель **должен** либо [Dialog.AcceptAsync()](/api/class-dialog.mdx#dialog-accept), либо [Dialog.DismissAsync()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница [заморозится](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking) в ожидании диалога, и действия, такие как клик, никогда не завершатся.

**Использование**

```csharp
page.RequestFailed += (_, request) =>
{
    Console.WriteLine(request.Url + " " + request.Failure);
};
```

:::note
Когда нет слушателей [Page.Dialog](/api/class-page.mdx#page-event-dialog) или [BrowserContext.Dialog](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### event DOMContentLoaded {#page-event-dom-content-loaded}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.event DOMContentLoaded</x-search>

Вызывается, когда событие JavaScript [`DOMContentLoaded`](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded) отправляется.

**Использование**

```csharp
Page.DOMContentLoaded += async (_, page) => {};
```

**Данные события**
- [Page]

---

### event Download {#page-event-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Download</x-search>

Вызывается, когда начинается загрузка вложения. Пользователь может получить доступ к основным операциям с файлами на загруженном контенте через переданный экземпляр [Download].

**Использование**

```csharp
Page.Download += async (_, download) => {};
```

**Данные события**
- [Download]

---

### event FileChooser {#page-event-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.event FileChooser</x-search>

Вызывается, когда предполагается появление выбора файла, например, после нажатия на `<input type=file>`. Playwright может ответить на это, установив файлы ввода с помощью [FileChooser.SetFilesAsync()](/api/class-filechooser.mdx#file-chooser-set-files), которые могут быть загружены после этого.

```csharp
page.FileChooser += (_, fileChooser) =>
{
    fileChooser.SetFilesAsync(@"C:\temp\myfile.pdf");
};
```

**Использование**

```csharp
Page.FileChooser += async (_, fileChooser) => {};
```

**Данные события**
- [FileChooser]

---

### event FrameAttached {#page-event-frame-attached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.event FrameAttached</x-search>

Вызывается, когда фрейм присоединяется.

**Использование**

```csharp
Page.FrameAttached += async (_, frame) => {};
```

**Данные события**
- [Frame]

---

### event FrameDetached {#page-event-frame-detached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.event FrameDetached</x-search>

Вызывается, когда фрейм отсоединяется.

**Использование**

```csharp
Page.FrameDetached += async (_, frame) => {};
```

**Данные события**
- [Frame]

---

### event FrameNavigated {#page-event-frame-navigated}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.event FrameNavigated</x-search>

Вызывается, когда фрейм переходит на новый URL.

**Использование**

```csharp
Page.FrameNavigated += async (_, frame) => {};
```

**Данные события**
- [Frame]

---

### event Load {#page-event-load}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Load</x-search>

Вызывается, когда событие JavaScript [`load`](https://developer.mozilla.org/en-US/docs/Web/Events/load) отправляется.

**Использование**

```csharp
Page.Load += async (_, page) => {};
```

**Данные события**
- [Page]

---

### event PageError {#page-event-page-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.event PageError</x-search>

Вызывается, когда на странице происходит необработанное исключение.

```csharp
// Записывать все необработанные ошибки в терминал
page.PageError += (_, exception) =>
{
  Console.WriteLine("Необработанное исключение: " + exception);
};
```

**Использование**

```csharp
Page.PageError += async (_, value) => {};
```

**Данные события**
- [string]

---

### event Popup {#page-event-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Popup</x-search>

Вызывается, когда страница открывает новую вкладку или окно. Это событие вызывается в дополнение к [BrowserContext.Page](/api/class-browsercontext.mdx#browser-context-event-page), но только для всплывающих окон, относящихся к этой странице.

Самый ранний момент, когда страница доступна, это когда она перешла на начальный URL. Например, при открытии всплывающего окна с `window.open('http://example.com')`, это событие будет вызвано, когда сетевой запрос к "http://example.com" будет выполнен и его ответ начнет загружаться во всплывающем окне. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) и [BrowserContext.Request](/api/class-browsercontext.mdx#browser-context-event-request) соответственно, вместо аналогичных методов на [Page].

```csharp
var popup = await page.RunAndWaitForPopupAsync(async () =>
{
    await page.GetByText("open the popup").ClickAsync();
});
Console.WriteLine(await popup.EvaluateAsync<string>("location.href"));
```

:::note
Используйте [Page.WaitForLoadStateAsync()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев это не потребуется).
:::

**Использование**

```csharp
Page.Popup += async (_, page) => {};
```

**Данные события**
- [Page]

---

### event Request {#page-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Request</x-search>

Вызывается, когда страница отправляет запрос. Объект [request] доступен только для чтения. Чтобы перехватывать и изменять запросы, см. [Page.RouteAsync()](/api/class-page.mdx#page-route) или [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route).

**Использование**

```csharp
Page.Request += async (_, request) => {};
```

**Данные события**
- [Request]

---

### event RequestFailed {#page-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.event RequestFailed</x-search>

Вызывается, когда запрос не удается, например, из-за истечения времени ожидания.

:::note

Ответы с ошибками HTTP, такие как 404 или 503, все еще считаются успешными ответами с точки зрения HTTP, поэтому запрос завершится событием [Page.RequestFinished](/api/class-page.mdx#page-event-request-finished), а не [Page.RequestFailed](/api/class-page.mdx#page-event-request-failed). Запрос будет считаться неудачным только в том случае, если клиент не может получить HTTP-ответ от сервера, например, из-за сетевой ошибки net::ERR_FAILED.
:::

**Использование**

```csharp
Page.RequestFailed += async (_, request) => {};
```

**Данные события**
- [Request]

---

### event RequestFinished {#page-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.event RequestFinished</x-search>

Вызывается, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```csharp
Page.RequestFinished += async (_, request) => {};
```

**Данные события**
- [Request]

---

### event Response {#page-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Response</x-search>

Вызывается, когда [response] статус и заголовки получены для запроса. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```csharp
Page.Response += async (_, response) => {};
```

**Данные события**
- [Response]

---

### event WebSocket {#page-event-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.event WebSocket</x-search>

Вызывается, когда отправляется запрос [WebSocket].

**Использование**

```csharp
Page.WebSocket += async (_, webSocket) => {};
```

**Данные события**
- [WebSocket]

---

### event Worker {#page-event-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.event Worker</x-search>

Вызывается, когда выделенный [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) запускается страницей.

**Использование**

```csharp
Page.Worker += async (_, worker) => {};
```

**Данные события**
- [Worker]

---

## Устаревшие

### CheckAsync {#page-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.CheckAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.CheckAsync()](/api/class-locator.mdx#locator-check) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод проверяет элемент, соответствующий [селектору](/api/class-page.mdx#page-check-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-check-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже отмечен, этот метод возвращает управление немедленно.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если только не установлена опция [Force](/api/class-page.mdx#page-check-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для нажатия в центре элемента.
1. Убедитесь, что элемент теперь отмечен. Если нет, этот метод выбрасывает исключение.

Если все шаги не завершены в течение указанного [времени ожидания](/api/class-page.mdx#page-check-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого времени ожидания отключает это.

**Использование**

```csharp
await Page.CheckAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-selector"/><a href="#page-check-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageCheckOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-force"/><a href="#page-check-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-no-wait-after"/><a href="#page-check-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-position"/><a href="#page-check-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-strict"/><a href="#page-check-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-timeout"/><a href="#page-check-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-trial"/><a href="#page-check-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию, без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-return"/><a href="#page-check-return" class="list-anchor">#</a>

---

### ClickAsync {#page-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.ClickAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.ClickAsync()](/api/class-locator.mdx#locator-click) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод кликает по элементу, соответствующему [селектору](/api/class-page.mdx#page-click-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-click-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если только не установлена опция [Force](/api/class-page.mdx#page-click-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для нажатия в центре элемента или в указанной [позиции](/api/class-page.mdx#page-click-option-position).
1. Подождите, пока инициированные навигации не завершатся успешно или не завершатся с ошибкой, если только не установлена опция [NoWaitAfter](/api/class-page.mdx#page-click-option-no-wait-after).

Если все шаги не завершены в течение указанного [времени ожидания](/api/class-page.mdx#page-click-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого времени ожидания отключает это.

**Использование**

```csharp
await Page.ClickAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-selector"/><a href="#page-click-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageClickOptions?` *(опционально)*
  - `Button` `enum MouseButton { Left, Right, Middle }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-button"/><a href="#page-click-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `ClickCount` [int]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-click-count"/><a href="#page-click-option-click-count" class="list-anchor">#</a>
    
    По умолчанию 1. См. [UIEvent.detail].
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-delay"/><a href="#page-click-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-force"/><a href="#page-click-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-modifiers"/><a href="#page-click-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-no-wait-after"/><a href="#page-click-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция по умолчанию будет `true` в будущем.
    :::
    
    Действия, инициирующие навигации, ожидают, пока эти навигации не произойдут и страницы не начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится эта опция только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-position"/><a href="#page-click-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-strict"/><a href="#page-click-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-timeout"/><a href="#page-click-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-trial"/><a href="#page-click-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию, без его выполнения. Обратите внимание, что клавиатурные `модификаторы` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-return"/><a href="#page-click-return" class="list-anchor">#</a>

---

### DblClickAsync {#page-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.DblClickAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.DblClickAsync()](/api/class-locator.mdx#locator-dblclick) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет двойной клик по элементу, соответствующему [селектору](/api/class-page.mdx#page-dblclick-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-dblclick-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если только не установлена опция [Force](/api/class-page.mdx#page-dblclick-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для двойного клика в центре элемента или в указанной [позиции](/api/class-page.mdx#page-dblclick-option-position).

Если все шаги не завершены в течение указанного [времени ожидания](/api/class-page.mdx#page-dblclick-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого времени ожидания отключает это.

:::note

`page.dblclick()` генерирует два события `click` и одно событие `dblclick`.
:::

**Использование**

```csharp
await Page.DblClickAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-selector"/><a href="#page-dblclick-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageDblClickOptions?` *(опционально)*
  - `Button` `enum MouseButton { Left, Right, Middle }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-button"/><a href="#page-dblclick-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-delay"/><a href="#page-dblclick-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-force"/><a href="#page-dblclick-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-modifiers"/><a href="#page-dblclick-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-no-wait-after"/><a href="#page-dblclick-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-position"/><a href="#page-dblclick-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-strict"/><a href="#page-dblclick-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-timeout"/><a href="#page-dblclick-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-trial"/><a href="#page-dblclick-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию, без его выполнения. Обратите внимание, что клавиатурные `модификаторы` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-return"/><a href="#page-dblclick-return" class="list-anchor">#</a>

---

### DispatchEventAsync {#page-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.DispatchEventAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.DispatchEventAsync()](/api/class-locator.mdx#locator-dispatch-event) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Пример ниже отправляет событие `click` на элемент. Независимо от состояния видимости элемента, `click` отправляется. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Использование**

```csharp
await page.DispatchEventAsync("button#submit", "click");
```

Внутри создается экземпляр события на основе указанного [типа](/api/class-page.mdx#page-dispatch-event-option-type), инициализируется с помощью свойств [eventInit](/api/class-page.mdx#page-dispatch-event-option-event-init) и отправляется на элемент. События по умолчанию `composed`, `cancelable` и всплывают.

Поскольку [eventInit](/api/class-page.mdx#page-dispatch-event-option-event-init) является специфичным для события, пожалуйста, обратитесь к документации по событиям для списков начальных свойств:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Вы также можете указать `JSHandle` в качестве значения свойства, если хотите, чтобы живые объекты передавались в событие:

```csharp
var dataTransfer = await page.EvaluateHandleAsync("() => new DataTransfer()");
await page.DispatchEventAsync("#source", "dragstart", new { dataTransfer });
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-selector"/><a href="#page-dispatch-event-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `type` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-type"/><a href="#page-dispatch-event-option-type" class="list-anchor">#</a>
  
  Тип DOM-события: `"click"`, `"dragstart"` и т.д.
- `eventInit` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-event-init"/><a href="#page-dispatch-event-option-event-init" class="list-anchor">#</a>
  
  Опциональные свойства инициализации, специфичные для события.
- `options` `PageDispatchEventOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-strict"/><a href="#page-dispatch-event-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-timeout"/><a href="#page-dispatch-event-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-return"/><a href="#page-dispatch-event-return" class="list-anchor">#</a>

---

### EvalOnSelectorAsync {#page-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.EvalOnSelectorAsync</x-search>

:::warning[Не рекомендуется]

Этот метод не ожидает, пока элемент пройдет проверки действительности, и поэтому может привести к нестабильным тестам. Используйте [Locator.EvaluateAsync()](/api/class-locator.mdx#locator-evaluate), другие вспомогательные методы [Locator] или утверждения с приоритетом на веб вместо этого.

:::

Метод находит элемент, соответствующий указанному селектору на странице, и передает его в качестве первого аргумента в [выражение](/api/class-page.mdx#page-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выбрасывает ошибку. Возвращает значение [выражения](/api/class-page.mdx#page-eval-on-selector-option-expression).

Если [выражение](/api/class-page.mdx#page-eval-on-selector-option-expression) возвращает [Promise], то [Page.EvalOnSelectorAsync()](/api/class-page.mdx#page-eval-on-selector) будет ждать разрешения промиса и вернет его значение.

**Использование**

```csharp
var searchValue = await page.EvalOnSelectorAsync<string>("#search", "el => el.value");
var preloadHref = await page.EvalOnSelectorAsync<string>("link[rel=preload]", "el => el.href");
var html = await page.EvalOnSelectorAsync(".main-container", "(e, suffix) => e.outerHTML + suffix", "hello");
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-selector"/><a href="#page-eval-on-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-expression"/><a href="#page-eval-on-selector-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-arg"/><a href="#page-eval-on-selector-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [выражение](/api/class-page.mdx#page-eval-on-selector-option-expression).
- `options` `PageEvalOnSelectorOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-strict"/><a href="#page-eval-on-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Возвращает**
- [object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-return"/><a href="#page-eval-on-selector-return" class="list-anchor">#</a>

---

### EvalOnSelectorAllAsync {#page-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.EvalOnSelectorAllAsync</x-search>

:::warning[Не рекомендуется]

В большинстве случаев [Locator.EvaluateAllAsync()](/api/class-locator.mdx#locator-evaluate-all), другие вспомогательные методы [Locator] и утверждения с приоритетом на веб выполняют работу лучше.

:::

Метод находит все элементы, соответствующие указанному селектору на странице, и передает массив найденных элементов в качестве первого аргумента в [выражение](/api/class-page.mdx#page-eval-on-selector-all-option-expression). Возвращает результат вызова [выражения](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

Если [выражение](/api/class-page.mdx#page-eval-on-selector-all-option-expression) возвращает [Promise], то [Page.EvalOnSelectorAllAsync()](/api/class-page.mdx#page-eval-on-selector-all) будет ждать разрешения промиса и вернет его значение.

**Использование**

```csharp
var divsCount = await page.EvalOnSelectorAllAsync<bool>("div", "(divs, min) => divs.length >= min", 10);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-selector"/><a href="#page-eval-on-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-expression"/><a href="#page-eval-on-selector-all-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-arg"/><a href="#page-eval-on-selector-all-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [выражение](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

**Возвращает**
- [object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-return"/><a href="#page-eval-on-selector-all-return" class="list-anchor">#</a>

---

### FillAsync {#page-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.FillAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.FillAsync()](/api/class-locator.mdx#locator-fill) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [селектору](/api/class-page.mdx#page-fill-option-selector), ожидает проверки [действительности](../actionability.mdx), фокусирует элемент, заполняет его и вызывает событие `input` после заполнения. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является `<input>`, `<textarea>` или `[contenteditable]` элементом, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [контроль](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен контроль.

Для отправки более детализированных событий клавиатуры используйте [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially).

**Использование**

```csharp
await Page.FillAsync(selector, value, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-selector"/><a href="#page-fill-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `value` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-value"/><a href="#page-fill-option-value" class="list-anchor">#</a>
  
  Значение для заполнения элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `options` `PageFillOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-force"/><a href="#page-fill-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-no-wait-after"/><a href="#page-fill-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-strict"/><a href="#page-fill-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-timeout"/><a href="#page-fill-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-return"/><a href="#page-fill-return" class="list-anchor">#</a>

---

### FocusAsync {#page-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.FocusAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.FocusAsync()](/api/class-locator.mdx#locator-focus) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод получает элемент с [селектором](/api/class-page.mdx#page-focus-option-selector) и фокусирует его. Если нет элемента, соответствующего [селектору](/api/class-page.mdx#page-focus-option-selector), метод ждет, пока соответствующий элемент не появится в DOM.

**Использование**

```csharp
await Page.FocusAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-selector"/><a href="#page-focus-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageFocusOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-strict"/><a href="#page-focus-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-timeout"/><a href="#page-focus-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-return"/><a href="#page-focus-return" class="list-anchor">#</a>

---

### GetAttributeAsync {#page-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.GetAttributeAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.GetAttributeAsync()](/api/class-locator.mdx#locator-get-attribute) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает значение атрибута элемента.

**Использование**

```csharp
await Page.GetAttributeAsync(selector, name, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-selector"/><a href="#page-get-attribute-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-name"/><a href="#page-get-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута, значение которого нужно получить.
- `options` `PageGetAttributeOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-strict"/><a href="#page-get-attribute-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-timeout"/><a href="#page-get-attribute-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-return"/><a href="#page-get-attribute-return" class="list-anchor">#</a>

---

### HoverAsync {#page-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.HoverAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.HoverAsync()](/api/class-locator.mdx#locator-hover) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод наводит курсор на элемент, соответствующий [селектору](/api/class-page.mdx#page-hover-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-hover-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если только не установлена опция [Force](/api/class-page.mdx#page-hover-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для наведения курсора на центр элемента или на указанную [позицию](/api/class-page.mdx#page-hover-option-position).

Если все шаги не завершены в течение указанного [времени ожидания](/api/class-page.mdx#page-hover-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого времени ожидания отключает это.

**Использование**

```csharp
await Page.HoverAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-selector"/><a href="#page-hover-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageHoverOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-force"/><a href="#page-hover-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-modifiers"/><a href="#page-hover-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-no-wait-after"/><a href="#page-hover-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-position"/><a href="#page-hover-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-strict"/><a href="#page-hover-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-timeout"/><a href="#page-hover-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-trial"/><a href="#page-hover-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию, без его выполнения. Обратите внимание, что клавиатурные `модификаторы` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-return"/><a href="#page-hover-return" class="list-anchor">#</a>

---

### InnerHTMLAsync {#page-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.InnerHTMLAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.InnerHTMLAsync()](/api/class-locator.mdx#locator-inner-html) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerHTML`.

**Использование**

```csharp
await Page.InnerHTMLAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-selector"/><a href="#page-inner-html-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageInnerHTMLOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-strict"/><a href="#page-inner-html-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-timeout"/><a href="#page-inner-html-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-return"/><a href="#page-inner-html-return" class="list-anchor">#</a>

---

### InnerTextAsync {#page-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.InnerTextAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.InnerTextAsync()](/api/class-locator.mdx#locator-inner-text) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerText`.

**Использование**

```csharp
await Page.InnerTextAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-selector"/><a href="#page-inner-text-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageInnerTextOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-strict"/><a href="#page-inner-text-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-timeout"/><a href="#page-inner-text-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-return"/><a href="#page-inner-text-return" class="list-anchor">#</a>

---

### InputValueAsync {#page-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>page.InputValueAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.InputValueAsync()](/api/class-locator.mdx#locator-input-value) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Выбрасывает исключение для не-input элементов. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращает значение контрола.

**Использование**

```csharp
await Page.InputValueAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-selector"/><a href="#page-input-value-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageInputValueOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-strict"/><a href="#page-input-value-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-timeout"/><a href="#page-input-value-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-return"/><a href="#page-input-value-return" class="list-anchor">#</a>

---

### IsCheckedAsync {#page-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.IsCheckedAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsCheckedAsync()](/api/class-locator.mdx#locator-is-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отмечен ли элемент. Выбрасывает исключение, если элемент не является чекбоксом или радио-кнопкой.

**Использование**

```csharp
await Page.IsCheckedAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-selector"/><a href="#page-is-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageIsCheckedOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-strict"/><a href="#page-is-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-timeout"/><a href="#page-is-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-return"/><a href="#page-is-checked-return" class="list-anchor">#</a>

---

### IsDisabledAsync {#page-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.IsDisabledAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsDisabledAsync()](/api/class-locator.mdx#locator-is-disabled) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отключен ли элемент, противоположность [enabled](../actionability.mdx#enabled).

**Использование**

```csharp
await Page.IsDisabledAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-selector"/><a href="#page-is-disabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageIsDisabledOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-strict"/><a href="#page-is-disabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-timeout"/><a href="#page-is-disabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-return"/><a href="#page-is-disabled-return" class="list-anchor">#</a>

---

### IsEditableAsync {#page-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.IsEditableAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsEditableAsync()](/api/class-locator.mdx#locator-is-editable) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Использование**

```csharp
await Page.IsEditableAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-selector"/><a href="#page-is-editable-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageIsEditableOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-strict"/><a href="#page-is-editable-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-timeout"/><a href="#page-is-editable-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-return"/><a href="#page-is-editable-return" class="list-anchor">#</a>

---

### IsEnabledAsync {#page-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.IsEnabledAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsEnabledAsync()](/api/class-locator.mdx#locator-is-enabled) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [включенным](../actionability.mdx#enabled).

**Использование**

```csharp
await Page.IsEnabledAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-selector"/><a href="#page-is-enabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageIsEnabledOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-strict"/><a href="#page-is-enabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-timeout"/><a href="#page-is-enabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-return"/><a href="#page-is-enabled-return" class="list-anchor">#</a>

---

### IsHiddenAsync {#page-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.IsHiddenAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsHiddenAsync()](/api/class-locator.mdx#locator-is-hidden) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, скрыт ли элемент, противоположность [visible](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-hidden-option-selector), который не соответствует ни одному элементу, считается скрытым.

**Использование**

```csharp
await Page.IsHiddenAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-selector"/><a href="#page-is-hidden-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageIsHiddenOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-strict"/><a href="#page-is-hidden-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-timeout"/><a href="#page-is-hidden-option-timeout" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция игнорируется. [Page.IsHiddenAsync()](/api/class-page.mdx#page-is-hidden) не ждет, пока элемент станет скрытым, и возвращает результат немедленно.
    :::

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-return"/><a href="#page-is-hidden-return" class="list-anchor">#</a>

---

### IsVisibleAsync {#page-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.IsVisibleAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsVisibleAsync()](/api/class-locator.mdx#locator-is-visible) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [видимым](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-visible-option-selector), который не соответствует ни одному элементу, считается невидимым.

**Использование**

```csharp
await Page.IsVisibleAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-selector"/><a href="#page-is-visible-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageIsVisibleOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-strict"/><a href="#page-is-visible-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-timeout"/><a href="#page-is-visible-option-timeout" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция игнорируется. [Page.IsVisibleAsync()](/api/class-page.mdx#page-is-visible) не ждет, пока элемент станет видимым, и возвращает результат немедленно.
    :::

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-return"/><a href="#page-is-visible-return" class="list-anchor">#</a>

---

### PressAsync {#page-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.PressAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.PressAsync()](/api/class-locator.mdx#locator-press) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Фокусируется на элементе, а затем использует [Keyboard.DownAsync()](/api/class-keyboard.mdx#keyboard-down) и [Keyboard.UpAsync()](/api/class-keyboard.mdx#keyboard-up).

[key](/api/class-page.mdx#page-press-option-key) может указывать предполагаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или один символ для генерации текста. Надмножество значений [key](/api/class-page.mdx#page-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры клавиш:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются следующие модификационные сочетания: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`. `ControlOrMeta` разрешается в `Control` на Windows и Linux и в `Meta` на macOS.

Удержание `Shift` будет вводить текст, соответствующий [key](/api/class-page.mdx#page-press-option-key) в верхнем регистре.

Если [key](/api/class-page.mdx#page-press-option-key) является одним символом, он чувствителен к регистру, поэтому значения `a` и `A` будут генерировать разные тексты.

Также поддерживаются сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++` или `key: "Control+Shift+T"`. При указании с модификатором, модификатор нажимается и удерживается, пока не будет нажата последующая клавиша.

**Использование**

```csharp
var page = await browser.NewPageAsync();
await page.GotoAsync("https://keycode.info");
await page.PressAsync("body", "A");
await page.ScreenshotAsync(new() { Path = "A.png" });
await page.PressAsync("body", "ArrowLeft");
await page.ScreenshotAsync(new() { Path = "ArrowLeft.png" });
await page.PressAsync("body", "Shift+O");
await page.ScreenshotAsync(new() { Path = "O.png" });
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-selector"/><a href="#page-press-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `key` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-key"/><a href="#page-press-option-key" class="list-anchor">#</a>
  
  Имя клавиши для нажатия или символ для генерации, например, `ArrowLeft` или `a`.
- `options` `PagePressOptions?` *(опционально)*
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-delay"/><a href="#page-press-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `keydown` и `keyup` в миллисекундах. По умолчанию 0.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-no-wait-after"/><a href="#page-press-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция по умолчанию будет `true` в будущем.
    :::
    
    Действия, инициирующие навигацию, ожидают, пока эти навигации произойдут и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится эта опция только в исключительных случаях, таких как навигация к недоступным страницам. По умолчанию `false`.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-strict"/><a href="#page-press-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-timeout"/><a href="#page-press-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-return"/><a href="#page-press-return" class="list-anchor">#</a>

---

### QuerySelectorAsync {#page-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.QuerySelectorAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Page.Locator()](/api/class-page.mdx#page-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Метод находит элемент, соответствующий указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение разрешается в `null`. Чтобы дождаться элемента на странице, используйте [Locator.WaitForAsync()](/api/class-locator.mdx#locator-wait-for).

**Использование**

```csharp
await Page.QuerySelectorAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-selector"/><a href="#page-query-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` `PageQuerySelectorOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-strict"/><a href="#page-query-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Возвращает**
- [ElementHandle]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-return"/><a href="#page-query-selector-return" class="list-anchor">#</a>

---

### QuerySelectorAllAsync {#page-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>page.QuerySelectorAllAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Page.Locator()](/api/class-page.mdx#page-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Метод находит все элементы, соответствующие указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение разрешается в `[]`.

**Использование**

```csharp
await Page.QuerySelectorAllAsync(selector);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-option-selector"/><a href="#page-query-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.

**Возвращает**
- [IReadOnlyList]&lt;[ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-return"/><a href="#page-query-selector-all-return" class="list-anchor">#</a>

---

### RunAndWaitForNavigationAsync {#page-wait-for-navigation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.RunAndWaitForNavigationAsync</x-search>

:::warning Устарело

Этот метод по своей природе является гонкой, пожалуйста, используйте [Page.WaitForURLAsync()](/api/class-page.mdx#page-wait-for-url) вместо этого.

:::

Ожидает навигации основного фрейма и возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация разрешится с ответом последнего перенаправления. В случае навигации к другому якорю или навигации из-за использования History API, навигация разрешится с `null`.

**Использование**

Это разрешается, когда страница переходит на новый URL или перезагружается. Это полезно, когда вы выполняете код, который косвенно вызывает навигацию страницы. Например, цель клика имеет обработчик `onclick`, который вызывает навигацию из `setTimeout`. Рассмотрим этот пример:

```csharp
await page.RunAndWaitForNavigationAsync(async () =>
{
    // Это действие вызывает навигацию после тайм-аута.
    await page.GetByText("Navigate after timeout").ClickAsync();
});

// Метод продолжается после завершения навигации
```

:::note
Использование [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) для изменения URL считается навигацией.
:::

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-action"/><a href="#page-wait-for-navigation-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `PageRunAndWaitForNavigationOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-timeout"/><a href="#page-wait-for-navigation-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Url|UrlRegex|UrlFunc` [string]? | [Regex]? | [Func]&lt;[string]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-url"/><a href="#page-wait-for-navigation-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для совпадения при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-wait-until"/><a href="#page-wait-for-navigation-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Response]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-return"/><a href="#page-wait-for-navigation-return" class="list-anchor">#</a>

---

### WaitForNavigationAsync {#page-wait-for-navigation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.WaitForNavigationAsync</x-search>

:::warning Устарело

Этот метод по своей природе является гонкой, пожалуйста, используйте [Page.WaitForURLAsync()](/api/class-page.mdx#page-wait-for-url) вместо этого.

:::

Ожидает навигации основного фрейма и возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация разрешится с ответом последнего перенаправления. В случае навигации к другому якорю или навигации из-за использования History API, навигация разрешится с `null`.

**Использование**

Это разрешается, когда страница переходит на новый URL или перезагружается. Это полезно, когда вы выполняете код, который косвенно вызывает навигацию страницы. Например, цель клика имеет обработчик `onclick`, который вызывает навигацию из `setTimeout`. Рассмотрим этот пример:

```csharp
await page.RunAndWaitForNavigationAsync(async () =>
{
    // Это действие вызывает навигацию после тайм-аута.
    await page.GetByText("Navigate after timeout").ClickAsync();
});

// Метод продолжается после завершения навигации
```

:::note
Использование [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) для изменения URL считается навигацией.
:::

**Аргументы**
- `options` `PageRunAndWaitForNavigationOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-timeout"/><a href="#page-wait-for-navigation-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Url|UrlRegex|UrlFunc` [string]? | [Regex]? | [Func]&lt;[string]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-url"/><a href="#page-wait-for-navigation-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для совпадения при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-wait-until"/><a href="#page-wait-for-navigation-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Response]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-return"/><a href="#page-wait-for-navigation-return" class="list-anchor">#</a>

---

### SelectOptionAsync {#page-select-option}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.SelectOptionAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SelectOptionAsync()](/api/class-locator.mdx#locator-select-option) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [селектору](/api/class-page.mdx#page-select-option-option-selector), выполняет проверки [действительности](../actionability.mdx), ожидает, пока все указанные опции не будут присутствовать в элементе `<select>`, и выбирает эти опции.

Если целевой элемент не является элементом `<select>`, этот метод вызывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контрол.

Возвращает массив значений опций, которые были успешно выбраны.

Вызывает события `change` и `input`, как только все предоставленные опции были выбраны.

**Использование**

```csharp
// Одиночный выбор, соответствующий значению или метке
await page.SelectOptionAsync("select#colors", new[] { "blue" });
// одиночный выбор, соответствующий как значению, так и метке
await page.SelectOptionAsync("select#colors", new[] { new SelectOptionValue() { Label = "blue" } });
// множественный выбор
await page.SelectOptionAsync("select#colors", new[] { "red", "green", "blue" });
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-selector"/><a href="#page-select-option-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `values` [string] | [ElementHandle] | [IEnumerable] | `SelectOption` | [IEnumerable] | [IEnumerable]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-values"/><a href="#page-select-option-option-values" class="list-anchor">#</a>
  - `Value` [string]? *(опционально)*
    
    Соответствует `option.value`. Опционально.
  - `Label` [string]? *(опционально)*
    
    Соответствует `option.label`. Опционально.
  - `Index` [int]? *(опционально)*
    
    Соответствует индексу. Опционально.
  
  Опции для выбора. Если у `<select>` есть атрибут `multiple`, все соответствующие опции выбираются, в противном случае выбирается только первая опция, соответствующая одной из переданных опций. Строковые значения соответствуют как значениям, так и меткам. Опция считается соответствующей, если все указанные свойства совпадают.
- `options` `PageSelectOptionOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-force"/><a href="#page-select-option-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-no-wait-after"/><a href="#page-select-option-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-strict"/><a href="#page-select-option-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-timeout"/><a href="#page-select-option-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [IReadOnlyList]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-return"/><a href="#page-select-option-return" class="list-anchor">#</a>

---

### SetCheckedAsync {#page-set-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.15</font><x-search>page.SetCheckedAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SetCheckedAsync()](/api/class-locator.mdx#locator-set-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод отмечает или снимает отметку с элемента, соответствующего [селектору](/api/class-page.mdx#page-set-checked-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-set-checked-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку.
1. Если элемент уже имеет правильное состояние отметки, этот метод возвращается немедленно.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если не установлена опция [Force](/api/class-page.mdx#page-set-checked-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента.
1. Убедитесь, что элемент теперь отмечен или снят. Если нет, этот метод вызывает ошибку.

Когда все шаги в совокупности не завершены в течение указанного [Timeout](/api/class-page.mdx#page-set-checked-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```csharp
await Page.SetCheckedAsync(selector, checked, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-selector"/><a href="#page-set-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `checkedState` [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-checked"/><a href="#page-set-checked-option-checked" class="list-anchor">#</a>
  
  Нужно ли отметить или снять отметку с флажка.
- `options` `PageSetCheckedOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-force"/><a href="#page-set-checked-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-no-wait-after"/><a href="#page-set-checked-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-position"/><a href="#page-set-checked-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла области отступов элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-strict"/><a href="#page-set-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-timeout"/><a href="#page-set-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-return"/><a href="#page-set-checked-return" class="list-anchor">#</a>

---

### SetInputFilesAsync {#page-set-input-files}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.SetInputFilesAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SetInputFilesAsync()](/api/class-locator.mdx#locator-set-input-files) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Устанавливает значение элемента ввода файла в указанные пути к файлам или файлы. Если некоторые из `filePaths` являются относительными путями, они разрешаются относительно текущей рабочей директории. Для пустого массива очищает выбранные файлы. Для входных данных с атрибутом `[webkitdirectory]` поддерживается только один путь к директории.

Этот метод ожидает, что [селектор](/api/class-page.mdx#page-set-input-files-option-selector) указывает на [элемент ввода](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контрол.

**Использование**

```csharp
await Page.SetInputFilesAsync(selector, files, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-selector"/><a href="#page-set-input-files-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `files` [string] | [IEnumerable]&lt;[string]&gt; | `FilePayload` | [IEnumerable]&lt;`FilePayload`&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-files"/><a href="#page-set-input-files-option-files" class="list-anchor">#</a>
  - `Name` [string]
    
    Имя файла
  - `MimeType` [string]
    
    Тип файла
  - `Buffer` [byte]&#91;&#93;
    
    Содержимое файла
- `options` `PageSetInputFilesOptions?` *(опционально)*
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-no-wait-after"/><a href="#page-set-input-files-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-strict"/><a href="#page-set-input-files-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-timeout"/><a href="#page-set-input-files-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-return"/><a href="#page-set-input-files-return" class="list-anchor">#</a>

---

### TapAsync {#page-tap}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.TapAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.TapAsync()](/api/class-locator.mdx#locator-tap) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет нажатие на элемент, соответствующий [селектору](/api/class-page.mdx#page-tap-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-tap-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если не установлена опция [Force](/api/class-page.mdx#page-tap-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Touchscreen](/api/class-page.mdx#page-touchscreen), чтобы нажать в центре элемента или в указанной [позиции](/api/class-page.mdx#page-tap-option-position).

Когда все шаги в совокупности не завершены в течение указанного [Timeout](/api/class-page.mdx#page-tap-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

Метод [Page.TapAsync()](/api/class-page.mdx#page-tap) вызовет ошибку, если опция [HasTouch](/api/class-browser.mdx#browser-new-context-option-has-touch) контекста браузера равна false.
:::

**Использование**

```csharp
await Page.TapAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-selector"/><a href="#page-tap-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageTapOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-force"/><a href="#page-tap-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-modifiers"/><a href="#page-tap-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-no-wait-after"/><a href="#page-tap-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-position"/><a href="#page-tap-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла области отступов элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-strict"/><a href="#page-tap-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-timeout"/><a href="#page-tap-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-trial"/><a href="#page-tap-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `модификаторы` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-return"/><a href="#page-tap-return" class="list-anchor">#</a>

---

### TextContentAsync {#page-text-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.TextContentAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.TextContentAsync()](/api/class-locator.mdx#locator-text-content) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.textContent`.

**Использование**

```csharp
await Page.TextContentAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-selector"/><a href="#page-text-content-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageTextContentOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-strict"/><a href="#page-text-content-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-timeout"/><a href="#page-text-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-return"/><a href="#page-text-content-return" class="list-anchor">#</a>

---

### TypeAsync {#page-type}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.TypeAsync</x-search>

:::warning Устарело

В большинстве случаев следует использовать [Locator.FillAsync()](/api/class-locator.mdx#locator-fill) вместо этого. Вам нужно нажимать клавиши по одной, только если на странице есть специальная обработка клавиатуры - в этом случае используйте [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially).

:::

Отправляет события `keydown`, `keypress`/`input` и `keyup` для каждого символа в тексте. `page.type` можно использовать для отправки детализированных событий клавиатуры. Для заполнения значений в полях формы используйте [Page.FillAsync()](/api/class-page.mdx#page-fill).

Чтобы нажать специальную клавишу, такую как `Control` или `ArrowDown`, используйте [Keyboard.PressAsync()](/api/class-keyboard.mdx#keyboard-press).

**Использование**

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-selector"/><a href="#page-type-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `text` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-text"/><a href="#page-type-option-text" class="list-anchor">#</a>
  
  Текст для ввода в фокусированный элемент.
- `options` `PageTypeOptions?` *(опционально)*
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-delay"/><a href="#page-type-option-delay" class="list-anchor">#</a>
    
    Время ожидания между нажатиями клавиш в миллисекундах. По умолчанию 0.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-no-wait-after"/><a href="#page-type-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-strict"/><a href="#page-type-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-timeout"/><a href="#page-type-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-return"/><a href="#page-type-return" class="list-anchor">#</a>

---

### UncheckAsync {#page-uncheck}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.UncheckAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.UncheckAsync()](/api/class-locator.mdx#locator-uncheck) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод снимает отметку с элемента, соответствующего [селектору](/api/class-page.mdx#page-uncheck-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-page.mdx#page-uncheck-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку. Если элемент уже снят, этот метод возвращается немедленно.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если не установлена опция [Force](/api/class-page.mdx#page-uncheck-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента.
1. Убедитесь, что элемент теперь снят. Если нет, этот метод вызывает ошибку.

Когда все шаги в совокупности не завершены в течение указанного [Timeout](/api/class-page.mdx#page-uncheck-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```csharp
await Page.UncheckAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-selector"/><a href="#page-uncheck-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `PageUncheckOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-force"/><a href="#page-uncheck-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-no-wait-after"/><a href="#page-uncheck-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-position"/><a href="#page-uncheck-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла области отступов элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-strict"/><a href="#page-uncheck-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-timeout"/><a href="#page-uncheck-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-trial"/><a href="#page-uncheck-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-return"/><a href="#page-uncheck-return" class="list-anchor">#</a>

---

### WaitForSelectorAsync {#page-wait-for-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.WaitForSelectorAsync</x-search>

:::warning[Не рекомендуется]

Используйте веб-утверждения, которые утверждают видимость, или основанный на локаторах метод [Locator.WaitForAsync()](/api/class-locator.mdx#locator-wait-for) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, когда элемент, указанный селектором, удовлетворяет опции [State](/api/class-page.mdx#page-wait-for-selector-option-state). Возвращает `null`, если ожидание для `hidden` или `detached`.

:::note

Playwright автоматически ожидает, пока элемент будет готов перед выполнением действия. Использование объектов [Locator] и веб-первых утверждений делает код свободным от ожидания селектора.
:::

Ожидает, пока [селектор](/api/class-page.mdx#page-wait-for-selector-option-selector) не удовлетворит опцию [State](/api/class-page.mdx#page-wait-for-selector-option-state) (либо появится/исчезнет из DOM, либо станет видимым/скрытым). Если в момент вызова метода [селектор](/api/class-page.mdx#page-wait-for-selector-option-selector) уже удовлетворяет условию, метод вернется немедленно. Если селектор не удовлетворяет условию в течение [Timeout](/api/class-page.mdx#page-wait-for-selector-option-timeout) миллисекунд, функция вызовет ошибку.

**Использование**

Этот метод работает через навигации:

```csharp
using Microsoft.Playwright;
using System;
using System.Threading.Tasks;

class FrameExamples
{
  public static async Task Images()
  {
      using var playwright = await Playwright.CreateAsync();
      await using var browser = await playwright.Chromium.LaunchAsync();
      var page = await browser.NewPageAsync();

      foreach (var currentUrl in new[] { "https://www.google.com", "https://bbc.com" })
      {
          await page.GotoAsync(currentUrl);
          var element = await page.WaitForSelectorAsync("img");
          Console.WriteLine($"Loaded image: {await element.GetAttributeAsync("src")}");
      }

      await browser.CloseAsync();
  }
}
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-selector"/><a href="#page-wait-for-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` `PageWaitForSelectorOptions?` *(опционально)*
  - `State` `enum WaitForSelectorState { Attached, Detached, Visible, Hidden }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-state"/><a href="#page-wait-for-selector-option-state" class="list-anchor">#</a>
    
    По умолчанию `'visible'`. Может быть:
    * `'attached'` - ожидание, пока элемент будет присутствовать в DOM.
    * `'detached'` - ожидание, пока элемент не будет присутствовать в DOM.
    * `'visible'` - ожидание, пока элемент не будет иметь пустую ограничивающую рамку и не будет `visibility:hidden`. Обратите внимание, что элемент без содержимого или с `display:none` имеет пустую ограничивающую рамку и не считается видимым.
    * `'hidden'` - ожидание, пока элемент либо не будет отсоединен от DOM, либо не будет иметь пустую ограничивающую рамку или `visibility:hidden`. Это противоположно опции `'visible'`.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-strict"/><a href="#page-wait-for-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-timeout"/><a href="#page-wait-for-selector-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [ElementHandle]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-return"/><a href="#page-wait-for-selector-return" class="list-anchor">#</a>

---

### WaitForTimeoutAsync {#page-wait-for-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>page.WaitForTimeoutAsync</x-search>

:::warning[Не рекомендуется]

Никогда не ждите тайм-аута в производственной среде. Тесты, которые ждут времени, по своей природе ненадежны. Используйте действия [Locator] и веб-утверждения, которые ждут автоматически.

:::

Ожидает указанный [тайм-аут](/api/class-page.mdx#page-wait-for-timeout-option-timeout) в миллисекундах.

Обратите внимание, что `page.waitForTimeout()` следует использовать только для отладки. Тесты, использующие таймер в производственной среде, будут ненадежными. Используйте сигналы, такие как сетевые события, селекторы, становящиеся видимыми, и другие вместо этого.

**Использование**

```csharp
// Ожидание 1 секунду
await page.WaitForTimeoutAsync(1000);
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-option-timeout"/><a href="#page-wait-for-timeout-option-timeout" class="list-anchor">#</a>
  
  Тайм-аут для ожидания

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-return"/><a href="#page-wait-for-timeout-return" class="list-anchor">#</a>

[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[CDPSessionEvent]: /api/class-cdpsessionevent.mdx "CDPSessionEvent"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[bool]: https://docs.microsoft.com/en-us/dotnet/api/system.boolean "bool"
[Date]: https://learn.microsoft.com/en-us/dotnet/api/system.datetime "DateTime"
[double]: https://docs.microsoft.com/en-us/dotnet/api/system.double "double"
[byte]: https://docs.microsoft.com/en-us/dotnet/api/system.byte "byte"
[int]: https://docs.microsoft.com/en-us/dotnet/api/system.int32 "int"
[long]: https://docs.microsoft.com/en-us/dotnet/api/system.int64 "long"
[void]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/void "void"
[string]: https://docs.microsoft.com/en-us/dotnet/api/system.string "string"
[URL]: https://nodejs.org/api/url.html "URL"
[Regex]: https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex "Regex"

[Action]: https://docs.microsoft.com/en-us/dotnet/api/system.action-1 "Action"
[Func]: https://docs.microsoft.com/en-us/dotnet/api/system.func-2 "Func"
[IEnumerable]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable "IEnumerable"
[IReadOnlyList]: https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1?view=net-9.0 "IReadOnlyList"
[IDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary "IDictionary"
[Task]: https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0 "Task"
[IReadOnlyDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2 "IReadOnlyDictionary"
[JsonElement]: https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement "JsonElement"

[все доступные теги изображений]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "все доступные теги изображений"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-dotnet/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
