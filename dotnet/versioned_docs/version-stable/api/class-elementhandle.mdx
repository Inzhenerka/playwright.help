---
id: class-elementhandle
title: "ElementHandle"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

* расширяет: [JSHandle]

ElementHandle представляет собой элемент DOM на странице. ElementHandles могут быть созданы с помощью метода [Page.QuerySelectorAsync()](/api/class-page.mdx#page-query-selector).

:::warning[Не рекомендуется]

Использование ElementHandle не рекомендуется, вместо этого используйте объекты [Locator] и утверждения, ориентированные на веб.
:::

```csharp
var handle = await page.QuerySelectorAsync("a");
await handle.ClickAsync();
```

ElementHandle предотвращает сборку мусора для DOM-элемента, если только дескриптор не будет удален с помощью [JsHandle.DisposeAsync()](/api/class-jshandle.mdx#js-handle-dispose). ElementHandles автоматически удаляются, когда их исходный фрейм переходит на другую страницу.

Экземпляры ElementHandle могут использоваться в качестве аргумента в методах [Page.EvalOnSelectorAsync()](/api/class-page.mdx#page-eval-on-selector) и [Page.EvaluateAsync()](/api/class-page.mdx#page-evaluate).

Разница между [Locator] и ElementHandle заключается в том, что ElementHandle указывает на конкретный элемент, в то время как [Locator] захватывает логику того, как получить элемент.

В примере ниже handle указывает на конкретный DOM-элемент на странице. Если этот элемент изменяет текст или используется React для рендеринга совершенно другого компонента, handle все равно указывает на этот самый DOM-элемент. Это может привести к неожиданным поведениям.

```csharp
var handle = await page.QuerySelectorAsync("text=Submit");
await handle.HoverAsync();
await handle.ClickAsync();
```

С локатором каждый раз, когда используется `element`, актуальный DOM-элемент находится на странице с использованием селектора. Таким образом, в приведенном ниже фрагменте кода базовый DOM-элемент будет найден дважды.

```csharp
var locator = page.GetByText("Submit");
await locator.HoverAsync();
await locator.ClickAsync();
```

---

## Методы

### BoundingBoxAsync {#element-handle-bounding-box}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.BoundingBoxAsync</x-search>

Этот метод возвращает ограничивающий прямоугольник элемента или `null`, если элемент не виден. Ограничивающий прямоугольник рассчитывается относительно области просмотра основного фрейма, которая обычно совпадает с окном браузера.

Прокрутка влияет на возвращаемый ограничивающий прямоугольник, аналогично [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect). Это означает, что `x` и/или `y` могут быть отрицательными.

Элементы из дочерних фреймов возвращают ограничивающий прямоугольник относительно основного фрейма, в отличие от [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).

Предполагая, что страница статична, безопасно использовать координаты ограничивающего прямоугольника для выполнения ввода. Например, следующий фрагмент должен кликнуть в центр элемента.

**Использование**

```csharp
var box = await elementHandle.BoundingBoxAsync();
await page.Mouse.ClickAsync(box.X + box.Width / 2, box.Y + box.Height / 2);
```

**Возвращает**
- BoundingBox?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-bounding-box-return"/><a href="#element-handle-bounding-box-return" class="list-anchor">#</a>
  - `x` [float]
    
    координата x элемента в пикселях.
  - `y` [float]
    
    координата y элемента в пикселях.
  - `width` [float]
    
    ширина элемента в пикселях.
  - `height` [float]
    
    высота элемента в пикселях.

---

### ContentFrameAsync {#element-handle-content-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.ContentFrameAsync</x-search>

Возвращает фрейм содержимого для дескрипторов элементов, ссылающихся на узлы iframe, или `null` в противном случае.

**Использование**

```csharp
await ElementHandle.ContentFrameAsync();
```

**Возвращает**
- [Frame]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-content-frame-return"/><a href="#element-handle-content-frame-return" class="list-anchor">#</a>

---

### OwnerFrameAsync {#element-handle-owner-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.OwnerFrameAsync</x-search>

Возвращает фрейм, содержащий данный элемент.

**Использование**

```csharp
await ElementHandle.OwnerFrameAsync();
```

**Возвращает**
- [Frame]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-owner-frame-return"/><a href="#element-handle-owner-frame-return" class="list-anchor">#</a>

---

### WaitForElementStateAsync {#element-handle-wait-for-element-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.WaitForElementStateAsync</x-search>

Возвращает, когда элемент удовлетворяет [state](/api/class-elementhandle.mdx#element-handle-wait-for-element-state-option-state).

В зависимости от параметра [state](/api/class-elementhandle.mdx#element-handle-wait-for-element-state-option-state), этот метод ожидает, пока один из проверок [actionability](../actionability.mdx) не пройдет. Этот метод выбрасывает исключение, когда элемент отсоединяется во время ожидания, если только не ожидается состояние `"hidden"`.
* `"visible"` Ожидание, пока элемент не станет [видимым](../actionability.mdx#visible).
* `"hidden"` Ожидание, пока элемент не станет [невидимым](../actionability.mdx#visible) или не будет отсоединен. Обратите внимание, что ожидание скрытия не выбрасывает исключение, когда элемент отсоединяется.
* `"stable"` Ожидание, пока элемент не станет одновременно [видимым](../actionability.mdx#visible) и [стабильным](../actionability.mdx#stable).
* `"enabled"` Ожидание, пока элемент не станет [включенным](../actionability.mdx#enabled).
* `"disabled"` Ожидание, пока элемент не станет [не включенным](../actionability.mdx#enabled).
* `"editable"` Ожидание, пока элемент не станет [редактируемым](../actionability.mdx#editable).

Если элемент не удовлетворяет условию в течение [Timeout](/api/class-elementhandle.mdx#element-handle-wait-for-element-state-option-timeout) миллисекунд, этот метод выбрасывает исключение.

**Использование**

```csharp
await ElementHandle.WaitForElementStateAsync(state, options);
```

**Аргументы**
- `state` `enum ElementState { Visible, Hidden, Stable, Enabled, Disabled, Editable }`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-element-state-option-state"/><a href="#element-handle-wait-for-element-state-option-state" class="list-anchor">#</a>
  
  Состояние, которое нужно ожидать, см. ниже для более подробной информации.
- `options` `ElementHandleWaitForElementStateOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-element-state-option-timeout"/><a href="#element-handle-wait-for-element-state-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-element-state-return"/><a href="#element-handle-wait-for-element-state-return" class="list-anchor">#</a>

---

## Устаревшие

### CheckAsync {#element-handle-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.CheckAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.CheckAsync()](/api/class-locator.mdx#locator-check) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод проверяет элемент, выполняя следующие шаги:
1. Убедитесь, что элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже отмечен, этот метод возвращается немедленно.
1. Ожидание проверок [actionability](../actionability.mdx) на элементе, если только не установлен параметр [Force](/api/class-elementhandle.mdx#element-handle-check-option-force).
1. Прокрутите элемент в поле зрения, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для клика в центр элемента.
1. Убедитесь, что элемент теперь отмечен. Если нет, этот метод выбрасывает исключение.

Если элемент отсоединяется от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [Timeout](/api/class-elementhandle.mdx#element-handle-check-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```csharp
await ElementHandle.CheckAsync(options);
```

**Аргументы**
- `options` `ElementHandleCheckOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-force"/><a href="#element-handle-check-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-no-wait-after"/><a href="#element-handle-check-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `Position` Position? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-position"/><a href="#element-handle-check-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-timeout"/><a href="#element-handle-check-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-trial"/><a href="#element-handle-check-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-return"/><a href="#element-handle-check-return" class="list-anchor">#</a>

---

### ClickAsync {#element-handle-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.ClickAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.ClickAsync()](/api/class-locator.mdx#locator-click) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод кликает по элементу, выполняя следующие шаги:
1. Ожидание проверок [actionability](../actionability.mdx) на элементе, если только не установлен параметр [Force](/api/class-elementhandle.mdx#element-handle-click-option-force).
1. Прокрутите элемент в поле зрения, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для клика в центр элемента или указанную [Position](/api/class-elementhandle.mdx#element-handle-click-option-position).
1. Ожидание, пока инициированные навигации либо завершатся успешно, либо неудачно, если только не установлен параметр [NoWaitAfter](/api/class-elementhandle.mdx#element-handle-click-option-no-wait-after).

Если элемент отсоединяется от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [Timeout](/api/class-elementhandle.mdx#element-handle-click-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```csharp
await ElementHandle.ClickAsync(options);
```

**Аргументы**
- `options` `ElementHandleClickOptions?` *(опционально)*
  - `Button` `enum MouseButton { Left, Right, Middle }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-button"/><a href="#element-handle-click-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `ClickCount` [int]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-click-count"/><a href="#element-handle-click-option-click-count" class="list-anchor">#</a>
    
    по умолчанию 1. См. [UIEvent.detail].
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-delay"/><a href="#element-handle-click-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-force"/><a href="#element-handle-click-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-modifiers"/><a href="#element-handle-click-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-no-wait-after"/><a href="#element-handle-click-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Этот параметр по умолчанию будет `true` в будущем.
    :::
    
    
    Действия, инициирующие навигации, ожидают, пока эти навигации произойдут и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится этот параметр только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-position"/><a href="#element-handle-click-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-timeout"/><a href="#element-handle-click-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-trial"/><a href="#element-handle-click-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-return"/><a href="#element-handle-click-return" class="list-anchor">#</a>

---

### DblClickAsync {#element-handle-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.DblClickAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.DblClickAsync()](/api/class-locator.mdx#locator-dblclick) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет двойной клик по элементу, выполняя следующие шаги:
1. Ожидание проверок [actionability](../actionability.mdx) на элементе, если только не установлен параметр [Force](/api/class-elementhandle.mdx#element-handle-dblclick-option-force).
1. Прокрутите элемент в поле зрения, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для двойного клика в центр элемента или указанную [Position](/api/class-elementhandle.mdx#element-handle-dblclick-option-position).

Если элемент отсоединяется от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [Timeout](/api/class-elementhandle.mdx#element-handle-dblclick-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

`elementHandle.dblclick()` генерирует два события `click` и одно событие `dblclick`.
:::

**Использование**

```csharp
await ElementHandle.DblClickAsync(options);
```

**Аргументы**
- `options` `ElementHandleDblClickOptions?` *(опционально)*
  - `Button` `enum MouseButton { Left, Right, Middle }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-button"/><a href="#element-handle-dblclick-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-delay"/><a href="#element-handle-dblclick-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-force"/><a href="#element-handle-dblclick-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-modifiers"/><a href="#element-handle-dblclick-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-no-wait-after"/><a href="#element-handle-dblclick-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-position"/><a href="#element-handle-dblclick-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-timeout"/><a href="#element-handle-dblclick-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-trial"/><a href="#element-handle-dblclick-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-return"/><a href="#element-handle-dblclick-return" class="list-anchor">#</a>

---

### DispatchEventAsync {#element-handle-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.DispatchEventAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.DispatchEventAsync()](/api/class-locator.mdx#locator-dispatch-event) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Приведенный ниже фрагмент кода генерирует событие `click` на элементе. Независимо от состояния видимости элемента, `click` генерируется. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Использование**

```csharp
await elementHandle.DispatchEventAsync("click");
```

Под капотом создается экземпляр события на основе указанного [type](/api/class-elementhandle.mdx#element-handle-dispatch-event-option-type), инициализируется с помощью свойств [eventInit](/api/class-elementhandle.mdx#element-handle-dispatch-event-option-event-init) и генерируется на элементе. События по умолчанию `composed`, `cancelable` и всплывают.

Поскольку [eventInit](/api/class-elementhandle.mdx#element-handle-dispatch-event-option-event-init) является специфичным для события, пожалуйста, обратитесь к документации по событиям для списков начальных свойств:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Вы также можете указать `JSHandle` в качестве значения свойства, если хотите, чтобы живые объекты передавались в событие:

```csharp
var dataTransfer = await page.EvaluateHandleAsync("() => new DataTransfer()");
await elementHandle.DispatchEventAsync("dragstart", new Dictionary<string, object>
{
    { "dataTransfer", dataTransfer }
});
```

**Аргументы**
- `type` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dispatch-event-option-type"/><a href="#element-handle-dispatch-event-option-type" class="list-anchor">#</a>
  
  Тип DOM-события: `"click"`, `"dragstart"`, и т.д.
- `eventInit` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dispatch-event-option-event-init"/><a href="#element-handle-dispatch-event-option-event-init" class="list-anchor">#</a>
  
  Опциональные специфичные для события свойства инициализации.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dispatch-event-return"/><a href="#element-handle-dispatch-event-return" class="list-anchor">#</a>

---

### EvalOnSelectorAsync {#element-handle-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.EvalOnSelectorAsync</x-search>

:::warning[Не рекомендуется]

Этот метод не ожидает, пока элемент пройдет проверки actionability, и поэтому может привести к нестабильным тестам. Используйте [Locator.EvaluateAsync()](/api/class-locator.mdx#locator-evaluate), другие вспомогательные методы [Locator] или утверждения, ориентированные на веб.

:::

Возвращает возвращаемое значение [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression).

Метод находит элемент, соответствующий указанному селектору в поддереве `ElementHandle`, и передает его в качестве первого аргумента в [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выбрасывает ошибку.

Если [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression) возвращает [Promise], то [ElementHandle.EvalOnSelectorAsync()](/api/class-elementhandle.mdx#element-handle-eval-on-selector) будет ожидать разрешения промиса и возвращать его значение.

**Использование**

```csharp
var tweetHandle = await page.QuerySelectorAsync(".tweet");
Assert.AreEqual("100", await tweetHandle.EvalOnSelectorAsync(".like", "node => node.innerText"));
Assert.AreEqual("10", await tweetHandle.EvalOnSelectorAsync(".retweets", "node => node.innerText"));
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-option-selector"/><a href="#element-handle-eval-on-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-option-expression"/><a href="#element-handle-eval-on-selector-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-option-arg"/><a href="#element-handle-eval-on-selector-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression).

**Возвращает**
- [object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-return"/><a href="#element-handle-eval-on-selector-return" class="list-anchor">#</a>

---

### EvalOnSelectorAllAsync {#element-handle-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.EvalOnSelectorAllAsync</x-search>

:::warning[Не рекомендуется]

В большинстве случаев [Locator.EvaluateAllAsync()](/api/class-locator.mdx#locator-evaluate-all), другие вспомогательные методы [Locator] и утверждения, ориентированные на веб, выполняют работу лучше.

:::

Возвращает возвращаемое значение [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression).

Метод находит все элементы, соответствующие указанному селектору в поддереве `ElementHandle`, и передает массив найденных элементов в качестве первого аргумента в [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression).

Если [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression) возвращает [Promise], то [ElementHandle.EvalOnSelectorAllAsync()](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all) будет ожидать разрешения промиса и возвращать его значение.

**Использование**

```html
<div class="feed">
  <div class="tweet">Hello!</div>
  <div class="tweet">Hi!</div>
</div>
```

```csharp
var feedHandle = await page.QuerySelectorAsync(".feed");
Assert.AreEqual(new [] { "Hello!", "Hi!" }, await feedHandle.EvalOnSelectorAllAsync<string[]>(".tweet", "nodes => nodes.map(n => n.innerText)"));
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-option-selector"/><a href="#element-handle-eval-on-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-option-expression"/><a href="#element-handle-eval-on-selector-all-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-option-arg"/><a href="#element-handle-eval-on-selector-all-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression).

**Возвращает**
- [object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-return"/><a href="#element-handle-eval-on-selector-all-return" class="list-anchor">#</a>

---

### FillAsync {#element-handle-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.FillAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.FillAsync()](/api/class-locator.mdx#locator-fill) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает проверок [actionability](../actionability.mdx), фокусируется на элементе, заполняет его и генерирует событие `input` после заполнения. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является элементом `<input>`, `<textarea>` или `[contenteditable]`, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен именно этот элемент управления.

Для отправки более детализированных событий клавиатуры используйте [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially).

**Использование**

```csharp
await ElementHandle.FillAsync(value, options);
```

**Аргументы**
- `value` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-value"/><a href="#element-handle-fill-option-value" class="list-anchor">#</a>
  
  Значение для установки для элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `options` `ElementHandleFillOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-force"/><a href="#element-handle-fill-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-no-wait-after"/><a href="#element-handle-fill-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-timeout"/><a href="#element-handle-fill-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-return"/><a href="#element-handle-fill-return" class="list-anchor">#</a>

---

### FocusAsync {#element-handle-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.FocusAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.FocusAsync()](/api/class-locator.mdx#locator-focus) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Вызывает [focus](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) на элементе.

**Использование**

```csharp
await ElementHandle.FocusAsync();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-focus-return"/><a href="#element-handle-focus-return" class="list-anchor">#</a>

---

### GetAttributeAsync {#element-handle-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.GetAttributeAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.GetAttributeAsync()](/api/class-locator.mdx#locator-get-attribute) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает значение атрибута элемента.

**Использование**

```csharp
await ElementHandle.GetAttributeAsync(name);
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-get-attribute-option-name"/><a href="#element-handle-get-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута, для которого нужно получить значение.

**Возвращает**
- [string]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-get-attribute-return"/><a href="#element-handle-get-attribute-return" class="list-anchor">#</a>

---

### HoverAsync {#element-handle-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.HoverAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.HoverAsync()](/api/class-locator.mdx#locator-hover) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод наводит курсор на элемент, выполняя следующие шаги:
1. Ожидание проверки [действительности](../actionability.mdx) элемента, если не установлена опция [Force](/api/class-elementhandle.mdx#element-handle-hover-option-force).
2. Прокрутка элемента в видимую область, если это необходимо.
3. Использование [Page.Mouse](/api/class-page.mdx#page-mouse) для наведения курсора на центр элемента или указанную [позицию](/api/class-elementhandle.mdx#element-handle-hover-option-position).

Если элемент отсоединяется от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Если все шаги не завершены в течение указанного [времени ожидания](/api/class-elementhandle.mdx#element-handle-hover-option-timeout), этот метод выбрасывает [TimeoutError]. Установка времени ожидания в ноль отключает его.

**Использование**

```csharp
await ElementHandle.HoverAsync(options);
```

**Аргументы**
- `options` `ElementHandleHoverOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-force"/><a href="#element-handle-hover-option-force" class="list-anchor">#</a>
    
    Пропускать ли проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-modifiers"/><a href="#element-handle-hover-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается как "Control" на Windows и Linux и как "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-no-wait-after"/><a href="#element-handle-hover-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-position"/><a href="#element-handle-hover-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла области отступов элемента. Если не указано, используется видимая точка элемента.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-timeout"/><a href="#element-handle-hover-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Установите `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить с помощью методов [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-trial"/><a href="#element-handle-hover-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-return"/><a href="#element-handle-hover-return" class="list-anchor">#</a>

---

### InnerHTMLAsync {#element-handle-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.InnerHTMLAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.InnerHTMLAsync()](/api/class-locator.mdx#locator-inner-html) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerHTML`.

**Использование**

```csharp
await ElementHandle.InnerHTMLAsync();
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-inner-html-return"/><a href="#element-handle-inner-html-return" class="list-anchor">#</a>

---

### InnerTextAsync {#element-handle-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.InnerTextAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.InnerTextAsync()](/api/class-locator.mdx#locator-inner-text) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerText`.

**Использование**

```csharp
await ElementHandle.InnerTextAsync();
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-inner-text-return"/><a href="#element-handle-inner-text-return" class="list-anchor">#</a>

---

### InputValueAsync {#element-handle-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>elementHandle.InputValueAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.InputValueAsync()](/api/class-locator.mdx#locator-input-value) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Выбрасывает исключение для элементов, не являющихся вводом. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращает значение контрола.

**Использование**

```csharp
await ElementHandle.InputValueAsync(options);
```

**Аргументы**
- `options` `ElementHandleInputValueOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-input-value-option-timeout"/><a href="#element-handle-input-value-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Установите `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить с помощью методов [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-input-value-return"/><a href="#element-handle-input-value-return" class="list-anchor">#</a>

---

### IsCheckedAsync {#element-handle-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.IsCheckedAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.IsCheckedAsync()](/api/class-locator.mdx#locator-is-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отмечен ли элемент. Выбрасывает исключение, если элемент не является флажком или радиокнопкой.

**Использование**

```csharp
await ElementHandle.IsCheckedAsync();
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-checked-return"/><a href="#element-handle-is-checked-return" class="list-anchor">#</a>

---

### IsDisabledAsync {#element-handle-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.IsDisabledAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.IsDisabledAsync()](/api/class-locator.mdx#locator-is-disabled) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отключен ли элемент, противоположность [включенному](../actionability.mdx#enabled).

**Использование**

```csharp
await ElementHandle.IsDisabledAsync();
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-disabled-return"/><a href="#element-handle-is-disabled-return" class="list-anchor">#</a>

---

### IsEditableAsync {#element-handle-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.IsEditableAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.IsEditableAsync()](/api/class-locator.mdx#locator-is-editable) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Использование**

```csharp
await ElementHandle.IsEditableAsync();
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-editable-return"/><a href="#element-handle-is-editable-return" class="list-anchor">#</a>

---

### IsEnabledAsync {#element-handle-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.IsEnabledAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.IsEnabledAsync()](/api/class-locator.mdx#locator-is-enabled) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [включенным](../actionability.mdx#enabled).

**Использование**

```csharp
await ElementHandle.IsEnabledAsync();
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-enabled-return"/><a href="#element-handle-is-enabled-return" class="list-anchor">#</a>

---

### IsHiddenAsync {#element-handle-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.IsHiddenAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.IsHiddenAsync()](/api/class-locator.mdx#locator-is-hidden) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, скрыт ли элемент, противоположность [видимому](../actionability.mdx#visible).

**Использование**

```csharp
await ElementHandle.IsHiddenAsync();
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-hidden-return"/><a href="#element-handle-is-hidden-return" class="list-anchor">#</a>

---

### IsVisibleAsync {#element-handle-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.IsVisibleAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.IsVisibleAsync()](/api/class-locator.mdx#locator-is-visible) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [видимым](../actionability.mdx#visible).

**Использование**

```csharp
await ElementHandle.IsVisibleAsync();
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-visible-return"/><a href="#element-handle-is-visible-return" class="list-anchor">#</a>

---

### PressAsync {#element-handle-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.PressAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.PressAsync()](/api/class-locator.mdx#locator-press) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Фокусирует элемент, а затем использует [Keyboard.DownAsync()](/api/class-keyboard.mdx#keyboard-down) и [Keyboard.UpAsync()](/api/class-keyboard.mdx#keyboard-up).

[key](/api/class-elementhandle.mdx#element-handle-press-option-key) может указывать предполагаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или один символ для генерации текста. Надмножество значений [key](/api/class-elementhandle.mdx#element-handle-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры клавиш:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются следующие сочетания модификаций: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`.

Удержание `Shift` будет вводить текст, соответствующий [key](/api/class-elementhandle.mdx#element-handle-press-option-key) в верхнем регистре.

Если [key](/api/class-elementhandle.mdx#element-handle-press-option-key) является одним символом, он чувствителен к регистру, поэтому значения `a` и `A` будут генерировать разные соответствующие тексты.

Также поддерживаются сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++` или `key: "Control+Shift+T"`. При указании с модификатором, модификатор нажимается и удерживается, пока не будет нажата последующая клавиша.

**Использование**

```csharp
await ElementHandle.PressAsync(key, options);
```

**Аргументы**
- `key` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-key"/><a href="#element-handle-press-option-key" class="list-anchor">#</a>
  
  Имя клавиши для нажатия или символ для генерации, например, `ArrowLeft` или `a`.
- `options` `ElementHandlePressOptions?` *(опционально)*
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-delay"/><a href="#element-handle-press-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `keydown` и `keyup` в миллисекундах. По умолчанию 0.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-no-wait-after"/><a href="#element-handle-press-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция по умолчанию будет `true` в будущем.
    :::
    
    
    Действия, инициирующие навигацию, ожидают, пока эти навигации не произойдут и страницы не начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится эта опция только в исключительных случаях, таких как переход на недоступные страницы. По умолчанию `false`.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-timeout"/><a href="#element-handle-press-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Установите `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить с помощью методов [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-return"/><a href="#element-handle-press-return" class="list-anchor">#</a>

---

### QuerySelectorAsync {#element-handle-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.QuerySelectorAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Page.Locator()](/api/class-page.mdx#page-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Метод находит элемент, соответствующий указанному селектору в поддереве `ElementHandle`. Если элементы, соответствующие селектору, не найдены, возвращает `null`.

**Использование**

```csharp
await ElementHandle.QuerySelectorAsync(selector);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-option-selector"/><a href="#element-handle-query-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.

**Возвращает**
- [ElementHandle]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-return"/><a href="#element-handle-query-selector-return" class="list-anchor">#</a>

---

### QuerySelectorAllAsync {#element-handle-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.QuerySelectorAllAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Page.Locator()](/api/class-page.mdx#page-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Метод находит все элементы, соответствующие указанному селектору в поддереве `ElementHandle`. Если элементы, соответствующие селектору, не найдены, возвращает пустой массив.

**Использование**

```csharp
await ElementHandle.QuerySelectorAllAsync(selector);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-all-option-selector"/><a href="#element-handle-query-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.

**Возвращает**
- [IEnumerable]&lt;[ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-all-return"/><a href="#element-handle-query-selector-all-return" class="list-anchor">#</a>

---

### ScreenshotAsync {#element-handle-screenshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.ScreenshotAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.ScreenshotAsync()](/api/class-locator.mdx#locator-screenshot) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод делает снимок экрана страницы, обрезанный до размера и положения этого конкретного элемента. Если элемент закрыт другими элементами, он не будет фактически виден на снимке экрана. Если элемент является прокручиваемым контейнером, на снимке экрана будет виден только текущий прокручиваемый контент.

Этот метод ожидает проверки [действительности](../actionability.mdx), затем прокручивает элемент в видимую область перед созданием снимка экрана. Если элемент отсоединен от DOM, метод выбрасывает ошибку.

Возвращает буфер с захваченным снимком экрана.

**Использование**

```csharp
await ElementHandle.ScreenshotAsync(options);
```

**Аргументы**
- `options` `ElementHandleScreenshotOptions?` *(опционально)*
  - `Animations` `enum ScreenshotAnimations { Disabled, Allow }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-animations"/><a href="#element-handle-screenshot-option-animations" class="list-anchor">#</a>
    
    Если установлено значение `"disabled"`, останавливает CSS-анимации, CSS-переходы и веб-анимации. Анимации получают различное обращение в зависимости от их продолжительности:
    * конечные анимации быстро перематываются до завершения, чтобы они вызвали событие `transitionend`.
    * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся снова после создания снимка экрана.
    
    По умолчанию `"allow"`, что оставляет анимации нетронутыми.
  - `Caret` `enum ScreenshotCaret { Hide, Initial }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-caret"/><a href="#element-handle-screenshot-option-caret" class="list-anchor">#</a>
    
    Если установлено значение `"hide"`, снимок экрана скроет текстовый курсор. Если установлено значение `"initial"`, поведение текстового курсора не будет изменено. По умолчанию `"hide"`.
  - `Mask` [IEnumerable]?&lt;[Locator]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-mask"/><a href="#element-handle-screenshot-option-mask" class="list-anchor">#</a>
    
    Укажите локаторы, которые должны быть замаскированы при создании снимка экрана. Замаскированные элементы будут перекрыты розовым прямоугольником `#FF00FF` (настраивается с помощью [MaskColor](/api/class-elementhandle.mdx#element-handle-screenshot-option-mask-color)), который полностью покрывает их ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Соответствие только видимым элементам](../locators.mdx#matching-only-visible-elements), чтобы отключить это.
  - `MaskColor` [string]? *(опционально)* <font size="2">Добавлено в: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-mask-color"/><a href="#element-handle-screenshot-option-mask-color" class="list-anchor">#</a>
    
    Укажите цвет перекрывающего прямоугольника для замаскированных элементов в [формате цвета CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию - розовый `#FF00FF`.
  - `OmitBackground` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-omit-background"/><a href="#element-handle-screenshot-option-omit-background" class="list-anchor">#</a>
    
    Скрывает белый фон по умолчанию и позволяет захватывать снимки экрана с прозрачностью. Не применимо к изображениям `jpeg`. По умолчанию `false`.
  - `Path` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-path"/><a href="#element-handle-screenshot-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения изображения. Тип снимка экрана будет определен по расширению файла. Если [Path](/api/class-elementhandle.mdx#element-handle-screenshot-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, изображение не будет сохранено на диск.
  - `Quality` [int]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-quality"/><a href="#element-handle-screenshot-option-quality" class="list-anchor">#</a>
    
    Качество изображения, от 0 до 100. Не применимо к изображениям `png`.
  - `Scale` `enum ScreenshotScale { Css, Device }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-scale"/><a href="#element-handle-screenshot-option-scale" class="list-anchor">#</a>
    
    Если установлено значение `"css"`, снимок экрана будет иметь один пиксель на каждый css-пиксель на странице. Для устройств с высоким разрешением это позволит сохранить снимки экрана небольшими. Использование опции `"device"` создаст один пиксель на каждый пиксель устройства, так что снимки экрана устройств с высоким разрешением будут в два раза больше или даже больше.
    
    По умолчанию `"device"`.
  - `Style` [string]? *(опционально)* <font size="2">Добавлено в: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-style"/><a href="#element-handle-screenshot-option-style" class="list-anchor">#</a>
    
    Текст таблицы стилей для применения при создании снимка экрана. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создать повторяемые снимки экрана. Эта таблица стилей проникает в Shadow DOM и применяется к внутренним фреймам.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-timeout"/><a href="#element-handle-screenshot-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Установите `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить с помощью методов [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Type` `enum ScreenshotType { Png, Jpeg }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-type"/><a href="#element-handle-screenshot-option-type" class="list-anchor">#</a>
    
    Укажите тип снимка экрана, по умолчанию `png`.

**Возвращает**
- [byte]&#91;&#93;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-return"/><a href="#element-handle-screenshot-return" class="list-anchor">#</a>

---

### ScrollIntoViewIfNeededAsync {#element-handle-scroll-into-view-if-needed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.ScrollIntoViewIfNeededAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.ScrollIntoViewIfNeededAsync()](/api/class-locator.mdx#locator-scroll-into-view-if-needed) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает проверки [действительности](../actionability.mdx), затем пытается прокрутить элемент в видимую область, если он не полностью виден, как это определено `ratio` в [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).

Вызывает ошибку, если `elementHandle` не указывает на элемент, [подключенный](https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected) к Document или ShadowRoot.

Смотрите [прокрутка](../input.mdx#scrolling) для альтернативных способов прокрутки.

**Использование**

```csharp
await ElementHandle.ScrollIntoViewIfNeededAsync(options);
```

**Аргументы**
- `options` `ElementHandleScrollIntoViewIfNeededOptions?` *(необязательно)*
  - `Timeout` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-scroll-into-view-if-needed-option-timeout"/><a href="#element-handle-scroll-into-view-if-needed-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-scroll-into-view-if-needed-return"/><a href="#element-handle-scroll-into-view-if-needed-return" class="list-anchor">#</a>

---

### SelectOptionAsync {#element-handle-select-option}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.SelectOptionAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SelectOptionAsync()](/api/class-locator.mdx#locator-select-option) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает проверки [действительности](../actionability.mdx), ждет, пока все указанные опции будут присутствовать в элементе `<select>`, и выбирает эти опции.

Если целевой элемент не является элементом `<select>`, этот метод вызывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанную [управляющую](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control) часть, будет использована управляющая часть.

Возвращает массив значений опций, которые были успешно выбраны.

Вызывает события `change` и `input`, как только все предоставленные опции были выбраны.

**Использование**

```csharp
// Одиночный выбор, соответствующий значению или метке
await handle.SelectOptionAsync(new[] { "blue" });
// одиночный выбор, соответствующий метке
await handle.SelectOptionAsync(new[] { new SelectOptionValue() { Label = "blue" } });
// множественный выбор
await handle.SelectOptionAsync(new[] { "red", "green", "blue" });
// множественный выбор для blue, red и второй опции
await handle.SelectOptionAsync(new[] {
    new SelectOptionValue() { Label = "blue" },
    new SelectOptionValue() { Index = 2 },
    new SelectOptionValue() { Value = "red" }});
```

**Аргументы**
- `values` [string] | [ElementHandle] | [IEnumerable] | `SelectOption` | [IEnumerable] | [IEnumerable]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-option-values"/><a href="#element-handle-select-option-option-values" class="list-anchor">#</a>
  - `Value` [string]? *(необязательно)*
    
    Соответствует `option.value`. Необязательно.
  - `Label` [string]? *(необязательно)*
    
    Соответствует `option.label`. Необязательно.
  - `Index` [int]? *(необязательно)*
    
    Соответствует индексу. Необязательно.
  
  Опции для выбора. Если у `<select>` есть атрибут `multiple`, все соответствующие опции выбираются, в противном случае выбирается только первая опция, соответствующая одной из переданных опций. Строковые значения соответствуют как значениям, так и меткам. Опция считается соответствующей, если все указанные свойства совпадают.
- `options` `ElementHandleSelectOptionOptions?` *(необязательно)*
  - `Force` [bool]? *(необязательно)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-option-force"/><a href="#element-handle-select-option-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-option-no-wait-after"/><a href="#element-handle-select-option-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Timeout` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-option-timeout"/><a href="#element-handle-select-option-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [IEnumerable]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-return"/><a href="#element-handle-select-option-return" class="list-anchor">#</a>

---

### SelectTextAsync {#element-handle-select-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.SelectTextAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SelectTextAsync()](/api/class-locator.mdx#locator-select-text) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает проверки [действительности](../actionability.mdx), затем фокусируется на элементе и выделяет весь его текстовый контент.

Если элемент находится внутри элемента `<label>`, который имеет связанную [управляющую](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control) часть, фокусируется и выделяет текст в управляющей части.

**Использование**

```csharp
await ElementHandle.SelectTextAsync(options);
```

**Аргументы**
- `options` `ElementHandleSelectTextOptions?` *(необязательно)*
  - `Force` [bool]? *(необязательно)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-text-option-force"/><a href="#element-handle-select-text-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Timeout` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-text-option-timeout"/><a href="#element-handle-select-text-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-text-return"/><a href="#element-handle-select-text-return" class="list-anchor">#</a>

---

### SetCheckedAsync {#element-handle-set-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.15</font><x-search>elementHandle.SetCheckedAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SetCheckedAsync()](/api/class-locator.mdx#locator-set-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод отмечает или снимает отметку с элемента, выполняя следующие шаги:
1. Убедитесь, что элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку.
1. Если элемент уже имеет правильное состояние отметки, этот метод возвращается немедленно.
1. Ожидайте проверки [действительности](../actionability.mdx) на совпадающем элементе, если только не установлена опция [Force](/api/class-elementhandle.mdx#element-handle-set-checked-option-force). Если элемент отсоединен во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для нажатия в центре элемента.
1. Убедитесь, что элемент теперь отмечен или снята отметка. Если нет, этот метод вызывает ошибку.

Если все шаги вместе не завершились в течение указанного [Timeout](/api/class-elementhandle.mdx#element-handle-set-checked-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```csharp
await ElementHandle.SetCheckedAsync(checked, options);
```

**Аргументы**
- `checkedState` [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-checked"/><a href="#element-handle-set-checked-option-checked" class="list-anchor">#</a>
  
  Нужно ли отметить или снять отметку с флажка.
- `options` `ElementHandleSetCheckedOptions?` *(необязательно)*
  - `Force` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-force"/><a href="#element-handle-set-checked-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-no-wait-after"/><a href="#element-handle-set-checked-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-position"/><a href="#element-handle-set-checked-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Timeout` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-timeout"/><a href="#element-handle-set-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.
  - `Trial` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-trial"/><a href="#element-handle-set-checked-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-return"/><a href="#element-handle-set-checked-return" class="list-anchor">#</a>

---

### SetInputFilesAsync {#element-handle-set-input-files}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.SetInputFilesAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SetInputFilesAsync()](/api/class-locator.mdx#locator-set-input-files) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Устанавливает значение файлового ввода в эти пути к файлам или файлы. Если некоторые из `filePaths` являются относительными путями, они разрешаются относительно текущего рабочего каталога. Для пустого массива очищает выбранные файлы. Для входных данных с атрибутом `[webkitdirectory]` поддерживается только один путь к каталогу.

Этот метод ожидает, что [ElementHandle] указывает на [элемент ввода](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Однако, если элемент находится внутри элемента `<label>`, который имеет связанную [управляющую](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control) часть, нацеливается на управляющую часть.

**Использование**

```csharp
await ElementHandle.SetInputFilesAsync(files, options);
```

**Аргументы**
- `files` [string] | [IEnumerable]&lt;[string]&gt; | `FilePayload` | [IEnumerable]&lt;`FilePayload`&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-input-files-option-files"/><a href="#element-handle-set-input-files-option-files" class="list-anchor">#</a>
  - `Name` [string]
    
    Имя файла
  - `MimeType` [string]
    
    Тип файла
  - `Buffer` [byte]&#91;&#93;
    
    Содержимое файла
- `options` `ElementHandleSetInputFilesOptions?` *(необязательно)*
  - `NoWaitAfter` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-input-files-option-no-wait-after"/><a href="#element-handle-set-input-files-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Timeout` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-input-files-option-timeout"/><a href="#element-handle-set-input-files-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-input-files-return"/><a href="#element-handle-set-input-files-return" class="list-anchor">#</a>

---

### TapAsync {#element-handle-tap}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.TapAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.TapAsync()](/api/class-locator.mdx#locator-tap) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет нажатие на элемент, выполняя следующие шаги:
1. Ожидайте проверки [действительности](../actionability.mdx) на элементе, если только не установлена опция [Force](/api/class-elementhandle.mdx#element-handle-tap-option-force).
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Touchscreen](/api/class-page.mdx#page-touchscreen) для нажатия в центре элемента или в указанной [Position](/api/class-elementhandle.mdx#element-handle-tap-option-position).

Если элемент отсоединен от DOM в любой момент во время действия, этот метод вызывает ошибку.

Если все шаги вместе не завершились в течение указанного [Timeout](/api/class-elementhandle.mdx#element-handle-tap-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

`elementHandle.tap()` требует, чтобы опция `hasTouch` контекста браузера была установлена в true.
:::

**Использование**

```csharp
await ElementHandle.TapAsync(options);
```

**Аргументы**
- `options` `ElementHandleTapOptions?` *(необязательно)*
  - `Force` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-force"/><a href="#element-handle-tap-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-modifiers"/><a href="#element-handle-tap-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-no-wait-after"/><a href="#element-handle-tap-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-position"/><a href="#element-handle-tap-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Timeout` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-timeout"/><a href="#element-handle-tap-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.
  - `Trial` [bool]? *(необязательно)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-trial"/><a href="#element-handle-tap-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-return"/><a href="#element-handle-tap-return" class="list-anchor">#</a>

---

### TextContentAsync {#element-handle-text-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.TextContentAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.TextContentAsync()](/api/class-locator.mdx#locator-text-content) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `node.textContent`.

**Использование**

```csharp
await ElementHandle.TextContentAsync();
```

**Возвращает**
- [string]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-text-content-return"/><a href="#element-handle-text-content-return" class="list-anchor">#</a>

---

### TypeAsync {#element-handle-type}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.TypeAsync</x-search>

:::warning Устарело

В большинстве случаев вам следует использовать [Locator.FillAsync()](/api/class-locator.mdx#locator-fill) вместо этого. Вам нужно нажимать клавиши одну за другой, только если на странице есть специальная обработка клавиатуры - в этом случае используйте [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially).

:::

Фокусируется на элементе, а затем отправляет события `keydown`, `keypress`/`input` и `keyup` для каждого символа в тексте.

Чтобы нажать специальную клавишу, такую как `Control` или `ArrowDown`, используйте [ElementHandle.PressAsync()](/api/class-elementhandle.mdx#element-handle-press).

**Использование**

**Аргументы**
- `text` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-option-text"/><a href="#element-handle-type-option-text" class="list-anchor">#</a>
  
  Текст для ввода в сфокусированный элемент.
- `options` `ElementHandleTypeOptions?` *(необязательно)*
  - `Delay` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-option-delay"/><a href="#element-handle-type-option-delay" class="list-anchor">#</a>
    
    Время ожидания между нажатиями клавиш в миллисекундах. По умолчанию 0.
  - `NoWaitAfter` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-option-no-wait-after"/><a href="#element-handle-type-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Timeout` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-option-timeout"/><a href="#element-handle-type-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-return"/><a href="#element-handle-type-return" class="list-anchor">#</a>

---

### UncheckAsync {#element-handle-uncheck}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.UncheckAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.UncheckAsync()](/api/class-locator.mdx#locator-uncheck) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод снимает отметку с элемента, выполняя следующие шаги:
1. Убедитесь, что элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку. Если элемент уже снят с отметки, этот метод возвращается немедленно.
1. Ожидайте проверки [действительности](../actionability.mdx) на элементе, если только не установлена опция [Force](/api/class-elementhandle.mdx#element-handle-uncheck-option-force).
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для нажатия в центре элемента.
1. Убедитесь, что элемент теперь снят с отметки. Если нет, этот метод вызывает ошибку.

Если элемент отсоединен от DOM в любой момент во время действия, этот метод вызывает ошибку.

Если все шаги вместе не завершились в течение указанного [Timeout](/api/class-elementhandle.mdx#element-handle-uncheck-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```csharp
await ElementHandle.UncheckAsync(options);
```

**Аргументы**
- `options` `ElementHandleUncheckOptions?` *(необязательно)*
  - `Force` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-force"/><a href="#element-handle-uncheck-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-no-wait-after"/><a href="#element-handle-uncheck-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(необязательно)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-position"/><a href="#element-handle-uncheck-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Timeout` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-timeout"/><a href="#element-handle-uncheck-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.
  - `Trial` [bool]? *(необязательно)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-trial"/><a href="#element-handle-uncheck-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-return"/><a href="#element-handle-uncheck-return" class="list-anchor">#</a>

---

### WaitForSelectorAsync {#element-handle-wait-for-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.WaitForSelectorAsync</x-search>

:::warning[Не рекомендуется]

Используйте веб-утверждения, которые утверждают видимость, или основанный на локаторах метод [Locator.WaitForAsync()](/api/class-locator.mdx#locator-wait-for) вместо этого.

:::

Возвращает элемент, указанный селектором, когда он удовлетворяет опции [State](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-state). Возвращает `null`, если ожидается `hidden` или `detached`.

Ожидает, пока [селектор](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-selector) относительно элемента handle удовлетворит опции [State](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-state) (либо появится/исчезнет из DOM, либо станет видимым/скрытым). Если в момент вызова метода [селектор](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-selector) уже удовлетворяет условию, метод вернется немедленно. Если селектор не удовлетворяет условию в течение [Timeout](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-timeout) миллисекунд, функция вызовет ошибку.

**Использование**

```csharp
await page.SetContentAsync("<div><span></span></div>");
var div = await page.QuerySelectorAsync("div");
// Ожидание селектора "span" относительно div.
var span = await page.WaitForSelectorAsync("span", WaitForSelectorState.Attached);
```

:::note
Этот метод не работает через навигации, используйте [Page.WaitForSelectorAsync()](/api/class-page.mdx#page-wait-for-selector) вместо этого.
:::

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-option-selector"/><a href="#element-handle-wait-for-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` `ElementHandleWaitForSelectorOptions?` *(необязательно)*
  - `State` `enum WaitForSelectorState { Attached, Detached, Visible, Hidden }?` *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-option-state"/><a href="#element-handle-wait-for-selector-option-state" class="list-anchor">#</a>
    
    По умолчанию `'visible'`. Может быть:
    * `'attached'` - ожидание, пока элемент будет присутствовать в DOM.
    * `'detached'` - ожидание, пока элемент не будет присутствовать в DOM.
    * `'visible'` - ожидание, пока элемент не будет иметь пустую рамку и не будет `visibility:hidden`. Обратите внимание, что элемент без какого-либо контента или с `display:none` имеет пустую рамку и не считается видимым.
    * `'hidden'` - ожидание, пока элемент будет либо отсоединен от DOM, либо иметь пустую рамку или `visibility:hidden`. Это противоположно опции `'visible'`.
  - `Strict` [bool]? *(необязательно)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-option-strict"/><a href="#element-handle-wait-for-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(необязательно)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-option-timeout"/><a href="#element-handle-wait-for-selector-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [ElementHandle]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-return"/><a href="#element-handle-wait-for-selector-return" class="list-anchor">#</a>


[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[CDPSessionEvent]: /api/class-cdpsessionevent.mdx "CDPSessionEvent"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[bool]: https://docs.microsoft.com/en-us/dotnet/api/system.boolean "bool"
[Date]: https://learn.microsoft.com/en-us/dotnet/api/system.datetime "DateTime"
[double]: https://docs.microsoft.com/en-us/dotnet/api/system.double "double"
[byte]: https://docs.microsoft.com/en-us/dotnet/api/system.byte "byte"
[int]: https://docs.microsoft.com/en-us/dotnet/api/system.int32 "int"
[long]: https://docs.microsoft.com/en-us/dotnet/api/system.int64 "long"
[void]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/void "void"
[string]: https://docs.microsoft.com/en-us/dotnet/api/system.string "string"
[URL]: https://nodejs.org/api/url.html "URL"
[Regex]: https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex "Regex"

[Action]: https://docs.microsoft.com/en-us/dotnet/api/system.action-1 "Action"
[Func]: https://docs.microsoft.com/en-us/dotnet/api/system.func-2 "Func"
[IEnumerable]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable "IEnumerable"
[IDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary "IDictionary"
[Task]: https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0 "Task"
[IReadOnlyDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2 "IReadOnlyDictionary"
[JsonElement]: https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement "JsonElement"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-dotnet/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
