---
id: class-browsercontext
title: "BrowserContext"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

BrowserContexts предоставляют способ работы с несколькими независимыми сессиями браузера.

Если страница открывает другую страницу, например, с помощью вызова `window.open`, всплывающее окно будет принадлежать контексту браузера родительской страницы.

Playwright позволяет создавать изолированные непостоянные контексты браузера с помощью метода [Browser.NewContextAsync()](/api/class-browser.mdx#browser-new-context). Непостоянные контексты браузера не записывают данные о просмотре на диск.

```csharp
using var playwright = await Playwright.CreateAsync();
var browser = await playwright.Firefox.LaunchAsync(new() { Headless = false });
// Создать новый инкогнито-контекст браузера
var context = await browser.NewContextAsync();
// Создать новую страницу внутри контекста.
var page = await context.NewPageAsync();
await page.GotoAsync("https://bing.com");
// Закрыть контекст, когда он больше не нужен.
await context.CloseAsync();
```

---

## Методы

### AddCookiesAsync {#browser-context-add-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.AddCookiesAsync</x-search>

Добавляет куки в этот контекст браузера. Все страницы в этом контексте будут иметь установленные куки. Куки можно получить с помощью [BrowserContext.CookiesAsync()](/api/class-browsercontext.mdx#browser-context-cookies).

**Использование**

```csharp
await context.AddCookiesAsync(new[] { cookie1, cookie2 });
```

**Аргументы**
- `cookies` [IEnumerable]&lt;`Cookie`&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-option-cookies"/><a href="#browser-context-add-cookies-option-cookies" class="list-anchor">#</a>
  - `Name` [string]
    
    
  - `Value` [string]
    
    
  - `Url` [string]? *(опционально)*
    
    Либо url, либо домен/путь обязательны. Опционально.
  - `Domain` [string]? *(опционально)*
    
    Чтобы куки применялись ко всем поддоменам, добавьте точку перед доменом, например: ".example.com". Либо url, либо домен/путь обязательны. Опционально.
  - `Path` [string]? *(опционально)*
    
    Либо url, либо домен/путь обязательны. Опционально.
  - `Expires` [float]? *(опционально)*
    
    Время Unix в секундах. Опционально.
  - `HttpOnly` [bool]? *(опционально)*
    
    Опционально.
  - `Secure` [bool]? *(опционально)*
    
    Опционально.
  - `SameSite` `enum SameSiteAttribute { Strict, Lax, None }?` *(опционально)*
    
    Опционально.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-return"/><a href="#browser-context-add-cookies-return" class="list-anchor">#</a>

---

### AddInitScriptAsync {#browser-context-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.AddInitScriptAsync</x-search>

Добавляет скрипт, который будет выполнен в одном из следующих сценариев:
* Всякий раз, когда страница создается в контексте браузера или происходит навигация.
* Всякий раз, когда дочерний фрейм прикрепляется или происходит навигация в любом фрейме в контексте браузера. В этом случае скрипт выполняется в контексте вновь прикрепленного фрейма.

Скрипт выполняется после создания документа, но до выполнения любых его скриптов. Это полезно для изменения среды JavaScript, например, для задания начального значения `Math.random`.

**Использование**

Пример переопределения `Math.random` перед загрузкой страницы:

```js
// preload.js
Math.random = () => 42;
```

```csharp
await Context.AddInitScriptAsync(scriptPath: "preload.js");
```

:::note
Порядок выполнения нескольких скриптов, установленных через [BrowserContext.AddInitScriptAsync()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [Page.AddInitScriptAsync()](/api/class-page.mdx#page-add-init-script), не определен.
:::

**Аргументы**
- `script` [string] | [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-option-script"/><a href="#browser-context-add-init-script-option-script" class="list-anchor">#</a>
  
  Скрипт, который будет выполнен на всех страницах в контексте браузера.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-return"/><a href="#browser-context-add-init-script-return" class="list-anchor">#</a>

---

### BackgroundPages {#browser-context-background-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.BackgroundPages</x-search>

:::note

Фоновые страницы поддерживаются только в браузерах на основе Chromium.
:::

Все существующие фоновые страницы в контексте.

**Использование**

```csharp
BrowserContext.BackgroundPages
```

**Возвращает**
- [IEnumerable]&lt;[Page]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-background-pages-return"/><a href="#browser-context-background-pages-return" class="list-anchor">#</a>

---

### Browser {#browser-context-browser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.Browser</x-search>

Возвращает экземпляр браузера контекста. Если он был запущен как постоянный контекст, возвращается null.

**Использование**

```csharp
BrowserContext.Browser
```

**Возвращает**
- [Browser]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-browser-return"/><a href="#browser-context-browser-return" class="list-anchor">#</a>

---

### ClearCookiesAsync {#browser-context-clear-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.ClearCookiesAsync</x-search>

Удаляет куки из контекста. Принимает необязательный фильтр.

**Использование**

```csharp
await context.ClearCookiesAsync();
await context.ClearCookiesAsync(new() { Name = "session-id" });
await context.ClearCookiesAsync(new() { Domain = "my-origin.com" });
await context.ClearCookiesAsync(new() { Path = "/api/v1" });
await context.ClearCookiesAsync(new() { Name = "session-id", Domain = "my-origin.com" });
```

**Аргументы**
- `options` `BrowserContextClearCookiesOptions?` *(опционально)*
  - `Domain|DomainRegex` [string]? | [Regex]? *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-domain"/><a href="#browser-context-clear-cookies-option-domain" class="list-anchor">#</a>
    
    Удаляет только куки с указанным доменом.
  - `Name|NameRegex` [string]? | [Regex]? *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-name"/><a href="#browser-context-clear-cookies-option-name" class="list-anchor">#</a>
    
    Удаляет только куки с указанным именем.
  - `Path|PathRegex` [string]? | [Regex]? *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-path"/><a href="#browser-context-clear-cookies-option-path" class="list-anchor">#</a>
    
    Удаляет только куки с указанным путем.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-return"/><a href="#browser-context-clear-cookies-return" class="list-anchor">#</a>

---

### ClearPermissionsAsync {#browser-context-clear-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.ClearPermissionsAsync</x-search>

Очищает все переопределения разрешений для контекста браузера.

**Использование**

```csharp
var context = await browser.NewContextAsync();
await context.GrantPermissionsAsync(new[] { "clipboard-read" });
// В качестве альтернативы, вы можете использовать вспомогательный класс ContextPermissions
// для указания разрешений...
// выполняйте действия ...
await context.ClearPermissionsAsync();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-permissions-return"/><a href="#browser-context-clear-permissions-return" class="list-anchor">#</a>

---

### CloseAsync {#browser-context-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.CloseAsync</x-search>

Закрывает контекст браузера. Все страницы, принадлежащие контексту браузера, будут закрыты.

:::note

Контекст браузера по умолчанию не может быть закрыт.
:::

**Использование**

```csharp
await BrowserContext.CloseAsync(options);
```

**Аргументы**
- `options` `BrowserContextCloseOptions?` *(опционально)*
  - `Reason` [string]? *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-option-reason"/><a href="#browser-context-close-option-reason" class="list-anchor">#</a>
    
    Причина, которая будет сообщена операциям, прерванным закрытием контекста.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-return"/><a href="#browser-context-close-return" class="list-anchor">#</a>

---

### CookiesAsync {#browser-context-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.CookiesAsync</x-search>

Если URL-адреса не указаны, этот метод возвращает все куки. Если URL-адреса указаны, возвращаются только куки, которые влияют на эти URL-адреса.

**Использование**

```csharp
await BrowserContext.CookiesAsync(urls);
```

**Аргументы**
- `urls` [string]? | [IEnumerable]?&lt;[string]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-option-urls"/><a href="#browser-context-cookies-option-urls" class="list-anchor">#</a>
  
  Необязательный список URL-адресов.

**Возвращает**
- [IEnumerable]&lt;`Cookie`&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-return"/><a href="#browser-context-cookies-return" class="list-anchor">#</a>
  - `name` [string]
    
    
  - `value` [string]
    
    
  - `domain` [string]
    
    
  - `path` [string]
    
    
  - `expires` [float]
    
    Время Unix в секундах.
  - `httpOnly` [bool]
    
    
  - `secure` [bool]
    
    
  - `sameSite` `enum SameSiteAttribute { Strict, Lax, None }`
    
    
---

### ExposeBindingAsync {#browser-context-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.ExposeBindingAsync</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-binding-option-name) в объект `window` каждого фрейма на каждой странице в контексте. При вызове функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback). Если [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) содержит информацию о вызывающем: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

См. [Page.ExposeBindingAsync()](/api/class-page.mdx#page-expose-binding) для версии только для страницы.

**Использование**

Пример предоставления URL страницы всем фреймам на всех страницах в контексте:

```csharp
using Microsoft.Playwright;

using var playwright = await Playwright.CreateAsync();
var browser = await playwright.Webkit.LaunchAsync(new() { Headless = false });
var context = await browser.NewContextAsync();

await context.ExposeBindingAsync("pageURL", source => source.Page.Url);
var page = await context.NewPageAsync();
await page.SetContentAsync("<script>\n" +
"  async function onClick() {\n" +
"    document.querySelector('div').textContent = await window.pageURL();\n" +
"  }\n" +
"</script>\n" +
"<button onclick=\"onClick()\">Click me</button>\n" +
"<div></div>");
await page.GetByRole(AriaRole.Button).ClickAsync();
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-name"/><a href="#browser-context-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Action]&lt;BindingSource, T, [TResult]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-callback"/><a href="#browser-context-expose-binding-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.
- `options` `BrowserContextExposeBindingOptions?` *(опционально)*
  - `Handle` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-handle"/><a href="#browser-context-expose-binding-option-handle" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция будет удалена в будущем.
    :::
    
    
    Передавать аргумент как handle, вместо передачи по значению. При передаче handle поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-return"/><a href="#browser-context-expose-binding-return" class="list-anchor">#</a>

---

### ExposeFunctionAsync {#browser-context-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.ExposeFunctionAsync</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-function-option-name) в объект `window` каждого фрейма на каждой странице в контексте. При вызове функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback).

Если [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) возвращает [Promise], он будет ожидаться.

См. [Page.ExposeFunctionAsync()](/api/class-page.mdx#page-expose-function) для версии только для страницы.

**Использование**

Пример добавления функции `sha256` на все страницы в контексте:

```csharp
using Microsoft.Playwright;
using System;
using System.Security.Cryptography;
using System.Threading.Tasks;

class BrowserContextExamples
{
    public static async Task Main()
    {
        using var playwright = await Playwright.CreateAsync();
        var browser = await playwright.Webkit.LaunchAsync(new() { Headless = false });
        var context = await browser.NewContextAsync();

        await context.ExposeFunctionAsync("sha256", (string input) =>
        {
            return Convert.ToBase64String(
                SHA256.Create().ComputeHash(System.Text.Encoding.UTF8.GetBytes(input)));
        });

        var page = await context.NewPageAsync();
        await page.SetContentAsync("<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>");

        await page.GetByRole(AriaRole.Button).ClickAsync();
        Console.WriteLine(await page.TextContentAsync("div"));
    }
}
```

**Аргументы**
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-name"/><a href="#browser-context-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` [Action]&lt;T, [TResult]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-callback"/><a href="#browser-context-expose-function-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-return"/><a href="#browser-context-expose-function-return" class="list-anchor">#</a>

---

### GrantPermissionsAsync {#browser-context-grant-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.GrantPermissionsAsync</x-search>

Предоставляет указанные разрешения для контекста браузера. Предоставляет соответствующие разрешения только для указанного источника, если он указан.

**Использование**

```csharp
await BrowserContext.GrantPermissionsAsync(permissions, options);
```

**Аргументы**
- `permissions` [IEnumerable]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-permissions"/><a href="#browser-context-grant-permissions-option-permissions" class="list-anchor">#</a>
  
  Список разрешений для предоставления.
  
  :::danger
  
  Поддерживаемые разрешения различаются между браузерами и даже между разными версиями одного и того же браузера. Любое разрешение может перестать работать после обновления.
  :::
  
  Вот некоторые разрешения, которые могут поддерживаться некоторыми браузерами:
  * `'accelerometer'`
  * `'ambient-light-sensor'`
  * `'background-sync'`
  * `'camera'`
  * `'clipboard-read'`
  * `'clipboard-write'`
  * `'geolocation'`
  * `'gyroscope'`
  * `'magnetometer'`
  * `'microphone'`
  * `'midi-sysex'` (системно-эксклюзивный midi)
  * `'midi'`
  * `'notifications'`
  * `'payment-handler'`
  * `'storage-access'`
- `options` `BrowserContextGrantPermissionsOptions?` *(опционально)*
  - `Origin` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-origin"/><a href="#browser-context-grant-permissions-option-origin" class="list-anchor">#</a>
    
    [Источник], для которого предоставляются разрешения, например, "https://example.com".

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-return"/><a href="#browser-context-grant-permissions-return" class="list-anchor">#</a>

---

### NewCDPSessionAsync {#browser-context-new-cdp-session}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.NewCDPSessionAsync</x-search>

:::note

Сессии CDP поддерживаются только в браузерах на основе Chromium.
:::

Возвращает вновь созданную сессию.

**Использование**

```csharp
await BrowserContext.NewCDPSessionAsync(page);
```

**Аргументы**
- `page` [Page] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-option-page"/><a href="#browser-context-new-cdp-session-option-page" class="list-anchor">#</a>
  
  Цель для создания новой сессии. Для обратной совместимости этот параметр называется `page`, но он может быть типа `Page` или `Frame`.

**Возвращает**
- [CDPSession]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-return"/><a href="#browser-context-new-cdp-session-return" class="list-anchor">#</a>

---

### NewPageAsync {#browser-context-new-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.NewPageAsync</x-search>

Создает новую страницу в контексте браузера.

**Использование**

```csharp
await BrowserContext.NewPageAsync();
```

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-page-return"/><a href="#browser-context-new-page-return" class="list-anchor">#</a>

---

### Pages {#browser-context-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.Pages</x-search>

Возвращает все открытые страницы в контексте.

**Использование**

```csharp
BrowserContext.Pages
```

**Возвращает**
- [IEnumerable]&lt;[Page]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-pages-return"/><a href="#browser-context-pages-return" class="list-anchor">#</a>

---

### RouteAsync {#browser-context-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.RouteAsync</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются любой страницей в контексте браузера. Как только маршрут включен, каждый запрос, соответствующий шаблону URL, будет приостановлен, если он не будет продолжен, выполнен или прерван.

:::note

[BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) не будет перехватывать запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [ServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

**Использование**

Пример простого обработчика, который прерывает все запросы изображений:

```csharp
var context = await browser.NewContextAsync();
var page = await context.NewPageAsync();
await context.RouteAsync("**/*.{png,jpg,jpeg}", r => r.AbortAsync());
await page.GotoAsync("https://theverge.com");
await browser.CloseAsync();
```

или тот же фрагмент с использованием шаблона регулярного выражения:

```csharp
var context = await browser.NewContextAsync();
var page = await context.NewPageAsync();
await context.RouteAsync(new Regex("(\\.png$)|(\\.jpg$)"), r => r.AbortAsync());
await page.GotoAsync("https://theverge.com");
await browser.CloseAsync();
```

Возможно исследовать запрос, чтобы решить, какое действие маршрута предпринять. Например, имитация всех запросов, содержащих некоторые данные POST, и оставление всех остальных запросов без изменений:

```csharp
await page.RouteAsync("/api/**", async r =>
{
    if (r.Request.PostData.Contains("my-string"))
        await r.FulfillAsync(new() { Body = "mocked-data" });
    else
        await r.ContinueAsync();
});
```

Маршруты страниц (установленные с помощью [Page.RouteAsync()](/api/class-page.mdx#page-route)) имеют приоритет над маршрутами контекста браузера, когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [BrowserContext.UnrouteAsync()](/api/class-browsercontext.mdx#browser-context-unroute).

:::note

Включение маршрутизации отключает http-кэш.
:::

**Аргументы**
- `url` [string] | [Regex] | [Func]&lt;[string], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-url"/><a href="#browser-context-route-option-url" class="list-anchor">#</a>
  
  Шаблон глоба, шаблон регулярного выражения или предикат, получающий [URL] для сопоставления при маршрутизации. Когда [BaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) через параметры контекста был предоставлен и переданный URL является путем, он объединяется через [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) конструктор.
- `handler` [Action]&lt;[Route]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-handler"/><a href="#browser-context-route-option-handler" class="list-anchor">#</a>
  
  Функция обработчика для маршрутизации запроса.
- `options` `BrowserContextRouteOptions?` *(опционально)*
  - `Times` [int]? *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-times"/><a href="#browser-context-route-option-times" class="list-anchor">#</a>
    
    Сколько раз маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-return"/><a href="#browser-context-route-return" class="list-anchor">#</a>

---

### RouteFromHARAsync {#browser-context-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>browserContext.RouteFromHARAsync</x-search>

Если указано, сетевые запросы, сделанные в контексте, будут обслуживаться из HAR-файла. Подробнее читайте в разделе [Воспроизведение из HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из HAR-файла. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [ServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```csharp
await BrowserContext.RouteFromHARAsync(har, options);
```

**Аргументы**
- `har` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-har"/><a href="#browser-context-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec) файлу с предварительно записанными сетевыми данными. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `options` `BrowserContextRouteFromHAROptions?` *(опционально)*
  - `NotFound` `enum HarNotFound { Abort, Fallback }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-not-found"/><a href="#browser-context-route-from-har-option-not-found" class="list-anchor">#</a>
    * Если установлено значение 'abort', любой запрос, не найденный в HAR-файле, будет прерван.
    * Если установлено значение 'fallback', переходит к следующему обработчику маршрута в цепочке обработчиков.
    
    По умолчанию прерывается.
  - `Update` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update"/><a href="#browser-context-route-from-har-option-update" class="list-anchor">#</a>
    
    Если указано, обновляет данный HAR с фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск, когда вызывается [BrowserContext.CloseAsync()](/api/class-browsercontext.mdx#browser-context-close).
  - `UpdateContent` `enum RouteFromHarUpdateContentPolicy { Embed, Attach }?` *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-content"/><a href="#browser-context-route-from-har-option-update-content" class="list-anchor">#</a>
    
    Опциональная настройка для управления содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP-архиве. Если указано `embed`, содержимое хранится встроенным в HAR-файл.
  - `UpdateMode` `enum HarMode { Full, Minimal }?` *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-mode"/><a href="#browser-context-route-from-har-option-update-mode" class="list-anchor">#</a>
    
    Когда установлено значение `minimal`, записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницу, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию `minimal`.
  - `Url|UrlRegex` [string]? | [Regex]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-url"/><a href="#browser-context-route-from-har-option-url" class="list-anchor">#</a>
    
    Шаблон глоба, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR-файла. Если не указано, все запросы обслуживаются из HAR-файла.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-return"/><a href="#browser-context-route-from-har-return" class="list-anchor">#</a>

---

### RouteWebSocketAsync {#browser-context-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>browserContext.RouteWebSocketAsync</x-search>

Этот метод позволяет изменять соединения WebSocket, которые создаются любой страницей в контексте браузера.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизироваться. Рекомендуется вызывать этот метод перед созданием любых страниц.

**Использование**

Ниже приведен пример простого обработчика, который блокирует некоторые сообщения WebSocket. Подробнее и примеры смотрите в [WebSocketRoute].

```csharp
await context.RouteWebSocketAsync("/ws", async ws => {
  ws.RouteSend(message => {
    if (message == "to-be-blocked")
      return;
    ws.Send(message);
  });
  await ws.ConnectAsync();
});
```

**Аргументы**
- `url` [string] | [Regex] | [Func]&lt;[string], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-url"/><a href="#browser-context-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизироваться. Строковый шаблон может быть относительным к опции контекста [BaseURL](/api/class-browser.mdx#browser-new-context-option-base-url).
- `handler` [Action]&lt;[WebSocketRoute]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-handler"/><a href="#browser-context-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-return"/><a href="#browser-context-route-web-socket-return" class="list-anchor">#</a>

---

### RunAndWaitForConsoleMessageAsync {#browser-context-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.RunAndWaitForConsoleMessageAsync</x-search>

Выполняет действие и ждет, пока [ConsoleMessage] не будет зарегистрировано на страницах в контексте. Если предикат предоставлен, он передает значение [ConsoleMessage] в функцию `predicate` и ждет, пока `predicate(message)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [BrowserContext.Console](/api/class-browsercontext.mdx#browser-context-event-console) будет вызвано.

**Использование**

```csharp
await BrowserContext.RunAndWaitForConsoleMessageAsync(action, options);
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-action"/><a href="#browser-context-wait-for-console-message-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `BrowserContextRunAndWaitForConsoleMessageOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[ConsoleMessage]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-predicate"/><a href="#browser-context-wait-for-console-message-option-predicate" class="list-anchor">#</a>
    
    Получает объект [ConsoleMessage] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-timeout"/><a href="#browser-context-wait-for-console-message-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [ConsoleMessage]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-return"/><a href="#browser-context-wait-for-console-message-return" class="list-anchor">#</a>

---

### WaitForConsoleMessageAsync {#browser-context-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.WaitForConsoleMessageAsync</x-search>

Выполняет действие и ждет, пока [ConsoleMessage] не будет зарегистрировано на страницах в контексте. Если предикат предоставлен, он передает значение [ConsoleMessage] в функцию `predicate` и ждет, пока `predicate(message)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [BrowserContext.Console](/api/class-browsercontext.mdx#browser-context-event-console) будет вызвано.

**Использование**

```csharp
await BrowserContext.WaitForConsoleMessageAsync(action, options);
```

**Аргументы**
- `options` `BrowserContextRunAndWaitForConsoleMessageOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[ConsoleMessage]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-predicate"/><a href="#browser-context-wait-for-console-message-option-predicate" class="list-anchor">#</a>
    
    Получает объект [ConsoleMessage] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-timeout"/><a href="#browser-context-wait-for-console-message-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [ConsoleMessage]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-return"/><a href="#browser-context-wait-for-console-message-return" class="list-anchor">#</a>

---

### RunAndWaitForPageAsync {#browser-context-wait-for-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>browserContext.RunAndWaitForPageAsync</x-search>

Выполняет действие и ждет, пока в контексте не будет создана новая [Page]. Если предикат предоставлен, он передает значение [Page] в функцию `predicate` и ждет, пока `predicate(event)` не вернет истинное значение. Выдаст ошибку, если контекст закроется до создания новой [Page].

**Использование**

```csharp
await BrowserContext.RunAndWaitForPageAsync(action, options);
```

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-action"/><a href="#browser-context-wait-for-page-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `BrowserContextRunAndWaitForPageOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Page]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-predicate"/><a href="#browser-context-wait-for-page-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Page] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-timeout"/><a href="#browser-context-wait-for-page-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-return"/><a href="#browser-context-wait-for-page-return" class="list-anchor">#</a>

---

### WaitForPageAsync {#browser-context-wait-for-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>browserContext.WaitForPageAsync</x-search>

Выполняет действие и ждет, пока в контексте не будет создана новая [Page]. Если предикат предоставлен, он передает значение [Page] в функцию `predicate` и ждет, пока `predicate(event)` не вернет истинное значение. Выдаст ошибку, если контекст закроется до создания новой [Page].

**Использование**

```csharp
await BrowserContext.WaitForPageAsync(action, options);
```

**Аргументы**
- `options` `BrowserContextRunAndWaitForPageOptions?` *(опционально)*
  - `Predicate` [Func]&lt;[Page]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-predicate"/><a href="#browser-context-wait-for-page-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Page] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-timeout"/><a href="#browser-context-wait-for-page-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-return"/><a href="#browser-context-wait-for-page-return" class="list-anchor">#</a>

---

### SetDefaultNavigationTimeout {#browser-context-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.SetDefaultNavigationTimeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных с ними ярлыков:
* [Page.GoBackAsync()](/api/class-page.mdx#page-go-back)
* [Page.GoForwardAsync()](/api/class-page.mdx#page-go-forward)
* [Page.GotoAsync()](/api/class-page.mdx#page-goto)
* [Page.ReloadAsync()](/api/class-page.mdx#page-reload)
* [Page.SetContentAsync()](/api/class-page.mdx#page-set-content)
* [Page.RunAndWaitForNavigationAsync()](/api/class-page.mdx#page-wait-for-navigation)

:::note

[Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) и [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) имеют приоритет над [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```csharp
BrowserContext.SetDefaultNavigationTimeout(timeout);
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-navigation-timeout-option-timeout"/><a href="#browser-context-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### SetDefaultTimeout {#browser-context-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.SetDefaultTimeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих опцию [timeout](/api/class-browsercontext.mdx#browser-context-set-default-timeout-option-timeout).

:::note

[Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout), [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) и [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout) имеют приоритет над [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
:::

**Использование**

```csharp
BrowserContext.SetDefaultTimeout(timeout);
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-timeout-option-timeout"/><a href="#browser-context-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### SetExtraHTTPHeadersAsync {#browser-context-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.SetExtraHTTPHeadersAsync</x-search>

Дополнительные HTTP-заголовки будут отправляться с каждым запросом, инициированным любой страницей в контексте. Эти заголовки объединяются с дополнительными HTTP-заголовками, установленными для страницы с помощью [Page.SetExtraHTTPHeadersAsync()](/api/class-page.mdx#page-set-extra-http-headers). Если страница переопределяет конкретный заголовок, будет использоваться значение заголовка, специфичное для страницы, вместо значения заголовка контекста браузера.

:::note

[BrowserContext.SetExtraHTTPHeadersAsync()](/api/class-browsercontext.mdx#browser-context-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```csharp
await BrowserContext.SetExtraHTTPHeadersAsync(headers);
```

**Аргументы**
- `headers` [IDictionary]&lt;[string], [string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-option-headers"/><a href="#browser-context-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP-заголовки, которые будут отправляться с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-return"/><a href="#browser-context-set-extra-http-headers-return" class="list-anchor">#</a>

---

### SetGeolocationAsync {#browser-context-set-geolocation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.SetGeolocationAsync</x-search>

Устанавливает геолокацию контекста. Передача `null` или `undefined` эмулирует недоступность позиции.

**Использование**

```csharp
await context.SetGeolocationAsync(new Geolocation()
{
    Latitude = 59.95f,
    Longitude = 30.31667f
});
```

:::note
Рассмотрите возможность использования [BrowserContext.GrantPermissionsAsync()](/api/class-browsercontext.mdx#browser-context-grant-permissions) для предоставления разрешений страницам контекста браузера на чтение его геолокации.
:::

**Аргументы**
- `geolocation` Geolocation?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-option-geolocation"/><a href="#browser-context-set-geolocation-option-geolocation" class="list-anchor">#</a>
  - `Latitude` [float]
    
    Широта между -90 и 90.
  - `Longitude` [float]
    
    Долгота между -180 и 180.
  - `Accuracy` [float]? *(опционально)*
    
    Неотрицательное значение точности. По умолчанию `0`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-return"/><a href="#browser-context-set-geolocation-return" class="list-anchor">#</a>

---

### SetOfflineAsync {#browser-context-set-offline}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.SetOfflineAsync</x-search>

**Использование**

```csharp
await BrowserContext.SetOfflineAsync(offline);
```

**Аргументы**
- `offline` [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-option-offline"/><a href="#browser-context-set-offline-option-offline" class="list-anchor">#</a>
  
  Эмулировать ли отсутствие сети для контекста браузера.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-return"/><a href="#browser-context-set-offline-return" class="list-anchor">#</a>

---

### StorageStateAsync {#browser-context-storage-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.StorageStateAsync</x-search>

Возвращает состояние хранилища для этого контекста браузера, содержит текущие куки, снимок локального хранилища и снимок IndexedDB.

**Использование**

```csharp
await BrowserContext.StorageStateAsync(options);
```

**Аргументы**
- `options` `BrowserContextStorageStateOptions?` *(опционально)*
  - `IndexedDB` [bool]? *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-indexed-db"/><a href="#browser-context-storage-state-option-indexed-db" class="list-anchor">#</a>
    
    Установите в `true`, чтобы включить [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) в снимок состояния хранилища. Если ваше приложение использует IndexedDB для хранения токенов аутентификации, таких как Firebase Authentication, включите это.
    
    :::note
    
    IndexedDB с типизированными массивами в настоящее время не поддерживается.
    :::
    
  - `Path` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-path"/><a href="#browser-context-storage-state-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения состояния хранилища. Если [Path](/api/class-browsercontext.mdx#browser-context-storage-state-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, состояние хранилища все равно возвращается, но не будет сохранено на диск.

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-return"/><a href="#browser-context-storage-state-return" class="list-anchor">#</a>

---

### UnrouteAsync {#browser-context-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.UnrouteAsync</x-search>

Удаляет маршрут, созданный с помощью [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route). Когда [handler](/api/class-browsercontext.mdx#browser-context-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-browsercontext.mdx#browser-context-unroute-option-url).

**Использование**

```csharp
await BrowserContext.UnrouteAsync(url, handler);
```

**Аргументы**
- `url` [string] | [Regex] | [Func]&lt;[string], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-url"/><a href="#browser-context-unroute-option-url" class="list-anchor">#</a>
  
  Шаблон глоба, шаблон регулярного выражения или предикат, получающий [URL], использованный для регистрации маршрутизации с [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route).
- `handler` [Action]&lt;[Route]?&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-handler"/><a href="#browser-context-unroute-option-handler" class="list-anchor">#</a>
  
  Опциональная функция-обработчик, использованная для регистрации маршрутизации с [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-return"/><a href="#browser-context-unroute-return" class="list-anchor">#</a>

---

### UnrouteAllAsync {#browser-context-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.41</font><x-search>browserContext.UnrouteAllAsync</x-search>

Удаляет все маршруты, созданные с помощью [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) и [BrowserContext.RouteFromHARAsync()](/api/class-browsercontext.mdx#browser-context-route-from-har).

**Использование**

```csharp
await BrowserContext.UnrouteAllAsync(options);
```

**Аргументы**
- `options` `BrowserContextUnrouteAllOptions?` *(опционально)*
  - `Behavior` `enum UnrouteBehavior { Wait, IgnoreErrors, Default }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-all-option-behavior"/><a href="#browser-context-unroute-all-option-behavior" class="list-anchor">#</a>
    
    Указывает, ждать ли уже выполняющихся обработчиков и что делать, если они выбрасывают ошибки:
    * `'default'` - не ждать завершения текущих вызовов обработчиков (если есть), если удаленный обработчик выбрасывает ошибку, это может привести к необработанной ошибке
    * `'wait'` - ждать завершения текущих вызовов обработчиков (если есть)
    * `'ignoreErrors'` - не ждать завершения текущих вызовов обработчиков (если есть), все ошибки, выброшенные обработчиками после удаления маршрутизации, тихо перехватываются

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-all-return"/><a href="#browser-context-unroute-all-return" class="list-anchor">#</a>

---

## Свойства

### APIRequest {#browser-context-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.16</font><x-search>browserContext.APIRequest</x-search>

Помощник для тестирования API, связанный с этим контекстом. Запросы, сделанные с помощью этого API, будут использовать куки контекста.

**Использование**

```csharp
BrowserContext.APIRequest
```

**Тип**
- [APIRequestContext]

---

### Clock {#browser-context-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.45</font><x-search>browserContext.Clock</x-search>

Playwright имеет возможность имитировать часы и ход времени.

**Использование**

```csharp
BrowserContext.Clock
```

**Тип**
- [Clock]

---

### Tracing {#browser-context-tracing}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.Tracing</x-search>

**Использование**

```csharp
BrowserContext.Tracing
```

**Тип**
- [Tracing]

---

## События

### event BackgroundPage {#browser-context-event-background-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.event BackgroundPage</x-search>

:::note

Работает только с постоянным контекстом браузера Chromium.
:::

Вызывается, когда в контексте создается новая фоновая страница.

```csharp
context.BackgroundPage += (_, backgroundPage) =>
{
    Console.WriteLine(backgroundPage.Url);
};

```

**Использование**

```csharp
BrowserContext.BackgroundPage += async (_, page) => {};
```

**Данные события**
- [Page]

---

### event Close {#browser-context-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.event Close</x-search>

Вызывается, когда контекст браузера закрывается. Это может произойти по одной из следующих причин:
* Контекст браузера закрыт.
* Приложение браузера закрыто или аварийно завершено.
* Метод [Browser.CloseAsync()](/api/class-browser.mdx#browser-close) был вызван.

**Использование**

```csharp
BrowserContext.Close += async (_, browserContext) => {};
```

**Данные события**
- [BrowserContext]

---

### event Console {#browser-context-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.event Console</x-search>

Вызывается, когда JavaScript на странице вызывает один из методов консоли API, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, и страница доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

```csharp
context.Console += async (_, msg) =>
{
    foreach (var arg in msg.Args)
        Console.WriteLine(await arg.JsonValueAsync<object>());
};

await page.EvaluateAsync("console.log('hello', 5, { foo: 'bar' })");
```

**Данные события**
- [ConsoleMessage]

---

### событие Dialog {#browser-context-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.event Dialog</x-search>

Вызывается, когда появляется JavaScript-диалог, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Слушатель **должен** либо [Dialog.AcceptAsync()](/api/class-dialog.mdx#dialog-accept), либо [Dialog.DismissAsync()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница [заморозится](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалог, и действия, такие как клик, никогда не завершатся.

**Использование**

```csharp
Context.Dialog += async (_, dialog) =>
{
    await dialog.AcceptAsync();
};
```

:::note
Когда нет слушателей [Page.Dialog](/api/class-page.mdx#page-event-dialog) или [BrowserContext.Dialog](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### событие Page {#browser-context-event-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.event Page</x-search>

Событие вызывается, когда в BrowserContext создается новая страница. Страница может все еще загружаться. Событие также будет срабатывать для всплывающих страниц. См. также [Page.Popup](/api/class-page.mdx#page-event-popup) для получения событий о всплывающих окнах, относящихся к конкретной странице.

Самый ранний момент, когда страница доступна, это когда она перешла на начальный URL. Например, при открытии всплывающего окна с помощью `window.open('http://example.com')`, это событие сработает, когда сетевой запрос к "http://example.com" будет выполнен и его ответ начнет загружаться во всплывающем окне. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) и [BrowserContext.Request](/api/class-browsercontext.mdx#browser-context-event-request) соответственно, вместо аналогичных методов на [Page].

```csharp
var popup = await context.RunAndWaitForPageAsync(async =>
{
    await page.GetByText("open new page").ClickAsync();
});
Console.WriteLine(await popup.EvaluateAsync<string>("location.href"));
```

:::note
Используйте [Page.WaitForLoadStateAsync()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев это не потребуется).
:::

**Использование**

```csharp
BrowserContext.Page += async (_, page) => {};
```

**Данные события**
- [Page]

---

### событие Request {#browser-context-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.event Request</x-search>

Вызывается, когда запрос отправляется с любой страницы, созданной через этот контекст. Объект [request] доступен только для чтения. Чтобы слушать запросы только с определенной страницы, используйте [Page.Request](/api/class-page.mdx#page-event-request).

Для перехвата и изменения запросов, см. [BrowserContext.RouteAsync()](/api/class-browsercontext.mdx#browser-context-route) или [Page.RouteAsync()](/api/class-page.mdx#page-route).

**Использование**

```csharp
BrowserContext.Request += async (_, request) => {};
```

**Данные события**
- [Request]

---

### событие RequestFailed {#browser-context-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.event RequestFailed</x-search>

Вызывается, когда запрос не удается выполнить, например, из-за тайм-аута. Чтобы слушать только неудачные запросы с определенной страницы, используйте [Page.RequestFailed](/api/class-page.mdx#page-event-request-failed).

:::note

Ответы с HTTP-ошибками, такие как 404 или 503, все еще считаются успешными с точки зрения HTTP, поэтому запрос завершится событием [BrowserContext.RequestFinished](/api/class-browsercontext.mdx#browser-context-event-request-finished), а не [BrowserContext.RequestFailed](/api/class-browsercontext.mdx#browser-context-event-request-failed).
:::

**Использование**

```csharp
BrowserContext.RequestFailed += async (_, request) => {};
```

**Данные события**
- [Request]

---

### событие RequestFinished {#browser-context-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.event RequestFinished</x-search>

Вызывается, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`. Чтобы слушать успешные запросы с определенной страницы, используйте [Page.RequestFinished](/api/class-page.mdx#page-event-request-finished).

**Использование**

```csharp
BrowserContext.RequestFinished += async (_, request) => {};
```

**Данные события**
- [Request]

---

### событие Response {#browser-context-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.event Response</x-search>

Вызывается, когда статус и заголовки [response] получены для запроса. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`. Чтобы слушать события ответа с определенной страницы, используйте [Page.Response](/api/class-page.mdx#page-event-response).

**Использование**

```csharp
BrowserContext.Response += async (_, response) => {};
```

**Данные события**
- [Response]

---

### событие WebError {#browser-context-event-web-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.38</font><x-search>browserContext.event WebError</x-search>

Вызывается, когда исключение не обрабатывается на любой из страниц в этом контексте. Чтобы слушать ошибки с определенной страницы, используйте [Page.PageError](/api/class-page.mdx#page-event-page-error).

**Использование**

```csharp
BrowserContext.WebError += async (_, webError) => {};
```

**Данные события**
- [WebError]


[Accessibility]: /api/class-accessibility.mdx "Accessibility"
[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[CDPSessionEvent]: /api/class-cdpsessionevent.mdx "CDPSessionEvent"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[bool]: https://docs.microsoft.com/en-us/dotnet/api/system.boolean "bool"
[Date]: https://learn.microsoft.com/en-us/dotnet/api/system.datetime "DateTime"
[double]: https://docs.microsoft.com/en-us/dotnet/api/system.double "double"
[byte]: https://docs.microsoft.com/en-us/dotnet/api/system.byte "byte"
[int]: https://docs.microsoft.com/en-us/dotnet/api/system.int32 "int"
[long]: https://docs.microsoft.com/en-us/dotnet/api/system.int64 "long"
[void]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/void "void"
[string]: https://docs.microsoft.com/en-us/dotnet/api/system.string "string"
[URL]: https://nodejs.org/api/url.html "URL"
[Regex]: https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex "Regex"

[Action]: https://docs.microsoft.com/en-us/dotnet/api/system.action-1 "Action"
[Func]: https://docs.microsoft.com/en-us/dotnet/api/system.func-2 "Func"
[IEnumerable]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable "IEnumerable"
[IDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary "IDictionary"
[Task]: https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0 "Task"
[IReadOnlyDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2 "IReadOnlyDictionary"
[JsonElement]: https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement "JsonElement"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-dotnet/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
