---
id: class-frame
title: "Frame"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

В любой момент времени страница предоставляет текущее дерево фреймов через методы [Page.MainFrame](/api/class-page.mdx#page-main-frame) и [Frame.ChildFrames](/api/class-frame.mdx#frame-child-frames).

Жизненный цикл объекта [Frame] контролируется тремя событиями, отправляемыми на объекте страницы:
* [Page.FrameAttached](/api/class-page.mdx#page-event-frame-attached) - срабатывает, когда фрейм присоединяется к странице. Фрейм может быть присоединен к странице только один раз.
* [Page.FrameNavigated](/api/class-page.mdx#page-event-frame-navigated) - срабатывает, когда фрейм совершает навигацию на другой URL.
* [Page.FrameDetached](/api/class-page.mdx#page-event-frame-detached) - срабатывает, когда фрейм отсоединяется от страницы. Фрейм может быть отсоединен от страницы только один раз.

Пример вывода дерева фреймов:

```csharp
using Microsoft.Playwright;
using System;
using System.Threading.Tasks;

class FrameExamples
{
    public static async Task Main()
    {
        using var playwright = await Playwright.CreateAsync();
        await using var browser = await playwright.Firefox.LaunchAsync();
        var page = await browser.NewPageAsync();

        await page.GotoAsync("https://www.bing.com");
        DumpFrameTree(page.MainFrame, string.Empty);
    }

    private static void DumpFrameTree(IFrame frame, string indent)
    {
        Console.WriteLine($"{indent}{frame.Url}");
        foreach (var child in frame.ChildFrames)
            DumpFrameTree(child, indent + " ");
    }
}
```

---

## Методы

### AddScriptTagAsync {#frame-add-script-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.AddScriptTagAsync</x-search>

Возвращает добавленный тег, когда срабатывает событие onload скрипта или когда содержимое скрипта было внедрено в фрейм.

Добавляет тег `<script>` на страницу с указанным URL или содержимым.

**Использование**

```csharp
await Frame.AddScriptTagAsync(options);
```

**Аргументы**
- `options` `FrameAddScriptTagOptions?` *(опционально)*
  - `Content` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-add-script-tag-option-content"/><a href="#frame-add-script-tag-option-content" class="list-anchor">#</a>
    
    Сырой JavaScript-контент для внедрения в фрейм.
  - `Path` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-add-script-tag-option-path"/><a href="#frame-add-script-tag-option-path" class="list-anchor">#</a>
    
    Путь к JavaScript-файлу для внедрения в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `Type` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-add-script-tag-option-type"/><a href="#frame-add-script-tag-option-type" class="list-anchor">#</a>
    
    Тип скрипта. Используйте 'module', чтобы загрузить JavaScript ES6 модуль. Подробнее см. [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script).
  - `Url` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-add-script-tag-option-url"/><a href="#frame-add-script-tag-option-url" class="list-anchor">#</a>
    
    URL скрипта, который нужно добавить.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-add-script-tag-return"/><a href="#frame-add-script-tag-return" class="list-anchor">#</a>

---

### AddStyleTagAsync {#frame-add-style-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.AddStyleTagAsync</x-search>

Возвращает добавленный тег, когда срабатывает событие onload таблицы стилей или когда CSS-контент был внедрен в фрейм.

Добавляет тег `<link rel="stylesheet">` на страницу с указанным URL или тег `<style type="text/css">` с содержимым.

**Использование**

```csharp
await Frame.AddStyleTagAsync(options);
```

**Аргументы**
- `options` `FrameAddStyleTagOptions?` *(опционально)*
  - `Content` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-add-style-tag-option-content"/><a href="#frame-add-style-tag-option-content" class="list-anchor">#</a>
    
    Сырой CSS-контент для внедрения в фрейм.
  - `Path` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-add-style-tag-option-path"/><a href="#frame-add-style-tag-option-path" class="list-anchor">#</a>
    
    Путь к CSS-файлу для внедрения в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `Url` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-add-style-tag-option-url"/><a href="#frame-add-style-tag-option-url" class="list-anchor">#</a>
    
    URL тега `<link>`.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-add-style-tag-return"/><a href="#frame-add-style-tag-return" class="list-anchor">#</a>

---

### ChildFrames {#frame-child-frames}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.ChildFrames</x-search>

**Использование**

```csharp
Frame.ChildFrames
```

**Возвращает**
- [IReadOnlyList]&lt;[Frame]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-child-frames-return"/><a href="#frame-child-frames-return" class="list-anchor">#</a>

---

### ContentAsync {#frame-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.ContentAsync</x-search>

Получает полный HTML-контент фрейма, включая doctype.

**Использование**

```csharp
await Frame.ContentAsync();
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-content-return"/><a href="#frame-content-return" class="list-anchor">#</a>

---

### DragAndDropAsync {#frame-drag-and-drop}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>frame.DragAndDropAsync</x-search>

**Использование**

```csharp
await Frame.DragAndDropAsync(source, target, options);
```

**Аргументы**
- `source` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-source"/><a href="#frame-drag-and-drop-option-source" class="list-anchor">#</a>
  
  Селектор для поиска элемента, который нужно перетащить. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `target` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-target"/><a href="#frame-drag-and-drop-option-target" class="list-anchor">#</a>
  
  Селектор для поиска элемента, на который нужно сбросить. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameDragAndDropOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-force"/><a href="#frame-drag-and-drop-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-no-wait-after"/><a href="#frame-drag-and-drop-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `SourcePosition` SourcePosition? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-source-position"/><a href="#frame-drag-and-drop-option-source-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Clicks on the source element at this point relative to the top-left corner of the element's padding box. If not specified, some visible point of the element is used.
  - `Steps` [int]? *(optional)* <font size="2">Added in: v1.57</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-steps"/><a href="#frame-drag-and-drop-option-steps" class="list-anchor">#</a>
    
    Defaults to 1. Sends `n` interpolated `mousemove` events to represent travel between the `mousedown` and `mouseup` of the drag. When set to 1, emits a single `mousemove` event at the destination location.
  - `Strict` [bool]? *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-strict"/><a href="#frame-drag-and-drop-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `TargetPosition` TargetPosition? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-target-position"/><a href="#frame-drag-and-drop-option-target-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Сбрасывает на целевой элемент в этой точке относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-timeout"/><a href="#frame-drag-and-drop-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-option-trial"/><a href="#frame-drag-and-drop-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-drag-and-drop-return"/><a href="#frame-drag-and-drop-return" class="list-anchor">#</a>

---

### EvaluateAsync {#frame-evaluate}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.EvaluateAsync</x-search>

Возвращает значение, возвращаемое [expression](/api/class-frame.mdx#frame-evaluate-option-expression).

Если функция, переданная в [Frame.EvaluateAsync()](/api/class-frame.mdx#frame-evaluate), возвращает [Promise], то [Frame.EvaluateAsync()](/api/class-frame.mdx#frame-evaluate) будет ждать разрешения промиса и вернет его значение.

Если функция, переданная в [Frame.EvaluateAsync()](/api/class-frame.mdx#frame-evaluate), возвращает значение, не являющееся [Serializable], то [Frame.EvaluateAsync()](/api/class-frame.mdx#frame-evaluate) возвращает `undefined`. Playwright также поддерживает передачу некоторых дополнительных значений, которые не сериализуются через `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.

**Использование**

```csharp
var result = await frame.EvaluateAsync<int>("([x, y]) => Promise.resolve(x * y)", new[] { 7, 8 });
Console.WriteLine(result);
```

Также можно передать строку вместо функции.

```csharp
Console.WriteLine(await frame.EvaluateAsync<int>("1 + 2")); // выводит "3"
```

Экземпляры [ElementHandle] могут быть переданы в качестве аргумента в [Frame.EvaluateAsync()](/api/class-frame.mdx#frame-evaluate):

```csharp
var bodyHandle = await frame.EvaluateAsync("document.body");
var html = await frame.EvaluateAsync<string>("([body, suffix]) => body.innerHTML + suffix", new object [] { bodyHandle, "hello" });
await bodyHandle.DisposeAsync();
```

**Аргументы**
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-evaluate-option-expression"/><a href="#frame-evaluate-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-evaluate-option-arg"/><a href="#frame-evaluate-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [expression](/api/class-frame.mdx#frame-evaluate-option-expression).

**Возвращает**
- [object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-evaluate-return"/><a href="#frame-evaluate-return" class="list-anchor">#</a>

---

### EvaluateHandleAsync {#frame-evaluate-handle}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.EvaluateHandleAsync</x-search>

Возвращает значение, возвращаемое [expression](/api/class-frame.mdx#frame-evaluate-handle-option-expression) в виде [JSHandle].

Единственное отличие между [Frame.EvaluateAsync()](/api/class-frame.mdx#frame-evaluate) и [Frame.EvaluateHandleAsync()](/api/class-frame.mdx#frame-evaluate-handle) заключается в том, что [Frame.EvaluateHandleAsync()](/api/class-frame.mdx#frame-evaluate-handle) возвращает [JSHandle].

Если функция, переданная в [Frame.EvaluateHandleAsync()](/api/class-frame.mdx#frame-evaluate-handle), возвращает [Promise], то [Frame.EvaluateHandleAsync()](/api/class-frame.mdx#frame-evaluate-handle) будет ждать разрешения промиса и вернет его значение.

**Использование**

```csharp
// Обработчик для объекта window.
var aWindowHandle = await frame.EvaluateHandleAsync("() => Promise.resolve(window)");
```

Также можно передать строку вместо функции.

```csharp
var docHandle = await frame.EvaluateHandleAsync("document"); // Обработчик для `document`
```

Экземпляры [JSHandle] могут быть переданы в качестве аргумента в [Frame.EvaluateHandleAsync()](/api/class-frame.mdx#frame-evaluate-handle):

```csharp
var handle = await frame.EvaluateHandleAsync("() => document.body");
var resultHandle = await frame.EvaluateHandleAsync("([body, suffix]) => body.innerHTML + suffix", new object[] { handle, "hello" });
Console.WriteLine(await resultHandle.JsonValueAsync<string>());
await resultHandle.DisposeAsync();
```

**Аргументы**
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-evaluate-handle-option-expression"/><a href="#frame-evaluate-handle-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-evaluate-handle-option-arg"/><a href="#frame-evaluate-handle-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [expression](/api/class-frame.mdx#frame-evaluate-handle-option-expression).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-evaluate-handle-return"/><a href="#frame-evaluate-handle-return" class="list-anchor">#</a>

---

### FrameElementAsync {#frame-frame-element}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.FrameElementAsync</x-search>

Возвращает обработчик элемента `frame` или `iframe`, который соответствует этому фрейму.

Это обратное действие к [ElementHandle.ContentFrameAsync()](/api/class-elementhandle.mdx#element-handle-content-frame). Обратите внимание, что возвращаемый обработчик фактически принадлежит родительскому фрейму.

Этот метод выбрасывает ошибку, если фрейм был отсоединен до того, как `frameElement()` вернет значение.

**Использование**

```csharp
var frameElement = await frame.FrameElementAsync();
var contentFrame = await frameElement.ContentFrameAsync();
Console.WriteLine(frame == contentFrame); // -> True
```

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-frame-element-return"/><a href="#frame-frame-element-return" class="list-anchor">#</a>

---

### FrameLocator {#frame-frame-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.17</font><x-search>frame.FrameLocator</x-search>

При работе с iframes вы можете создать локатор фрейма, который войдет в iframe и позволит выбирать элементы в этом iframe.

**Использование**

Следующий фрагмент кода находит элемент с текстом "Submit" в iframe с id `my-frame`, например `<iframe id="my-frame">`:

```csharp
var locator = frame.FrameLocator("#my-iframe").GetByText("Submit");
await locator.ClickAsync();
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-frame-locator-option-selector"/><a href="#frame-frame-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении DOM-элемента.

**Возвращает**
- [FrameLocator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-frame-locator-return"/><a href="#frame-frame-locator-return" class="list-anchor">#</a>

---

### GetByAltText {#frame-get-by-alt-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>frame.GetByAltText</x-search>

Позволяет находить элементы по их alt-тексту.

**Использование**

Например, этот метод найдет изображение по alt-тексту "Playwright logo":

```html
<img alt='Playwright logo'>
```

```csharp
await page.GetByAltText("Playwright logo").ClickAsync();
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-alt-text-option-text"/><a href="#frame-get-by-alt-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `FrameGetByAltTextOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-alt-text-option-exact"/><a href="#frame-get-by-alt-text-option-exact" class="list-anchor">#</a>
    
    Нужно ли искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-alt-text-return"/><a href="#frame-get-by-alt-text-return" class="list-anchor">#</a>

---

### GetByLabel {#frame-get-by-label}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>frame.GetByLabel</x-search>

Позволяет находить элементы ввода по тексту связанного элемента `<label>` или элемента `aria-labelledby`, или по атрибуту `aria-label`.

**Использование**

Например, этот метод найдет поля ввода по меткам "Username" и "Password" в следующем DOM:

```html
<input aria-label="Username">
<label for="password-input">Password:</label>
<input id="password-input">
```

```csharp
await page.GetByLabel("Username").FillAsync("john");
await page.GetByLabel("Password").FillAsync("secret");
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-label-option-text"/><a href="#frame-get-by-label-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `FrameGetByLabelOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-label-option-exact"/><a href="#frame-get-by-label-option-exact" class="list-anchor">#</a>
    
    Нужно ли искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-label-return"/><a href="#frame-get-by-label-return" class="list-anchor">#</a>

---

### GetByPlaceholder {#frame-get-by-placeholder}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>frame.GetByPlaceholder</x-search>

Позволяет находить элементы ввода по тексту-заполнителю.

**Использование**

Например, рассмотрим следующую структуру DOM.

```html
<input type="email" placeholder="name@example.com" />
```

Вы можете заполнить поле ввода, найдя его по тексту-заполнителю:

```csharp
await page
    .GetByPlaceholder("name@example.com")
    .FillAsync("playwright@microsoft.com");
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-placeholder-option-text"/><a href="#frame-get-by-placeholder-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `FrameGetByPlaceholderOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-placeholder-option-exact"/><a href="#frame-get-by-placeholder-option-exact" class="list-anchor">#</a>
    
    Нужно ли искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-placeholder-return"/><a href="#frame-get-by-placeholder-return" class="list-anchor">#</a>

---

### GetByRole {#frame-get-by-role}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>frame.GetByRole</x-search>

Позволяет находить элементы по их [ARIA роли](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA атрибутам](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) и [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name).

**Использование**

Рассмотрим следующую структуру DOM.

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```

Вы можете найти каждый элемент по его неявной роли:

```csharp
await Expect(Page
    .GetByRole(AriaRole.Heading, new() { Name = "Sign up" }))
    .ToBeVisibleAsync();

await page
    .GetByRole(AriaRole.Checkbox, new() { Name = "Subscribe" })
    .CheckAsync();

await page
    .GetByRole(AriaRole.Button, new() {
        NameRegex = new Regex("submit", RegexOptions.IgnoreCase)
    })
    .ClickAsync();
```

**Аргументы**
- `role` `enum AriaRole { Alert, Alertdialog, Application, Article, Banner, Blockquote, Button, Caption, Cell, Checkbox, Code, Columnheader, Combobox, Complementary, Contentinfo, Definition, Deletion, Dialog, Directory, Document, Emphasis, Feed, Figure, Form, Generic, Grid, Gridcell, Group, Heading, Img, Insertion, Link, List, Listbox, Listitem, Log, Main, Marquee, Math, Meter, Menu, Menubar, Menuitem, Menuitemcheckbox, Menuitemradio, Navigation, None, Note, Option, Paragraph, Presentation, Progressbar, Radio, Radiogroup, Region, Row, Rowgroup, Rowheader, Scrollbar, Search, Searchbox, Separator, Slider, Spinbutton, Status, Strong, Subscript, Superscript, Switch, Tab, Table, Tablist, Tabpanel, Term, Textbox, Time, Timer, Toolbar, Tooltip, Tree, Treegrid, Treeitem }`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-role"/><a href="#frame-get-by-role-option-role" class="list-anchor">#</a>
  
  Требуемая aria роль.
- `options` `FrameGetByRoleOptions?` *(опционально)*
  - `Checked` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-checked"/><a href="#frame-get-by-role-option-checked" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-checked` или нативных `<input type=checkbox>` контролов.
    
    Узнайте больше о [`aria-checked`](https://www.w3.org/TR/wai-aria-1.2/#aria-checked).
  - `Disabled` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-disabled"/><a href="#frame-get-by-role-option-disabled" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-disabled` или `disabled`.
    
    :::note
    
    В отличие от большинства других атрибутов, `disabled` наследуется через иерархию DOM. Узнайте больше о [`aria-disabled`](https://www.w3.org/TR/wai-aria-1.2/#aria-disabled).
    :::
    
  - `Exact` [bool]? *(опционально)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-exact"/><a href="#frame-get-by-role-option-exact" class="list-anchor">#</a>
    
    Является ли [Name|NameRegex](/api/class-frame.mdx#frame-get-by-role-option-name) точным совпадением: с учетом регистра и всей строки. По умолчанию false. Игнорируется, когда [Name|NameRegex](/api/class-frame.mdx#frame-get-by-role-option-name) является регулярным выражением. Обратите внимание, что точное совпадение все равно обрезает пробелы.
  - `Expanded` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-expanded"/><a href="#frame-get-by-role-option-expanded" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-expanded`.
    
    Узнайте больше о [`aria-expanded`](https://www.w3.org/TR/wai-aria-1.2/#aria-expanded).
  - `IncludeHidden` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-include-hidden"/><a href="#frame-get-by-role-option-include-hidden" class="list-anchor">#</a>
    
    Опция, которая контролирует, соответствуют ли скрытые элементы. По умолчанию, только не скрытые элементы, как [определено ARIA](https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion), соответствуют селектору роли.
    
    Узнайте больше о [`aria-hidden`](https://www.w3.org/TR/wai-aria-1.2/#aria-hidden).
  - `Level` [int]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-level"/><a href="#frame-get-by-role-option-level" class="list-anchor">#</a>
    
    Числовой атрибут, который обычно присутствует для ролей `heading`, `listitem`, `row`, `treeitem`, с значениями по умолчанию для элементов `<h1>-<h6>`.
    
    Узнайте больше о [`aria-level`](https://www.w3.org/TR/wai-aria-1.2/#aria-level).
  - `Name|NameRegex` [string]? | [Regex]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-name"/><a href="#frame-get-by-role-option-name" class="list-anchor">#</a>
    
    Опция для сопоставления [доступного имени](https://w3c.github.io/accname/#dfn-accessible-name). По умолчанию, сопоставление не учитывает регистр и ищет подстроку, используйте [Exact](/api/class-frame.mdx#frame-get-by-role-option-exact) для управления этим поведением.
    
    Узнайте больше о [доступном имени](https://w3c.github.io/accname/#dfn-accessible-name).
  - `Pressed` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-pressed"/><a href="#frame-get-by-role-option-pressed" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-pressed`.
    
    Узнайте больше о [`aria-pressed`](https://www.w3.org/TR/wai-aria-1.2/#aria-pressed).
  - `Selected` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-option-selected"/><a href="#frame-get-by-role-option-selected" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается с помощью `aria-selected`.
    
    Узнайте больше о [`aria-selected`](https://www.w3.org/TR/wai-aria-1.2/#aria-selected).

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-role-return"/><a href="#frame-get-by-role-return" class="list-anchor">#</a>

**Детали**

Селектор роли **не заменяет** аудиты доступности и тесты на соответствие, но дает раннюю обратную связь о руководствах ARIA.

Многие HTML-элементы имеют неявно [определенную роль](https://w3c.github.io/html-aam/#html-element-role-mappings), которая распознается селектором роли. Вы можете найти все [поддерживаемые роли здесь](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). Руководства ARIA **не рекомендуют** дублировать неявные роли и атрибуты, устанавливая `role` и/или `aria-*` атрибуты на значения по умолчанию.

---

### GetByTestId {#frame-get-by-test-id}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>frame.GetByTestId</x-search>

Находит элемент по тестовому идентификатору.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<button data-testid="directions">Itinéraire</button>
```

Вы можете найти элемент по его тестовому идентификатору:

```csharp
await page.GetByTestId("directions").ClickAsync();
```

**Аргументы**
- `testId` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-test-id-option-test-id"/><a href="#frame-get-by-test-id-option-test-id" class="list-anchor">#</a>
  
  Идентификатор для поиска элемента.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-test-id-return"/><a href="#frame-get-by-test-id-return" class="list-anchor">#</a>

**Детали**

По умолчанию атрибут `data-testid` используется как тестовый идентификатор. Используйте [Selectors.SetTestIdAttribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute), чтобы настроить другой атрибут тестового идентификатора, если это необходимо.

---

### GetByText {#frame-get-by-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>frame.GetByText</x-search>

Позволяет находить элементы, содержащие заданный текст.

См. также [Locator.Filter()](/api/class-locator.mdx#locator-filter), который позволяет сопоставлять по другим критериям, таким как доступная роль, а затем фильтровать по содержимому текста.

**Использование**

Рассмотрим следующую структуру DOM:

```html
<div>Hello <span>world</span></div>
<div>Hello</div>
```

Вы можете найти по подстроке текста, точной строке или регулярному выражению:

```csharp
// Соответствует <span>
page.GetByText("world");

// Соответствует первому <div>
page.GetByText("Hello world");

// Соответствует второму <div>
page.GetByText("Hello", new() { Exact = true });

// Соответствует обоим <div>
page.GetByText(new Regex("Hello"));

// Соответствует второму <div>
page.GetByText(new Regex("^hello$", RegexOptions.IgnoreCase));
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-text-option-text"/><a href="#frame-get-by-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `FrameGetByTextOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-text-option-exact"/><a href="#frame-get-by-text-option-exact" class="list-anchor">#</a>
    
    Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-text-return"/><a href="#frame-get-by-text-return" class="list-anchor">#</a>

**Детали**

Сопоставление по тексту всегда нормализует пробелы, даже при точном совпадении. Например, оно превращает несколько пробелов в один, превращает разрывы строк в пробелы и игнорирует начальные и конечные пробелы.

Элементы ввода типа `button` и `submit` сопоставляются по их `value`, а не по содержимому текста. Например, поиск по тексту `"Log in"` соответствует `<input type=button value="Log in">`.

---

### GetByTitle {#frame-get-by-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.27</font><x-search>frame.GetByTitle</x-search>

Позволяет находить элементы по их атрибуту title.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<span title='Issues count'>25 issues</span>
```

Вы можете проверить количество проблем, найдя его по тексту заголовка:

```csharp
await Expect(Page.GetByTitle("Issues count")).toHaveText("25 issues");
```

**Аргументы**
- `text` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-title-option-text"/><a href="#frame-get-by-title-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `FrameGetByTitleOptions?` *(опционально)*
  - `Exact` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-title-option-exact"/><a href="#frame-get-by-title-option-exact" class="list-anchor">#</a>
    
    Искать точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-by-title-return"/><a href="#frame-get-by-title-return" class="list-anchor">#</a>

---

### GotoAsync {#frame-goto}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.GotoAsync</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация завершится с ответом последнего перенаправления.

Метод вызовет ошибку, если:
* произошла ошибка SSL (например, в случае самоподписанных сертификатов).
* целевой URL недействителен.
* [Timeout](/api/class-frame.mdx#frame-goto-option-timeout) превышен во время навигации.
* удаленный сервер не отвечает или недоступен.
* основной ресурс не удалось загрузить.

Метод не вызовет ошибку, если удаленный сервер вернет любой допустимый код состояния HTTP, включая 404 "Не найдено" и 500 "Внутренняя ошибка сервера". Код состояния для таких ответов можно получить, вызвав [Response.Status](/api/class-response.mdx#response-status).

:::note

Метод либо вызывает ошибку, либо возвращает ответ основного ресурса. Единственными исключениями являются навигация на `about:blank` или навигация на тот же URL с другим хэшем, которые будут успешными и вернут `null`.
:::

:::note
Режим без головы не поддерживает навигацию к PDF-документу. См. [проблему в исходном коде](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).
:::

**Использование**

```csharp
await Frame.GotoAsync(url, options);
```

**Аргументы**
- `url` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-goto-option-url"/><a href="#frame-goto-option-url" class="list-anchor">#</a>
  
  URL для навигации фрейма. URL должен включать схему, например, `https://`.
- `options` `FrameGotoOptions?` *(опционально)*
  - `Referer` [string]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-goto-option-referer"/><a href="#frame-goto-option-referer" class="list-anchor">#</a>
    
    Значение заголовка Referer. Если указано, оно будет иметь приоритет над значением заголовка referer, установленным с помощью [Page.SetExtraHTTPHeadersAsync()](/api/class-page.mdx#page-set-extra-http-headers).
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-goto-option-timeout"/><a href="#frame-goto-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-goto-option-wait-until"/><a href="#frame-goto-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Response]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-goto-return"/><a href="#frame-goto-return" class="list-anchor">#</a>

---

### IsDetached {#frame-is-detached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.IsDetached</x-search>

Возвращает `true`, если фрейм был отсоединен, или `false` в противном случае.

**Использование**

```csharp
Frame.IsDetached
```

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-detached-return"/><a href="#frame-is-detached-return" class="list-anchor">#</a>

---

### IsEnabledAsync {#frame-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.IsEnabledAsync</x-search>

Возвращает, является ли элемент [включенным](../actionability.mdx#enabled).

**Использование**

```csharp
await Frame.IsEnabledAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-enabled-option-selector"/><a href="#frame-is-enabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `FrameIsEnabledOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-enabled-option-strict"/><a href="#frame-is-enabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-enabled-option-timeout"/><a href="#frame-is-enabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-enabled-return"/><a href="#frame-is-enabled-return" class="list-anchor">#</a>

---

### Locator {#frame-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.14</font><x-search>frame.Locator</x-search>

Метод возвращает локатор элемента, который можно использовать для выполнения действий на этой странице/фрейме. Локатор разрешается в элемент непосредственно перед выполнением действия, поэтому серия действий на одном и том же локаторе может фактически выполняться на разных элементах DOM. Это произойдет, если структура DOM между этими действиями изменилась.

[Узнайте больше о локаторах](../locators.mdx).

[Узнайте больше о локаторах](../locators.mdx).

**Использование**

```csharp
Frame.Locator(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-locator-option-selector"/><a href="#frame-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении элемента DOM.
- `options` `FrameLocatorOptions?` *(опционально)*
  - `Has` [Locator]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-locator-option-has"/><a href="#frame-locator-option-has" class="list-anchor">#</a>
    
    Сужает результаты метода до тех, которые содержат элементы, соответствующие этому относительному локатору. Например, `article`, который имеет `text=Playwright`, соответствует `<article><div>Playwright</div></article>`.
    
    Внутренний локатор **должен быть относительным** к внешнему локатору и запрашивается, начиная с совпадения внешнего локатора, а не с корня документа. Например, вы можете найти `content`, который имеет `div` в `<article><content><div>Playwright</div></content></article>`. Однако поиск `content`, который имеет `article div`, не удастся, потому что внутренний локатор должен быть относительным и не должен использовать элементы за пределами `content`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `HasNot` [Locator]? *(опционально)* <font size="2">Добавлено в: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-locator-option-has-not"/><a href="#frame-locator-option-has-not" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат элемента, соответствующего внутреннему локатору. Внутренний локатор запрашивается относительно внешнего. Например, `article`, который не имеет `div`, соответствует `<article><span>Playwright</span></article>`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `HasNotText|HasNotTextRegex` [string]? | [Regex]? *(опционально)* <font size="2">Добавлено в: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-locator-option-has-not-text"/><a href="#frame-locator-option-has-not-text" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [string] сопоставление не учитывает регистр и ищет подстроку.
  - `HasText|HasTextRegex` [string]? | [Regex]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-locator-option-has-text"/><a href="#frame-locator-option-has-text" class="list-anchor">#</a>
    
    Соответствует элементам, содержащим указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [string] сопоставление не учитывает регистр и ищет подстроку. Например, `"Playwright"` соответствует `<article><div>Playwright</div></article>`.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-locator-return"/><a href="#frame-locator-return" class="list-anchor">#</a>

---

### Name {#frame-name}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.Name</x-search>

Возвращает атрибут name фрейма, как указано в теге.

Если имя пустое, возвращает атрибут id.

:::note

Это значение вычисляется один раз при создании фрейма и не будет обновляться, если атрибут изменится позже.
:::

**Использование**

```csharp
Frame.Name
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-name-return"/><a href="#frame-name-return" class="list-anchor">#</a>

---

### Page {#frame-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.Page</x-search>

Возвращает страницу, содержащую этот фрейм.

**Использование**

```csharp
Frame.Page
```

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-page-return"/><a href="#frame-page-return" class="list-anchor">#</a>

---

### ParentFrame {#frame-parent-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.ParentFrame</x-search>

Родительский фрейм, если он есть. Отсоединенные фреймы и основные фреймы возвращают `null`.

**Использование**

```csharp
Frame.ParentFrame
```

**Возвращает**
- [Frame]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-parent-frame-return"/><a href="#frame-parent-frame-return" class="list-anchor">#</a>

---

### SetContentAsync {#frame-set-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.SetContentAsync</x-search>

Этот метод внутренне вызывает [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), наследуя все его специфические характеристики и поведения.

**Использование**

```csharp
await Frame.SetContentAsync(html, options);
```

**Аргументы**
- `html` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-content-option-html"/><a href="#frame-set-content-option-html" class="list-anchor">#</a>
  
  HTML-разметка для назначения странице.
- `options` `FrameSetContentOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-content-option-timeout"/><a href="#frame-set-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-content-option-wait-until"/><a href="#frame-set-content-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-content-return"/><a href="#frame-set-content-return" class="list-anchor">#</a>

---

### TitleAsync {#frame-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.TitleAsync</x-search>

Возвращает заголовок страницы.

**Использование**

```csharp
await Frame.TitleAsync();
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-title-return"/><a href="#frame-title-return" class="list-anchor">#</a>

---

### Url {#frame-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.Url</x-search>

Возвращает URL фрейма.

**Использование**

```csharp
Frame.Url
```

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-url-return"/><a href="#frame-url-return" class="list-anchor">#</a>

---

### WaitForFunctionAsync {#frame-wait-for-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.WaitForFunctionAsync</x-search>

Возвращает, когда [выражение](/api/class-frame.mdx#frame-wait-for-function-option-expression) возвращает истинное значение, возвращает это значение.

**Использование**

[Frame.WaitForFunctionAsync()](/api/class-frame.mdx#frame-wait-for-function) можно использовать для наблюдения за изменением размера области просмотра:

```csharp
using Microsoft.Playwright;
using System.Threading.Tasks;

class FrameExamples
{
    public static async Task Main()
    {
        using var playwright = await Playwright.CreateAsync();
        await using var browser = await playwright.Firefox.LaunchAsync();
        var page = await browser.NewPageAsync();
        await page.SetViewportSizeAsync(50, 50);
        await page.MainFrame.WaitForFunctionAsync("window.innerWidth < 100");
    }
}
```

Чтобы передать аргумент в предикат функции `frame.waitForFunction`:

```csharp
var selector = ".foo";
await page.MainFrame.WaitForFunctionAsync("selector => !!document.querySelector(selector)", selector);
```

**Аргументы**
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-function-option-expression"/><a href="#frame-wait-for-function-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-function-option-arg"/><a href="#frame-wait-for-function-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [выражение](/api/class-frame.mdx#frame-wait-for-function-option-expression).
- `options` `FrameWaitForFunctionOptions?` *(опционально)*
  - `PollingInterval` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-function-option-polling-interval"/><a href="#frame-wait-for-function-option-polling-interval" class="list-anchor">#</a>
    
    Если указано, то это интервал в миллисекундах, с которым функция будет выполняться. По умолчанию, если опция не указана, [выражение](/api/class-frame.mdx#frame-wait-for-function-option-expression) выполняется в обратном вызове `requestAnimationFrame`.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-function-option-timeout"/><a href="#frame-wait-for-function-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-function-return"/><a href="#frame-wait-for-function-return" class="list-anchor">#</a>

---

### WaitForLoadStateAsync {#frame-wait-for-load-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.WaitForLoadStateAsync</x-search>

Ожидает достижения требуемого состояния загрузки.

Это возвращает, когда фрейм достигает требуемого состояния загрузки, по умолчанию `load`. Навигация должна быть завершена, когда этот метод вызывается. Если текущий документ уже достиг требуемого состояния, метод разрешается немедленно.

:::note

Большую часть времени этот метод не нужен, потому что Playwright [автоматически ожидает перед каждым действием](../actionability.mdx).
:::

**Использование**

```csharp
await frame.ClickAsync("button");
await frame.WaitForLoadStateAsync(); // По умолчанию LoadState.Load
```

**Аргументы**
- `state` `enum LoadState { Load, DOMContentLoaded, NetworkIdle }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-load-state-option-state"/><a href="#frame-wait-for-load-state-option-state" class="list-anchor">#</a>
  
  Необязательное состояние загрузки для ожидания, по умолчанию `load`. Если состояние уже достигнуто при загрузке текущего документа, метод разрешается немедленно. Может быть одним из:
  * `'load'` - ожидать, пока событие `load` не будет вызвано.
  * `'domcontentloaded'` - ожидать, пока событие `DOMContentLoaded` не будет вызвано.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** ожидать, пока не будет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
- `options` `FrameWaitForLoadStateOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-load-state-option-timeout"/><a href="#frame-wait-for-load-state-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-load-state-return"/><a href="#frame-wait-for-load-state-return" class="list-anchor">#</a>

---

### WaitForURLAsync {#frame-wait-for-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>frame.WaitForURLAsync</x-search>

Ожидает, пока фрейм перейдет на указанный URL.

**Использование**

```csharp
await frame.ClickAsync("a.delayed-navigation"); // нажатие на ссылку косвенно вызовет навигацию
await frame.WaitForURLAsync("**/target.html");
```

**Аргументы**
- `url` [string] | [Regex] | [Func]&lt;[string], bool&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-url-option-url"/><a href="#frame-wait-for-url-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, шаблон регулярного выражения или предикат, получающий [URL] для сопоставления при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
- `options` `FrameWaitForURLOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-url-option-timeout"/><a href="#frame-wait-for-url-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-url-option-wait-until"/><a href="#frame-wait-for-url-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-url-return"/><a href="#frame-wait-for-url-return" class="list-anchor">#</a>

---

## Устаревшие

### CheckAsync {#frame-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.CheckAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.CheckAsync()](/api/class-locator.mdx#locator-check) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод отмечает элемент, соответствующий [селектору](/api/class-frame.mdx#frame-check-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-frame.mdx#frame-check-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже отмечен, метод сразу возвращает управление.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если не установлена опция [Force](/api/class-frame.mdx#frame-check-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для нажатия в центре элемента.
1. Убедитесь, что элемент теперь отмечен. Если нет, этот метод выбрасывает исключение.

Если все шаги не завершились в течение указанного [времени ожидания](/api/class-frame.mdx#frame-check-option-timeout), метод выбрасывает [TimeoutError]. Передача нулевого времени ожидания отключает это.

**Использование**

```csharp
await Frame.CheckAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-check-option-selector"/><a href="#frame-check-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameCheckOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-check-option-force"/><a href="#frame-check-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-check-option-no-wait-after"/><a href="#frame-check-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-check-option-position"/><a href="#frame-check-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-check-option-strict"/><a href="#frame-check-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-check-option-timeout"/><a href="#frame-check-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-check-option-trial"/><a href="#frame-check-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-check-return"/><a href="#frame-check-return" class="list-anchor">#</a>

---

### ClickAsync {#frame-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.ClickAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.ClickAsync()](/api/class-locator.mdx#locator-click) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод кликает по элементу, соответствующему [селектору](/api/class-frame.mdx#frame-click-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-frame.mdx#frame-click-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если не установлена опция [Force](/api/class-frame.mdx#frame-click-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для нажатия в центре элемента или в указанной [позиции](/api/class-frame.mdx#frame-click-option-position).
1. Подождите, пока инициированные навигации не завершатся успешно или не завершатся с ошибкой, если не установлена опция [NoWaitAfter](/api/class-frame.mdx#frame-click-option-no-wait-after).

Если все шаги не завершились в течение указанного [времени ожидания](/api/class-frame.mdx#frame-click-option-timeout), метод выбрасывает [TimeoutError]. Передача нулевого времени ожидания отключает это.

**Использование**

```csharp
await Frame.ClickAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-selector"/><a href="#frame-click-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameClickOptions?` *(опционально)*
  - `Button` `enum MouseButton { Left, Right, Middle }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-button"/><a href="#frame-click-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `ClickCount` [int]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-click-count"/><a href="#frame-click-option-click-count" class="list-anchor">#</a>
    
    По умолчанию 1. См. [UIEvent.detail].
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-delay"/><a href="#frame-click-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-force"/><a href="#frame-click-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-modifiers"/><a href="#frame-click-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-no-wait-after"/><a href="#frame-click-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция в будущем будет по умолчанию `true`.
    :::
    
    Действия, инициирующие навигации, ожидают, пока эти навигации не произойдут и страницы не начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Эта опция нужна только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-position"/><a href="#frame-click-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-strict"/><a href="#frame-click-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-timeout"/><a href="#frame-click-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-option-trial"/><a href="#frame-click-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `модификаторы` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-click-return"/><a href="#frame-click-return" class="list-anchor">#</a>

---

### DblClickAsync {#frame-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.DblClickAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.DblClickAsync()](/api/class-locator.mdx#locator-dblclick) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет двойной клик по элементу, соответствующему [селектору](/api/class-frame.mdx#frame-dblclick-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-frame.mdx#frame-dblclick-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если не установлена опция [Force](/api/class-frame.mdx#frame-dblclick-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для двойного клика в центре элемента или в указанной [позиции](/api/class-frame.mdx#frame-dblclick-option-position). Если первый клик `dblclick()` вызывает событие навигации, этот метод выбросит исключение.

Если все шаги не завершились в течение указанного [времени ожидания](/api/class-frame.mdx#frame-dblclick-option-timeout), метод выбрасывает [TimeoutError]. Передача нулевого времени ожидания отключает это.

:::note

`frame.dblclick()` генерирует два события `click` и одно событие `dblclick`.
:::

**Использование**

```csharp
await Frame.DblClickAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-selector"/><a href="#frame-dblclick-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameDblClickOptions?` *(опционально)*
  - `Button` `enum MouseButton { Left, Right, Middle }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-button"/><a href="#frame-dblclick-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-delay"/><a href="#frame-dblclick-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-force"/><a href="#frame-dblclick-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-modifiers"/><a href="#frame-dblclick-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-no-wait-after"/><a href="#frame-dblclick-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-position"/><a href="#frame-dblclick-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-strict"/><a href="#frame-dblclick-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-timeout"/><a href="#frame-dblclick-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-option-trial"/><a href="#frame-dblclick-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `модификаторы` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dblclick-return"/><a href="#frame-dblclick-return" class="list-anchor">#</a>

---

### DispatchEventAsync {#frame-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.DispatchEventAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.DispatchEventAsync()](/api/class-locator.mdx#locator-dispatch-event) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Пример ниже генерирует событие `click` на элементе. Независимо от состояния видимости элемента, `click` генерируется. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Использование**

```csharp
await frame.DispatchEventAsync("button#submit", "click");
```

Под капотом создается экземпляр события на основе указанного [типа](/api/class-frame.mdx#frame-dispatch-event-option-type), инициализируется с помощью свойств [eventInit](/api/class-frame.mdx#frame-dispatch-event-option-event-init) и генерируется на элементе. События по умолчанию `составные`, `отменяемые` и всплывают.

Поскольку [eventInit](/api/class-frame.mdx#frame-dispatch-event-option-event-init) специфичен для события, пожалуйста, обратитесь к документации по событиям для списков начальных свойств:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Вы также можете указать `JSHandle` в качестве значения свойства, если хотите, чтобы живые объекты передавались в событие:

```csharp
// Обратите внимание, что вы можете создать DataTransfer только в Chromium и Firefox
var dataTransfer = await frame.EvaluateHandleAsync("() => new DataTransfer()");
await frame.DispatchEventAsync("#source", "dragstart", new { dataTransfer });
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dispatch-event-option-selector"/><a href="#frame-dispatch-event-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `type` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dispatch-event-option-type"/><a href="#frame-dispatch-event-option-type" class="list-anchor">#</a>
  
  Тип DOM-события: `"click"`, `"dragstart"` и т.д.
- `eventInit` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dispatch-event-option-event-init"/><a href="#frame-dispatch-event-option-event-init" class="list-anchor">#</a>
  
  Опциональные свойства инициализации, специфичные для события.
- `options` `FrameDispatchEventOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dispatch-event-option-strict"/><a href="#frame-dispatch-event-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dispatch-event-option-timeout"/><a href="#frame-dispatch-event-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-dispatch-event-return"/><a href="#frame-dispatch-event-return" class="list-anchor">#</a>

---

### EvalOnSelectorAsync {#frame-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>frame.EvalOnSelectorAsync</x-search>

:::warning[Не рекомендуется]

Этот метод не ожидает, пока элемент пройдет проверки действительности, и поэтому может привести к нестабильным тестам. Используйте [Locator.EvaluateAsync()](/api/class-locator.mdx#locator-evaluate), другие вспомогательные методы [Locator] или утверждения, ориентированные на веб.

:::

Возвращает значение, возвращаемое [выражением](/api/class-frame.mdx#frame-eval-on-selector-option-expression).

Метод находит элемент, соответствующий указанному селектору в фрейме, и передает его в качестве первого аргумента [выражению](/api/class-frame.mdx#frame-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выбрасывает ошибку.

Если [выражение](/api/class-frame.mdx#frame-eval-on-selector-option-expression) возвращает [Promise], то [Frame.EvalOnSelectorAsync()](/api/class-frame.mdx#frame-eval-on-selector) будет ждать разрешения промиса и вернет его значение.

**Использование**

```csharp
var searchValue = await frame.EvalOnSelectorAsync<string>("#search", "el => el.value");
var preloadHref = await frame.EvalOnSelectorAsync<string>("link[rel=preload]", "el => el.href");
var html = await frame.EvalOnSelectorAsync(".main-container", "(e, suffix) => e.outerHTML + suffix", "hello");
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-eval-on-selector-option-selector"/><a href="#frame-eval-on-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-eval-on-selector-option-expression"/><a href="#frame-eval-on-selector-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-eval-on-selector-option-arg"/><a href="#frame-eval-on-selector-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи [выражению](/api/class-frame.mdx#frame-eval-on-selector-option-expression).
- `options` `FrameEvalOnSelectorOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-eval-on-selector-option-strict"/><a href="#frame-eval-on-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Возвращает**
- [object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-eval-on-selector-return"/><a href="#frame-eval-on-selector-return" class="list-anchor">#</a>

---

### EvalOnSelectorAllAsync {#frame-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>frame.EvalOnSelectorAllAsync</x-search>

:::warning[Не рекомендуется]

В большинстве случаев [Locator.EvaluateAllAsync()](/api/class-locator.mdx#locator-evaluate-all), другие вспомогательные методы [Locator] и утверждения, ориентированные на веб, выполняют работу лучше.

:::

Возвращает значение, возвращаемое [выражением](/api/class-frame.mdx#frame-eval-on-selector-all-option-expression).

Метод находит все элементы, соответствующие указанному селектору в фрейме, и передает массив найденных элементов в качестве первого аргумента [выражению](/api/class-frame.mdx#frame-eval-on-selector-all-option-expression).

Если [выражение](/api/class-frame.mdx#frame-eval-on-selector-all-option-expression) возвращает [Promise], то [Frame.EvalOnSelectorAllAsync()](/api/class-frame.mdx#frame-eval-on-selector-all) будет ждать разрешения промиса и вернет его значение.

**Использование**

```csharp
var divsCount = await frame.EvalOnSelectorAllAsync<bool>("div", "(divs, min) => divs.length >= min", 10);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-eval-on-selector-all-option-selector"/><a href="#frame-eval-on-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-eval-on-selector-all-option-expression"/><a href="#frame-eval-on-selector-all-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-eval-on-selector-all-option-arg"/><a href="#frame-eval-on-selector-all-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи [выражению](/api/class-frame.mdx#frame-eval-on-selector-all-option-expression).

**Возвращает**
- [object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-eval-on-selector-all-return"/><a href="#frame-eval-on-selector-all-return" class="list-anchor">#</a>

---

### FillAsync {#frame-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.FillAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.FillAsync()](/api/class-locator.mdx#locator-fill) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [селектору](/api/class-frame.mdx#frame-fill-option-selector), ожидает проверки [действительности](../actionability.mdx), фокусирует элемент, заполняет его и генерирует событие `input` после заполнения. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является элементом `<input>`, `<textarea>` или `[contenteditable]`, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен контрол.

Для отправки более детализированных событий клавиатуры используйте [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially).

**Использование**

```csharp
await Frame.FillAsync(selector, value, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-fill-option-selector"/><a href="#frame-fill-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `value` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-fill-option-value"/><a href="#frame-fill-option-value" class="list-anchor">#</a>
  
  Значение для заполнения элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `options` `FrameFillOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-fill-option-force"/><a href="#frame-fill-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-fill-option-no-wait-after"/><a href="#frame-fill-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-fill-option-strict"/><a href="#frame-fill-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-fill-option-timeout"/><a href="#frame-fill-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-fill-return"/><a href="#frame-fill-return" class="list-anchor">#</a>

---

### FocusAsync {#frame-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.FocusAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.FocusAsync()](/api/class-locator.mdx#locator-focus) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод получает элемент с [селектором](/api/class-frame.mdx#frame-focus-option-selector) и фокусирует его. Если нет элемента, соответствующего [селектору](/api/class-frame.mdx#frame-focus-option-selector), метод ждет, пока соответствующий элемент не появится в DOM.

**Использование**

```csharp
await Frame.FocusAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-focus-option-selector"/><a href="#frame-focus-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameFocusOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-focus-option-strict"/><a href="#frame-focus-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-focus-option-timeout"/><a href="#frame-focus-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-focus-return"/><a href="#frame-focus-return" class="list-anchor">#</a>

---

### GetAttributeAsync {#frame-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.GetAttributeAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.GetAttributeAsync()](/api/class-locator.mdx#locator-get-attribute) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает значение атрибута элемента.

**Использование**

```csharp
await Frame.GetAttributeAsync(selector, name, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-attribute-option-selector"/><a href="#frame-get-attribute-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `name` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-attribute-option-name"/><a href="#frame-get-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута, для которого нужно получить значение.
- `options` `FrameGetAttributeOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-attribute-option-strict"/><a href="#frame-get-attribute-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-attribute-option-timeout"/><a href="#frame-get-attribute-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-get-attribute-return"/><a href="#frame-get-attribute-return" class="list-anchor">#</a>

---

### HoverAsync {#frame-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.HoverAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.HoverAsync()](/api/class-locator.mdx#locator-hover) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод наводит курсор на элемент, соответствующий [селектору](/api/class-frame.mdx#frame-hover-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-frame.mdx#frame-hover-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если не установлена опция [Force](/api/class-frame.mdx#frame-hover-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse) для наведения курсора на центр элемента или на указанную [позицию](/api/class-frame.mdx#frame-hover-option-position).

Если все шаги не завершились в течение указанного [времени ожидания](/api/class-frame.mdx#frame-hover-option-timeout), метод выбрасывает [TimeoutError]. Передача нулевого времени ожидания отключает это.

**Использование**

```csharp
await Frame.HoverAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-hover-option-selector"/><a href="#frame-hover-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameHoverOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-hover-option-force"/><a href="#frame-hover-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-hover-option-modifiers"/><a href="#frame-hover-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-hover-option-no-wait-after"/><a href="#frame-hover-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-hover-option-position"/><a href="#frame-hover-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-hover-option-strict"/><a href="#frame-hover-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-hover-option-timeout"/><a href="#frame-hover-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить время ожидания. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-hover-option-trial"/><a href="#frame-hover-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `модификаторы` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-hover-return"/><a href="#frame-hover-return" class="list-anchor">#</a>

---

### InnerHTMLAsync {#frame-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.InnerHTMLAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.InnerHTMLAsync()](/api/class-locator.mdx#locator-inner-html) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerHTML`.

**Использование**

```csharp
await Frame.InnerHTMLAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-inner-html-option-selector"/><a href="#frame-inner-html-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameInnerHTMLOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-inner-html-option-strict"/><a href="#frame-inner-html-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-inner-html-option-timeout"/><a href="#frame-inner-html-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-inner-html-return"/><a href="#frame-inner-html-return" class="list-anchor">#</a>

---

### InnerTextAsync {#frame-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.InnerTextAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.InnerTextAsync()](/api/class-locator.mdx#locator-inner-text) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerText`.

**Использование**

```csharp
await Frame.InnerTextAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-inner-text-option-selector"/><a href="#frame-inner-text-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameInnerTextOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-inner-text-option-strict"/><a href="#frame-inner-text-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-inner-text-option-timeout"/><a href="#frame-inner-text-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-inner-text-return"/><a href="#frame-inner-text-return" class="list-anchor">#</a>

---

### InputValueAsync {#frame-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>frame.InputValueAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.InputValueAsync()](/api/class-locator.mdx#locator-input-value) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Выбрасывает исключение для элементов, не являющихся вводом. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращает значение контрола.

**Использование**

```csharp
await Frame.InputValueAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-input-value-option-selector"/><a href="#frame-input-value-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameInputValueOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-input-value-option-strict"/><a href="#frame-input-value-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-input-value-option-timeout"/><a href="#frame-input-value-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-input-value-return"/><a href="#frame-input-value-return" class="list-anchor">#</a>

---

### IsCheckedAsync {#frame-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.IsCheckedAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsCheckedAsync()](/api/class-locator.mdx#locator-is-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отмечен ли элемент. Выбрасывает исключение, если элемент не является флажком или радиокнопкой.

**Использование**

```csharp
await Frame.IsCheckedAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-checked-option-selector"/><a href="#frame-is-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameIsCheckedOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-checked-option-strict"/><a href="#frame-is-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-checked-option-timeout"/><a href="#frame-is-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-checked-return"/><a href="#frame-is-checked-return" class="list-anchor">#</a>

---

### IsDisabledAsync {#frame-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.IsDisabledAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsDisabledAsync()](/api/class-locator.mdx#locator-is-disabled) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отключен ли элемент, противоположность [enabled](../actionability.mdx#enabled).

**Использование**

```csharp
await Frame.IsDisabledAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-disabled-option-selector"/><a href="#frame-is-disabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameIsDisabledOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-disabled-option-strict"/><a href="#frame-is-disabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-disabled-option-timeout"/><a href="#frame-is-disabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-disabled-return"/><a href="#frame-is-disabled-return" class="list-anchor">#</a>

---

### IsEditableAsync {#frame-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.IsEditableAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsEditableAsync()](/api/class-locator.mdx#locator-is-editable) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Использование**

```csharp
await Frame.IsEditableAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-editable-option-selector"/><a href="#frame-is-editable-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameIsEditableOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-editable-option-strict"/><a href="#frame-is-editable-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-editable-option-timeout"/><a href="#frame-is-editable-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-editable-return"/><a href="#frame-is-editable-return" class="list-anchor">#</a>

---

### IsHiddenAsync {#frame-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.IsHiddenAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsHiddenAsync()](/api/class-locator.mdx#locator-is-hidden) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, скрыт ли элемент, противоположность [visible](../actionability.mdx#visible). [selector](/api/class-frame.mdx#frame-is-hidden-option-selector), который не соответствует ни одному элементу, считается скрытым.

**Использование**

```csharp
await Frame.IsHiddenAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-hidden-option-selector"/><a href="#frame-is-hidden-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameIsHiddenOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-hidden-option-strict"/><a href="#frame-is-hidden-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-hidden-option-timeout"/><a href="#frame-is-hidden-option-timeout" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция игнорируется. [Frame.IsHiddenAsync()](/api/class-frame.mdx#frame-is-hidden) не ждет, пока элемент станет скрытым, и возвращает результат немедленно.
    :::

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-hidden-return"/><a href="#frame-is-hidden-return" class="list-anchor">#</a>

---

### IsVisibleAsync {#frame-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.IsVisibleAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.IsVisibleAsync()](/api/class-locator.mdx#locator-is-visible) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [видимым](../actionability.mdx#visible). [selector](/api/class-frame.mdx#frame-is-visible-option-selector), который не соответствует ни одному элементу, считается невидимым.

**Использование**

```csharp
await Frame.IsVisibleAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-visible-option-selector"/><a href="#frame-is-visible-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `FrameIsVisibleOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-visible-option-strict"/><a href="#frame-is-visible-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-visible-option-timeout"/><a href="#frame-is-visible-option-timeout" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция игнорируется. [Frame.IsVisibleAsync()](/api/class-frame.mdx#frame-is-visible) не ждет, пока элемент станет видимым, и возвращает результат немедленно.
    :::

**Возвращает**
- [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-is-visible-return"/><a href="#frame-is-visible-return" class="list-anchor">#</a>

---

### PressAsync {#frame-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.PressAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.PressAsync()](/api/class-locator.mdx#locator-press) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

[key](/api/class-frame.mdx#frame-press-option-key) может указывать предполагаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или один символ для генерации текста. Надмножество значений [key](/api/class-frame.mdx#frame-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры ключей:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются следующие модификационные сочетания: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`. `ControlOrMeta` разрешается в `Control` на Windows и Linux и в `Meta` на macOS.

Удержание `Shift` будет вводить текст, соответствующий [key](/api/class-frame.mdx#frame-press-option-key) в верхнем регистре.

Если [key](/api/class-frame.mdx#frame-press-option-key) является одним символом, он чувствителен к регистру, поэтому значения `a` и `A` будут генерировать разные тексты.

Также поддерживаются сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++` или `key: "Control+Shift+T"`. При указании с модификатором, модификатор нажимается и удерживается, пока не будет нажата последующая клавиша.

**Использование**

```csharp
await Frame.PressAsync(selector, key, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-press-option-selector"/><a href="#frame-press-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `key` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-press-option-key"/><a href="#frame-press-option-key" class="list-anchor">#</a>
  
  Имя клавиши для нажатия или символ для генерации, например, `ArrowLeft` или `a`.
- `options` `FramePressOptions?` *(опционально)*
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-press-option-delay"/><a href="#frame-press-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `keydown` и `keyup` в миллисекундах. По умолчанию 0.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-press-option-no-wait-after"/><a href="#frame-press-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция по умолчанию будет `true` в будущем.
    :::
    
    Действия, инициирующие навигацию, ожидают, пока эта навигация произойдет и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится эта опция только в исключительных случаях, таких как навигация к недоступным страницам. По умолчанию `false`.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-press-option-strict"/><a href="#frame-press-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-press-option-timeout"/><a href="#frame-press-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-press-return"/><a href="#frame-press-return" class="list-anchor">#</a>

---

### QuerySelectorAsync {#frame-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>frame.QuerySelectorAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Frame.Locator()](/api/class-frame.mdx#frame-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает ElementHandle, указывающий на элемент фрейма.

:::caution

Использование [ElementHandle] не рекомендуется, используйте объекты [Locator] и веб-первичные утверждения вместо этого.
:::

Метод находит элемент, соответствующий указанному селектору в фрейме. Если ни один элемент не соответствует селектору, возвращает `null`.

**Использование**

```csharp
await Frame.QuerySelectorAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-query-selector-option-selector"/><a href="#frame-query-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` `FrameQuerySelectorOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-query-selector-option-strict"/><a href="#frame-query-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Возвращает**
- [ElementHandle]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-query-selector-return"/><a href="#frame-query-selector-return" class="list-anchor">#</a>

---

### QuerySelectorAllAsync {#frame-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>frame.QuerySelectorAllAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Frame.Locator()](/api/class-frame.mdx#frame-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает ElementHandles, указывающие на элементы фрейма.

:::caution

Использование [ElementHandle] не рекомендуется, используйте объекты [Locator] вместо этого.
:::

Метод находит все элементы, соответствующие указанному селектору в фрейме. Если ни один элемент не соответствует селектору, возвращает пустой массив.

**Использование**

```csharp
await Frame.QuerySelectorAllAsync(selector);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-query-selector-all-option-selector"/><a href="#frame-query-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.

**Возвращает**
- [IReadOnlyList]&lt;[ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-query-selector-all-return"/><a href="#frame-query-selector-all-return" class="list-anchor">#</a>

---

### RunAndWaitForNavigationAsync {#frame-wait-for-navigation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.RunAndWaitForNavigationAsync</x-search>

:::warning Устарело

Этот метод по своей природе является гонкой, пожалуйста, используйте [Frame.WaitForURLAsync()](/api/class-frame.mdx#frame-wait-for-url) вместо этого.

:::

Ожидает навигации фрейма и возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация разрешится с ответом последнего перенаправления. В случае навигации к другому якорю или навигации из-за использования History API, навигация разрешится с `null`.

**Использование**

Этот метод ожидает, пока фрейм перейдет на новый URL. Это полезно, когда вы выполняете код, который косвенно вызывает навигацию фрейма. Рассмотрим этот пример:

```csharp
await frame.RunAndWaitForNavigationAsync(async () =>
{
    // Клик по ссылке косвенно вызовет навигацию.
    await frame.ClickAsync("a.delayed-navigation");
});

// Разрешается после завершения навигации
```

:::note
Использование [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) для изменения URL считается навигацией.
:::

**Аргументы**
- `action` [Func]&lt;[Task]&gt; <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-navigation-option-action"/><a href="#frame-wait-for-navigation-option-action" class="list-anchor">#</a>
  
  Действие, которое вызывает событие.
- `options` `FrameRunAndWaitForNavigationOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-navigation-option-timeout"/><a href="#frame-wait-for-navigation-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Url|UrlRegex|UrlFunc` [string]? | [Regex]? | [Func]&lt;[string]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-navigation-option-url"/><a href="#frame-wait-for-navigation-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для совпадения при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-navigation-option-wait-until"/><a href="#frame-wait-for-navigation-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Response]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-navigation-return"/><a href="#frame-wait-for-navigation-return" class="list-anchor">#</a>

---

### WaitForNavigationAsync {#frame-wait-for-navigation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>frame.WaitForNavigationAsync</x-search>

:::warning Устарело

Этот метод по своей природе является гонкой, пожалуйста, используйте [Frame.WaitForURLAsync()](/api/class-frame.mdx#frame-wait-for-url) вместо этого.

:::

Ожидает навигации фрейма и возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация разрешится с ответом последнего перенаправления. В случае навигации к другому якорю или навигации из-за использования History API, навигация разрешится с `null`.

**Использование**

Этот метод ожидает, пока фрейм перейдет на новый URL. Это полезно, когда вы выполняете код, который косвенно вызывает навигацию фрейма. Рассмотрим этот пример:

```csharp
await frame.RunAndWaitForNavigationAsync(async () =>
{
    // Клик по ссылке косвенно вызовет навигацию.
    await frame.ClickAsync("a.delayed-navigation");
});

// Разрешается после завершения навигации
```

:::note
Использование [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) для изменения URL считается навигацией.
:::

**Аргументы**
- `options` `FrameRunAndWaitForNavigationOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-navigation-option-timeout"/><a href="#frame-wait-for-navigation-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.SetDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `Url|UrlRegex|UrlFunc` [string]? | [Regex]? | [Func]&lt;[string]?, bool&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-navigation-option-url"/><a href="#frame-wait-for-navigation-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для совпадения при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
  - `WaitUntil` `enum WaitUntilState { Load, DOMContentLoaded, NetworkIdle, Commit }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-navigation-option-wait-until"/><a href="#frame-wait-for-navigation-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [Response]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-navigation-return"/><a href="#frame-wait-for-navigation-return" class="list-anchor">#</a>

---

### SelectOptionAsync {#frame-select-option}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.SelectOptionAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SelectOptionAsync()](/api/class-locator.mdx#locator-select-option) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [селектору](/api/class-frame.mdx#frame-select-option-option-selector), выполняет проверки [действительности](../actionability.mdx), ожидает, пока все указанные опции не будут присутствовать в элементе `<select>`, и выбирает эти опции.

Если целевой элемент не является элементом `<select>`, этот метод вызывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контрол.

Возвращает массив значений опций, которые были успешно выбраны.

Вызывает событие `change` и `input`, как только все предоставленные опции были выбраны.

**Использование**

```csharp
// Одиночный выбор, соответствующий значению или метке
await frame.SelectOptionAsync("select#colors", new[] { "blue" });
// одиночный выбор, соответствующий как значению, так и метке
await frame.SelectOptionAsync("select#colors", new[] { new SelectOptionValue() { Label = "blue" } });
// множественный выбор
await frame.SelectOptionAsync("select#colors", new[] { "red", "green", "blue" });
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-select-option-option-selector"/><a href="#frame-select-option-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.
- `values` [string] | [ElementHandle] | [IEnumerable] | `SelectOption` | [IEnumerable] | [IEnumerable]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-select-option-option-values"/><a href="#frame-select-option-option-values" class="list-anchor">#</a>
  - `Value` [string]? *(опционально)*
    
    Соответствует `option.value`. Опционально.
  - `Label` [string]? *(опционально)*
    
    Соответствует `option.label`. Опционально.
  - `Index` [int]? *(опционально)*
    
    Соответствует индексу. Опционально.
  
  Опции для выбора. Если `<select>` имеет атрибут `multiple`, все соответствующие опции выбираются, в противном случае выбирается только первая опция, соответствующая одной из переданных опций. Строковые значения соответствуют как значениям, так и меткам. Опция считается соответствующей, если все указанные свойства совпадают.
- `options` `FrameSelectOptionOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-select-option-option-force"/><a href="#frame-select-option-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-select-option-option-no-wait-after"/><a href="#frame-select-option-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-select-option-option-strict"/><a href="#frame-select-option-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-select-option-option-timeout"/><a href="#frame-select-option-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [IReadOnlyList]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-select-option-return"/><a href="#frame-select-option-return" class="list-anchor">#</a>

---

### SetCheckedAsync {#frame-set-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.15</font><x-search>frame.SetCheckedAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SetCheckedAsync()](/api/class-locator.mdx#locator-set-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод устанавливает или снимает флажок с элемента, соответствующего [селектору](/api/class-frame.mdx#frame-set-checked-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-frame.mdx#frame-set-checked-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку.
3. Если элемент уже имеет правильное состояние, этот метод возвращается немедленно.
4. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если только не установлена опция [Force](/api/class-frame.mdx#frame-set-checked-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
5. Прокрутите элемент в видимую область, если это необходимо.
6. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента.
7. Убедитесь, что элемент теперь отмечен или не отмечен. Если нет, этот метод вызывает ошибку.

Если все шаги вместе не завершились в течение указанного [Timeout](/api/class-frame.mdx#frame-set-checked-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```csharp
await Frame.SetCheckedAsync(selector, checked, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-checked-option-selector"/><a href="#frame-set-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `checkedState` [bool]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-checked-option-checked"/><a href="#frame-set-checked-option-checked" class="list-anchor">#</a>
  
  Установить или снять флажок.
- `options` `FrameSetCheckedOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-checked-option-force"/><a href="#frame-set-checked-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-checked-option-no-wait-after"/><a href="#frame-set-checked-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-checked-option-position"/><a href="#frame-set-checked-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-checked-option-strict"/><a href="#frame-set-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-checked-option-timeout"/><a href="#frame-set-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.
  - `Trial` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-checked-option-trial"/><a href="#frame-set-checked-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-checked-return"/><a href="#frame-set-checked-return" class="list-anchor">#</a>

---

### SetInputFilesAsync {#frame-set-input-files}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.SetInputFilesAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.SetInputFilesAsync()](/api/class-locator.mdx#locator-set-input-files) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Устанавливает значение элемента ввода файла на указанные пути к файлам или файлы. Если некоторые из `filePaths` являются относительными путями, они разрешаются относительно текущей рабочей директории. Для пустого массива очищает выбранные файлы.

Этот метод ожидает, что [селектор](/api/class-frame.mdx#frame-set-input-files-option-selector) указывает на [элемент ввода](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контрол.

**Использование**

```csharp
await Frame.SetInputFilesAsync(selector, files, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-input-files-option-selector"/><a href="#frame-set-input-files-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `files` [string] | [IEnumerable]&lt;[string]&gt; | `FilePayload` | [IEnumerable]&lt;`FilePayload`&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-input-files-option-files"/><a href="#frame-set-input-files-option-files" class="list-anchor">#</a>
  - `Name` [string]
    
    Имя файла
  - `MimeType` [string]
    
    Тип файла
  - `Buffer` [byte]&#91;&#93;
    
    Содержимое файла
- `options` `FrameSetInputFilesOptions?` *(опционально)*
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-input-files-option-no-wait-after"/><a href="#frame-set-input-files-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-input-files-option-strict"/><a href="#frame-set-input-files-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-input-files-option-timeout"/><a href="#frame-set-input-files-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-set-input-files-return"/><a href="#frame-set-input-files-return" class="list-anchor">#</a>

---

### TapAsync {#frame-tap}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.TapAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.TapAsync()](/api/class-locator.mdx#locator-tap) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет нажатие на элемент, соответствующий [селектору](/api/class-frame.mdx#frame-tap-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-frame.mdx#frame-tap-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если только не установлена опция [Force](/api/class-frame.mdx#frame-tap-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
3. Прокрутите элемент в видимую область, если это необходимо.
4. Используйте [Page.Touchscreen](/api/class-page.mdx#page-touchscreen), чтобы нажать в центре элемента или в указанной [позиции](/api/class-frame.mdx#frame-tap-option-position).

Если все шаги вместе не завершились в течение указанного [Timeout](/api/class-frame.mdx#frame-tap-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

`frame.tap()` требует, чтобы опция `hasTouch` контекста браузера была установлена в true.
:::

**Использование**

```csharp
await Frame.TapAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-tap-option-selector"/><a href="#frame-tap-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `FrameTapOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-tap-option-force"/><a href="#frame-tap-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `Modifiers` [IEnumerable]?&lt;`enum KeyboardModifier { Alt, Control, ControlOrMeta, Meta, Shift }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-tap-option-modifiers"/><a href="#frame-tap-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, чтобы только эти модификаторы были нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-tap-option-no-wait-after"/><a href="#frame-tap-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-tap-option-position"/><a href="#frame-tap-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-tap-option-strict"/><a href="#frame-tap-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-tap-option-timeout"/><a href="#frame-tap-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-tap-option-trial"/><a href="#frame-tap-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `модификаторы` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-tap-return"/><a href="#frame-tap-return" class="list-anchor">#</a>

---

### TextContentAsync {#frame-text-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.TextContentAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.TextContentAsync()](/api/class-locator.mdx#locator-text-content) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.textContent`.

**Использование**

```csharp
await Frame.TextContentAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-text-content-option-selector"/><a href="#frame-text-content-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `FrameTextContentOptions?` *(опционально)*
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-text-content-option-strict"/><a href="#frame-text-content-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-text-content-option-timeout"/><a href="#frame-text-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [string]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-text-content-return"/><a href="#frame-text-content-return" class="list-anchor">#</a>

---

### TypeAsync {#frame-type}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.TypeAsync</x-search>

:::warning Устарело

В большинстве случаев следует использовать [Locator.FillAsync()](/api/class-locator.mdx#locator-fill) вместо этого. Вам нужно нажимать клавиши по одной, только если на странице есть специальная обработка клавиатуры - в этом случае используйте [Locator.PressSequentiallyAsync()](/api/class-locator.mdx#locator-press-sequentially).

:::

Отправляет событие `keydown`, `keypress`/`input` и `keyup` для каждого символа в тексте. `frame.type` можно использовать для отправки детализированных событий клавиатуры. Для заполнения значений в полях формы используйте [Frame.FillAsync()](/api/class-frame.mdx#frame-fill).

Чтобы нажать специальную клавишу, такую как `Control` или `ArrowDown`, используйте [Keyboard.PressAsync()](/api/class-keyboard.mdx#keyboard-press).

**Использование**

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-type-option-selector"/><a href="#frame-type-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `text` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-type-option-text"/><a href="#frame-type-option-text" class="list-anchor">#</a>
  
  Текст для ввода в фокусированный элемент.
- `options` `FrameTypeOptions?` *(опционально)*
  - `Delay` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-type-option-delay"/><a href="#frame-type-option-delay" class="list-anchor">#</a>
    
    Время ожидания между нажатиями клавиш в миллисекундах. По умолчанию 0.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-type-option-no-wait-after"/><a href="#frame-type-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-type-option-strict"/><a href="#frame-type-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-type-option-timeout"/><a href="#frame-type-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-type-return"/><a href="#frame-type-return" class="list-anchor">#</a>

---

### UncheckAsync {#frame-uncheck}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.UncheckAsync</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.UncheckAsync()](/api/class-locator.mdx#locator-uncheck) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод снимает флажок с элемента, соответствующего [селектору](/api/class-frame.mdx#frame-uncheck-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [селектору](/api/class-frame.mdx#frame-uncheck-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку. Если элемент уже снят, этот метод возвращается немедленно.
3. Подождите, пока не будут выполнены проверки [действительности](../actionability.mdx) на найденном элементе, если только не установлена опция [Force](/api/class-frame.mdx#frame-uncheck-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
4. Прокрутите элемент в видимую область, если это необходимо.
5. Используйте [Page.Mouse](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента.
6. Убедитесь, что элемент теперь снят. Если нет, этот метод вызывает ошибку.

Если все шаги вместе не завершились в течение указанного [Timeout](/api/class-frame.mdx#frame-uncheck-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```csharp
await Frame.UncheckAsync(selector, options);
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-uncheck-option-selector"/><a href="#frame-uncheck-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `FrameUncheckOptions?` *(опционально)*
  - `Force` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-uncheck-option-force"/><a href="#frame-uncheck-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `NoWaitAfter` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-uncheck-option-no-wait-after"/><a href="#frame-uncheck-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `Position` Position? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-uncheck-option-position"/><a href="#frame-uncheck-option-position" class="list-anchor">#</a>
    - `X` [float]
      
      
    - `Y` [float]
      
      
    Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-uncheck-option-strict"/><a href="#frame-uncheck-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-uncheck-option-timeout"/><a href="#frame-uncheck-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.
  - `Trial` [bool]? *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-uncheck-option-trial"/><a href="#frame-uncheck-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-uncheck-return"/><a href="#frame-uncheck-return" class="list-anchor">#</a>

---

### WaitForSelectorAsync {#frame-wait-for-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.WaitForSelectorAsync</x-search>

:::warning[Не рекомендуется]

Используйте веб-утверждения, которые утверждают видимость, или основанный на локаторах метод [Locator.WaitForAsync()](/api/class-locator.mdx#locator-wait-for) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, когда элемент, указанный селектором, удовлетворяет опции [State](/api/class-frame.mdx#frame-wait-for-selector-option-state). Возвращает `null`, если ожидание для `hidden` или `detached`.

:::note

Playwright автоматически ожидает, пока элемент будет готов перед выполнением действия. Использование объектов [Locator] и веб-первых утверждений делает код свободным от ожидания селектора.
:::

Ожидает, пока [селектор](/api/class-frame.mdx#frame-wait-for-selector-option-selector) не удовлетворит опцию [State](/api/class-frame.mdx#frame-wait-for-selector-option-state) (либо появится/исчезнет из DOM, либо станет видимым/скрытым). Если в момент вызова метода [селектор](/api/class-frame.mdx#frame-wait-for-selector-option-selector) уже удовлетворяет условию, метод вернется немедленно. Если селектор не удовлетворяет условию в течение [Timeout](/api/class-frame.mdx#frame-wait-for-selector-option-timeout) миллисекунд, функция вызовет ошибку.

**Использование**

Этот метод работает через навигации:

```csharp
using Microsoft.Playwright;
using System;
using System.Threading.Tasks;

class FrameExamples
{
    public static async Task Main()
    {
        using var playwright = await Playwright.CreateAsync();
        await using var browser = await playwright.Chromium.LaunchAsync();
        var page = await browser.NewPageAsync();

        foreach (var currentUrl in new[] { "https://www.google.com", "https://bbc.com" })
        {
            await page.GotoAsync(currentUrl);
            element = await page.MainFrame.WaitForSelectorAsync("img");
            Console.WriteLine($"Загружено изображение: {await element.GetAttributeAsync("src")}");
        }
    }
}
```

**Аргументы**
- `selector` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-selector-option-selector"/><a href="#frame-wait-for-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.
- `options` `FrameWaitForSelectorOptions?` *(опционально)*
  - `State` `enum WaitForSelectorState { Attached, Detached, Visible, Hidden }?` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-selector-option-state"/><a href="#frame-wait-for-selector-option-state" class="list-anchor">#</a>
    
    По умолчанию `'visible'`. Может быть:
    * `'attached'` - ожидание, пока элемент будет присутствовать в DOM.
    * `'detached'` - ожидание, пока элемент не будет присутствовать в DOM.
    * `'visible'` - ожидание, пока элемент не будет иметь пустую ограничивающую рамку и `visibility:hidden`. Обратите внимание, что элемент без содержимого или с `display:none` имеет пустую ограничивающую рамку и не считается видимым.
    * `'hidden'` - ожидание, пока элемент либо не будет отсоединен от DOM, либо не будет иметь пустую ограничивающую рамку или `visibility:hidden`. Это противоположно опции `'visible'`.
  - `Strict` [bool]? *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-selector-option-strict"/><a href="#frame-wait-for-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-selector-option-timeout"/><a href="#frame-wait-for-selector-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.SetDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.SetDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [ElementHandle]?<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-selector-return"/><a href="#frame-wait-for-selector-return" class="list-anchor">#</a>

---

### WaitForTimeoutAsync {#frame-wait-for-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>frame.WaitForTimeoutAsync</x-search>

:::warning[Не рекомендуется]

Никогда не ждите тайм-аута в производственной среде. Тесты, которые ждут времени, по своей природе ненадежны. Используйте действия [Locator] и веб-утверждения, которые ожидают автоматически.

:::

Ожидает указанный [тайм-аут](/api/class-frame.mdx#frame-wait-for-timeout-option-timeout) в миллисекундах.

Обратите внимание, что `frame.waitForTimeout()` следует использовать только для отладки. Тесты, использующие таймер в производственной среде, будут ненадежными. Используйте сигналы, такие как сетевые события, селекторы, становящиеся видимыми, и другие вместо этого.

**Использование**

```csharp
await Frame.WaitForTimeoutAsync(timeout);
```

**Аргументы**
- `timeout` [float]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-timeout-option-timeout"/><a href="#frame-wait-for-timeout-option-timeout" class="list-anchor">#</a>
  
  Тайм-аут для ожидания

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="frame-wait-for-timeout-return"/><a href="#frame-wait-for-timeout-return" class="list-anchor">#</a>


[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[CDPSessionEvent]: /api/class-cdpsessionevent.mdx "CDPSessionEvent"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[bool]: https://docs.microsoft.com/en-us/dotnet/api/system.boolean "bool"
[Date]: https://learn.microsoft.com/en-us/dotnet/api/system.datetime "DateTime"
[double]: https://docs.microsoft.com/en-us/dotnet/api/system.double "double"
[byte]: https://docs.microsoft.com/en-us/dotnet/api/system.byte "byte"
[int]: https://docs.microsoft.com/en-us/dotnet/api/system.int32 "int"
[long]: https://docs.microsoft.com/en-us/dotnet/api/system.int64 "long"
[void]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/void "void"
[string]: https://docs.microsoft.com/en-us/dotnet/api/system.string "string"
[URL]: https://nodejs.org/api/url.html "URL"
[Regex]: https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex "Regex"

[Action]: https://docs.microsoft.com/en-us/dotnet/api/system.action-1 "Action"
[Func]: https://docs.microsoft.com/en-us/dotnet/api/system.func-2 "Func"
[IEnumerable]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable "IEnumerable"
[IReadOnlyList]: https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1?view=net-9.0 "IReadOnlyList"
[IDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary "IDictionary"
[Task]: https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0 "Task"
[IReadOnlyDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2 "IReadOnlyDictionary"
[JsonElement]: https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement "JsonElement"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-dotnet/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
