---
id: class-locatorassertions
title: "LocatorAssertions"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

Класс [LocatorAssertions] предоставляет методы утверждений, которые могут быть использованы для проверки состояния [Locator] в тестах.

```csharp
using Microsoft.Playwright;
using Microsoft.Playwright.MSTest;

namespace PlaywrightTests;

[TestClass]
public class ExampleTests : PageTest
{
    [TestMethod]
    public async Task StatusBecomesSubmitted()
    {
        // ...
        await Page.GetByRole(AriaRole.Button, new() { Name = "Sign In" }).ClickAsync();
        await Expect(Page.Locator(".status")).ToHaveTextAsync("Submitted");
    }
}
```

---

## Методы {#methods}

### ToBeAttachedAsync {#locator-assertions-to-be-attached}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.33</font><x-search>locatorAssertions.ToBeAttachedAsync</x-search>

Убеждается, что [Locator] указывает на элемент, который [подключен](https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected) к Document или ShadowRoot.

**Использование**

```csharp
await Expect(Page.GetByText("Hidden text")).ToBeAttachedAsync();
```

**Аргументы**
- `options` `LocatorAssertionsToBeAttachedOptions?` *(опционально)*
  - `Attached` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-attached-option-attached"/><a href="#locator-assertions-to-be-attached-option-attached" class="list-anchor">#</a>
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-attached-option-timeout"/><a href="#locator-assertions-to-be-attached-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-attached-return"/><a href="#locator-assertions-to-be-attached-return" class="list-anchor">#</a>

---

### ToBeCheckedAsync {#locator-assertions-to-be-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToBeCheckedAsync</x-search>

Убеждается, что [Locator] указывает на отмеченный элемент ввода.

**Использование**

```csharp
var locator = Page.GetByLabel("Subscribe to newsletter");
await Expect(locator).ToBeCheckedAsync();
```

**Аргументы**
- `options` `LocatorAssertionsToBeCheckedOptions?` *(опционально)*
  - `Checked` [bool]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-checked-option-checked"/><a href="#locator-assertions-to-be-checked-option-checked" class="list-anchor">#</a>
    
    Предоставляет состояние для утверждения. По умолчанию утверждает, что элемент ввода отмечен. Эта опция не может быть использована, когда [Indeterminate](/api/class-locatorassertions.mdx#locator-assertions-to-be-checked-option-indeterminate) установлена в true.
  - `Indeterminate` [bool]? *(опционально)* <font size="2">Добавлено в: v1.50</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-checked-option-indeterminate"/><a href="#locator-assertions-to-be-checked-option-indeterminate" class="list-anchor">#</a>
    
    Утверждает, что элемент находится в неопределенном (смешанном) состоянии. Поддерживается только для флажков и радиокнопок. Эта опция не может быть true, когда [Checked](/api/class-locatorassertions.mdx#locator-assertions-to-be-checked-option-checked) предоставлена.
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-checked-option-timeout"/><a href="#locator-assertions-to-be-checked-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-checked-return"/><a href="#locator-assertions-to-be-checked-return" class="list-anchor">#</a>

---

### ToBeDisabledAsync {#locator-assertions-to-be-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToBeDisabledAsync</x-search>

Убеждается, что [Locator] указывает на отключенный элемент. Элемент считается отключенным, если у него есть атрибут "disabled" или он отключен через ['aria-disabled'](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-disabled). Обратите внимание, что только элементы управления, такие как HTML `button`, `input`, `select`, `textarea`, `option`, `optgroup`, могут быть отключены установкой атрибута "disabled". Атрибут "disabled" на других элементах игнорируется браузером.

**Использование**

```csharp
var locator = Page.Locator("button.submit");
await Expect(locator).ToBeDisabledAsync();
```

**Аргументы**
- `options` `LocatorAssertionsToBeDisabledOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-disabled-option-timeout"/><a href="#locator-assertions-to-be-disabled-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-disabled-return"/><a href="#locator-assertions-to-be-disabled-return" class="list-anchor">#</a>

---

### ToBeEditableAsync {#locator-assertions-to-be-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToBeEditableAsync</x-search>

Убеждается, что [Locator] указывает на редактируемый элемент.

**Использование**

```csharp
var locator = Page.GetByRole(AriaRole.Textbox);
await Expect(locator).ToBeEditableAsync();
```

**Аргументы**
- `options` `LocatorAssertionsToBeEditableOptions?` *(опционально)*
  - `Editable` [bool]? *(опционально)* <font size="2">Добавлено в: v1.26</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-editable-option-editable"/><a href="#locator-assertions-to-be-editable-option-editable" class="list-anchor">#</a>
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-editable-option-timeout"/><a href="#locator-assertions-to-be-editable-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-editable-return"/><a href="#locator-assertions-to-be-editable-return" class="list-anchor">#</a>

---

### ToBeEmptyAsync {#locator-assertions-to-be-empty}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToBeEmptyAsync</x-search>

Убеждается, что [Locator] указывает на пустой редактируемый элемент или на DOM-узел, который не содержит текста.

**Использование**

```csharp
var locator = Page.Locator("div.warning");
await Expect(locator).ToBeEmptyAsync();
```

**Аргументы**
- `options` `LocatorAssertionsToBeEmptyOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-empty-option-timeout"/><a href="#locator-assertions-to-be-empty-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-empty-return"/><a href="#locator-assertions-to-be-empty-return" class="list-anchor">#</a>

---

### ToBeEnabledAsync {#locator-assertions-to-be-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToBeEnabledAsync</x-search>

Убеждается, что [Locator] указывает на включенный элемент.

**Использование**

```csharp
var locator = Page.Locator("button.submit");
await Expect(locator).ToBeEnabledAsync();
```

**Аргументы**
- `options` `LocatorAssertionsToBeEnabledOptions?` *(опционально)*
  - `Enabled` [bool]? *(опционально)* <font size="2">Добавлено в: v1.26</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-enabled-option-enabled"/><a href="#locator-assertions-to-be-enabled-option-enabled" class="list-anchor">#</a>
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-enabled-option-timeout"/><a href="#locator-assertions-to-be-enabled-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-enabled-return"/><a href="#locator-assertions-to-be-enabled-return" class="list-anchor">#</a>

---

### ToBeFocusedAsync {#locator-assertions-to-be-focused}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToBeFocusedAsync</x-search>

Убеждается, что [Locator] указывает на сфокусированный DOM-узел.

**Использование**

```csharp
var locator = Page.GetByRole(AriaRole.Textbox);
await Expect(locator).ToBeFocusedAsync();
```

**Аргументы**
- `options` `LocatorAssertionsToBeFocusedOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-focused-option-timeout"/><a href="#locator-assertions-to-be-focused-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-focused-return"/><a href="#locator-assertions-to-be-focused-return" class="list-anchor">#</a>

---

### ToBeHiddenAsync {#locator-assertions-to-be-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToBeHiddenAsync</x-search>

Убеждается, что [Locator] либо не разрешается ни в один DOM-узел, либо разрешается в [невидимый](../actionability.mdx#visible) узел.

**Использование**

```csharp
var locator = Page.Locator(".my-element");
await Expect(locator).ToBeHiddenAsync();
```

**Аргументы**
- `options` `LocatorAssertionsToBeHiddenOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-hidden-option-timeout"/><a href="#locator-assertions-to-be-hidden-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-hidden-return"/><a href="#locator-assertions-to-be-hidden-return" class="list-anchor">#</a>

---

### ToBeInViewportAsync {#locator-assertions-to-be-in-viewport}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.31</font><x-search>locatorAssertions.ToBeInViewportAsync</x-search>

Убеждается, что [Locator] указывает на элемент, который пересекает область просмотра, согласно [API наблюдателя пересечений](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).

**Использование**

```csharp
var locator = Page.GetByRole(AriaRole.Button);
// Убедитесь, что хотя бы часть элемента пересекает область просмотра.
await Expect(locator).ToBeInViewportAsync();
// Убедитесь, что элемент полностью вне области просмотра.
await Expect(locator).Not.ToBeInViewportAsync();
// Убедитесь, что хотя бы половина элемента пересекает область просмотра.
await Expect(locator).ToBeInViewportAsync(new() { Ratio = 0.5 });
```

**Аргументы**
- `options` `LocatorAssertionsToBeInViewportOptions?` *(опционально)*
  - `Ratio` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-in-viewport-option-ratio"/><a href="#locator-assertions-to-be-in-viewport-option-ratio" class="list-anchor">#</a>
    
    Минимальное соотношение элемента для пересечения области просмотра. Если равно `0`, то элемент должен пересекать область просмотра при любом положительном соотношении. По умолчанию `0`.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-in-viewport-option-timeout"/><a href="#locator-assertions-to-be-in-viewport-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-in-viewport-return"/><a href="#locator-assertions-to-be-in-viewport-return" class="list-anchor">#</a>

---

### ToBeVisibleAsync {#locator-assertions-to-be-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToBeVisibleAsync</x-search>

Убеждается, что [Locator] указывает на подключенный и [видимый](../actionability.mdx#visible) DOM-узел.

Чтобы проверить, что хотя бы один элемент из списка виден, используйте [Locator.First](/api/class-locator.mdx#locator-first).

**Использование**

```csharp
// Конкретный элемент виден.
await Expect(Page.GetByText("Welcome")).ToBeVisibleAsync();

// По крайней мере один элемент в списке виден.
await Expect(Page.GetByTestId("todo-item").First).ToBeVisibleAsync();

// По крайней мере один из двух элементов виден, возможно, оба.
await Expect(
  Page.GetByRole(AriaRole.Button, new() { Name = "Sign in" })
    .Or(Page.GetByRole(AriaRole.Button, new() { Name = "Sign up" }))
    .First
).ToBeVisibleAsync();
```

**Аргументы**
- `options` `LocatorAssertionsToBeVisibleOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-visible-option-timeout"/><a href="#locator-assertions-to-be-visible-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.
  - `Visible` [bool]? *(опционально)* <font size="2">Добавлено в: v1.26</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-visible-option-visible"/><a href="#locator-assertions-to-be-visible-option-visible" class="list-anchor">#</a>

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-be-visible-return"/><a href="#locator-assertions-to-be-visible-return" class="list-anchor">#</a>

---

### ToContainClassAsync {#locator-assertions-to-contain-class}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.52</font><x-search>locatorAssertions.ToContainClassAsync</x-search>

Гарантирует, что [Locator] указывает на элемент с заданными CSS-классами. Все классы из проверяемого значения, разделённые пробелами, должны присутствовать в [Element.classList](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList) в любом порядке.

**Использование**

```html
<div class='middle selected row' id='component'></div>
```

```csharp
var locator = Page.Locator("#component");
await Expect(locator).ToContainClassAsync("middle selected row");
await Expect(locator).ToContainClassAsync("selected");
await Expect(locator).ToContainClassAsync("row middle");
```

При передаче массива метод проверяет, что список найденных элементов соответствует соответствующему списку ожидаемых списков классов. Атрибут class каждого элемента сопоставляется с соответствующим классом в массиве:

```html
<div class='list'>
  <div class='component inactive'></div>
  <div class='component active'></div>
  <div class='component inactive'></div>
</div>
```

```csharp
var locator = Page.Locator(".list > .component");
await Expect(locator).ToContainClassAsync(new string[]{"inactive", "active", "inactive"});
```

**Аргументы**
- `expected` [string] | [IEnumerable]&lt;[string]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-class-option-expected"/><a href="#locator-assertions-to-contain-class-option-expected" class="list-anchor">#</a>
  
  Строка, содержащая ожидаемые имена классов, разделённые пробелами, или список таких строк для проверки нескольких элементов.
- `options` `LocatorAssertionsToContainClassOptions?` (опционально)
  - `Timeout` [float]? (опционально)<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-class-option-timeout"/><a href="#locator-assertions-to-contain-class-option-timeout" class="list-anchor">#</a>
    
    Время повторных попыток выполнения проверки в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-class-return"/><a href="#locator-assertions-to-contain-class-return" class="list-anchor">#</a>

---

### ToContainTextAsync {#locator-assertions-to-contain-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToContainTextAsync</x-search>

Убеждается, что [Locator] указывает на элемент, который содержит указанный текст. Все вложенные элементы будут учитываться при вычислении текстового содержимого элемента. Вы также можете использовать регулярные выражения для значения.

**Использование**

```csharp
var locator = Page.Locator(".title");
await Expect(locator).ToContainTextAsync("substring");
await Expect(locator).ToContainTextAsync(new Regex("\\d messages"));
```

Если вы передаете массив в качестве ожидаемого значения, ожидания следующие:
1. Локатор разрешается в список элементов.
1. Элементы из **подмножества** этого списка содержат текст из ожидаемого массива соответственно.
1. Соответствующее подмножество элементов имеет тот же порядок, что и ожидаемый массив.
1. Каждое текстовое значение из ожидаемого массива соответствует какому-то элементу из списка.

Например, рассмотрим следующий список:

```html
<ul>
  <li>Item Text 1</li>
  <li>Item Text 2</li>
  <li>Item Text 3</li>
</ul>
```

Посмотрим, как мы можем использовать утверждение:

```csharp
// ✓ Содержит правильные элементы в правильном порядке
await Expect(Page.Locator("ul > li")).ToContainTextAsync(new string[] {"Text 1", "Text 3", "Text 4"});

// ✖ Неправильный порядок
await Expect(Page.Locator("ul > li")).ToContainTextAsync(new string[] {"Text 3", "Text 2"});

// ✖ Ни один элемент не содержит этот текст
await Expect(Page.Locator("ul > li")).ToContainTextAsync(new string[] {"Some 33"});

// ✖ Локатор указывает на внешний элемент списка, а не на элементы списка
await Expect(Page.Locator("ul")).ToContainTextAsync(new string[] {"Text 3"});
```

**Аргументы**
- `expected` [string] | [Regex] | [IEnumerable]&lt;[string]&gt; | [IEnumerable]&lt;[Regex]&gt; <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-option-expected"/><a href="#locator-assertions-to-contain-text-option-expected" class="list-anchor">#</a>
  
  Ожидаемая подстрока или RegExp или список из них.
- `options` `LocatorAssertionsToContainTextOptions?` *(опционально)*
  - `IgnoreCase` [bool]? *(опционально)* <font size="2">Добавлено в: v1.23</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-option-ignore-case"/><a href="#locator-assertions-to-contain-text-option-ignore-case" class="list-anchor">#</a>
    
    Выполнять ли сопоставление без учета регистра. Опция [IgnoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-contain-text-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-option-timeout"/><a href="#locator-assertions-to-contain-text-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.
  - `UseInnerText` [bool]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-option-use-inner-text"/><a href="#locator-assertions-to-contain-text-option-use-inner-text" class="list-anchor">#</a>
    
    Использовать ли `element.innerText` вместо `element.textContent` при получении текста DOM-узла.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-contain-text-return"/><a href="#locator-assertions-to-contain-text-return" class="list-anchor">#</a>

**Детали**

Когда параметр `expected` является строкой, Playwright нормализует пробелы и разрывы строк как в фактическом тексте, так и в ожидаемой строке перед сопоставлением. Когда используется регулярное выражение, фактический текст сопоставляется как есть.

---

### ToHaveAccessibleDescriptionAsync {#locator-assertions-to-have-accessible-description}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.44</font><x-search>locatorAssertions.ToHaveAccessibleDescriptionAsync</x-search>

Убеждается, что [Locator] указывает на элемент с заданным [доступным описанием](https://w3c.github.io/accname/#dfn-accessible-description).

**Использование**

```csharp
var locator = Page.GetByTestId("save-button");
await Expect(locator).ToHaveAccessibleDescriptionAsync("Save results to disk");
```

**Аргументы**
- `description` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-description-option-description"/><a href="#locator-assertions-to-have-accessible-description-option-description" class="list-anchor">#</a>
  
  Ожидаемое доступное описание.
- `options` `LocatorAssertionsToHaveAccessibleDescriptionOptions?` *(опционально)*
  - `IgnoreCase` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-description-option-ignore-case"/><a href="#locator-assertions-to-have-accessible-description-option-ignore-case" class="list-anchor">#</a>
    
    Выполнять ли сопоставление без учета регистра. Опция [IgnoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-description-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-description-option-timeout"/><a href="#locator-assertions-to-have-accessible-description-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-description-return"/><a href="#locator-assertions-to-have-accessible-description-return" class="list-anchor">#</a>

---

### ToHaveAccessibleErrorMessageAsync {#locator-assertions-to-have-accessible-error-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.50</font><x-search>locatorAssertions.ToHaveAccessibleErrorMessageAsync</x-search>

Убеждается, что [Locator] указывает на элемент с заданным [сообщением об ошибке aria](https://w3c.github.io/aria/#aria-errormessage).

**Использование**

```csharp
var locator = Page.GetByTestId("username-input");
await Expect(locator).ToHaveAccessibleErrorMessageAsync("Username is required.");
```

**Аргументы**
- `errorMessage` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-error-message-option-error-message"/><a href="#locator-assertions-to-have-accessible-error-message-option-error-message" class="list-anchor">#</a>
  
  Ожидаемое доступное сообщение об ошибке.
- `options` `LocatorAssertionsToHaveAccessibleErrorMessageOptions?` *(опционально)*
  - `IgnoreCase` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-error-message-option-ignore-case"/><a href="#locator-assertions-to-have-accessible-error-message-option-ignore-case" class="list-anchor">#</a>
    
    Выполнять ли сопоставление без учета регистра. Опция [IgnoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-error-message-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-error-message-option-timeout"/><a href="#locator-assertions-to-have-accessible-error-message-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-error-message-return"/><a href="#locator-assertions-to-have-accessible-error-message-return" class="list-anchor">#</a>

---

### ToHaveAccessibleNameAsync {#locator-assertions-to-have-accessible-name}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.44</font><x-search>locatorAssertions.ToHaveAccessibleNameAsync</x-search>

Убеждается, что [Locator] указывает на элемент с заданным [доступным именем](https://w3c.github.io/accname/#dfn-accessible-name).

**Использование**

```csharp
var locator = Page.GetByTestId("save-button");
await Expect(locator).ToHaveAccessibleNameAsync("Save to disk");
```

**Аргументы**
- `name` [string] | [Regex]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-name-option-name"/><a href="#locator-assertions-to-have-accessible-name-option-name" class="list-anchor">#</a>
  
  Ожидаемое доступное имя.
- `options` `LocatorAssertionsToHaveAccessibleNameOptions?` *(опционально)*
  - `IgnoreCase` [bool]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-name-option-ignore-case"/><a href="#locator-assertions-to-have-accessible-name-option-ignore-case" class="list-anchor">#</a>
    
    Выполнять ли сопоставление без учета регистра. Опция [IgnoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-accessible-name-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-name-option-timeout"/><a href="#locator-assertions-to-have-accessible-name-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-accessible-name-return"/><a href="#locator-assertions-to-have-accessible-name-return" class="list-anchor">#</a>

---

### ToHaveAttributeAsync {#locator-assertions-to-have-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToHaveAttributeAsync</x-search>

Убеждается, что [Locator] указывает на элемент с заданным атрибутом.

**Использование**

```csharp
var locator = Page.Locator("input");
await Expect(locator).ToHaveAttributeAsync("type", "text");
```

**Аргументы**
- `name` [string] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-option-name"/><a href="#locator-assertions-to-have-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута.
- `value` [string] | [Regex] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-option-value"/><a href="#locator-assertions-to-have-attribute-option-value" class="list-anchor">#</a>
  
  Ожидаемое значение атрибута.
- `options` `LocatorAssertionsToHaveAttributeOptions?` *(опционально)*
  - `IgnoreCase` [bool]? *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-option-ignore-case"/><a href="#locator-assertions-to-have-attribute-option-ignore-case" class="list-anchor">#</a>
    
    Выполнять ли сопоставление без учета регистра. Опция [IgnoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-attribute-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-option-timeout"/><a href="#locator-assertions-to-have-attribute-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-attribute-return"/><a href="#locator-assertions-to-have-attribute-return" class="list-anchor">#</a>

---

### ToHaveClassAsync {#locator-assertions-to-have-class}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToHaveClassAsync</x-search>

Проверяет, что [Locator] указывает на элемент с заданными CSS-классами. Если передана строка, она должна полностью совпасть со значением атрибута `class` у элемента. Чтобы проверять отдельные классы, используйте [Expect(Locator).ToContainClassAsync()](/api/class-locatorassertions.mdx#locator-assertions-to-contain-class).

**Использование**

```html
<div class='middle selected row' id='component'></div>
```

```csharp
var locator = Page.Locator("#component");
await Expect(locator).ToHaveClassAsync("middle selected row");
await Expect(locator).ToHaveClassAsync(new Regex("(^|\\s)selected(\\s|$)"));
```

Когда передается массив, метод утверждает, что список найденных элементов соответствует соответствующему списку ожидаемых значений классов. Атрибут class каждого элемента сопоставляется с соответствующей строкой или регулярным выражением в массиве:

```csharp
var locator = Page.Locator(".list > .component");
await Expect(locator).ToHaveClassAsync(new string[]{"component", "component selected", "component"});
```

**Аргументы**
- `expected` [string] | [Regex] | [IEnumerable]&lt;[string]&gt; | [IEnumerable]&lt;[Regex]&gt; <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-class-option-expected"/><a href="#locator-assertions-to-have-class-option-expected" class="list-anchor">#</a>
  
  Ожидаемый класс или RegExp или список из них.
- `options` `LocatorAssertionsToHaveClassOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-class-option-timeout"/><a href="#locator-assertions-to-have-class-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-class-return"/><a href="#locator-assertions-to-have-class-return" class="list-anchor">#</a>

---

### ToHaveCountAsync {#locator-assertions-to-have-count}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToHaveCountAsync</x-search>

Убеждается, что [Locator] разрешается в точное количество DOM-узлов.

**Использование**

```csharp
var locator = Page.Locator("list > .component");
await Expect(locator).ToHaveCountAsync(3);
```

**Аргументы**
- `count` [int] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-count-option-count"/><a href="#locator-assertions-to-have-count-option-count" class="list-anchor">#</a>
  
  Ожидаемое количество.
- `options` `LocatorAssertionsToHaveCountOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-count-option-timeout"/><a href="#locator-assertions-to-have-count-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-count-return"/><a href="#locator-assertions-to-have-count-return" class="list-anchor">#</a>

---

### ToHaveCSSAsync {#locator-assertions-to-have-css}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToHaveCSSAsync</x-search>

Убеждается, что [Locator] разрешается в элемент с заданным вычисленным стилем CSS.

**Использование**

```csharp
var locator = Page.GetByRole(AriaRole.Button);
await Expect(locator).ToHaveCSSAsync("display", "flex");
```

**Аргументы**
- `name` [string] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-css-option-name"/><a href="#locator-assertions-to-have-css-option-name" class="list-anchor">#</a>
  
  Имя CSS-свойства.
- `value` [string] | [Regex] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-css-option-value"/><a href="#locator-assertions-to-have-css-option-value" class="list-anchor">#</a>
  
  Значение CSS-свойства.
- `options` `LocatorAssertionsToHaveCSSOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-css-option-timeout"/><a href="#locator-assertions-to-have-css-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-css-return"/><a href="#locator-assertions-to-have-css-return" class="list-anchor">#</a>

---

### ToHaveIdAsync {#locator-assertions-to-have-id}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToHaveIdAsync</x-search>

Убеждается, что [Locator] указывает на элемент с заданным ID DOM-узла.

**Использование**

```csharp
var locator = Page.GetByRole(AriaRole.Textbox);
await Expect(locator).ToHaveIdAsync("lastname");
```

**Аргументы**
- `id` [string] | [Regex] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-id-option-id"/><a href="#locator-assertions-to-have-id-option-id" class="list-anchor">#</a>
  
  ID элемента.
- `options` `LocatorAssertionsToHaveIdOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-id-option-timeout"/><a href="#locator-assertions-to-have-id-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-id-return"/><a href="#locator-assertions-to-have-id-return" class="list-anchor">#</a>

---

### ToHaveJSPropertyAsync {#locator-assertions-to-have-js-property}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToHaveJSPropertyAsync</x-search>

Убеждается, что [Locator] указывает на элемент с заданным свойством JavaScript. Обратите внимание, что это свойство может быть как примитивного типа, так и простым сериализуемым объектом JavaScript.

**Использование**

```csharp
var locator = Page.Locator(".component");
await Expect(locator).ToHaveJSPropertyAsync("loaded", true);
```

**Аргументы**
- `name` [string] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-js-property-option-name"/><a href="#locator-assertions-to-have-js-property-option-name" class="list-anchor">#</a>
  
  Имя свойства.
- `value` [object] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-js-property-option-value"/><a href="#locator-assertions-to-have-js-property-option-value" class="list-anchor">#</a>
  
  Значение свойства.
- `options` `LocatorAssertionsToHaveJSPropertyOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-js-property-option-timeout"/><a href="#locator-assertions-to-have-js-property-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-js-property-return"/><a href="#locator-assertions-to-have-js-property-return" class="list-anchor">#</a>

---

### ToHaveRoleAsync {#locator-assertions-to-have-role}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.44</font><x-search>locatorAssertions.ToHaveRoleAsync</x-search>

Убеждается, что [Locator] указывает на элемент с заданной [ролью ARIA](https://www.w3.org/TR/wai-aria-1.2/#roles).

Обратите внимание, что роль сопоставляется как строка, игнорируя иерархию ролей ARIA. Например, утверждение о роли суперкласса `"checkbox"` на элементе с ролью подкласса `"switch"` завершится неудачей.

**Использование**

```csharp
var locator = Page.GetByTestId("save-button");
await Expect(locator).ToHaveRoleAsync(AriaRole.Button);
```

**Аргументы**
- `role` `enum AriaRole { Alert, Alertdialog, Application, Article, Banner, Blockquote, Button, Caption, Cell, Checkbox, Code, Columnheader, Combobox, Complementary, Contentinfo, Definition, Deletion, Dialog, Directory, Document, Emphasis, Feed, Figure, Form, Generic, Grid, Gridcell, Group, Heading, Img, Insertion, Link, List, Listbox, Listitem, Log, Main, Marquee, Math, Meter, Menu, Menubar, Menuitem, Menuitemcheckbox, Menuitemradio, Navigation, None, Note, Option, Paragraph, Presentation, Progressbar, Radio, Radiogroup, Region, Row, Rowgroup, Rowheader, Scrollbar, Search, Searchbox, Separator, Slider, Spinbutton, Status, Strong, Subscript, Superscript, Switch, Tab, Table, Tablist, Tabpanel, Term, Textbox, Time, Timer, Toolbar, Tooltip, Tree, Treegrid, Treeitem }`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-role-option-role"/><a href="#locator-assertions-to-have-role-option-role" class="list-anchor">#</a>
  
  Требуемая роль aria.
- `options` `LocatorAssertionsToHaveRoleOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-role-option-timeout"/><a href="#locator-assertions-to-have-role-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-role-return"/><a href="#locator-assertions-to-have-role-return" class="list-anchor">#</a>

---

### ToHaveTextAsync {#locator-assertions-to-have-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToHaveTextAsync</x-search>

Убеждается, что [Locator] указывает на элемент с заданным текстом. Все вложенные элементы будут учитываться при вычислении текстового содержимого элемента. Вы можете использовать регулярные выражения для значения.

**Использование**

```csharp
var locator = Page.Locator(".title");
await Expect(locator).ToHaveTextAsync(new Regex("Welcome, Test User"));
await Expect(locator).ToHaveTextAsync(new Regex("Welcome, .*"));
```

Если вы передаете массив в качестве ожидаемого значения, ожидания следующие:
1. Локатор разрешается в список элементов.
1. Количество элементов равно количеству ожидаемых значений в массиве.
1. Элементы из списка имеют текст, соответствующий ожидаемым значениям массива, один за другим, в порядке.

Например, рассмотрим следующий список:

```html
<ul>
  <li>Text 1</li>
  <li>Text 2</li>
  <li>Text 3</li>
</ul>
```

Посмотрим, как мы можем использовать утверждение:

```csharp
// ✓ Имеет правильные элементы в правильном порядке
await Expect(Page.Locator("ul > li")).ToHaveTextAsync(new string[] {"Text 1", "Text 2", "Text 3"});

// ✖ Неправильный порядок
await Expect(Page.Locator("ul > li")).ToHaveTextAsync(new string[] {"Text 3", "Text 2", "Text 1"});

// ✖ Последний элемент не совпадает
await Expect(Page.Locator("ul > li")).ToHaveTextAsync(new string[] {"Text 1", "Text 2", "Text"});

// ✖ Локатор указывает на внешний элемент списка, а не на элементы списка
await Expect(Page.Locator("ul")).ToHaveTextAsync(new string[] {"Text 1", "Text 2", "Text 3"});
```

**Аргументы**
- `expected` [string] | [Regex] | [IEnumerable]&lt;[string]&gt; | [IEnumerable]&lt;[Regex]&gt; <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-option-expected"/><a href="#locator-assertions-to-have-text-option-expected" class="list-anchor">#</a>
  
  Ожидаемая строка или RegExp или список из них.
- `options` `LocatorAssertionsToHaveTextOptions?` *(опционально)*
  - `IgnoreCase` [bool]? *(опционально)* <font size="2">Добавлено в: v1.23</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-option-ignore-case"/><a href="#locator-assertions-to-have-text-option-ignore-case" class="list-anchor">#</a>
    
    Выполнять ли сопоставление без учета регистра. Опция [IgnoreCase](/api/class-locatorassertions.mdx#locator-assertions-to-have-text-option-ignore-case) имеет приоритет над соответствующим флагом регулярного выражения, если он указан.
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-option-timeout"/><a href="#locator-assertions-to-have-text-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.
  - `UseInnerText` [bool]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-option-use-inner-text"/><a href="#locator-assertions-to-have-text-option-use-inner-text" class="list-anchor">#</a>
    
    Использовать ли `element.innerText` вместо `element.textContent` при получении текста DOM-узла.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-text-return"/><a href="#locator-assertions-to-have-text-return" class="list-anchor">#</a>

**Детали**

Когда параметр `expected` является строкой, Playwright нормализует пробелы и разрывы строк как в фактическом тексте, так и в ожидаемой строке перед сопоставлением. Когда используется регулярное выражение, фактический текст сопоставляется как есть.

---

### ToHaveValueAsync {#locator-assertions-to-have-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.ToHaveValueAsync</x-search>

Убеждается, что [Locator] указывает на элемент с заданным значением ввода. Вы можете использовать регулярные выражения для значения.

**Использование**

```csharp
var locator = Page.Locator("input[type=number]");
await Expect(locator).ToHaveValueAsync(new Regex("[0-9]"));
```

**Аргументы**
- `value` [string] | [Regex] <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-value-option-value"/><a href="#locator-assertions-to-have-value-option-value" class="list-anchor">#</a>
  
  Ожидаемое значение.
- `options` `LocatorAssertionsToHaveValueOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)* <font size="2">Добавлено в: v1.18</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-value-option-timeout"/><a href="#locator-assertions-to-have-value-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-value-return"/><a href="#locator-assertions-to-have-value-return" class="list-anchor">#</a>

---

### ToHaveValuesAsync {#locator-assertions-to-have-values}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>locatorAssertions.ToHaveValuesAsync</x-search>

Убеждается, что [Locator] указывает на мультивыбор/комбобокс (т.е. `select` с атрибутом `multiple`) и указанные значения выбраны.

**Использование**

Например, учитывая следующий элемент:

```html
<select id="favorite-colors" multiple>
  <option value="R">Red</option>
  <option value="G">Green</option>
  <option value="B">Blue</option>
</select>
```

```csharp
var locator = Page.Locator("id=favorite-colors");
await locator.SelectOptionAsync(new string[] { "R", "G" });
await Expect(locator).ToHaveValuesAsync(new Regex[] { new Regex("R"), new Regex("G") });
```

**Аргументы**
- `values` [IEnumerable]&lt;[string]&gt; | [IEnumerable]&lt;[Regex]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-values-option-values"/><a href="#locator-assertions-to-have-values-option-values" class="list-anchor">#</a>
  
  Ожидаемые в данный момент выбранные опции.
- `options` `LocatorAssertionsToHaveValuesOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-values-option-timeout"/><a href="#locator-assertions-to-have-values-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-have-values-return"/><a href="#locator-assertions-to-have-values-return" class="list-anchor">#</a>

---

### ToMatchAriaSnapshotAsync {#locator-assertions-to-match-aria-snapshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.49</font><x-search>locatorAssertions.ToMatchAriaSnapshotAsync</x-search>

Утверждает, что целевой элемент соответствует заданному [снимку доступности](../aria-snapshots.mdx).

**Использование**

```csharp
await page.GotoAsync("https://demo.playwright.dev/todomvc/");
await Expect(page.Locator("body")).ToMatchAriaSnapshotAsync(@"
  - heading ""todos""
  - textbox ""What needs to be done?""
");
```

**Аргументы**
- `expected` [string]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-match-aria-snapshot-option-expected"/><a href="#locator-assertions-to-match-aria-snapshot-option-expected" class="list-anchor">#</a>
- `options` `LocatorAssertionsToMatchAriaSnapshotOptions?` *(опционально)*
  - `Timeout` [float]? *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-match-aria-snapshot-option-timeout"/><a href="#locator-assertions-to-match-aria-snapshot-option-timeout" class="list-anchor">#</a>
    
    Время для повторной попытки утверждения в миллисекундах. По умолчанию `5000`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="locator-assertions-to-match-aria-snapshot-return"/><a href="#locator-assertions-to-match-aria-snapshot-return" class="list-anchor">#</a>

---

## Свойства {#properties}

### Not {#locator-assertions-not}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.20</font><x-search>locatorAssertions.Not</x-search>

Заставляет проверку утверждения для противоположного условия. Например, этот код проверяет, что Локатор не содержит текст `"error"`:

```csharp
await Expect(locator).Not.ToContainTextAsync("error");
```

**Использование**

```csharp
Expect(Locator).Not
```

**Тип**
- [LocatorAssertions]


[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[CDPSessionEvent]: /api/class-cdpsessionevent.mdx "CDPSessionEvent"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[Request]: /api/class-request.mdx "Request"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[bool]: https://docs.microsoft.com/en-us/dotnet/api/system.boolean "bool"
[Date]: https://learn.microsoft.com/en-us/dotnet/api/system.datetime "DateTime"
[double]: https://docs.microsoft.com/en-us/dotnet/api/system.double "double"
[byte]: https://docs.microsoft.com/en-us/dotnet/api/system.byte "byte"
[int]: https://docs.microsoft.com/en-us/dotnet/api/system.int32 "int"
[long]: https://docs.microsoft.com/en-us/dotnet/api/system.int64 "long"
[void]: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/void "void"
[string]: https://docs.microsoft.com/en-us/dotnet/api/system.string "string"
[URL]: https://nodejs.org/api/url.html "URL"
[Regex]: https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex "Regex"

[Action]: https://docs.microsoft.com/en-us/dotnet/api/system.action-1 "Action"
[Func]: https://docs.microsoft.com/en-us/dotnet/api/system.func-2 "Func"
[IEnumerable]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable "IEnumerable"
[IReadOnlyList]: https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlylist-1?view=net-9.0 "IReadOnlyList"
[IDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary "IDictionary"
[Task]: https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-5.0 "Task"
[IReadOnlyDictionary]: https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ireadonlydictionary-2 "IReadOnlyDictionary"
[JsonElement]: https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement "JsonElement"

[все доступные теги образов]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "все доступные теги образов"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/dotnet/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-dotnet/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
