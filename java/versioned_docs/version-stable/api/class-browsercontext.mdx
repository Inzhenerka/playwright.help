---
id: class-browsercontext
title: "BrowserContext"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

BrowserContexts provide a way to operate multiple independent browser sessions.

Если страница открывает другую страницу, например, с помощью вызова `window.open`, всплывающее окно будет принадлежать контексту браузера родительской страницы.

Playwright позволяет создавать изолированные непостоянные (неперсистентные) контексты браузера с помощью метода [Browser.newContext()](/api/class-browser.mdx#browser-new-context). Такие контексты не сохраняют данные просмотра на диск.

```java
// Создание нового приватного (инкогнито) контекста браузера
BrowserContext context = browser.newContext();
// Создание новой страницы в этом контексте.
Page page = context.newPage();
page.navigate("https://example.com");
// Закрытие контекста, когда он больше не нужен.
context.close();
```

---

## Методы

### addCookies {#browser-context-add-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.addCookies</x-search>

Добавляет cookies в данный контекст браузера. Все страницы в этом контексте будут иметь указанные cookies. Cookies можно получить с помощью метода [BrowserContext.cookies()](/api/class-browsercontext.mdx#browser-context-cookies).

**Использование**

```java
browserContext.addCookies(Arrays.asList(cookieObject1, cookieObject2));
```

**Аргументы**
- `cookies` [List]&lt;`Cookie`&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-option-cookies"/><a href="#browser-context-add-cookies-option-cookies" class="list-anchor">#</a>
  - `setName` [String]

  - `setValue` [String]

  - `setUrl` [String] *(опционально)*
    Необходимо указать либо `url`, либо `domain` и `path`. Необязательный параметр.
  - `setDomain` [String] *(опционально)*
    Чтобы cookie применялась ко всем поддоменам, добавьте точку перед доменом, например: ".example.com". Необходимо указать либо `url`, либо `domain` и `path`. Необязательный параметр.
  - `setPath` [String] *(опционально)*
    Необходимо указать либо `url`, либо `domain` и `path`. Необязательный параметр.
  - `setExpires` [double] *(опционально)*
    Время в формате Unix (в секундах). Необязательный параметр.
  - `setHttpOnly` [boolean] *(опционально)*
    Необязательный параметр.
  - `setSecure` [boolean] *(опционально)*
    Необязательный параметр.
  - `setSameSite` `enum SameSiteAttribute { STRICT, LAX, NONE }` *(опционально)*
    Необязательный параметр.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-cookies-return"/><a href="#browser-context-add-cookies-return" class="list-anchor">#</a>

---

### addInitScript {#browser-context-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.addInitScript</x-search>

Добавляет скрипт, который будет выполняться в одном из следующих случаев:
* Когда создаётся страница в контексте браузера или происходит навигация.
* Когда вложенный фрейм добавляется или в нём происходит навигация на любой странице в контексте браузера. В этом случае скрипт выполняется в контексте нового фрейма.

Скрипт выполняется после создания документа, но до запуска любых скриптов самой страницы. Это полезно для настройки окружения JavaScript, например, для подмены `Math.random`.

**Использование**

Пример переопределения `Math.random` до загрузки страницы:

```js
// preload.js
Math.random = () => 42;
```

```java
// В вашем скрипте playwright, если файл preload.js находится в той же директории.
browserContext.addInitScript(Paths.get("preload.js"));
```

:::note
Порядок выполнения нескольких скриптов, установленных через [BrowserContext.addInitScript()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [Page.addInitScript()](/api/class-page.mdx#page-add-init-script), не определён.
:::

**Аргументы**
- `script` [String] | [Path]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-option-script"/><a href="#browser-context-add-init-script-option-script" class="list-anchor">#</a>
  Скрипт, который будет выполняться на всех страницах в данном контексте браузера.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-add-init-script-return"/><a href="#browser-context-add-init-script-return" class="list-anchor">#</a>

---

### backgroundPages {#browser-context-background-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.backgroundPages</x-search>

:::note

Фоновые страницы поддерживаются только в браузерах на базе Chromium.
:::

Все существующие фоновые страницы в данном контексте.

**Использование**

```java
BrowserContext.backgroundPages();
```

**Возвращает**
- [List]&lt;[Page]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-background-pages-return"/><a href="#browser-context-background-pages-return" class="list-anchor">#</a>

---

### browser {#browser-context-browser}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.browser</x-search>

Возвращает экземпляр браузера, к которому относится данный контекст. Если контекст был создан как постоянный (persistent), возвращается `null`.

**Использование**

```java
BrowserContext.browser();
```

**Возвращает**
- [null] | [Browser]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-browser-return"/><a href="#browser-context-browser-return" class="list-anchor">#</a>

---

### clearCookies {#browser-context-clear-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.clearCookies</x-search>

Удаляет cookies из контекста. Поддерживает необязательный фильтр.

**Использование**

```java
context.clearCookies();
context.clearCookies(new BrowserContext.ClearCookiesOptions().setName("session-id"));
context.clearCookies(new BrowserContext.ClearCookiesOptions().setDomain("my-origin.com"));
context.clearCookies(new BrowserContext.ClearCookiesOptions().setPath("/api/v1"));
context.clearCookies(new BrowserContext.ClearCookiesOptions()
                         .setName("session-id")
                         .setDomain("my-origin.com"));
```

**Аргументы**
- `options` `BrowserContext.ClearCookiesOptions` *(опционально)*
  - `setDomain` [String] | [Pattern] *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-domain"/><a href="#browser-context-clear-cookies-option-domain" class="list-anchor">#</a>
    Удаляет только cookies с указанным доменом.
  - `setName` [String] | [Pattern] *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-name"/><a href="#browser-context-clear-cookies-option-name" class="list-anchor">#</a>
    Удаляет только cookies с указанным именем.
  - `setPath` [String] | [Pattern] *(опционально)* <font size="2">Добавлено в: v1.43</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-option-path"/><a href="#browser-context-clear-cookies-option-path" class="list-anchor">#</a>
    Удаляет только cookies с указанным путём.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-cookies-return"/><a href="#browser-context-clear-cookies-return" class="list-anchor">#</a>

---

### clearPermissions {#browser-context-clear-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.clearPermissions</x-search>

Сбрасывает все переопределения разрешений для данного контекста браузера.

**Использование**

```java
BrowserContext context = browser.newContext();
context.grantPermissions(Arrays.asList("clipboard-read"));
// выполнение действий...
context.clearPermissions();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-clear-permissions-return"/><a href="#browser-context-clear-permissions-return" class="list-anchor">#</a>

---

### close {#browser-context-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.close</x-search>

Закрывает данный контекст браузера. Все страницы, относящиеся к этому контексту, будут закрыты.

:::note

Контекст браузера по умолчанию не может быть закрыт.
:::

**Использование**

```java
BrowserContext.close();
BrowserContext.close(options);
```

**Аргументы**
- `options` `BrowserContext.CloseOptions` *(опционально)*
  - `setReason` [String] *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-option-reason"/><a href="#browser-context-close-option-reason" class="list-anchor">#</a>
    Причина, которая будет указана для операций, прерванных из-за закрытия контекста.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-close-return"/><a href="#browser-context-close-return" class="list-anchor">#</a>

---

### cookies {#browser-context-cookies}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.cookies</x-search>

Если не указаны URL-адреса, метод возвращает все cookies. Если указаны URL, возвращаются только cookies, относящиеся к этим URL.

**Использование**

```java
BrowserContext.cookies();
BrowserContext.cookies(urls);
```

**Аргументы**
- `urls` [String] | [List]&lt;[String]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-option-urls"/><a href="#browser-context-cookies-option-urls" class="list-anchor">#</a>
  Необязательный список URL-адресов.

**Возвращает**
- [List]&lt;`Cookie`&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-cookies-return"/><a href="#browser-context-cookies-return" class="list-anchor">#</a>
  - `name` [String]
  - `value` [String]
  - `domain` [String]
  - `path` [String]
  - `expires` [double]
    Время в формате Unix (в секундах).
  - `httpOnly` [boolean]
  - `secure` [boolean]
  - `sameSite` `enum SameSiteAttribute { STRICT, LAX, NONE }`

---

### exposeBinding {#browser-context-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.exposeBinding</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-binding-option-name) в объект `window` каждого фрейма на каждой странице в контексте. При вызове эта функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback) и возвращает [Promise], который резолвится в результат выполнения [callback](/api/class-browsercontext.mdx#browser-context-expose-binding-option-callback). Если [callback] возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback] содержит информацию о вызывающем контексте: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

Смотрите также [Page.exposeBinding()](/api/class-page.mdx#page-expose-binding) для версии, ограниченной страницей.

**Использование**

Пример: передача URL страницы во все фреймы на всех страницах контекста:

```java
import com.microsoft.playwright.*;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch(new BrowserType.LaunchOptions().setHeadless(false));
      BrowserContext context = browser.newContext();
      context.exposeBinding("pageURL", (source, args) -> source.page().url());
      Page page = context.newPage();
      page.setContent("<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.pageURL();\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>");
      page.getByRole(AriaRole.BUTTON).click();
    }
  }
}
```

**Аргументы**
- `name` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-name"/><a href="#browser-context-expose-binding-option-name" class="list-anchor">#</a>
  Имя функции в объекте window.
- `callback` `BindingCallback`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-callback"/><a href="#browser-context-expose-binding-option-callback" class="list-anchor">#</a>
  Callback-функция, которая будет вызываться в контексте Playwright.
- `options` `BrowserContext.ExposeBindingOptions` *(опционально)*
  - `setHandle` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-option-handle"/><a href="#browser-context-expose-binding-option-handle" class="list-anchor">#</a>
    :::warning[Устарело]
    Эта опция будет удалена в будущих версиях.
    :::

    Определяет, передавать ли аргумент как handle вместо значения. При передаче handle поддерживается только один аргумент. При передаче по значению — несколько.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-binding-return"/><a href="#browser-context-expose-binding-return" class="list-anchor">#</a>

---

### exposeFunction {#browser-context-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.exposeFunction</x-search>

Метод добавляет функцию с именем [name](/api/class-browsercontext.mdx#browser-context-expose-function-option-name) в объект `window` каждого фрейма на каждой странице в контексте. При вызове эта функция выполняет [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) и возвращает [Promise], который резолвится в результат выполнения callback.

Если [callback](/api/class-browsercontext.mdx#browser-context-expose-function-option-callback) возвращает [Promise], он будет ожидаем.

Смотрите также [Page.exposeFunction()](/api/class-page.mdx#page-expose-function) для версии, ограниченной страницей.

**Использование**

Пример добавления функции `sha256` во все страницы в контексте:

```java
import com.microsoft.playwright.*;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch(new BrowserType.LaunchOptions().setHeadless(false));
      BrowserContext context = browser.newContext();
      context.exposeFunction("sha256", args -> {
        String text = (String) args[0];
        MessageDigest crypto;
        try {
          crypto = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException e) {
          return null;
        }
        byte[] token = crypto.digest(text.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(token);
      });
      Page page = context.newPage();
      page.setContent("<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>\n");
      page.getByRole(AriaRole.BUTTON).click();
    }
  }
}
```

**Аргументы**
- `name` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-name"/><a href="#browser-context-expose-function-option-name" class="list-anchor">#</a>
  Имя функции в объекте window.
- `callback` `FunctionCallback`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-option-callback"/><a href="#browser-context-expose-function-option-callback" class="list-anchor">#</a>
  Callback-функция, которая будет вызываться в контексте Playwright.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-expose-function-return"/><a href="#browser-context-expose-function-return" class="list-anchor">#</a>

---

### grantPermissions {#browser-context-grant-permissions}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.grantPermissions</x-search>

Выдаёт указанные разрешения контексту браузера. Если указано origin, разрешения применяются только к этому источнику.

**Использование**

```java
BrowserContext.grantPermissions(permissions);
BrowserContext.grantPermissions(permissions, options);
```

**Аргументы**
- `permissions` [List]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-permissions"/><a href="#browser-context-grant-permissions-option-permissions" class="list-anchor">#</a>
  Список разрешений, которые нужно выдать.

  :::danger

  Поддерживаемые разрешения различаются в зависимости от браузера и даже между разными версиями одного и того же браузера. Любое разрешение может перестать работать после обновления.
  :::

  Некоторые из разрешений, которые могут поддерживаться:
  * `'accelerometer'`
  * `'ambient-light-sensor'`
  * `'background-sync'`
  * `'camera'`
  * `'clipboard-read'`
  * `'clipboard-write'`
  * `'geolocation'`
  * `'gyroscope'`
  * `'magnetometer'`
  * `'microphone'`
  * `'midi-sysex'` (system-exclusive midi)
  * `'midi'`
  * `'notifications'`
  * `'payment-handler'`
  * `'storage-access'`

- `options` `BrowserContext.GrantPermissionsOptions` *(опционально)*
  - `setOrigin` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-option-origin"/><a href="#browser-context-grant-permissions-option-origin" class="list-anchor">#</a>
    [Origin], которому следует выдать разрешения, например `"https://example.com"`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-grant-permissions-return"/><a href="#browser-context-grant-permissions-return" class="list-anchor">#</a>

---

### newCDPSession {#browser-context-new-cdp-session}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.newCDPSession</x-search>

:::note

Сессии CDP поддерживаются только в браузерах на базе Chromium.
:::

Возвращает вновь созданную сессию.

**Использование**

```java
BrowserContext.newCDPSession(page);
```

**Аргументы**
- `page` [Page] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-option-page"/><a href="#browser-context-new-cdp-session-option-page" class="list-anchor">#</a>
  Цель, для которой создаётся новая сессия. Для обратной совместимости параметр называется `page`, но может быть как `Page`, так и `Frame`.

**Возвращает**
- [CDPSession]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-cdp-session-return"/><a href="#browser-context-new-cdp-session-return" class="list-anchor">#</a>

---

### newPage {#browser-context-new-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.newPage</x-search>

Создаёт новую страницу в данном контексте браузера.

**Использование**

```java
BrowserContext.newPage();
```

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-new-page-return"/><a href="#browser-context-new-page-return" class="list-anchor">#</a>

---

### pages {#browser-context-pages}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.pages</x-search>

Возвращает все открытые страницы в контексте.

**Использование**

```java
BrowserContext.pages();
```

**Возвращает**
- [List]&lt;[Page]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-pages-return"/><a href="#browser-context-pages-return" class="list-anchor">#</a>

---

### route {#browser-context-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.route</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются любой страницей в контексте браузера. Как только маршрут включен, каждый запрос, соответствующий шаблону URL, будет приостановлен, если он не будет продолжен, выполнен или прерван.

:::note

[BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route) не будет перехватывать запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [setServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

**Использование**

Пример простого обработчика, который прерывает все запросы изображений:

```java
BrowserContext context = browser.newContext();
context.route("**/*.{png,jpg,jpeg}", route -> route.abort());
Page page = context.newPage();
page.navigate("https://example.com");
browser.close();
```

или тот же фрагмент кода, но с использованием регулярного выражения:

```java
BrowserContext context = browser.newContext();
context.route(Pattern.compile("(\\.png$)|(\\.jpg$)"), route -> route.abort());
Page page = context.newPage();
page.navigate("https://example.com");
browser.close();
```

Можно исследовать запрос, чтобы решить, какое действие выполнить с маршрутом. Например, имитировать все запросы, содержащие некоторые данные POST, и оставлять все остальные запросы без изменений:

```java
context.route("/api/**", route -> {
  if (route.request().postData().contains("my-string"))
    route.fulfill(new Route.FulfillOptions().setBody("mocked-data"));
  else
    route.resume();
});
```

Маршруты страниц (настроенные с помощью [Page.route()](/api/class-page.mdx#page-route)) имеют приоритет над маршрутами контекста браузера, когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [BrowserContext.unroute()](/api/class-browsercontext.mdx#browser-context-unroute).

:::note

Включение маршрутизации отключает HTTP-кэш.
:::

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-url"/><a href="#browser-context-route-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для сопоставления при маршрутизации. Когда [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) через параметры контекста был предоставлен и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `handler` [Consumer]&lt;[Route]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-handler"/><a href="#browser-context-route-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации запроса.
- `options` `BrowserContext.RouteOptions` *(опционально)*
  - `setTimes` [int] *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-option-times"/><a href="#browser-context-route-option-times" class="list-anchor">#</a>
    
    Как часто маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-return"/><a href="#browser-context-route-return" class="list-anchor">#</a>

---

### routeFromHAR {#browser-context-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.23</font><x-search>browserContext.routeFromHAR</x-search>

Если указано, сетевые запросы, выполняемые в контексте, будут обслуживаться из HAR-файла. Подробнее о [Replaying from HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из HAR-файла. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [setServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```java
BrowserContext.routeFromHAR(har);
BrowserContext.routeFromHAR(har, options);
```

**Аргументы**
- `har` [Path]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-har"/><a href="#browser-context-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec) файлу с предварительно записанными сетевыми данными. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `options` `BrowserContext.RouteFromHAROptions` *(опционально)*
  - `setNotFound` `enum HarNotFound { ABORT, FALLBACK }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-not-found"/><a href="#browser-context-route-from-har-option-not-found" class="list-anchor">#</a>
    * Если установлено значение 'abort', любой запрос, не найденный в HAR-файле, будет прерван.
    * Если установлено значение 'fallback', переходит к следующему обработчику маршрута в цепочке обработчиков.
    
    По умолчанию прерывается.
  - `setUpdate` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update"/><a href="#browser-context-route-from-har-option-update" class="list-anchor">#</a>
    
    Если указано, обновляет данный HAR с фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск, когда [BrowserContext.close()](/api/class-browsercontext.mdx#browser-context-close) вызывается.
  - `setUpdateContent` `enum RouteFromHarUpdateContentPolicy { EMBED, ATTACH }` *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-content"/><a href="#browser-context-route-from-har-option-update-content" class="list-anchor">#</a>
    
    Опциональная настройка для управления содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP-архиве. Если указано `embed`, содержимое сохраняется в HAR-файле.
  - `setUpdateMode` `enum HarMode { FULL, MINIMAL }` *(опционально)* <font size="2">Добавлено в: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-update-mode"/><a href="#browser-context-route-from-har-option-update-mode" class="list-anchor">#</a>
    
    Когда установлено значение `minimal`, записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницу, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию `minimal`.
  - `setUrl` [String] | [Pattern] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-option-url"/><a href="#browser-context-route-from-har-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR-файла. Если не указано, все запросы обслуживаются из HAR-файла.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-from-har-return"/><a href="#browser-context-route-from-har-return" class="list-anchor">#</a>

---

### routeWebSocket {#browser-context-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.48</font><x-search>browserContext.routeWebSocket</x-search>

Этот метод позволяет изменять соединения WebSocket, которые создаются любой страницей в контексте браузера.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизированы. Рекомендуется вызывать этот метод перед созданием любых страниц.

**Использование**

Ниже приведен пример простого обработчика, который блокирует некоторые сообщения WebSocket. См. [WebSocketRoute] для получения более подробной информации и примеров.

```java
context.routeWebSocket("/ws", ws -> {
  ws.routeSend(message -> {
    if ("to-be-blocked".equals(message))
      return;
    ws.send(message);
  });
  ws.connect();
});
```

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-url"/><a href="#browser-context-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизированы. Строковый шаблон может быть относительным к параметру контекста [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url).
- `handler` [Consumer]&lt;[WebSocketRoute]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-option-handler"/><a href="#browser-context-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-route-web-socket-return"/><a href="#browser-context-route-web-socket-return" class="list-anchor">#</a>

---

### setDefaultNavigationTimeout {#browser-context-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setDefaultNavigationTimeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных с ними ярлыков:
* [Page.goBack()](/api/class-page.mdx#page-go-back)
* [Page.goForward()](/api/class-page.mdx#page-go-forward)
* [Page.navigate()](/api/class-page.mdx#page-goto)
* [Page.reload()](/api/class-page.mdx#page-reload)
* [Page.setContent()](/api/class-page.mdx#page-set-content)
* [Page.waitForNavigation()](/api/class-page.mdx#page-wait-for-navigation)

:::note

[Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) и [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) имеют приоритет над [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```java
BrowserContext.setDefaultNavigationTimeout(timeout);
```

**Аргументы**
- `timeout` [double]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-navigation-timeout-option-timeout"/><a href="#browser-context-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### setDefaultTimeout {#browser-context-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setDefaultTimeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих параметр [timeout](/api/class-browsercontext.mdx#browser-context-set-default-timeout-option-timeout).

:::note

[Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout), [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) и [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout) имеют приоритет над [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
:::

**Использование**

```java
BrowserContext.setDefaultTimeout(timeout);
```

**Аргументы**
- `timeout` [double]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-default-timeout-option-timeout"/><a href="#browser-context-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### setExtraHTTPHeaders {#browser-context-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setExtraHTTPHeaders</x-search>

Дополнительные HTTP-заголовки будут отправляться с каждым запросом, инициированным любой страницей в контексте. Эти заголовки объединяются с дополнительными HTTP-заголовками, установленными для страницы с помощью [Page.setExtraHTTPHeaders()](/api/class-page.mdx#page-set-extra-http-headers). Если страница переопределяет определенный заголовок, будет использоваться значение заголовка, специфичное для страницы, вместо значения заголовка контекста браузера.

:::note

[BrowserContext.setExtraHTTPHeaders()](/api/class-browsercontext.mdx#browser-context-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```java
BrowserContext.setExtraHTTPHeaders(headers);
```

**Аргументы**
- `headers` [Map]&lt;[String], [String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-option-headers"/><a href="#browser-context-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP-заголовки, которые будут отправляться с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-extra-http-headers-return"/><a href="#browser-context-set-extra-http-headers-return" class="list-anchor">#</a>

---

### setGeolocation {#browser-context-set-geolocation}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setGeolocation</x-search>

Устанавливает геолокацию контекста. Передача `null` или `undefined` эмулирует недоступность позиции.

**Использование**

```java
browserContext.setGeolocation(new Geolocation(59.95, 30.31667));
```

:::note
Рассмотрите возможность использования [BrowserContext.grantPermissions()](/api/class-browsercontext.mdx#browser-context-grant-permissions) для предоставления разрешений страницам контекста браузера на чтение его геолокации.
:::

**Аргументы**
- `geolocation` [null] | Geolocation<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-option-geolocation"/><a href="#browser-context-set-geolocation-option-geolocation" class="list-anchor">#</a>
  - `setLatitude` [double]
    
    Широта между -90 и 90.
  - `setLongitude` [double]
    
    Долгота между -180 и 180.
  - `setAccuracy` [double] *(опционально)*
    
    Неотрицательное значение точности. По умолчанию `0`.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-geolocation-return"/><a href="#browser-context-set-geolocation-return" class="list-anchor">#</a>

---

### setOffline {#browser-context-set-offline}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.setOffline</x-search>

**Использование**

```java
BrowserContext.setOffline(offline);
```

**Аргументы**
- `offline` [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-option-offline"/><a href="#browser-context-set-offline-option-offline" class="list-anchor">#</a>
  
  Эмулировать ли отсутствие сети для контекста браузера.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-set-offline-return"/><a href="#browser-context-set-offline-return" class="list-anchor">#</a>

---

### storageState {#browser-context-storage-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.storageState</x-search>

Возвращает состояние хранилища для этого контекста браузера, содержит текущие куки, снимок локального хранилища и снимок IndexedDB.

**Использование**

```java
BrowserContext.storageState();
BrowserContext.storageState(options);
```

**Аргументы**
- `options` `BrowserContext.StorageStateOptions` *(опционально)*
  - `setIndexedDB` [boolean] *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-indexed-db"/><a href="#browser-context-storage-state-option-indexed-db" class="list-anchor">#</a>
    
    Установите значение `true`, чтобы включить [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) в снимок состояния хранилища. Если ваше приложение использует IndexedDB для хранения токенов аутентификации, таких как Firebase Authentication, включите это.
    
    :::note
    
    IndexedDB с типизированными массивами в настоящее время не поддерживается.
    :::
    
  - `setPath` [Path] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-option-path"/><a href="#browser-context-storage-state-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения состояния хранилища. Если [setPath](/api/class-browsercontext.mdx#browser-context-storage-state-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, состояние хранилища все равно возвращается, но не будет сохранено на диск.

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-storage-state-return"/><a href="#browser-context-storage-state-return" class="list-anchor">#</a>

---

### unroute {#browser-context-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.unroute</x-search>

Удаляет маршрут, созданный с помощью [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route). Когда [handler](/api/class-browsercontext.mdx#browser-context-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-browsercontext.mdx#browser-context-unroute-option-url).

**Использование**

```java
BrowserContext.unroute(url);
BrowserContext.unroute(url, handler);
```

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-url"/><a href="#browser-context-unroute-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий [URL], использованный для регистрации маршрутизации с [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route).
- `handler` [Consumer]&lt;[Route]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-option-handler"/><a href="#browser-context-unroute-option-handler" class="list-anchor">#</a>
  
  Опциональная функция-обработчик, использованная для регистрации маршрутизации с [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-return"/><a href="#browser-context-unroute-return" class="list-anchor">#</a>

---

### unrouteAll {#browser-context-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.41</font><x-search>browserContext.unrouteAll</x-search>

Удаляет все маршруты, созданные с помощью [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [BrowserContext.routeFromHAR()](/api/class-browsercontext.mdx#browser-context-route-from-har).

**Использование**

```java
BrowserContext.unrouteAll();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-unroute-all-return"/><a href="#browser-context-unroute-all-return" class="list-anchor">#</a>

---

### waitForCondition {#browser-context-wait-for-condition}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.32</font><x-search>browserContext.waitForCondition</x-search>

Метод будет блокировать выполнение до тех пор, пока условие не вернет true. Все события Playwright будут обрабатываться, пока метод ожидает выполнения условия.

**Использование**

Используйте метод для ожидания условия, зависящего от событий страницы:

```java
List<String> failedUrls = new ArrayList<>();
context.onResponse(response -> {
  if (!response.ok()) {
    failedUrls.add(response.url());
  }
});
page1.getByText("Create user").click();
page2.getByText("Submit button").click();
context.waitForCondition(() -> failedUrls.size() > 3);
```

**Аргументы**
- `condition` [BooleanSupplier]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-condition-option-condition"/><a href="#browser-context-wait-for-condition-option-condition" class="list-anchor">#</a>
  
  Условие для ожидания.
- `options` `BrowserContext.WaitForConditionOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-condition-option-timeout"/><a href="#browser-context-wait-for-condition-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-condition-return"/><a href="#browser-context-wait-for-condition-return" class="list-anchor">#</a>

---

### waitForConsoleMessage {#browser-context-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.waitForConsoleMessage</x-search>

Выполняет действие и ожидает, пока [ConsoleMessage] не будет зарегистрировано на страницах в контексте. Если предикат предоставлен, он передает значение [ConsoleMessage] в функцию `predicate` и ожидает, пока `predicate(message)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [BrowserContext.onConsoleMessage(handler)](/api/class-browsercontext.mdx#browser-context-event-console) будет вызвано.

**Использование**

```java
BrowserContext.waitForConsoleMessage(callback);
BrowserContext.waitForConsoleMessage(callback, options);
```

**Аргументы**
- `options` `BrowserContext.WaitForConsoleMessageOptions` *(опционально)*
  - `setPredicate` [Predicate]&lt;[ConsoleMessage]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-predicate"/><a href="#browser-context-wait-for-console-message-option-predicate" class="list-anchor">#</a>
    
    Получает объект [ConsoleMessage] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-timeout"/><a href="#browser-context-wait-for-console-message-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-option-callback"/><a href="#browser-context-wait-for-console-message-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, выполняющий действие, вызывающее событие.

**Возвращает**
- [ConsoleMessage]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-console-message-return"/><a href="#browser-context-wait-for-console-message-return" class="list-anchor">#</a>

---

### waitForPage {#browser-context-wait-for-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>browserContext.waitForPage</x-search>

Выполняет действие и ожидает, пока в контексте не будет создана новая [Page]. Если предикат предоставлен, он передает значение [Page] в функцию `predicate` и ожидает, пока `predicate(event)` не вернет истинное значение. Выдаст ошибку, если контекст закроется до создания новой [Page].

**Использование**

```java
BrowserContext.waitForPage(callback);
BrowserContext.waitForPage(callback, options);
```

**Аргументы**
- `options` `BrowserContext.WaitForPageOptions` *(опционально)*
  - `setPredicate` [Predicate]&lt;[Page]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-predicate"/><a href="#browser-context-wait-for-page-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Page] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-timeout"/><a href="#browser-context-wait-for-page-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-option-callback"/><a href="#browser-context-wait-for-page-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, выполняющий действие, вызывающее событие.

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="browser-context-wait-for-page-return"/><a href="#browser-context-wait-for-page-return" class="list-anchor">#</a>

---

## Properties

### clock() {#browser-context-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.45</font><x-search>browserContext.clock()</x-search>

Playwright имеет возможность имитировать часы и ход времени.

**Использование**

```java
BrowserContext.clock()
```

**Возвращает**
- [Clock]

---

### request() {#browser-context-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.16</font><x-search>browserContext.request()</x-search>

Помощник для тестирования API, связанный с этим контекстом. Запросы, сделанные с помощью этого API, будут использовать куки контекста.

**Использование**

```java
BrowserContext.request()
```

**Возвращает**
- [APIRequestContext]

---

### tracing() {#browser-context-tracing}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.tracing()</x-search>

**Использование**

```java
BrowserContext.tracing()
```

**Возвращает**
- [Tracing]

---

## Events

### onBackgroundPage(handler) {#browser-context-event-background-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.11</font><x-search>browserContext.onBackgroundPage(handler)</x-search>

:::note

Работает только с постоянным контекстом браузера Chromium.
:::

Вызывается, когда в контексте создается новая фоновая страница.

```java
context.onBackgroundPage(backgroundPage -> {
  System.out.println(backgroundPage.url());
});
```

**Использование**

```java
BrowserContext.onBackgroundPage(handler)
```

**Данные события**
- [Page]

---

### onClose(handler) {#browser-context-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.onClose(handler)</x-search>

Вызывается, когда контекст браузера закрывается. Это может произойти по одной из следующих причин:
* Контекст браузера закрыт.
* Приложение браузера закрыто или произошло его аварийное завершение.
* Был вызван метод [Browser.close()](/api/class-browser.mdx#browser-close).

**Использование**

```java
BrowserContext.onClose(handler)
```

**Данные события**
- [BrowserContext]

---

### onConsoleMessage(handler) {#browser-context-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.onConsoleMessage(handler)</x-search>

Вызывается, когда JavaScript на странице вызывает один из методов консольного API, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log` и страницу, доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

```java
context.onConsoleMessage(msg -> {
  for (int i = 0; i < msg.args().size(); ++i)
    System.out.println(i + ": " + msg.args().get(i).jsonValue());
});
page.evaluate("() => console.log('hello', 5, { foo: 'bar' })");
```

**Данные события**
- [ConsoleMessage]

---

### onDialog(handler) {#browser-context-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.34</font><x-search>browserContext.onDialog(handler)</x-search>

Вызывается, когда появляется JavaScript-диалог, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Обработчик **должен** либо [Dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [Dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница [заморозится](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалога, и действия, такие как клик, никогда не завершатся.

**Использование**

```java
context.onDialog(dialog -> {
  dialog.accept();
});
```

:::note
Когда отсутствуют обработчики [Page.onDialog(handler)](/api/class-page.mdx#page-event-dialog) или [BrowserContext.onDialog(handler)](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### onPage(handler) {#browser-context-event-page}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>browserContext.onPage(handler)</x-search>

Событие вызывается, когда в BrowserContext создается новая страница. Страница может все еще загружаться. Событие также будет срабатывать для всплывающих страниц. См. также [Page.onPopup(handler)](/api/class-page.mdx#page-event-popup) для получения событий о всплывающих окнах, относящихся к конкретной странице.

Самый ранний момент, когда страница доступна, это когда она перешла на начальный URL. Например, при открытии всплывающего окна с `window.open('http://example.com')`, это событие сработает, когда сетевой запрос к "http://example.com" будет выполнен и его ответ начнет загружаться во всплывающем окне. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [BrowserContext.onRequest(handler)](/api/class-browsercontext.mdx#browser-context-event-request) соответственно, вместо аналогичных методов на [Page].

```java
Page newPage = context.waitForPage(() -> {
  page.getByText("open new page").click();
});
System.out.println(newPage.evaluate("location.href"));
```

:::note
Используйте [Page.waitForLoadState()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев это не потребуется).
:::

**Использование**

```java
BrowserContext.onPage(handler)
```

**Данные события**
- [Page]

---

### onRequest(handler) {#browser-context-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.onRequest(handler)</x-search>

Вызывается, когда запрос отправляется с любой страницы, созданной через этот контекст. Объект [request] доступен только для чтения. Чтобы слушать запросы только с определенной страницы, используйте [Page.onRequest(handler)](/api/class-page.mdx#page-event-request).

Для перехвата и изменения запросов см. [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route) или [Page.route()](/api/class-page.mdx#page-route).

**Использование**

```java
BrowserContext.onRequest(handler)
```

**Данные события**
- [Request]

---

### onRequestFailed(handler) {#browser-context-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.onRequestFailed(handler)</x-search>

Вызывается, когда запрос не удается выполнить, например, из-за тайм-аута. Чтобы слушать только неудачные запросы с определенной страницы, используйте [Page.onRequestFailed(handler)](/api/class-page.mdx#page-event-request-failed).

:::note

HTTP-ошибки, такие как 404 или 503, все еще считаются успешными ответами с точки зрения HTTP, поэтому запрос завершится событием [BrowserContext.onRequestFinished(handler)](/api/class-browsercontext.mdx#browser-context-event-request-finished), а не [BrowserContext.onRequestFailed(handler)](/api/class-browsercontext.mdx#browser-context-event-request-failed).
:::

**Использование**

```java
BrowserContext.onRequestFailed(handler)
```

**Данные события**
- [Request]

---

### onRequestFinished(handler) {#browser-context-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.onRequestFinished(handler)</x-search>

Вызывается, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`. Чтобы слушать успешные запросы с определенной страницы, используйте [Page.onRequestFinished(handler)](/api/class-page.mdx#page-event-request-finished).

**Использование**

```java
BrowserContext.onRequestFinished(handler)
```

**Данные события**
- [Request]

---

### onResponse(handler) {#browser-context-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.12</font><x-search>browserContext.onResponse(handler)</x-search>

Вызывается, когда статус и заголовки [response] получены для запроса. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`. Чтобы слушать события ответа с определенной страницы, используйте [Page.onResponse(handler)](/api/class-page.mdx#page-event-response).

**Использование**

```java
BrowserContext.onResponse(handler)
```

**Данные события**
- [Response]

---

### onWebError(handler) {#browser-context-event-web-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.38</font><x-search>browserContext.onWebError(handler)</x-search>

Вызывается, когда исключение не обработано на любой из страниц в этом контексте. Чтобы слушать ошибки с определенной страницы, используйте [Page.onPageError(handler)](/api/class-page.mdx#page-event-page-error) вместо этого.

**Использование**

```java
BrowserContext.onWebError(handler)
```

**Данные события**
- [WebError]


[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[PlaywrightException]: /api/class-playwrightexception.mdx "PlaywrightException"
[Request]: /api/class-request.mdx "Request"
[RequestOptions]: /api/class-requestoptions.mdx "RequestOptions"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[boolean]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "boolean"
[byte&#91;&#93;]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "byte[]"
[Consumer]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html "Consumer"
[Date]: https://docs.oracle.com/javase/8/docs/api/java/util/Date.html "Date"
[double]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "double"
[InputStream]: https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html "InputStream"
[int]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "int"
[long]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "long"
[JsonObject]: https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/JsonObject.html "JsonObject"
[List]: https://docs.oracle.com/javase/8/docs/api/java/util/List.html "List"
[Map]: https://docs.oracle.com/javase/8/docs/api/java/util/Map.html "Map"
[null]: https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.7 "null"
[Object]: https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html "Object"
[Path]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html "Path"
[Pattern]: https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html "Pattern"
[Predicate]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html "Predicate"
[void]: https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html "void"
[Runnable]: https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html "Runnable"
[RuntimeException]: https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html "RuntimeException"
[String]: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html "String"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/java/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/java/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-java/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
