---
id: class-elementhandle
title: "ElementHandle"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

* расширяет: [JSHandle]

ElementHandle представляет собой элемент DOM на странице. ElementHandles могут быть созданы с помощью метода [Page.querySelector()](/api/class-page.mdx#page-query-selector).

:::warning[Не рекомендуется]

Использование ElementHandle не рекомендуется, вместо этого используйте объекты [Locator] и утверждения, ориентированные на веб.
:::

```java
ElementHandle hrefElement = page.querySelector("a");
hrefElement.click();
```

ElementHandle предотвращает сборку мусора для DOM-элемента, если только дескриптор не будет удален с помощью [JSHandle.dispose()](/api/class-jshandle.mdx#js-handle-dispose). ElementHandles автоматически удаляются, когда их исходный фрейм переходит на другую страницу.

Экземпляры ElementHandle могут использоваться в качестве аргумента в методах [Page.evalOnSelector()](/api/class-page.mdx#page-eval-on-selector) и [Page.evaluate()](/api/class-page.mdx#page-evaluate).

Разница между [Locator] и ElementHandle заключается в том, что ElementHandle указывает на конкретный элемент, в то время как [Locator] захватывает логику того, как получить элемент.

В примере ниже дескриптор указывает на конкретный DOM-элемент на странице. Если этот элемент изменяет текст или используется React для рендеринга совершенно другого компонента, дескриптор все равно указывает на этот самый DOM-элемент. Это может привести к неожиданным поведениям.

```java
ElementHandle handle = page.querySelector("text=Submit");
handle.hover();
handle.click();
```

С локатором каждый раз, когда используется `element`, актуальный DOM-элемент находится на странице с использованием селектора. Таким образом, в приведенном ниже фрагменте подлежащий DOM-элемент будет найден дважды.

```java
Locator locator = page.getByText("Submit");
locator.hover();
locator.click();
```

---

## Методы

### boundingBox {#element-handle-bounding-box}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.boundingBox</x-search>

Этот метод возвращает ограничивающий прямоугольник элемента или `null`, если элемент не виден. Ограничивающий прямоугольник рассчитывается относительно области просмотра основного фрейма, которая обычно совпадает с окном браузера.

Прокрутка влияет на возвращаемый ограничивающий прямоугольник, аналогично [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect). Это означает, что `x` и/или `y` могут быть отрицательными.

Элементы из дочерних фреймов возвращают ограничивающий прямоугольник относительно основного фрейма, в отличие от [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).

Предполагая, что страница статична, безопасно использовать координаты ограничивающего прямоугольника для выполнения ввода. Например, следующий фрагмент должен кликнуть в центр элемента.

**Использование**

```java
BoundingBox box = elementHandle.boundingBox();
page.mouse().click(box.x + box.width / 2, box.y + box.height / 2);
```

**Возвращает**
- [null] | BoundingBox<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-bounding-box-return"/><a href="#element-handle-bounding-box-return" class="list-anchor">#</a>
  - `x` [double]
    
    x-координата элемента в пикселях.
  - `y` [double]
    
    y-координата элемента в пикселях.
  - `width` [double]
    
    ширина элемента в пикселях.
  - `height` [double]
    
    высота элемента в пикселях.

---

### contentFrame {#element-handle-content-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.contentFrame</x-search>

Возвращает фрейм содержимого для дескрипторов элементов, ссылающихся на узлы iframe, или `null` в противном случае.

**Использование**

```java
ElementHandle.contentFrame();
```

**Возвращает**
- [null] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-content-frame-return"/><a href="#element-handle-content-frame-return" class="list-anchor">#</a>

---

### ownerFrame {#element-handle-owner-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.ownerFrame</x-search>

Возвращает фрейм, содержащий данный элемент.

**Использование**

```java
ElementHandle.ownerFrame();
```

**Возвращает**
- [null] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-owner-frame-return"/><a href="#element-handle-owner-frame-return" class="list-anchor">#</a>

---

### waitForElementState {#element-handle-wait-for-element-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.waitForElementState</x-search>

Возвращает, когда элемент удовлетворяет [state](/api/class-elementhandle.mdx#element-handle-wait-for-element-state-option-state).

В зависимости от параметра [state](/api/class-elementhandle.mdx#element-handle-wait-for-element-state-option-state), этот метод ожидает, пока один из проверок [actionability](../actionability.mdx) не пройдет. Этот метод выбрасывает исключение, когда элемент отсоединяется во время ожидания, если только не ожидается состояние `"hidden"`.
* `"visible"` Ожидание, пока элемент не станет [видимым](../actionability.mdx#visible).
* `"hidden"` Ожидание, пока элемент не станет [невидимым](../actionability.mdx#visible) или не будет отсоединен. Обратите внимание, что ожидание скрытия не выбрасывает исключение, когда элемент отсоединяется.
* `"stable"` Ожидание, пока элемент не станет одновременно [видимым](../actionability.mdx#visible) и [стабильным](../actionability.mdx#stable).
* `"enabled"` Ожидание, пока элемент не станет [включенным](../actionability.mdx#enabled).
* `"disabled"` Ожидание, пока элемент не станет [не включенным](../actionability.mdx#enabled).
* `"editable"` Ожидание, пока элемент не станет [редактируемым](../actionability.mdx#editable).

Если элемент не удовлетворяет условию в течение [setTimeout](/api/class-elementhandle.mdx#element-handle-wait-for-element-state-option-timeout) миллисекунд, этот метод выбрасывает исключение.

**Использование**

```java
ElementHandle.waitForElementState(state);
ElementHandle.waitForElementState(state, options);
```

**Аргументы**
- `state` `enum ElementState { VISIBLE, HIDDEN, STABLE, ENABLED, DISABLED, EDITABLE }`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-element-state-option-state"/><a href="#element-handle-wait-for-element-state-option-state" class="list-anchor">#</a>
  
  Состояние, которое нужно ожидать, см. ниже для более подробной информации.
- `options` `ElementHandle.WaitForElementStateOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-element-state-option-timeout"/><a href="#element-handle-wait-for-element-state-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-element-state-return"/><a href="#element-handle-wait-for-element-state-return" class="list-anchor">#</a>

---

## Устаревшие

### check {#element-handle-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.check</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.check()](/api/class-locator.mdx#locator-check) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод проверяет элемент, выполняя следующие шаги:
1. Убедитесь, что элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже отмечен, этот метод возвращается немедленно.
1. Ожидание проверок [actionability](../actionability.mdx) на элементе, если только не установлен параметр [setForce](/api/class-elementhandle.mdx#element-handle-check-option-force).
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы кликнуть в центр элемента.
1. Убедитесь, что элемент теперь отмечен. Если нет, этот метод выбрасывает исключение.

Если элемент отсоединяется от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-elementhandle.mdx#element-handle-check-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
ElementHandle.check();
ElementHandle.check(options);
```

**Аргументы**
- `options` `ElementHandle.CheckOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-force"/><a href="#element-handle-check-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-no-wait-after"/><a href="#element-handle-check-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `setPosition` Position *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-position"/><a href="#element-handle-check-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-timeout"/><a href="#element-handle-check-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-option-trial"/><a href="#element-handle-check-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-check-return"/><a href="#element-handle-check-return" class="list-anchor">#</a>

---

### click {#element-handle-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.click</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.click()](/api/class-locator.mdx#locator-click) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод кликает по элементу, выполняя следующие шаги:
1. Ожидание проверок [actionability](../actionability.mdx) на элементе, если только не установлен параметр [setForce](/api/class-elementhandle.mdx#element-handle-click-option-force).
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы кликнуть в центр элемента или в указанную [setPosition](/api/class-elementhandle.mdx#element-handle-click-option-position).
1. Ожидание, пока инициированные навигации либо завершатся успешно, либо потерпят неудачу, если только не установлен параметр [setNoWaitAfter](/api/class-elementhandle.mdx#element-handle-click-option-no-wait-after).

Если элемент отсоединяется от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-elementhandle.mdx#element-handle-click-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
ElementHandle.click();
ElementHandle.click(options);
```

**Аргументы**
- `options` `ElementHandle.ClickOptions` *(опционально)*
  - `setButton` `enum MouseButton { LEFT, RIGHT, MIDDLE }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-button"/><a href="#element-handle-click-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `setClickCount` [int] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-click-count"/><a href="#element-handle-click-option-click-count" class="list-anchor">#</a>
    
    по умолчанию 1. См. [UIEvent.detail].
  - `setDelay` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-delay"/><a href="#element-handle-click-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-force"/><a href="#element-handle-click-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-modifiers"/><a href="#element-handle-click-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-no-wait-after"/><a href="#element-handle-click-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Этот параметр по умолчанию будет `true` в будущем.
    :::
    
    
    Действия, инициирующие навигации, ожидают, пока эти навигации не произойдут и страницы не начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится этот параметр только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `setPosition` Position *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-position"/><a href="#element-handle-click-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-timeout"/><a href="#element-handle-click-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-option-trial"/><a href="#element-handle-click-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-click-return"/><a href="#element-handle-click-return" class="list-anchor">#</a>

---

### dblclick {#element-handle-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.dblclick</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.dblclick()](/api/class-locator.mdx#locator-dblclick) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет двойной клик по элементу, выполняя следующие шаги:
1. Ожидание проверок [actionability](../actionability.mdx) на элементе, если только не установлен параметр [setForce](/api/class-elementhandle.mdx#element-handle-dblclick-option-force).
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы выполнить двойной клик в центр элемента или в указанную [setPosition](/api/class-elementhandle.mdx#element-handle-dblclick-option-position).

Если элемент отсоединяется от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-elementhandle.mdx#element-handle-dblclick-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

`elementHandle.dblclick()` генерирует два события `click` и одно событие `dblclick`.
:::

**Использование**

```java
ElementHandle.dblclick();
ElementHandle.dblclick(options);
```

**Аргументы**
- `options` `ElementHandle.DblclickOptions` *(опционально)*
  - `setButton` `enum MouseButton { LEFT, RIGHT, MIDDLE }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-button"/><a href="#element-handle-dblclick-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `setDelay` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-delay"/><a href="#element-handle-dblclick-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-force"/><a href="#element-handle-dblclick-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-modifiers"/><a href="#element-handle-dblclick-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-no-wait-after"/><a href="#element-handle-dblclick-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `setPosition` Position *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-position"/><a href="#element-handle-dblclick-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка, используемая относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-timeout"/><a href="#element-handle-dblclick-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-option-trial"/><a href="#element-handle-dblclick-option-trial" class="list-anchor">#</a>
    
    Когда установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dblclick-return"/><a href="#element-handle-dblclick-return" class="list-anchor">#</a>

---

### dispatchEvent {#element-handle-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.dispatchEvent</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.dispatchEvent()](/api/class-locator.mdx#locator-dispatch-event) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Приведенный ниже фрагмент генерирует событие `click` на элементе. Независимо от состояния видимости элемента, `click` генерируется. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Использование**

```java
elementHandle.dispatchEvent("click");
```

Внутри создается экземпляр события на основе указанного [type](/api/class-elementhandle.mdx#element-handle-dispatch-event-option-type), инициализируется с помощью свойств [eventInit](/api/class-elementhandle.mdx#element-handle-dispatch-event-option-event-init) и генерируется на элементе. События по умолчанию `composed`, `cancelable` и всплывают.

Поскольку [eventInit](/api/class-elementhandle.mdx#element-handle-dispatch-event-option-event-init) является специфичным для события, пожалуйста, обратитесь к документации по событиям для списков начальных свойств:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Вы также можете указать `JSHandle` в качестве значения свойства, если хотите, чтобы живые объекты передавались в событие:

```java
// Обратите внимание, что вы можете создать DataTransfer только в Chromium и Firefox
JSHandle dataTransfer = page.evaluateHandle("() => new DataTransfer()");
Map<String, Object> arg = new HashMap<>();
arg.put("dataTransfer", dataTransfer);
elementHandle.dispatchEvent("dragstart", arg);
```

**Аргументы**
- `type` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dispatch-event-option-type"/><a href="#element-handle-dispatch-event-option-type" class="list-anchor">#</a>
  
  Тип DOM-события: `"click"`, `"dragstart"`, и т.д.
- `eventInit` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dispatch-event-option-event-init"/><a href="#element-handle-dispatch-event-option-event-init" class="list-anchor">#</a>
  
  Опциональные свойства инициализации, специфичные для события.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-dispatch-event-return"/><a href="#element-handle-dispatch-event-return" class="list-anchor">#</a>

---

### evalOnSelector {#element-handle-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.evalOnSelector</x-search>

:::warning[Не рекомендуется]

Этот метод не ожидает, пока элемент пройдет проверки actionability, и поэтому может привести к нестабильным тестам. Используйте [Locator.evaluate()](/api/class-locator.mdx#locator-evaluate), другие вспомогательные методы [Locator] или утверждения, ориентированные на веб.

:::

Возвращает возвращаемое значение [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression).

Метод находит элемент, соответствующий указанному селектору в поддереве `ElementHandle`, и передает его в качестве первого аргумента в [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выбрасывает ошибку.

Если [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression) возвращает [Promise], то [ElementHandle.evalOnSelector()](/api/class-elementhandle.mdx#element-handle-eval-on-selector) будет ожидать разрешения промиса и возвращать его значение.

**Использование**

```java
ElementHandle tweetHandle = page.querySelector(".tweet");
assertEquals("100", tweetHandle.evalOnSelector(".like", "node => node.innerText"));
assertEquals("10", tweetHandle.evalOnSelector(".retweets", "node => node.innerText"));
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-option-selector"/><a href="#element-handle-eval-on-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-option-expression"/><a href="#element-handle-eval-on-selector-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-option-arg"/><a href="#element-handle-eval-on-selector-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-option-expression).

**Возвращает**
- [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-return"/><a href="#element-handle-eval-on-selector-return" class="list-anchor">#</a>

---

### evalOnSelectorAll {#element-handle-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.evalOnSelectorAll</x-search>

:::warning[Не рекомендуется]

В большинстве случаев [Locator.evaluateAll()](/api/class-locator.mdx#locator-evaluate-all), другие вспомогательные методы [Locator] и утверждения, ориентированные на веб, выполняют работу лучше.

:::

Возвращает возвращаемое значение [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression).

Метод находит все элементы, соответствующие указанному селектору в поддереве `ElementHandle`, и передает массив найденных элементов в качестве первого аргумента в [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression).

Если [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression) возвращает [Promise], то [ElementHandle.evalOnSelectorAll()](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all) будет ожидать разрешения промиса и возвращать его значение.

**Использование**

```html
<div class="feed">
  <div class="tweet">Hello!</div>
  <div class="tweet">Hi!</div>
</div>
```

```java
ElementHandle feedHandle = page.querySelector(".feed");
assertEquals(Arrays.asList("Hello!", "Hi!"), feedHandle.evalOnSelectorAll(".tweet", "nodes => nodes.map(n => n.innerText)"));
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-option-selector"/><a href="#element-handle-eval-on-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-option-expression"/><a href="#element-handle-eval-on-selector-all-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-option-arg"/><a href="#element-handle-eval-on-selector-all-option-arg" class="list-anchor">#</a>
  
  Опциональный аргумент для передачи в [expression](/api/class-elementhandle.mdx#element-handle-eval-on-selector-all-option-expression).

**Возвращает**
- [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-eval-on-selector-all-return"/><a href="#element-handle-eval-on-selector-all-return" class="list-anchor">#</a>

---

### fill {#element-handle-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.fill</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.fill()](/api/class-locator.mdx#locator-fill) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает проверок [actionability](../actionability.mdx), фокусируется на элементе, заполняет его и генерирует событие `input` после заполнения. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является `<input>`, `<textarea>` или `[contenteditable]` элементом, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен именно этот элемент управления.

Для отправки более детализированных событий клавиатуры используйте [Locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially).

**Использование**

```java
ElementHandle.fill(value);
ElementHandle.fill(value, options);
```

**Аргументы**
- `value` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-value"/><a href="#element-handle-fill-option-value" class="list-anchor">#</a>
  
  Значение для установки для элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `options` `ElementHandle.FillOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-force"/><a href="#element-handle-fill-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-no-wait-after"/><a href="#element-handle-fill-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-option-timeout"/><a href="#element-handle-fill-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) методы.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-fill-return"/><a href="#element-handle-fill-return" class="list-anchor">#</a>

---

### focus {#element-handle-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.focus</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.focus()](/api/class-locator.mdx#locator-focus) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Вызывает [focus](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) на элементе.

**Использование**

```java
ElementHandle.focus();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-focus-return"/><a href="#element-handle-focus-return" class="list-anchor">#</a>

---

### getAttribute {#element-handle-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.getAttribute</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.getAttribute()](/api/class-locator.mdx#locator-get-attribute) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает значение атрибута элемента.

**Использование**

```java
ElementHandle.getAttribute(name);
```

**Аргументы**
- `name` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-get-attribute-option-name"/><a href="#element-handle-get-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута, для которого нужно получить значение.

**Возвращает**
- [null] | [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-get-attribute-return"/><a href="#element-handle-get-attribute-return" class="list-anchor">#</a>

---

### hover {#element-handle-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.hover</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.hover()](/api/class-locator.mdx#locator-hover) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод наводит курсор на элемент, выполняя следующие шаги:
1. Ожидает проверки [действительности](../actionability.mdx) элемента, если не установлена опция [setForce](/api/class-elementhandle.mdx#element-handle-hover-option-force).
2. Прокручивает элемент в видимую область, если это необходимо.
3. Использует [Page.mouse()](/api/class-page.mdx#page-mouse) для наведения на центр элемента или указанную позицию [setPosition](/api/class-elementhandle.mdx#element-handle-hover-option-position).

Если элемент отсоединяется от DOM в любой момент во время действия, этот метод выбрасывает исключение.

Если все шаги не завершены в течение указанного времени [setTimeout](/api/class-elementhandle.mdx#element-handle-hover-option-timeout), этот метод выбрасывает [TimeoutError]. Установка нулевого таймаута отключает это.

**Использование**

```java
ElementHandle.hover();
ElementHandle.hover(options);
```

**Аргументы**
- `options` `ElementHandle.HoverOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-force"/><a href="#element-handle-hover-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-modifiers"/><a href="#element-handle-hover-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается как "Control" на Windows и Linux и как "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(опционально)* <font size="2">Добавлено в: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-no-wait-after"/><a href="#element-handle-hover-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setPosition` Position *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-position"/><a href="#element-handle-hover-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-timeout"/><a href="#element-handle-hover-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Установите `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-option-trial"/><a href="#element-handle-hover-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-hover-return"/><a href="#element-handle-hover-return" class="list-anchor">#</a>

---

### innerHTML {#element-handle-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.innerHTML</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.innerHTML()](/api/class-locator.mdx#locator-inner-html) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerHTML`.

**Использование**

```java
ElementHandle.innerHTML();
```

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-inner-html-return"/><a href="#element-handle-inner-html-return" class="list-anchor">#</a>

---

### innerText {#element-handle-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.innerText</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.innerText()](/api/class-locator.mdx#locator-inner-text) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `element.innerText`.

**Использование**

```java
ElementHandle.innerText();
```

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-inner-text-return"/><a href="#element-handle-inner-text-return" class="list-anchor">#</a>

---

### inputValue {#element-handle-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>elementHandle.inputValue</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.inputValue()](/api/class-locator.mdx#locator-input-value) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Выбрасывает исключение для элементов, не являющихся вводом. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращает значение контрола.

**Использование**

```java
ElementHandle.inputValue();
ElementHandle.inputValue(options);
```

**Аргументы**
- `options` `ElementHandle.InputValueOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-input-value-option-timeout"/><a href="#element-handle-input-value-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Установите `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-input-value-return"/><a href="#element-handle-input-value-return" class="list-anchor">#</a>

---

### isChecked {#element-handle-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isChecked</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.isChecked()](/api/class-locator.mdx#locator-is-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отмечен ли элемент. Выбрасывает исключение, если элемент не является флажком или радиокнопкой.

**Использование**

```java
ElementHandle.isChecked();
```

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-checked-return"/><a href="#element-handle-is-checked-return" class="list-anchor">#</a>

---

### isDisabled {#element-handle-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isDisabled</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.isDisabled()](/api/class-locator.mdx#locator-is-disabled) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, отключен ли элемент, противоположность [включенному](../actionability.mdx#enabled).

**Использование**

```java
ElementHandle.isDisabled();
```

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-disabled-return"/><a href="#element-handle-is-disabled-return" class="list-anchor">#</a>

---

### isEditable {#element-handle-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isEditable</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.isEditable()](/api/class-locator.mdx#locator-is-editable) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Использование**

```java
ElementHandle.isEditable();
```

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-editable-return"/><a href="#element-handle-is-editable-return" class="list-anchor">#</a>

---

### isEnabled {#element-handle-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isEnabled</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.isEnabled()](/api/class-locator.mdx#locator-is-enabled) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [включенным](../actionability.mdx#enabled).

**Использование**

```java
ElementHandle.isEnabled();
```

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-enabled-return"/><a href="#element-handle-is-enabled-return" class="list-anchor">#</a>

---

### isHidden {#element-handle-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isHidden</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.isHidden()](/api/class-locator.mdx#locator-is-hidden) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, скрыт ли элемент, противоположность [видимому](../actionability.mdx#visible).

**Использование**

```java
ElementHandle.isHidden();
```

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-hidden-return"/><a href="#element-handle-is-hidden-return" class="list-anchor">#</a>

---

### isVisible {#element-handle-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.isVisible</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.isVisible()](/api/class-locator.mdx#locator-is-visible) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает, является ли элемент [видимым](../actionability.mdx#visible).

**Использование**

```java
ElementHandle.isVisible();
```

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-is-visible-return"/><a href="#element-handle-is-visible-return" class="list-anchor">#</a>

---

### press {#element-handle-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.press</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.press()](/api/class-locator.mdx#locator-press) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Фокусируется на элементе, а затем использует [Keyboard.down()](/api/class-keyboard.mdx#keyboard-down) и [Keyboard.up()](/api/class-keyboard.mdx#keyboard-up).

[key](/api/class-elementhandle.mdx#element-handle-press-option-key) может указывать предполагаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или один символ для генерации текста. Надмножество значений [key](/api/class-elementhandle.mdx#element-handle-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры клавиш:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются следующие модификационные сочетания: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`.

Удержание `Shift` будет вводить текст, соответствующий [key](/api/class-elementhandle.mdx#element-handle-press-option-key) в верхнем регистре.

Если [key](/api/class-elementhandle.mdx#element-handle-press-option-key) является одним символом, он чувствителен к регистру, поэтому значения `a` и `A` будут генерировать разные тексты.

Также поддерживаются сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++` или `key: "Control+Shift+T"`. При указании с модификатором, модификатор нажимается и удерживается, пока не будет нажата последующая клавиша.

**Использование**

```java
ElementHandle.press(key);
ElementHandle.press(key, options);
```

**Аргументы**
- `key` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-key"/><a href="#element-handle-press-option-key" class="list-anchor">#</a>
  
  Имя клавиши для нажатия или символ для генерации, например, `ArrowLeft` или `a`.
- `options` `ElementHandle.PressOptions` *(опционально)*
  - `setDelay` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-delay"/><a href="#element-handle-press-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `keydown` и `keyup` в миллисекундах. По умолчанию 0.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-no-wait-after"/><a href="#element-handle-press-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция по умолчанию будет `true` в будущем.
    :::
    
    
    Действия, инициирующие навигацию, ожидают, пока эти навигации не произойдут и страницы не начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится эта опция только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-option-timeout"/><a href="#element-handle-press-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Установите `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-press-return"/><a href="#element-handle-press-return" class="list-anchor">#</a>

---

### querySelector {#element-handle-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.querySelector</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Page.locator()](/api/class-page.mdx#page-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Метод находит элемент, соответствующий указанному селектору в поддереве `ElementHandle`. Если ни один элемент не соответствует селектору, возвращает `null`.

**Использование**

```java
ElementHandle.querySelector(selector);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-option-selector"/><a href="#element-handle-query-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.

**Возвращает**
- [null] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-return"/><a href="#element-handle-query-selector-return" class="list-anchor">#</a>

---

### querySelectorAll {#element-handle-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.9</font><x-search>elementHandle.querySelectorAll</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Page.locator()](/api/class-page.mdx#page-locator) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Метод находит все элементы, соответствующие указанному селектору в поддереве `ElementHandle`. Если ни один элемент не соответствует селектору, возвращает пустой массив.

**Использование**

```java
ElementHandle.querySelectorAll(selector);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-all-option-selector"/><a href="#element-handle-query-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска.

**Возвращает**
- [List]&lt;[ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-query-selector-all-return"/><a href="#element-handle-query-selector-all-return" class="list-anchor">#</a>

---

### screenshot {#element-handle-screenshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>elementHandle.screenshot</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.screenshot()](/api/class-locator.mdx#locator-screenshot) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод делает скриншот страницы, обрезанный до размера и позиции этого конкретного элемента. Если элемент закрыт другими элементами, он не будет фактически виден на скриншоте. Если элемент является прокручиваемым контейнером, на скриншоте будет виден только текущий прокручиваемый контент.

Этот метод ожидает проверки [действительности](../actionability.mdx), затем прокручивает элемент в видимую область перед созданием скриншота. Если элемент отсоединен от DOM, метод выбрасывает ошибку.

Возвращает буфер с захваченным скриншотом.

**Использование**

```java
ElementHandle.screenshot();
ElementHandle.screenshot(options);
```

**Аргументы**
- `options` `ElementHandle.ScreenshotOptions` *(опционально)*
  - `setAnimations` `enum ScreenshotAnimations { DISABLED, ALLOW }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-animations"/><a href="#element-handle-screenshot-option-animations" class="list-anchor">#</a>
    
    Если установлено в `"disabled"`, останавливает CSS-анимации, CSS-переходы и веб-анимации. Анимации получают разное обращение в зависимости от их продолжительности:
    * конечные анимации быстро перематываются до завершения, чтобы они вызвали событие `transitionend`.
    * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся после скриншота.
    
    По умолчанию `"allow"`, оставляет анимации нетронутыми.
  - `setCaret` `enum ScreenshotCaret { HIDE, INITIAL }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-caret"/><a href="#element-handle-screenshot-option-caret" class="list-anchor">#</a>
    
    Если установлено в `"hide"`, скриншот скроет текстовый курсор. Если установлено в `"initial"`, поведение текстового курсора не изменится. По умолчанию `"hide"`.
  - `setMask` [List]&lt;[Locator]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-mask"/><a href="#element-handle-screenshot-option-mask" class="list-anchor">#</a>
    
    Укажите локаторы, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут покрыты розовым прямоугольником `#FF00FF` (настраивается с помощью [setMaskColor](/api/class-elementhandle.mdx#element-handle-screenshot-option-mask-color)), который полностью покрывает их ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Соответствие только видимым элементам](../locators.mdx#matching-only-visible-elements), чтобы отключить это.
  - `setMaskColor` [String] *(опционально)* <font size="2">Добавлено в: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-mask-color"/><a href="#element-handle-screenshot-option-mask-color" class="list-anchor">#</a>
    
    Укажите цвет наложения для замаскированных элементов в [формате цвета CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию розовый `#FF00FF`.
  - `setOmitBackground` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-omit-background"/><a href="#element-handle-screenshot-option-omit-background" class="list-anchor">#</a>
    
    Скрывает белый фон по умолчанию и позволяет делать скриншоты с прозрачностью. Не применимо к изображениям `jpeg`. По умолчанию `false`.
  - `setPath` [Path] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-path"/><a href="#element-handle-screenshot-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения изображения. Тип скриншота будет определен по расширению файла. Если [setPath](/api/class-elementhandle.mdx#element-handle-screenshot-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, изображение не будет сохранено на диск.
  - `setQuality` [int] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-quality"/><a href="#element-handle-screenshot-option-quality" class="list-anchor">#</a>
    
    Качество изображения, от 0 до 100. Не применимо к изображениям `png`.
  - `setScale` `enum ScreenshotScale { CSS, DEVICE }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-scale"/><a href="#element-handle-screenshot-option-scale" class="list-anchor">#</a>
    
    Если установлено в `"css"`, скриншот будет иметь один пиксель на каждый css пиксель на странице. Для устройств с высоким разрешением это позволит сохранить скриншоты небольшими. Использование опции `"device"` создаст один пиксель на каждый пиксель устройства, так что скриншоты устройств с высоким разрешением будут в два раза больше или даже больше.
    
    По умолчанию `"device"`.
  - `setStyle` [String] *(опционально)* <font size="2">Добавлено в: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-style"/><a href="#element-handle-screenshot-option-style" class="list-anchor">#</a>
    
    Текст таблицы стилей для применения при создании скриншота. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создать повторяемые скриншоты. Эта таблица стилей проникает в Shadow DOM и применяется к внутренним фреймам.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-timeout"/><a href="#element-handle-screenshot-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Установите `0`, чтобы отключить таймаут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setType` `enum ScreenshotType { PNG, JPEG }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-option-type"/><a href="#element-handle-screenshot-option-type" class="list-anchor">#</a>
    
    Укажите тип скриншота, по умолчанию `png`.

**Возвращает**
- [byte&#91;&#93;]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-screenshot-return"/><a href="#element-handle-screenshot-return" class="list-anchor">#</a>

---

### scrollIntoViewIfNeeded {#element-handle-scroll-into-view-if-needed}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.scrollIntoViewIfNeeded</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.scrollIntoViewIfNeeded()](/api/class-locator.mdx#locator-scroll-into-view-if-needed) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает проверки [действительности](../actionability.mdx), затем пытается прокрутить элемент в видимую область, если он не полностью виден, как это определено `ratio` [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API).

Вызывает ошибку, если `elementHandle` не указывает на элемент, [подключенный](https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected) к Document или ShadowRoot.

Смотрите [прокрутка](../input.mdx#scrolling) для альтернативных способов прокрутки.

**Использование**

```java
ElementHandle.scrollIntoViewIfNeeded();
ElementHandle.scrollIntoViewIfNeeded(options);
```

**Аргументы**
- `options` `ElementHandle.ScrollIntoViewIfNeededOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-scroll-into-view-if-needed-option-timeout"/><a href="#element-handle-scroll-into-view-if-needed-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-scroll-into-view-if-needed-return"/><a href="#element-handle-scroll-into-view-if-needed-return" class="list-anchor">#</a>

---

### selectOption {#element-handle-select-option}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.selectOption</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.selectOption()](/api/class-locator.mdx#locator-select-option) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает проверки [действительности](../actionability.mdx), ждет, пока все указанные опции будут присутствовать в элементе `<select>`, и выбирает эти опции.

Если целевой элемент не является элементом `<select>`, этот метод вызывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контрол.

Возвращает массив значений опций, которые были успешно выбраны.

Вызывает событие `change` и `input`, как только все предоставленные опции были выбраны.

**Использование**

```java
// Одиночный выбор, соответствующий значению или метке
handle.selectOption("blue");
// одиночный выбор, соответствующий метке
handle.selectOption(new SelectOption().setLabel("Blue"));
// множественный выбор
handle.selectOption(new String[] {"red", "green", "blue"});
```

**Аргументы**
- `values` [null] | [String] | [ElementHandle] | [String]&#91;&#93; | `SelectOption` | [ElementHandle]&#91;&#93; | `SelectOption`&#91;&#93;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-option-values"/><a href="#element-handle-select-option-option-values" class="list-anchor">#</a>
  - `setValue` [String] *(опционально)*
    
    Соответствует `option.value`. Опционально.
  - `setLabel` [String] *(опционально)*
    
    Соответствует `option.label`. Опционально.
  - `setIndex` [int] *(опционально)*
    
    Соответствует индексу. Опционально.
  
  Опции для выбора. Если у `<select>` есть атрибут `multiple`, все соответствующие опции выбираются, в противном случае выбирается только первая опция, соответствующая одной из переданных опций. Строковые значения соответствуют как значениям, так и меткам. Опция считается соответствующей, если все указанные свойства совпадают.
- `options` `ElementHandle.SelectOptionOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-option-force"/><a href="#element-handle-select-option-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-option-no-wait-after"/><a href="#element-handle-select-option-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-option-timeout"/><a href="#element-handle-select-option-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [List]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-option-return"/><a href="#element-handle-select-option-return" class="list-anchor">#</a>

---

### selectText {#element-handle-select-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.selectText</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.selectText()](/api/class-locator.mdx#locator-select-text) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод ожидает проверки [действительности](../actionability.mdx), затем фокусируется на элементе и выделяет весь его текстовый контент.

Если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), фокусируется и выделяет текст в контроле вместо этого.

**Использование**

```java
ElementHandle.selectText();
ElementHandle.selectText(options);
```

**Аргументы**
- `options` `ElementHandle.SelectTextOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)* <font size="2">Добавлено в: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-text-option-force"/><a href="#element-handle-select-text-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-text-option-timeout"/><a href="#element-handle-select-text-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-select-text-return"/><a href="#element-handle-select-text-return" class="list-anchor">#</a>

---

### setChecked {#element-handle-set-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.15</font><x-search>elementHandle.setChecked</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.setChecked()](/api/class-locator.mdx#locator-set-checked) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод отмечает или снимает отметку с элемента, выполняя следующие шаги:
1. Убедитесь, что элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку.
1. Если элемент уже имеет правильное состояние, этот метод возвращается немедленно.
1. Ожидайте проверки [действительности](../actionability.mdx) на совпадающем элементе, если не установлена опция [setForce](/api/class-elementhandle.mdx#element-handle-set-checked-option-force). Если элемент отсоединен во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse) для нажатия в центре элемента.
1. Убедитесь, что элемент теперь отмечен или снят. Если нет, этот метод вызывает ошибку.

Если все шаги вместе не завершились в течение указанного времени [setTimeout](/api/class-elementhandle.mdx#element-handle-set-checked-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
ElementHandle.setChecked(checked);
ElementHandle.setChecked(checked, options);
```

**Аргументы**
- `checked` [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-checked"/><a href="#element-handle-set-checked-option-checked" class="list-anchor">#</a>
  
  Следует ли отметить или снять отметку с флажка.
- `options` `ElementHandle.SetCheckedOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-force"/><a href="#element-handle-set-checked-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-no-wait-after"/><a href="#element-handle-set-checked-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setPosition` Position *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-position"/><a href="#element-handle-set-checked-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-timeout"/><a href="#element-handle-set-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.
  - `setTrial` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-option-trial"/><a href="#element-handle-set-checked-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-checked-return"/><a href="#element-handle-set-checked-return" class="list-anchor">#</a>

---

### setInputFiles {#element-handle-set-input-files}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.setInputFiles</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.setInputFiles()](/api/class-locator.mdx#locator-set-input-files) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Устанавливает значение файлового ввода на эти пути к файлам или файлы. Если некоторые из `filePaths` являются относительными путями, они разрешаются относительно текущей рабочей директории. Для пустого массива очищает выбранные файлы. Для входов с атрибутом `[webkitdirectory]` поддерживается только один путь к директории.

Этот метод ожидает, что [ElementHandle] указывает на [элемент ввода](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [контрол](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), нацелен на контрол вместо этого.

**Использование**

```java
ElementHandle.setInputFiles(files);
ElementHandle.setInputFiles(files, options);
```

**Аргументы**
- `files` [Path] | [Path]&#91;&#93; | `FilePayload` | `FilePayload`&#91;&#93;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-input-files-option-files"/><a href="#element-handle-set-input-files-option-files" class="list-anchor">#</a>
  - `setName` [String]
    
    Имя файла
  - `setMimeType` [String]
    
    Тип файла
  - `setBuffer` [byte&#91;&#93;]
    
    Содержимое файла
- `options` `ElementHandle.SetInputFilesOptions` *(опционально)*
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-input-files-option-no-wait-after"/><a href="#element-handle-set-input-files-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-input-files-option-timeout"/><a href="#element-handle-set-input-files-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-set-input-files-return"/><a href="#element-handle-set-input-files-return" class="list-anchor">#</a>

---

### tap {#element-handle-tap}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.tap</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.tap()](/api/class-locator.mdx#locator-tap) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод выполняет нажатие на элемент, выполняя следующие шаги:
1. Ожидайте проверки [действительности](../actionability.mdx) на элементе, если не установлена опция [setForce](/api/class-elementhandle.mdx#element-handle-tap-option-force).
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.touchscreen()](/api/class-page.mdx#page-touchscreen) для нажатия в центре элемента или в указанной [setPosition](/api/class-elementhandle.mdx#element-handle-tap-option-position).

Если элемент отсоединен от DOM в любой момент во время действия, этот метод вызывает ошибку.

Если все шаги вместе не завершились в течение указанного времени [setTimeout](/api/class-elementhandle.mdx#element-handle-tap-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

`elementHandle.tap()` требует, чтобы опция `hasTouch` контекста браузера была установлена в true.
:::

**Использование**

```java
ElementHandle.tap();
ElementHandle.tap(options);
```

**Аргументы**
- `options` `ElementHandle.TapOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-force"/><a href="#element-handle-tap-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-modifiers"/><a href="#element-handle-tap-option-modifiers" class="list-anchor">#</a>
    
    Модификаторы клавиш для нажатия. Обеспечивает, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается как "Control" на Windows и Linux и как "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-no-wait-after"/><a href="#element-handle-tap-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setPosition` Position *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-position"/><a href="#element-handle-tap-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-timeout"/><a href="#element-handle-tap-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.
  - `setTrial` [boolean] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-option-trial"/><a href="#element-handle-tap-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-tap-return"/><a href="#element-handle-tap-return" class="list-anchor">#</a>

---

### textContent {#element-handle-text-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.textContent</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.textContent()](/api/class-locator.mdx#locator-text-content) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Возвращает `node.textContent`.

**Использование**

```java
ElementHandle.textContent();
```

**Возвращает**
- [null] | [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-text-content-return"/><a href="#element-handle-text-content-return" class="list-anchor">#</a>

---

### type {#element-handle-type}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.type</x-search>

:::warning Устарело

В большинстве случаев следует использовать [Locator.fill()](/api/class-locator.mdx#locator-fill) вместо этого. Вам нужно нажимать клавиши по одной, только если на странице есть специальная обработка клавиатуры - в этом случае используйте [Locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially).

:::

Фокусируется на элементе, а затем отправляет событие `keydown`, `keypress`/`input` и `keyup` для каждого символа в тексте.

Чтобы нажать специальную клавишу, такую как `Control` или `ArrowDown`, используйте [ElementHandle.press()](/api/class-elementhandle.mdx#element-handle-press).

**Использование**

**Аргументы**
- `text` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-option-text"/><a href="#element-handle-type-option-text" class="list-anchor">#</a>
  
  Текст для ввода в сфокусированный элемент.
- `options` `ElementHandle.TypeOptions` *(опционально)*
  - `setDelay` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-option-delay"/><a href="#element-handle-type-option-delay" class="list-anchor">#</a>
    
    Время ожидания между нажатиями клавиш в миллисекундах. По умолчанию 0.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-option-no-wait-after"/><a href="#element-handle-type-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-option-timeout"/><a href="#element-handle-type-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-type-return"/><a href="#element-handle-type-return" class="list-anchor">#</a>

---

### uncheck {#element-handle-uncheck}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.uncheck</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах метод [Locator.uncheck()](/api/class-locator.mdx#locator-uncheck) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод снимает отметку с элемента, выполняя следующие шаги:
1. Убедитесь, что элемент является флажком или радиокнопкой. Если нет, этот метод вызывает ошибку. Если элемент уже снят, этот метод возвращается немедленно.
1. Ожидайте проверки [действительности](../actionability.mdx) на элементе, если не установлена опция [setForce](/api/class-elementhandle.mdx#element-handle-uncheck-option-force).
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse) для нажатия в центре элемента.
1. Убедитесь, что элемент теперь снят. Если нет, этот метод вызывает ошибку.

Если элемент отсоединен от DOM в любой момент во время действия, этот метод вызывает ошибку.

Если все шаги вместе не завершились в течение указанного времени [setTimeout](/api/class-elementhandle.mdx#element-handle-uncheck-option-timeout), этот метод вызывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
ElementHandle.uncheck();
ElementHandle.uncheck(options);
```

**Аргументы**
- `options` `ElementHandle.UncheckOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-force"/><a href="#element-handle-uncheck-option-force" class="list-anchor">#</a>
    
    Следует ли обходить проверки [действительности](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-no-wait-after"/><a href="#element-handle-uncheck-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setPosition` Position *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-position"/><a href="#element-handle-uncheck-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла элемента. Если не указано, используется видимая точка элемента.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-timeout"/><a href="#element-handle-uncheck-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.
  - `setTrial` [boolean] *(опционально)* <font size="2">Добавлено в: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-option-trial"/><a href="#element-handle-uncheck-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [действительности](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-uncheck-return"/><a href="#element-handle-uncheck-return" class="list-anchor">#</a>

---

### waitForSelector {#element-handle-wait-for-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до версии v1.9</font><x-search>elementHandle.waitForSelector</x-search>

:::warning[Не рекомендуется]

Используйте веб-утверждения, которые утверждают видимость, или основанный на локаторах метод [Locator.waitFor()](/api/class-locator.mdx#locator-wait-for) вместо этого.

:::

Возвращает элемент, указанный селектором, когда он удовлетворяет опции [setState](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-state). Возвращает `null`, если ожидается `hidden` или `detached`.

Ожидает, пока [селектор](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-selector) относительно элемента удовлетворит опции [setState](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-state) (либо появится/исчезнет из DOM, либо станет видимым/скрытым). Если на момент вызова метода [селектор](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-selector) уже удовлетворяет условию, метод вернется немедленно. Если селектор не удовлетворяет условию в течение [setTimeout](/api/class-elementhandle.mdx#element-handle-wait-for-selector-option-timeout) миллисекунд, функция вызовет ошибку.

**Использование**

```java
page.setContent("<div><span></span></div>");
ElementHandle div = page.querySelector("div");
// Ожидание селектора "span" относительно div.
ElementHandle span = div.waitForSelector("span", new ElementHandle.WaitForSelectorOptions()
  .setState(WaitForSelectorState.ATTACHED));
```

:::note
Этот метод не работает через навигации, используйте [Page.waitForSelector()](/api/class-page.mdx#page-wait-for-selector) вместо этого.
:::

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-option-selector"/><a href="#element-handle-wait-for-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` `ElementHandle.WaitForSelectorOptions` *(опционально)*
  - `setState` `enum WaitForSelectorState { ATTACHED, DETACHED, VISIBLE, HIDDEN }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-option-state"/><a href="#element-handle-wait-for-selector-option-state" class="list-anchor">#</a>
    
    По умолчанию `'visible'`. Может быть:
    * `'attached'` - ожидание, пока элемент будет присутствовать в DOM.
    * `'detached'` - ожидание, пока элемент не будет присутствовать в DOM.
    * `'visible'` - ожидание, пока элемент не будет иметь пустую ограничивающую рамку и не будет `visibility:hidden`. Обратите внимание, что элемент без какого-либо контента или с `display:none` имеет пустую ограничивающую рамку и не считается видимым.
    * `'hidden'` - ожидание, пока элемент либо не будет отсоединен от DOM, либо не будет иметь пустую ограничивающую рамку или `visibility:hidden`. Это противоположно опции `'visible'`.
  - `setStrict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-option-strict"/><a href="#element-handle-wait-for-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-option-timeout"/><a href="#element-handle-wait-for-selector-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [null] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="element-handle-wait-for-selector-return"/><a href="#element-handle-wait-for-selector-return" class="list-anchor">#</a>


[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[PlaywrightException]: /api/class-playwrightexception.mdx "PlaywrightException"
[Request]: /api/class-request.mdx "Request"
[RequestOptions]: /api/class-requestoptions.mdx "RequestOptions"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[boolean]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "boolean"
[byte&#91;&#93;]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "byte[]"
[Consumer]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html "Consumer"
[Date]: https://docs.oracle.com/javase/8/docs/api/java/util/Date.html "Date"
[double]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "double"
[InputStream]: https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html "InputStream"
[int]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "int"
[long]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "long"
[JsonObject]: https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/JsonObject.html "JsonObject"
[List]: https://docs.oracle.com/javase/8/docs/api/java/util/List.html "List"
[Map]: https://docs.oracle.com/javase/8/docs/api/java/util/Map.html "Map"
[null]: https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.7 "null"
[Object]: https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html "Object"
[Path]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html "Path"
[Pattern]: https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html "Pattern"
[Predicate]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html "Predicate"
[void]: https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html "void"
[Runnable]: https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html "Runnable"
[RuntimeException]: https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html "RuntimeException"
[String]: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html "String"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/java/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/java/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-java/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
