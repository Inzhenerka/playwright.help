---
id: class-page
title: "Page"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';


Page предоставляет методы для взаимодействия с одной вкладкой в [Browser] или [background page расширения](https://developer.chrome.com/extensions/background_pages) в Chromium. Один экземпляр [Browser] может иметь несколько экземпляров [Page].

Этот пример создает страницу, переходит на URL и затем сохраняет скриншот:

```java
import com.microsoft.playwright.*;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch();
      BrowserContext context = browser.newContext();
      Page page = context.newPage();
      page.navigate("https://example.com");
      page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("screenshot.png")));
      browser.close();
    }
  }
}
```

Класс Page генерирует различные события (описанные ниже), которые могут быть обработаны с использованием любых методов нативного [`EventEmitter`](https://nodejs.org/api/events.html#events_class_eventemitter) в Node, таких как `on`, `once` или `removeListener`.

Этот пример выводит сообщение для одного события загрузки страницы `load`:

```java
page.onLoad(p -> System.out.println("Page loaded!"));
```

Чтобы отписаться от событий, используйте метод `removeListener`:

```java
Consumer<Request> logRequest = interceptedRequest -> {
  System.out.println("A request was made: " + interceptedRequest.url());
};
page.onRequest(logRequest);
// Позже...
page.offRequest(logRequest);
```


---

## Методы

### addInitScript {#page-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.addInitScript</x-search>

Добавляет скрипт, который будет выполнен в одном из следующих случаев:
* Каждый раз, когда страница переходит на новый URL.
* Каждый раз, когда дочерний фрейм присоединяется или переходит на новый URL. В этом случае скрипт выполняется в контексте вновь присоединенного фрейма.

Скрипт выполняется после создания документа, но до выполнения любых его скриптов. Это полезно для изменения среды JavaScript, например, для установки начального значения `Math.random`.

**Использование**

Пример переопределения `Math.random` перед загрузкой страницы:

```js
// preload.js
Math.random = () => 42;
```

```java
// В вашем скрипте playwright, предполагая, что файл preload.js находится в той же директории
page.addInitScript(Paths.get("./preload.js"));
```

:::note
Порядок выполнения нескольких скриптов, установленных через [BrowserContext.addInitScript()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [Page.addInitScript()](/api/class-page.mdx#page-add-init-script), не определен.
:::

**Аргументы**
- `script` [String] | [Path]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-option-script"/><a href="#page-add-init-script-option-script" class="list-anchor">#</a>
  
  Скрипт, который будет выполнен на всех страницах в контексте браузера.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-return"/><a href="#page-add-init-script-return" class="list-anchor">#</a>

---

### addLocatorHandler {#page-add-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.42</font><x-search>page.addLocatorHandler</x-search>

При тестировании веб-страницы иногда появляются неожиданные наложения, такие как диалог "Зарегистрироваться", которые блокируют действия, которые вы хотите автоматизировать, например, нажатие кнопки. Эти наложения не всегда появляются одинаково или в одно и то же время, что делает их сложными для обработки в автоматизированных тестах.

Этот метод позволяет вам настроить специальную функцию, называемую обработчиком, которая активируется, когда обнаруживает, что наложение видно. Задача обработчика - удалить наложение, позволяя вашему тесту продолжаться так, как будто наложения не было.

Вещи, которые нужно учитывать:
* Когда наложение показывается предсказуемо, мы рекомендуем явно ожидать его в вашем тесте и закрывать его как часть вашего обычного тестового потока, вместо использования [Page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler).
* Playwright проверяет наличие наложения каждый раз перед выполнением или повторной попыткой действия, требующего [проверки возможности действия](../actionability.mdx), или перед выполнением проверки утверждения с автоматическим ожиданием. Когда наложение видно, Playwright сначала вызывает обработчик, а затем продолжает с действием/утверждением. Обратите внимание, что обработчик вызывается только тогда, когда вы выполняете действие/утверждение - если наложение становится видимым, но вы не выполняете никаких действий, обработчик не будет вызван.
* После выполнения обработчика Playwright убедится, что наложение, вызвавшее обработчик, больше не видно. Вы можете отказаться от этого поведения с помощью [setNoWaitAfter](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after).
* Время выполнения обработчика учитывается в тайм-ауте действия/утверждения, которое вызвало обработчик. Если ваш обработчик занимает слишком много времени, это может вызвать тайм-ауты.
* Вы можете зарегистрировать несколько обработчиков. Однако в любой момент времени будет выполняться только один обработчик. Убедитесь, что действия внутри обработчика не зависят от другого обработчика.

:::warning

Выполнение обработчика изменит состояние вашей страницы в середине теста. Например, это изменит текущий фокусированный элемент и переместит мышь. Убедитесь, что действия, выполняемые после обработчика, являются автономными и не зависят от того, что фокус и состояние мыши не изменились.

Например, рассмотрим тест, который вызывает [Locator.focus()](/api/class-locator.mdx#locator-focus) с последующим [Keyboard.press()](/api/class-keyboard.mdx#keyboard-press). Если ваш обработчик нажимает кнопку между этими двумя действиями, фокусированный элемент, скорее всего, будет неправильным, и нажатие клавиши произойдет на неожиданном элементе. Используйте [Locator.press()](/api/class-locator.mdx#locator-press) вместо этого, чтобы избежать этой проблемы.

Другой пример - серия действий с мышью, где [Mouse.move()](/api/class-mouse.mdx#mouse-move) следует за [Mouse.down()](/api/class-mouse.mdx#mouse-down). Опять же, когда обработчик выполняется между этими двумя действиями, положение мыши будет неправильным во время нажатия мыши. Предпочитайте автономные действия, такие как [Locator.click()](/api/class-locator.mdx#locator-click), которые не зависят от того, что состояние не изменилось обработчиком.
:::

**Использование**

Пример, который закрывает диалог "Подписаться на рассылку", когда он появляется:

```java
// Настройте обработчик.
page.addLocatorHandler(page.getByText("Sign up to the newsletter"), () -> {
  page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("No thanks")).click();
});

// Пишите тест как обычно.
page.navigate("https://example.com");
page.getByRole("button", Page.GetByRoleOptions().setName("Start here")).click();
```

Пример, который пропускает страницу "Подтвердите свои данные безопасности", когда она показывается:

```java
// Настройте обработчик.
page.addLocatorHandler(page.getByText("Confirm your security details"), () -> {
  page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("Remind me later")).click();
});

// Пишите тест как обычно.
page.navigate("https://example.com");
page.getByRole("button", Page.GetByRoleOptions().setName("Start here")).click();
```

Пример с пользовательским обратным вызовом на каждую проверку возможности действия. Он использует локатор `<body>`, который всегда виден, поэтому обработчик вызывается перед каждой проверкой возможности действия. Важно указать [setNoWaitAfter](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after), потому что обработчик не скрывает элемент `<body>`.

```java
// Настройте обработчик.
page.addLocatorHandler(page.locator("body"), () -> {
  page.evaluate("window.removeObstructionsForTestIfNeeded()");
}, new Page.AddLocatorHandlerOptions().setNoWaitAfter(true));

// Пишите тест как обычно.
page.navigate("https://example.com");
page.getByRole("button", Page.GetByRoleOptions().setName("Start here")).click();
```

Обработчик принимает оригинальный локатор в качестве аргумента. Вы также можете автоматически удалить обработчик после определенного количества вызовов, установив [setTimes](/api/class-page.mdx#page-add-locator-handler-option-times):

```java
page.addLocatorHandler(page.getByLabel("Close"), locator -> {
  locator.click();
}, new Page.AddLocatorHandlerOptions().setTimes(1));
```

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-locator"/><a href="#page-add-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, который вызывает обработчик.
- `handler` [Consumer]&lt;[Locator]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-handler"/><a href="#page-add-locator-handler-option-handler" class="list-anchor">#</a>
  
  Функция, которая должна быть выполнена, как только [локатор](/api/class-page.mdx#page-add-locator-handler-option-locator) появится. Эта функция должна избавиться от элемента, который блокирует действия, такие как клик.
- `options` `Page.AddLocatorHandlerOptions` *(опционально)*
  - `setNoWaitAfter` [boolean] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-no-wait-after"/><a href="#page-add-locator-handler-option-no-wait-after" class="list-anchor">#</a>
    
    По умолчанию, после вызова обработчика Playwright будет ждать, пока наложение не станет скрытым, и только затем продолжит с действием/утверждением, которое вызвало обработчик. Эта опция позволяет отказаться от этого поведения, так что наложение может оставаться видимым после выполнения обработчика.
  - `setTimes` [int] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-times"/><a href="#page-add-locator-handler-option-times" class="list-anchor">#</a>
    
    Указывает максимальное количество раз, которое этот обработчик должен быть вызван. По умолчанию неограниченно.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-return"/><a href="#page-add-locator-handler-return" class="list-anchor">#</a>

---

### addScriptTag {#page-add-script-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.addScriptTag</x-search>

Добавляет тег `<script>` на страницу с желаемым URL или содержимым. Возвращает добавленный тег, когда срабатывает событие onload скрипта или когда содержимое скрипта было внедрено в фрейм.

**Использование**

```java
Page.addScriptTag();
Page.addScriptTag(options);
```

**Аргументы**
- `options` `Page.AddScriptTagOptions` *(опционально)*
  - `setContent` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-content"/><a href="#page-add-script-tag-option-content" class="list-anchor">#</a>
    
    Сырой JavaScript-контент, который будет внедрен в фрейм.
  - `setPath` [Path] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-path"/><a href="#page-add-script-tag-option-path" class="list-anchor">#</a>
    
    Путь к JavaScript-файлу, который будет внедрен в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `setType` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-type"/><a href="#page-add-script-tag-option-type" class="list-anchor">#</a>
    
    Тип скрипта. Используйте 'module', чтобы загрузить JavaScript ES6 модуль. Подробнее см. [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script).
  - `setUrl` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-url"/><a href="#page-add-script-tag-option-url" class="list-anchor">#</a>
    
    URL скрипта, который будет добавлен.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-return"/><a href="#page-add-script-tag-return" class="list-anchor">#</a>

---

### addStyleTag {#page-add-style-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.addStyleTag</x-search>

Добавляет тег `<link rel="stylesheet">` на страницу с желаемым URL или тег `<style type="text/css">` с содержимым. Возвращает добавленный тег, когда срабатывает событие onload стиля или когда CSS-контент был внедрен в фрейм.

**Использование**

```java
Page.addStyleTag();
Page.addStyleTag(options);
```

**Аргументы**
- `options` `Page.AddStyleTagOptions` *(опционально)*
  - `setContent` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-content"/><a href="#page-add-style-tag-option-content" class="list-anchor">#</a>
    
    Сырой CSS-контент, который будет внедрен в фрейм.
  - `setPath` [Path] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-path"/><a href="#page-add-style-tag-option-path" class="list-anchor">#</a>
    
    Путь к CSS-файлу, который будет внедрен в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `setUrl` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-url"/><a href="#page-add-style-tag-option-url" class="list-anchor">#</a>
    
    URL тега `<link>`.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-return"/><a href="#page-add-style-tag-return" class="list-anchor">#</a>

---

### bringToFront {#page-bring-to-front}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.bringToFront</x-search>

Выводит страницу на передний план (активирует вкладку).

**Использование**

```java
Page.bringToFront();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-bring-to-front-return"/><a href="#page-bring-to-front-return" class="list-anchor">#</a>

---

### close {#page-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.close</x-search>

Если [setRunBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) равен `false`, не выполняет обработчики выгрузки и ждет, пока страница не будет закрыта. Если [setRunBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) равен `true`, метод выполнит обработчики выгрузки, но **не** будет ждать закрытия страницы.

По умолчанию, `page.close()` **не** выполняет обработчики `beforeunload`.

:::note

если [setRunBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) передан как true, может быть вызван диалог `beforeunload`, который должен быть обработан вручную через событие [Page.onDialog(handler)](/api/class-page.mdx#page-event-dialog).
:::

**Использование**

```java
Page.close();
Page.close(options);
```

**Аргументы**
- `options` `Page.CloseOptions` *(опционально)*
  - `setReason` [String] *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-reason"/><a href="#page-close-option-reason" class="list-anchor">#</a>
    
    Причина, которая будет сообщена операциям, прерванным закрытием страницы.
  - `setRunBeforeUnload` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-run-before-unload"/><a href="#page-close-option-run-before-unload" class="list-anchor">#</a>
    
    По умолчанию `false`. Выполнять ли обработчики страницы [before unload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-return"/><a href="#page-close-return" class="list-anchor">#</a>

---

### content {#page-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.content</x-search>

Получает полное содержимое HTML страницы, включая doctype.

**Использование**

```java
Page.content();
```

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-content-return"/><a href="#page-content-return" class="list-anchor">#</a>

---

### context {#page-context}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.context</x-search>

Получает контекст браузера, к которому принадлежит страница.

**Использование**

```java
Page.context();
```

**Возвращает**
- [BrowserContext]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-context-return"/><a href="#page-context-return" class="list-anchor">#</a>

---

### dragAndDrop {#page-drag-and-drop}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>page.dragAndDrop</x-search>

Этот метод перетаскивает исходный элемент на целевой элемент. Сначала он перемещается к исходному элементу, выполняет `mousedown`, затем перемещается к целевому элементу и выполняет `mouseup`.

**Использование**

```java
page.dragAndDrop("#source", "#target");
// или укажите точные позиции относительно верхнего левого угла элементов:
page.dragAndDrop("#source", "#target", new Page.DragAndDropOptions()
  .setSourcePosition(34, 7).setTargetPosition(10, 20));
```

**Аргументы**
- `source` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source"/><a href="#page-drag-and-drop-option-source" class="list-anchor">#</a>
  
  Селектор для поиска элемента, который нужно перетащить. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `target` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target"/><a href="#page-drag-and-drop-option-target" class="list-anchor">#</a>
  
  Селектор для поиска элемента, на который нужно сбросить. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `Page.DragAndDropOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-force"/><a href="#page-drag-and-drop-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [возможности действия](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-no-wait-after"/><a href="#page-drag-and-drop-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setSourcePosition` SourcePosition *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source-position"/><a href="#page-drag-and-drop-option-source-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Кликает на исходный элемент в этой точке относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-strict"/><a href="#page-drag-and-drop-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTargetPosition` TargetPosition *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target-position"/><a href="#page-drag-and-drop-option-target-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Сбрасывает на целевой элемент в этой точке относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-timeout"/><a href="#page-drag-and-drop-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-trial"/><a href="#page-drag-and-drop-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [возможности действия](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-return"/><a href="#page-drag-and-drop-return" class="list-anchor">#</a>

---

### emulateMedia {#page-emulate-media}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.emulateMedia</x-search>

Этот метод изменяет `CSS media type` через аргумент `media`, и/или медиа-функцию `'prefers-colors-scheme'`, используя аргумент `colorScheme`.

**Использование**

```java
page.evaluate("() => matchMedia('screen').matches");
// → true
page.evaluate("() => matchMedia('print').matches");
// → false

page.emulateMedia(new Page.EmulateMediaOptions().setMedia(Media.PRINT));
page.evaluate("() => matchMedia('screen').matches");
// → false
page.evaluate("() => matchMedia('print').matches");
// → true

page.emulateMedia(new Page.EmulateMediaOptions());
page.evaluate("() => matchMedia('screen').matches");
// → true
page.evaluate("() => matchMedia('print').matches");
// → false
```

```java
page.emulateMedia(new Page.EmulateMediaOptions().setColorScheme(ColorScheme.DARK));
page.evaluate("() => matchMedia('(prefers-color-scheme: dark)').matches");
// → true
page.evaluate("() => matchMedia('(prefers-color-scheme: light)').matches");
// → false
```

**Аргументы**
- `options` `Page.EmulateMediaOptions` *(опционально)*
  - `setColorScheme` [null] | `enum ColorScheme { LIGHT, DARK, NO_PREFERENCE }` *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-color-scheme"/><a href="#page-emulate-media-option-color-scheme" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию [prefers-colors-scheme](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme), поддерживаемые значения: `'light'` и `'dark'`. Передача `null` отключает эмуляцию цветовой схемы. `'no-preference'` устарело.
  - `setContrast` [null] | `enum Contrast { NO_PREFERENCE, MORE }` *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-contrast"/><a href="#page-emulate-media-option-contrast" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'prefers-contrast'`, поддерживаемые значения: `'no-preference'`, `'more'`. Передача `null` отключает эмуляцию контраста.
  - `setForcedColors` [null] | `enum ForcedColors { ACTIVE, NONE }` *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-forced-colors"/><a href="#page-emulate-media-option-forced-colors" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'forced-colors'`, поддерживаемые значения: `'active'` и `'none'`. Передача `null` отключает эмуляцию принудительных цветов.
  - `setMedia` [null] | `enum Media { SCREEN, PRINT }` *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-media"/><a href="#page-emulate-media-option-media" class="list-anchor">#</a>
    
    Изменяет тип CSS media страницы. Единственные допустимые значения: `'screen'`, `'print'` и `null`. Передача `null` отключает эмуляцию CSS media.
  - `setReducedMotion` [null] | `enum ReducedMotion { REDUCE, NO_PREFERENCE }` *(опционально)* <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-reduced-motion"/><a href="#page-emulate-media-option-reduced-motion" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'prefers-reduced-motion'`, поддерживаемые значения: `'reduce'`, `'no-preference'`. Передача `null` отключает эмуляцию уменьшенного движения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-return"/><a href="#page-emulate-media-return" class="list-anchor">#</a>

---

### evaluate {#page-evaluate}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.evaluate</x-search>

Возвращает значение вызова [expression](/api/class-page.mdx#page-evaluate-option-expression).

Если функция, переданная в [Page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает [Promise], то [Page.evaluate()](/api/class-page.mdx#page-evaluate) будет ждать разрешения промиса и вернет его значение.

Если функция, переданная в [Page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает значение, не являющееся [Serializable], то [Page.evaluate()](/api/class-page.mdx#page-evaluate) разрешается в `undefined`. Playwright также поддерживает передачу некоторых дополнительных значений, которые не сериализуются через `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.

**Использование**

Передача аргумента в [expression](/api/class-page.mdx#page-evaluate-option-expression):

```java
Object result = page.evaluate("([x, y]) => {\n" +
  "  return Promise.resolve(x * y);\n" +
  "}", Arrays.asList(7, 8));
System.out.println(result); // выводит "56"
```

Также можно передать строку вместо функции:

```java
System.out.println(page.evaluate("1 + 2")); // выводит "3"
```

Экземпляры [ElementHandle] могут быть переданы в качестве аргумента в [Page.evaluate()](/api/class-page.mdx#page-evaluate):

```java
ElementHandle bodyHandle = page.evaluate("document.body");
String html = (String) page.evaluate("([body, suffix]) => body.innerHTML + suffix", Arrays.asList(bodyHandle, "hello"));
bodyHandle.dispose();
```

**Аргументы**
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-expression"/><a href="#page-evaluate-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение, которое будет выполнено в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-arg"/><a href="#page-evaluate-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-evaluate-option-expression).

**Возвращает**
- [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-return"/><a href="#page-evaluate-return" class="list-anchor">#</a>

---

### evaluateHandle {#page-evaluate-handle}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.evaluateHandle</x-search>

Возвращает значение вызова [expression](/api/class-page.mdx#page-evaluate-handle-option-expression) в виде [JSHandle].

Единственное отличие между [Page.evaluate()](/api/class-page.mdx#page-evaluate) и [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle) заключается в том, что [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle) возвращает [JSHandle].

Если функция, переданная в [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle), возвращает [Promise], то [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle) будет ждать разрешения промиса и вернет его значение.

**Использование**

```java
// Обработчик для объекта window.
JSHandle aWindowHandle = page.evaluateHandle("() => Promise.resolve(window)");
```

Также можно передать строку вместо функции:

```java
JSHandle aHandle = page.evaluateHandle("document"); // Обработчик для "document".
```

Экземпляры [JSHandle] могут быть переданы в качестве аргумента в [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle):

```java
JSHandle aHandle = page.evaluateHandle("() => document.body");
JSHandle resultHandle = page.evaluateHandle("([body, suffix]) => body.innerHTML + suffix", Arrays.asList(aHandle, "hello"));
System.out.println(resultHandle.jsonValue());
resultHandle.dispose();
```

**Аргументы**
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-expression"/><a href="#page-evaluate-handle-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение, которое будет выполнено в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-arg"/><a href="#page-evaluate-handle-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-evaluate-handle-option-expression).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-return"/><a href="#page-evaluate-handle-return" class="list-anchor">#</a>

---

### exposeBinding {#page-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.exposeBinding</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-binding-option-name) в объект `window` каждого фрейма на этой странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-binding-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-binding-option-callback). Если [callback](/api/class-page.mdx#page-expose-binding-option-callback) возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-page.mdx#page-expose-binding-option-callback) содержит информацию о вызывающем: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

Смотрите [BrowserContext.exposeBinding()](/api/class-browsercontext.mdx#browser-context-expose-binding) для версии, охватывающей весь контекст.

:::note

Функции, установленные через [Page.exposeBinding()](/api/class-page.mdx#page-expose-binding), сохраняются при навигации.
:::

**Использование**

Пример предоставления URL страницы всем фреймам на странице:

```java
import com.microsoft.playwright.*;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch(new BrowserType.LaunchOptions().setHeadless(false));
      BrowserContext context = browser.newContext();
      Page page = context.newPage();
      page.exposeBinding("pageURL", (source, args) -> source.page().url());
      page.setContent("<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.pageURL();\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>");
      page.click("button");
    }
  }
}
```

**Аргументы**
- `name` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-name"/><a href="#page-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` `BindingCallback`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-callback"/><a href="#page-expose-binding-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.
- `options` `Page.ExposeBindingOptions` *(optional)*
  - `setHandle` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-handle"/><a href="#page-expose-binding-option-handle" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция будет удалена в будущем.
    :::
    
    Передавать ли аргумент как handle, вместо передачи по значению. При передаче handle поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-return"/><a href="#page-expose-binding-return" class="list-anchor">#</a>

---

### exposeFunction {#page-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.exposeFunction</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-function-option-name) в объект `window` каждого фрейма на странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-function-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-function-option-callback).

Если [callback](/api/class-page.mdx#page-expose-function-option-callback) возвращает [Promise], он будет ожидаться.

Смотрите [BrowserContext.exposeFunction()](/api/class-browsercontext.mdx#browser-context-expose-function) для версии, охватывающей весь контекст.

:::note

Функции, установленные через [Page.exposeFunction()](/api/class-page.mdx#page-expose-function), сохраняются при навигации.
:::

**Использование**

Пример добавления функции `sha256` на страницу:

```java
import com.microsoft.playwright.*;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch(new BrowserType.LaunchOptions().setHeadless(false));
      Page page = browser.newPage();
      page.exposeFunction("sha256", args -> {
        try {
          String text = (String) args[0];
          MessageDigest crypto = MessageDigest.getInstance("SHA-256");
          byte[] token = crypto.digest(text.getBytes(StandardCharsets.UTF_8));
          return Base64.getEncoder().encodeToString(token);
        } catch (NoSuchAlgorithmException e) {
          return null;
        }
      });
      page.setContent(
        "<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>"
      );
      page.click("button");
    }
  }
}
```

**Аргументы**
- `name` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-name"/><a href="#page-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` `FunctionCallback`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-callback"/><a href="#page-expose-function-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-return"/><a href="#page-expose-function-return" class="list-anchor">#</a>

---

### frame {#page-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.frame</x-search>

Возвращает фрейм, соответствующий указанным критериям. Должно быть указано либо `name`, либо `url`.

**Использование**

```java
Frame frame = page.frame("frame-name");
```

```java
Frame frame = page.frameByUrl(Pattern.compile(".*domain.*"));
```

**Аргументы**
- `name` [String] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-option-name"/><a href="#page-frame-option-name" class="list-anchor">#</a>
  
  Имя фрейма, указанное в атрибуте `name` тега `iframe`.

**Возвращает**
- [null] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-return"/><a href="#page-frame-return" class="list-anchor">#</a>

---

### frameByUrl {#page-frame-by-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.frameByUrl</x-search>

Возвращает фрейм с соответствующим URL.

**Использование**

```java
Page.frameByUrl(url);
```

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-by-url-option-url"/><a href="#page-frame-by-url-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий `url` фрейма как объект [URL].

**Возвращает**
- [null] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-by-url-return"/><a href="#page-frame-by-url-return" class="list-anchor">#</a>

---

### frameLocator {#page-frame-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.17</font><x-search>page.frameLocator</x-search>

При работе с iframes вы можете создать локатор фрейма, который войдет в iframe и позволит выбирать элементы в этом iframe.

**Использование**

Следующий фрагмент кода находит элемент с текстом "Submit" в iframe с id `my-frame`, например `<iframe id="my-frame">`:

```java
Locator locator = page.frameLocator("#my-iframe").getByText("Submit");
locator.click();
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-option-selector"/><a href="#page-frame-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении DOM элемента.

**Возвращает**
- [FrameLocator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-return"/><a href="#page-frame-locator-return" class="list-anchor">#</a>

---

### frames {#page-frames}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.frames</x-search>

Массив всех фреймов, прикрепленных к странице.

**Использование**

```java
Page.frames();
```

**Возвращает**
- [List]&lt;[Frame]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frames-return"/><a href="#page-frames-return" class="list-anchor">#</a>

---

### getByAltText {#page-get-by-alt-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByAltText</x-search>

Позволяет находить элементы по их alt тексту.

**Использование**

Например, этот метод найдет изображение по alt тексту "Playwright logo":

```html
<img alt='Playwright logo'>
```

```java
page.getByAltText("Playwright logo").click();
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-text"/><a href="#page-get-by-alt-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByAltTextOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-exact"/><a href="#page-get-by-alt-text-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-return"/><a href="#page-get-by-alt-text-return" class="list-anchor">#</a>

---

### getByLabel {#page-get-by-label}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByLabel</x-search>

Позволяет находить элементы ввода по тексту связанного элемента `<label>` или элемента `aria-labelledby`, или по атрибуту `aria-label`.

**Использование**

Например, этот метод найдет поля ввода по меткам "Username" и "Password" в следующем DOM:

```html
<input aria-label="Username">
<label for="password-input">Password:</label>
<input id="password-input">
```

```java
page.getByLabel("Username").fill("john");
page.getByLabel("Password").fill("secret");
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-text"/><a href="#page-get-by-label-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByLabelOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-exact"/><a href="#page-get-by-label-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-return"/><a href="#page-get-by-label-return" class="list-anchor">#</a>

---

### getByPlaceholder {#page-get-by-placeholder}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByPlaceholder</x-search>

Позволяет находить элементы ввода по тексту-заполнителю.

**Использование**

Например, рассмотрим следующую структуру DOM.

```html
<input type="email" placeholder="name@example.com" />
```

Вы можете заполнить поле ввода, найдя его по тексту-заполнителю:

```java
page.getByPlaceholder("name@example.com").fill("playwright@microsoft.com");
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-text"/><a href="#page-get-by-placeholder-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByPlaceholderOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-exact"/><a href="#page-get-by-placeholder-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-return"/><a href="#page-get-by-placeholder-return" class="list-anchor">#</a>

---

### getByRole {#page-get-by-role}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByRole</x-search>

Позволяет находить элементы по их [ARIA роли](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA атрибутам](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) и [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name).

**Использование**

Рассмотрим следующую структуру DOM.

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```

Вы можете найти каждый элемент по его неявной роли:

```java
assertThat(page
    .getByRole(AriaRole.HEADING,
               new Page.GetByRoleOptions().setName("Sign up")))
    .isVisible();

page.getByRole(AriaRole.CHECKBOX,
               new Page.GetByRoleOptions().setName("Subscribe"))
    .check();

page.getByRole(AriaRole.BUTTON,
               new Page.GetByRoleOptions().setName(
                   Pattern.compile("submit", Pattern.CASE_INSENSITIVE)))
    .click();
```

**Аргументы**
- `role` `enum AriaRole { ALERT, ALERTDIALOG, APPLICATION, ARTICLE, BANNER, BLOCKQUOTE, BUTTON, CAPTION, CELL, CHECKBOX, CODE, COLUMNHEADER, COMBOBOX, COMPLEMENTARY, CONTENTINFO, DEFINITION, DELETION, DIALOG, DIRECTORY, DOCUMENT, EMPHASIS, FEED, FIGURE, FORM, GENERIC, GRID, GRIDCELL, GROUP, HEADING, IMG, INSERTION, LINK, LIST, LISTBOX, LISTITEM, LOG, MAIN, MARQUEE, MATH, METER, MENU, MENUBAR, MENUITEM, MENUITEMCHECKBOX, MENUITEMRADIO, NAVIGATION, NONE, NOTE, OPTION, PARAGRAPH, PRESENTATION, PROGRESSBAR, RADIO, RADIOGROUP, REGION, ROW, ROWGROUP, ROWHEADER, SCROLLBAR, SEARCH, SEARCHBOX, SEPARATOR, SLIDER, SPINBUTTON, STATUS, STRONG, SUBSCRIPT, SUPERSCRIPT, SWITCH, TAB, TABLE, TABLIST, TABPANEL, TERM, TEXTBOX, TIME, TIMER, TOOLBAR, TOOLTIP, TREE, TREEGRID, TREEITEM }`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-role"/><a href="#page-get-by-role-option-role" class="list-anchor">#</a>
  
  Требуемая ARIA роль.
- `options` `Page.GetByRoleOptions` *(optional)*
  - `setChecked` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-checked"/><a href="#page-get-by-role-option-checked" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-checked` или нативными элементами `<input type=checkbox>`.
    
    Узнайте больше о [`aria-checked`](https://www.w3.org/TR/wai-aria-1.2/#aria-checked).
  - `setDisabled` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-disabled"/><a href="#page-get-by-role-option-disabled" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-disabled` или `disabled`.
    
    :::note
    
    В отличие от большинства других атрибутов, `disabled` наследуется через иерархию DOM. Узнайте больше о [`aria-disabled`](https://www.w3.org/TR/wai-aria-1.2/#aria-disabled).
    :::
    
  - `setExact` [boolean] *(optional)* <font size="2">Added in: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-exact"/><a href="#page-get-by-role-option-exact" class="list-anchor">#</a>
    
    Совпадает ли [setName](/api/class-page.mdx#page-get-by-role-option-name) точно: с учетом регистра и всей строки. По умолчанию false. Игнорируется, когда [setName](/api/class-page.mdx#page-get-by-role-option-name) является регулярным выражением. Обратите внимание, что точное совпадение все равно обрезает пробелы.
  - `setExpanded` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-expanded"/><a href="#page-get-by-role-option-expanded" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-expanded`.
    
    Узнайте больше о [`aria-expanded`](https://www.w3.org/TR/wai-aria-1.2/#aria-expanded).
  - `setIncludeHidden` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-include-hidden"/><a href="#page-get-by-role-option-include-hidden" class="list-anchor">#</a>
    
    Опция, которая контролирует, соответствуют ли скрытые элементы. По умолчанию, только не скрытые элементы, как [определено ARIA](https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion), соответствуют селектору роли.
    
    Узнайте больше о [`aria-hidden`](https://www.w3.org/TR/wai-aria-1.2/#aria-hidden).
  - `setLevel` [int] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-level"/><a href="#page-get-by-role-option-level" class="list-anchor">#</a>
    
    Числовой атрибут, который обычно присутствует для ролей `heading`, `listitem`, `row`, `treeitem`, с значениями по умолчанию для элементов `<h1>-<h6>`.
    
    Узнайте больше о [`aria-level`](https://www.w3.org/TR/wai-aria-1.2/#aria-level).
  - `setName` [String] | [Pattern] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-name"/><a href="#page-get-by-role-option-name" class="list-anchor">#</a>
    
    Опция для соответствия [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name). По умолчанию, соответствие не учитывает регистр и ищет подстроку, используйте [setExact](/api/class-page.mdx#page-get-by-role-option-exact) для управления этим поведением.
    
    Узнайте больше о [доступном имени](https://w3c.github.io/accname/#dfn-accessible-name).
  - `setPressed` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-pressed"/><a href="#page-get-by-role-option-pressed" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-pressed`.
    
    Узнайте больше о [`aria-pressed`](https://www.w3.org/TR/wai-aria-1.2/#aria-pressed).
  - `setSelected` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-selected"/><a href="#page-get-by-role-option-selected" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-selected`.
    
    Узнайте больше о [`aria-selected`](https://www.w3.org/TR/wai-aria-1.2/#aria-selected).

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-return"/><a href="#page-get-by-role-return" class="list-anchor">#</a>

**Детали**

Селектор роли **не заменяет** аудиты доступности и тесты на соответствие, но дает раннюю обратную связь о рекомендациях ARIA.

Многие HTML элементы имеют неявно [определенную роль](https://w3c.github.io/html-aam/#html-element-role-mappings), которая распознается селектором роли. Вы можете найти все [поддерживаемые роли здесь](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). Рекомендации ARIA **не рекомендуют** дублировать неявные роли и атрибуты, устанавливая `role` и/или `aria-*` атрибуты на значения по умолчанию.

---

### getByTestId {#page-get-by-test-id}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByTestId</x-search>

Находит элемент по тестовому идентификатору.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<button data-testid="directions">Itinéraire</button>
```

Вы можете найти элемент по его тестовому идентификатору:

```java
page.getByTestId("directions").click();
```

**Аргументы**
- `testId` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-option-test-id"/><a href="#page-get-by-test-id-option-test-id" class="list-anchor">#</a>
  
  Идентификатор для поиска элемента.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-return"/><a href="#page-get-by-test-id-return" class="list-anchor">#</a>

**Детали**

По умолчанию используется атрибут `data-testid` в качестве тестового идентификатора. Используйте [Selectors.setTestIdAttribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute) для настройки другого атрибута тестового идентификатора, если это необходимо.

---

### getByText {#page-get-by-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByText</x-search>

Позволяет находить элементы, содержащие заданный текст.

Смотрите также [Locator.filter()](/api/class-locator.mdx#locator-filter), который позволяет сопоставлять по другим критериям, таким как доступная роль, а затем фильтровать по текстовому содержимому.

**Использование**

Рассмотрим следующую структуру DOM:

```html
<div>Hello <span>world</span></div>
<div>Hello</div>
```

Вы можете найти по подстроке текста, точной строке или регулярному выражению:

```java
// Соответствует <span>
page.getByText("world");

// Соответствует первому <div>
page.getByText("Hello world");

// Соответствует второму <div>
page.getByText("Hello", new Page.GetByTextOptions().setExact(true));

// Соответствует обоим <div>
page.getByText(Pattern.compile("Hello"));

// Соответствует второму <div>
page.getByText(Pattern.compile("^hello$", Pattern.CASE_INSENSITIVE));
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-text"/><a href="#page-get-by-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByTextOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-exact"/><a href="#page-get-by-text-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-return"/><a href="#page-get-by-text-return" class="list-anchor">#</a>

**Детали**

Сопоставление по тексту всегда нормализует пробелы, даже при точном совпадении. Например, оно превращает несколько пробелов в один, превращает разрывы строк в пробелы и игнорирует начальные и конечные пробелы.

Элементы ввода типа `button` и `submit` сопоставляются по их `value`, а не по текстовому содержимому. Например, поиск по тексту `"Log in"` соответствует `<input type=button value="Log in">`.

---

### getByTitle {#page-get-by-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByTitle</x-search>

Позволяет находить элементы по их атрибуту title.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<span title='Issues count'>25 issues</span>
```

Вы можете проверить количество проблем, найдя его по тексту заголовка:

```java
assertThat(page.getByTitle("Issues count")).hasText("25 issues");
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-text"/><a href="#page-get-by-title-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByTitleOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-exact"/><a href="#page-get-by-title-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-return"/><a href="#page-get-by-title-return" class="list-anchor">#</a>

---

### goBack {#page-go-back}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.goBack</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. Если невозможно вернуться назад, возвращает `null`.

Переход на предыдущую страницу в истории.

**Usage**

```java
Page.goBack();
Page.goBack(options);
```

**Arguments**
- `options` `Page.GoBackOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-timeout"/><a href="#page-go-back-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-wait-until"/><a href="#page-go-back-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Returns**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-return"/><a href="#page-go-back-return" class="list-anchor">#</a>

---

### goForward {#page-go-forward}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.goForward</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. Если невозможно перейти вперед, возвращает `null`.

Переход на следующую страницу в истории.

**Usage**

```java
Page.goForward();
Page.goForward(options);
```

**Arguments**
- `options` `Page.GoForwardOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-timeout"/><a href="#page-go-forward-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-wait-until"/><a href="#page-go-forward-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Returns**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-return"/><a href="#page-go-forward-return" class="list-anchor">#</a>

---

### isClosed {#page-is-closed}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isClosed</x-search>

Указывает, что страница была закрыта.

**Usage**

```java
Page.isClosed();
```

**Returns**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-closed-return"/><a href="#page-is-closed-return" class="list-anchor">#</a>

---

### locator {#page-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.14</font><x-search>page.locator</x-search>

Метод возвращает локатор элемента, который можно использовать для выполнения действий на этой странице/фрейме. Локатор разрешается в элемент непосредственно перед выполнением действия, поэтому серия действий на одном и том же локаторе может фактически выполняться на разных элементах DOM. Это произойдет, если структура DOM между этими действиями изменилась.

[Узнайте больше о локаторах](../locators.mdx).

**Usage**

```java
Page.locator(selector);
Page.locator(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-selector"/><a href="#page-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении элемента DOM.
- `options` `Page.LocatorOptions` *(optional)*
  - `setHas` [Locator] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has"/><a href="#page-locator-option-has" class="list-anchor">#</a>
    
    Сужает результаты метода до тех, которые содержат элементы, соответствующие этому относительному локатору. Например, `article`, который имеет `text=Playwright`, соответствует `<article><div>Playwright</div></article>`.
    
    Внутренний локатор **должен быть относительным** к внешнему локатору и запрашивается, начиная с совпадения внешнего локатора, а не с корня документа. Например, вы можете найти `content`, который имеет `div` в `<article><content><div>Playwright</div></content></article>`. Однако поиск `content`, который имеет `article div`, не удастся, потому что внутренний локатор должен быть относительным и не должен использовать элементы за пределами `content`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `setHasNot` [Locator] *(optional)* <font size="2">Added in: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not"/><a href="#page-locator-option-has-not" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат элемент, соответствующий внутреннему локатору. Внутренний локатор запрашивается относительно внешнего. Например, `article`, который не имеет `div`, соответствует `<article><span>Playwright</span></article>`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `setHasNotText` [String] | [Pattern] *(optional)* <font size="2">Added in: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not-text"/><a href="#page-locator-option-has-not-text" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [строки] сопоставление нечувствительно к регистру и ищет подстроку.
  - `setHasText` [String] | [Pattern] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-text"/><a href="#page-locator-option-has-text" class="list-anchor">#</a>
    
    Соответствует элементам, содержащим указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [строки] сопоставление нечувствительно к регистру и ищет подстроку. Например, `"Playwright"` соответствует `<article><div>Playwright</div></article>`.

**Returns**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-return"/><a href="#page-locator-return" class="list-anchor">#</a>

---

### mainFrame {#page-main-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.mainFrame</x-search>

Основной фрейм страницы. Страница гарантированно имеет основной фрейм, который сохраняется во время навигации.

**Usage**

```java
Page.mainFrame();
```

**Returns**
- [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-main-frame-return"/><a href="#page-main-frame-return" class="list-anchor">#</a>

---

### navigate {#page-goto}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.navigate</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с первым не перенаправленным ответом.

Метод вызовет ошибку, если:
* произошла ошибка SSL (например, в случае самоподписанных сертификатов).
* целевой URL недействителен.
* [setTimeout](/api/class-page.mdx#page-goto-option-timeout) превышен во время навигации.
* удаленный сервер не отвечает или недоступен.
* основной ресурс не удалось загрузить.

Метод не вызовет ошибку, если удаленный сервер вернет любой допустимый код состояния HTTP, включая 404 "Не найдено" и 500 "Внутренняя ошибка сервера". Код состояния для таких ответов можно получить, вызвав [Response.status()](/api/class-response.mdx#response-status).

:::note

Метод либо вызывает ошибку, либо возвращает ответ основного ресурса. Единственными исключениями являются навигация на `about:blank` или навигация на тот же URL с другим хэшем, которые будут успешными и вернут `null`.
:::

:::note
Режим без головы не поддерживает навигацию к PDF-документу. См. [проблему](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).
:::

**Usage**

```java
Page.navigate(url);
Page.navigate(url, options);
```

**Arguments**
- `url` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-url"/><a href="#page-goto-option-url" class="list-anchor">#</a>
  
  URL для перехода на страницу. URL должен включать схему, например, `https://`. Когда [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `Page.NavigateOptions` *(optional)*
  - `setReferer` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-referer"/><a href="#page-goto-option-referer" class="list-anchor">#</a>
    
    Значение заголовка Referer. Если предоставлено, оно будет иметь приоритет над значением заголовка referer, установленным с помощью [Page.setExtraHTTPHeaders()](/api/class-page.mdx#page-set-extra-http-headers).
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-timeout"/><a href="#page-goto-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-wait-until"/><a href="#page-goto-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Returns**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-return"/><a href="#page-goto-return" class="list-anchor">#</a>

---

### onceDialog {#page-once-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.10</font><x-search>page.onceDialog</x-search>

Добавляет одноразовый обработчик [Dialog]. Обработчик будет удален сразу после создания следующего [Dialog].

```java
page.onceDialog(dialog -> {
  dialog.accept("foo");
});

// выводит 'foo'
System.out.println(page.evaluate("prompt('Enter string:')"));

// выводит 'null', так как диалог будет автоматически отклонен, потому что нет обработчиков.
System.out.println(page.evaluate("prompt('Enter string:')"));
```

Этот код выше эквивалентен:

```java
Consumer<Dialog> handler = new Consumer<Dialog>() {
  @Override
  public void accept(Dialog dialog) {
    dialog.accept("foo");
    page.offDialog(this);
  }
};
page.onDialog(handler);

// выводит 'foo'
System.out.println(page.evaluate("prompt('Enter string:')"));

// выводит 'null', так как диалог будет автоматически отклонен, потому что нет обработчиков.
System.out.println(page.evaluate("prompt('Enter string:')"));
```

**Usage**

```java
Page.onceDialog(handler);
```

**Arguments**
- `handler` [Consumer]&lt;[Dialog]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-once-dialog-option-handler"/><a href="#page-once-dialog-option-handler" class="list-anchor">#</a>
  
  Получает объект [Dialog], он **должен** либо [Dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [Dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница будет [заморожена](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалога, и такие действия, как клик, никогда не завершатся.

---

### opener {#page-opener}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.opener</x-search>

Возвращает открыватель для всплывающих страниц и `null` для других. Если открыватель уже был закрыт, возвращает `null`.

**Usage**

```java
Page.opener();
```

**Returns**
- [null] | [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-opener-return"/><a href="#page-opener-return" class="list-anchor">#</a>

---

### pause {#page-pause}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.pause</x-search>

Приостанавливает выполнение скрипта. Playwright остановит выполнение скрипта и будет ждать, пока пользователь не нажмет кнопку 'Resume' в оверлее страницы или не вызовет `playwright.resume()` в консоли DevTools.

Пользователь может исследовать селекторы или выполнять ручные шаги во время паузы. Возобновление продолжит выполнение оригинального скрипта с того места, где он был приостановлен.

:::note

Этот метод требует, чтобы Playwright был запущен в режиме с интерфейсом, с ложным параметром [setHeadless](/api/class-browsertype.mdx#browser-type-launch-option-headless).
:::

**Usage**

```java
Page.pause();
```

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pause-return"/><a href="#page-pause-return" class="list-anchor">#</a>

---

### pdf {#page-pdf}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.pdf</x-search>

Возвращает буфер PDF.

`page.pdf()` генерирует pdf страницы с `print` css media. Чтобы сгенерировать pdf с `screen` media, вызовите [Page.emulateMedia()](/api/class-page.mdx#page-emulate-media) перед вызовом `page.pdf()`:

:::note

По умолчанию `page.pdf()` генерирует pdf с измененными цветами для печати. Используйте свойство [`-webkit-print-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust), чтобы принудительно отобразить точные цвета.
:::

**Usage**

```java
// Генерирует PDF с типом медиа "screen".
page.emulateMedia(new Page.EmulateMediaOptions().setMedia(Media.SCREEN));
page.pdf(new Page.PdfOptions().setPath(Paths.get("page.pdf")));
```

Параметры [setWidth](/api/class-page.mdx#page-pdf-option-width), [setHeight](/api/class-page.mdx#page-pdf-option-height) и [setMargin](/api/class-page.mdx#page-pdf-option-margin) принимают значения с указанием единиц измерения. Значения без указания единиц измерения считаются пикселями.

Несколько примеров:
* `page.pdf({width: 100})` - печатает с шириной, установленной в 100 пикселей
* `page.pdf({width: '100px'})` - печатает с шириной, установленной в 100 пикселей
* `page.pdf({width: '10cm'})` - печатает с шириной, установленной в 10 сантиметров.

Все возможные единицы измерения:
* `px` - пиксель
* `in` - дюйм
* `cm` - сантиметр
* `mm` - миллиметр

Параметры [setFormat](/api/class-page.mdx#page-pdf-option-format):
* `Letter`: 8.5in x 11in
* `Legal`: 8.5in x 14in
* `Tabloid`: 11in x 17in
* `Ledger`: 17in x 11in
* `A0`: 33.1in x 46.8in
* `A1`: 23.4in x 33.1in
* `A2`: 16.54in x 23.4in
* `A3`: 11.7in x 16.54in
* `A4`: 8.27in x 11.7in
* `A5`: 5.83in x 8.27in
* `A6`: 4.13in x 5.83in

:::note

Разметка [setHeaderTemplate](/api/class-page.mdx#page-pdf-option-header-template) и [setFooterTemplate](/api/class-page.mdx#page-pdf-option-footer-template) имеет следующие ограничения: > 1. Теги скриптов внутри шаблонов не оцениваются. > 2. Стили страницы не видны внутри шаблонов.
:::

**Arguments**
- `options` `Page.PdfOptions` *(optional)*
  - `setDisplayHeaderFooter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-display-header-footer"/><a href="#page-pdf-option-display-header-footer" class="list-anchor">#</a>
    
    Отображать заголовок и нижний колонтитул. По умолчанию `false`.
  - `setFooterTemplate` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-footer-template"/><a href="#page-pdf-option-footer-template" class="list-anchor">#</a>
    
    HTML-шаблон для нижнего колонтитула печати. Должен использовать тот же формат, что и [setHeaderTemplate](/api/class-page.mdx#page-pdf-option-header-template).
  - `setFormat` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-format"/><a href="#page-pdf-option-format" class="list-anchor">#</a>
    
    Формат бумаги. Если установлен, имеет приоритет над параметрами [setWidth](/api/class-page.mdx#page-pdf-option-width) или [setHeight](/api/class-page.mdx#page-pdf-option-height). По умолчанию 'Letter'.
  - `setHeaderTemplate` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-header-template"/><a href="#page-pdf-option-header-template" class="list-anchor">#</a>
    
    HTML-шаблон для заголовка печати. Должен быть допустимой HTML-разметкой с использованием следующих классов для вставки значений печати в них:
    * `'date'` отформатированная дата печати
    * `'title'` заголовок документа
    * `'url'` местоположение документа
    * `'pageNumber'` номер текущей страницы
    * `'totalPages'` общее количество страниц в документе
  - `setHeight` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-height"/><a href="#page-pdf-option-height" class="list-anchor">#</a>
    
    Высота бумаги, принимает значения с указанием единиц измерения.
  - `setLandscape` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-landscape"/><a href="#page-pdf-option-landscape" class="list-anchor">#</a>
    
    Ориентация бумаги. По умолчанию `false`.
  - `setMargin` Margin *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-margin"/><a href="#page-pdf-option-margin" class="list-anchor">#</a>
    - `setTop` [String] *(optional)*
      
      Верхнее поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    - `setRight` [String] *(optional)*
      
      Правое поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    - `setBottom` [String] *(optional)*
      
      Нижнее поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    - `setLeft` [String] *(optional)*
      
      Левое поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    
    Поля бумаги, по умолчанию отсутствуют.
  - `setOutline` [boolean] *(optional)* <font size="2">Added in: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-outline"/><a href="#page-pdf-option-outline" class="list-anchor">#</a>
    
    Включать ли контур документа в PDF. По умолчанию `false`.
  - `setPageRanges` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-page-ranges"/><a href="#page-pdf-option-page-ranges" class="list-anchor">#</a>
    
    Диапазоны страниц для печати, например, '1-5, 8, 11-13'. По умолчанию пустая строка, что означает печать всех страниц.
  - `setPath` [Path] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-path"/><a href="#page-pdf-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения PDF. Если [setPath](/api/class-page.mdx#page-pdf-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, PDF не будет сохранен на диск.
  - `setPreferCSSPageSize` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-prefer-css-page-size"/><a href="#page-pdf-option-prefer-css-page-size" class="list-anchor">#</a>
    
    Предпочитать любой размер страницы CSS `@page`, объявленный на странице, над тем, что объявлено в параметрах [setWidth](/api/class-page.mdx#page-pdf-option-width) и [setHeight](/api/class-page.mdx#page-pdf-option-height) или [setFormat](/api/class-page.mdx#page-pdf-option-format). По умолчанию `false`, что будет масштабировать содержимое, чтобы оно соответствовало размеру бумаги.
  - `setPrintBackground` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-print-background"/><a href="#page-pdf-option-print-background" class="list-anchor">#</a>
    
    Печать фоновой графики. По умолчанию `false`.
  - `setScale` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-scale"/><a href="#page-pdf-option-scale" class="list-anchor">#</a>
    
    Масштаб рендеринга веб-страницы. По умолчанию `1`. Масштаб должен быть между 0.1 и 2.
  - `setTagged` [boolean] *(optional)* <font size="2">Added in: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-tagged"/><a href="#page-pdf-option-tagged" class="list-anchor">#</a>
    
    Генерировать ли тегированный (доступный) PDF. По умолчанию `false`.
  - `setWidth` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-width"/><a href="#page-pdf-option-width" class="list-anchor">#</a>
    
    Ширина бумаги, принимает значения с указанием единиц измерения.

**Returns**
- [byte&#91;&#93;]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-return"/><a href="#page-pdf-return" class="list-anchor">#</a>

---

### reload {#page-reload}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.reload</x-search>

Этот метод перезагружает текущую страницу так же, как если бы пользователь инициировал обновление браузера. Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления.

**Usage**

```java
Page.reload();
Page.reload(options);
```

**Arguments**
- `options` `Page.ReloadOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-timeout"/><a href="#page-reload-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-wait-until"/><a href="#page-reload-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Returns**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-return"/><a href="#page-reload-return" class="list-anchor">#</a>

---

### removeLocatorHandler {#page-remove-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.44</font><x-search>page.removeLocatorHandler</x-search>

Удаляет все обработчики локаторов, добавленные с помощью [Page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler) для конкретного локатора.

**Usage**

```java
Page.removeLocatorHandler(locator);
```

**Arguments**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-option-locator"/><a href="#page-remove-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, переданный в [Page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler).

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-return"/><a href="#page-remove-locator-handler-return" class="list-anchor">#</a>

---

### requestGC {#page-request-gc}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.48</font><x-search>page.requestGC</x-search>

Запросить у страницы выполнение сборки мусора. Обратите внимание, что нет гарантии, что все недоступные объекты будут собраны.

Это полезно для обнаружения утечек памяти. Например, если на вашей странице есть большой объект `'suspect'`, который может утекать, вы можете проверить, что он не утек, используя [`WeakRef`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef).

```java
// 1. На вашей странице сохраните WeakRef для "suspect".
page.evaluate("globalThis.suspectWeakRef = new WeakRef(suspect)");
// 2. Запросите сборку мусора.
page.requestGC();
// 3. Убедитесь, что weak ref не ссылается на оригинальный объект.
assertTrue(page.evaluate("!globalThis.suspectWeakRef.deref()"));
```

**Usage**

```java
Page.requestGC();
```

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-request-gc-return"/><a href="#page-request-gc-return" class="list-anchor">#</a>

---

### route {#page-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.route</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются страницей.

После включения маршрутизации каждый запрос, соответствующий шаблону URL, будет приостановлен, если он не будет продолжен, выполнен или прерван.

:::note

Обработчик будет вызван только для первого URL, если ответ является перенаправлением.
:::

:::note
[Page.route()](/api/class-page.mdx#page-route) не будет перехватывать запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [setServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

:::note
[Page.route()](/api/class-page.mdx#page-route) не будет перехватывать первый запрос всплывающей страницы. Используйте [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route) вместо этого.
:::

**Usage**

Пример наивного обработчика, который прерывает все запросы изображений:

```java
Page page = browser.newPage();
page.route("**/*.{png,jpg,jpeg}", route -> route.abort());
page.navigate("https://example.com");
browser.close();
```

или тот же фрагмент, используя вместо этого шаблон регулярного выражения:

```java
Page page = browser.newPage();
page.route(Pattern.compile("(\\.png$)|(\\.jpg$)"),route -> route.abort());
page.navigate("https://example.com");
browser.close();
```

Возможно исследовать запрос, чтобы решить, какое действие маршрута выполнить. Например, имитируя все запросы, содержащие некоторые данные POST, и оставляя все остальные запросы как есть:

```java
page.route("/api/**", route -> {
  if (route.request().postData().contains("my-string"))
    route.fulfill(new Route.FulfillOptions().setBody("mocked-data"));
  else
    route.resume();
});
```

Маршруты страницы имеют приоритет над маршрутами контекста браузера (настроенными с помощью [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route)), когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [Page.unroute()](/api/class-page.mdx#page-unroute).

:::note

Включение маршрутизации отключает http-кэш.
:::

**Arguments**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-url"/><a href="#page-route-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, шаблон регулярного выражения или предикат, получающий [URL] для сопоставления при маршрутизации. Когда [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `handler` [Consumer]&lt;[Route]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-handler"/><a href="#page-route-option-handler" class="list-anchor">#</a>
  
  функция обработчика для маршрутизации запроса.
- `options` `Page.RouteOptions` *(optional)*
  - `setTimes` [int] *(optional)* <font size="2">Added in: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-times"/><a href="#page-route-option-times" class="list-anchor">#</a>
    
    Как часто маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-return"/><a href="#page-route-return" class="list-anchor">#</a>

---

### routeFromHAR {#page-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.23</font><x-search>page.routeFromHAR</x-search>

Если указано, сетевые запросы, сделанные на странице, будут обслуживаться из HAR-файла. Подробнее читайте в разделе [Replaying from HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из HAR-файла. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [setServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```java
Page.routeFromHAR(har);
Page.routeFromHAR(har, options);
```

**Аргументы**
- `har` [Path]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-har"/><a href="#page-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec) файлу с предварительно записанными сетевыми данными. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `options` `Page.RouteFromHAROptions` *(опционально)*
  - `setNotFound` `enum HarNotFound { ABORT, FALLBACK }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-not-found"/><a href="#page-route-from-har-option-not-found" class="list-anchor">#</a>
    * Если установлено в 'abort', любой запрос, не найденный в HAR-файле, будет прерван.
    * Если установлено в 'fallback', отсутствующие запросы будут отправлены в сеть.
    
    По умолчанию `abort`.
  - `setUpdate` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update"/><a href="#page-route-from-har-option-update" class="list-anchor">#</a>
    
    Если указано, обновляет данный HAR с фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск, когда [BrowserContext.close()](/api/class-browsercontext.mdx#browser-context-close) вызывается.
  - `setUpdateContent` `enum RouteFromHarUpdateContentPolicy { EMBED, ATTACH }` *(опционально)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-content"/><a href="#page-route-from-har-option-update-content" class="list-anchor">#</a>
    
    Опциональная настройка для управления содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP-архиве. Если указано `embed`, содержимое хранится в HAR-файле.
  - `setUpdateMode` `enum HarMode { FULL, MINIMAL }` *(опционально)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-mode"/><a href="#page-route-from-har-option-update-mode" class="list-anchor">#</a>
    
    Когда установлено в `minimal`, записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницу, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию `minimal`.
  - `setUrl` [String] | [Pattern] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-url"/><a href="#page-route-from-har-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR-файла. Если не указано, все запросы обслуживаются из HAR-файла.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-return"/><a href="#page-route-from-har-return" class="list-anchor">#</a>

---

### routeWebSocket {#page-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.48</font><x-search>page.routeWebSocket</x-search>

Этот метод позволяет изменять WebSocket-соединения, которые создаются страницей.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизированы. Рекомендуется вызывать этот метод перед навигацией по странице.

**Использование**

Ниже приведен пример простого мока, который отвечает на одно сообщение. Подробнее и примеры смотрите в [WebSocketRoute].

```java
page.routeWebSocket("/ws", ws -> {
  ws.onMessage(frame -> {
    if ("request".equals(frame.text()))
      ws.send("response");
  });
});
```

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-url"/><a href="#page-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизированы. Строковый шаблон может быть относительным к [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) контекстной опции.
- `handler` [Consumer]&lt;[WebSocketRoute]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-handler"/><a href="#page-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-return"/><a href="#page-route-web-socket-return" class="list-anchor">#</a>

---

### screenshot {#page-screenshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.screenshot</x-search>

Возвращает буфер с захваченным скриншотом.

**Использование**

```java
Page.screenshot();
Page.screenshot(options);
```

**Аргументы**
- `options` `Page.ScreenshotOptions` *(опционально)*
  - `setAnimations` `enum ScreenshotAnimations { DISABLED, ALLOW }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-animations"/><a href="#page-screenshot-option-animations" class="list-anchor">#</a>
    
    Когда установлено в `"disabled"`, останавливает CSS-анимации, CSS-переходы и Web-анимации. Анимации получают разное обращение в зависимости от их продолжительности:
    * конечные анимации быстро перематываются до завершения, так что они вызовут событие `transitionend`.
    * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся после скриншота.
    
    По умолчанию `"allow"`, что оставляет анимации нетронутыми.
  - `setCaret` `enum ScreenshotCaret { HIDE, INITIAL }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-caret"/><a href="#page-screenshot-option-caret" class="list-anchor">#</a>
    
    Когда установлено в `"hide"`, скриншот скроет текстовый курсор. Когда установлено в `"initial"`, поведение текстового курсора не изменится. По умолчанию `"hide"`.
  - `setClip` Clip *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-clip"/><a href="#page-screenshot-option-clip" class="list-anchor">#</a>
    - `setX` [double]
      
      x-координата верхнего левого угла области обрезки
    - `setY` [double]
      
      y-координата верхнего левого угла области обрезки
    - `setWidth` [double]
      
      ширина области обрезки
    - `setHeight` [double]
      
      высота области обрезки
    
    Объект, который указывает обрезку результирующего изображения.
  - `setFullPage` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-full-page"/><a href="#page-screenshot-option-full-page" class="list-anchor">#</a>
    
    Если true, делает скриншот всей прокручиваемой страницы, вместо текущего видимого окна. По умолчанию `false`.
  - `setMask` [List]&lt;[Locator]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask"/><a href="#page-screenshot-option-mask" class="list-anchor">#</a>
    
    Укажите локаторы, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут перекрыты розовым прямоугольником `#FF00FF` (настраивается с помощью [setMaskColor](/api/class-page.mdx#page-screenshot-option-mask-color)), который полностью покрывает их ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Matching only visible elements](../locators.mdx#matching-only-visible-elements) для отключения этого.
  - `setMaskColor` [String] *(опционально)* <font size="2">Added in: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask-color"/><a href="#page-screenshot-option-mask-color" class="list-anchor">#</a>
    
    Укажите цвет перекрывающего прямоугольника для замаскированных элементов в [CSS color format](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию розовый `#FF00FF`.
  - `setOmitBackground` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-omit-background"/><a href="#page-screenshot-option-omit-background" class="list-anchor">#</a>
    
    Скрывает белый фон по умолчанию и позволяет делать скриншоты с прозрачностью. Не применимо к изображениям `jpeg`. По умолчанию `false`.
  - `setPath` [Path] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-path"/><a href="#page-screenshot-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения изображения. Тип скриншота будет определен по расширению файла. Если [setPath](/api/class-page.mdx#page-screenshot-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, изображение не будет сохранено на диск.
  - `setQuality` [int] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-quality"/><a href="#page-screenshot-option-quality" class="list-anchor">#</a>
    
    Качество изображения, от 0 до 100. Не применимо к изображениям `png`.
  - `setScale` `enum ScreenshotScale { CSS, DEVICE }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-scale"/><a href="#page-screenshot-option-scale" class="list-anchor">#</a>
    
    Когда установлено в `"css"`, скриншот будет иметь один пиксель на каждый css пиксель на странице. Для устройств с высоким разрешением это позволит сохранить скриншоты небольшими. Использование опции `"device"` создаст один пиксель на каждый пиксель устройства, так что скриншоты устройств с высоким разрешением будут в два раза больше или даже больше.
    
    По умолчанию `"device"`.
  - `setStyle` [String] *(опционально)* <font size="2">Added in: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-style"/><a href="#page-screenshot-option-style" class="list-anchor">#</a>
    
    Текст стиля, который будет применен при создании скриншота. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создавать повторяемые скриншоты. Этот стиль проникает в Shadow DOM и применяется к внутренним фреймам.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-timeout"/><a href="#page-screenshot-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setType` `enum ScreenshotType { PNG, JPEG }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-type"/><a href="#page-screenshot-option-type" class="list-anchor">#</a>
    
    Укажите тип скриншота, по умолчанию `png`.

**Возвращает**
- [byte&#91;&#93;]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-return"/><a href="#page-screenshot-return" class="list-anchor">#</a>

---

### setContent {#page-set-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setContent</x-search>

Этот метод внутренне вызывает [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), наследуя все его специфические характеристики и поведение.

**Использование**

```java
Page.setContent(html);
Page.setContent(html, options);
```

**Аргументы**
- `html` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-html"/><a href="#page-set-content-option-html" class="list-anchor">#</a>
  
  HTML-разметка для назначения странице.
- `options` `Page.SetContentOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-timeout"/><a href="#page-set-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-wait-until"/><a href="#page-set-content-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-return"/><a href="#page-set-content-return" class="list-anchor">#</a>

---

### setDefaultNavigationTimeout {#page-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setDefaultNavigationTimeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных с ними ярлыков:
* [Page.goBack()](/api/class-page.mdx#page-go-back)
* [Page.goForward()](/api/class-page.mdx#page-go-forward)
* [Page.navigate()](/api/class-page.mdx#page-goto)
* [Page.reload()](/api/class-page.mdx#page-reload)
* [Page.setContent()](/api/class-page.mdx#page-set-content)
* [Page.waitForNavigation()](/api/class-page.mdx#page-wait-for-navigation)
* [Page.waitForURL()](/api/class-page.mdx#page-wait-for-url)

:::note

[Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) и [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```java
Page.setDefaultNavigationTimeout(timeout);
```

**Аргументы**
- `timeout` [double]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-navigation-timeout-option-timeout"/><a href="#page-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### setDefaultTimeout {#page-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setDefaultTimeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих опцию [timeout](/api/class-page.mdx#page-set-default-timeout-option-timeout).

:::note

[Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
:::

**Использование**

```java
Page.setDefaultTimeout(timeout);
```

**Аргументы**
- `timeout` [double]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-timeout-option-timeout"/><a href="#page-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### setExtraHTTPHeaders {#page-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setExtraHTTPHeaders</x-search>

Дополнительные HTTP-заголовки будут отправлены с каждым запросом, инициированным страницей.

:::note

[Page.setExtraHTTPHeaders()](/api/class-page.mdx#page-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```java
Page.setExtraHTTPHeaders(headers);
```

**Аргументы**
- `headers` [Map]&lt;[String], [String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-option-headers"/><a href="#page-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP-заголовки, которые будут отправлены с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-return"/><a href="#page-set-extra-http-headers-return" class="list-anchor">#</a>

---

### setViewportSize {#page-set-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setViewportSize</x-search>

В случае нескольких страниц в одном браузере каждая страница может иметь свой собственный размер области просмотра. Однако [Browser.newContext()](/api/class-browser.mdx#browser-new-context) позволяет установить размер области просмотра (и многое другое) для всех страниц в контексте сразу.

[Page.setViewportSize()](/api/class-page.mdx#page-set-viewport-size) изменит размер страницы. Многие веб-сайты не ожидают, что телефоны изменят размер, поэтому вы должны установить размер области просмотра перед навигацией по странице. [Page.setViewportSize()](/api/class-page.mdx#page-set-viewport-size) также сбросит размер `screen`, используйте [Browser.newContext()](/api/class-browser.mdx#browser-new-context) с параметрами `screen` и `viewport`, если вам нужно лучше контролировать эти свойства.

**Использование**

```java
Page page = browser.newPage();
page.setViewportSize(640, 480);
page.navigate("https://example.com");
```

**Аргументы**
- `width` [int] <font size="2">Added in: v1.10</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-option-width"/><a href="#page-set-viewport-size-option-width" class="list-anchor">#</a>
  
  Ширина страницы в пикселях.
- `height` [int] <font size="2">Added in: v1.10</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-option-height"/><a href="#page-set-viewport-size-option-height" class="list-anchor">#</a>
  
  Высота страницы в пикселях.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-return"/><a href="#page-set-viewport-size-return" class="list-anchor">#</a>

---

### title {#page-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.title</x-search>

Возвращает заголовок страницы.

**Использование**

```java
Page.title();
```

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-title-return"/><a href="#page-title-return" class="list-anchor">#</a>

---

### unroute {#page-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.unroute</x-search>

Удаляет маршрут, созданный с помощью [Page.route()](/api/class-page.mdx#page-route). Когда [handler](/api/class-page.mdx#page-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-page.mdx#page-unroute-option-url).

**Использование**

```java
Page.unroute(url);
Page.unroute(url, handler);
```

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-url"/><a href="#page-unroute-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для сопоставления при маршрутизации.
- `handler` [Consumer]&lt;[Route]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-handler"/><a href="#page-unroute-option-handler" class="list-anchor">#</a>
  
  Опциональная функция-обработчик для маршрутизации запроса.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-return"/><a href="#page-unroute-return" class="list-anchor">#</a>

---

### unrouteAll {#page-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.41</font><x-search>page.unrouteAll</x-search>

Удаляет все маршруты, созданные с помощью [Page.route()](/api/class-page.mdx#page-route) и [Page.routeFromHAR()](/api/class-page.mdx#page-route-from-har).

**Использование**

```java
Page.unrouteAll();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-return"/><a href="#page-unroute-all-return" class="list-anchor">#</a>

---

### url {#page-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.url</x-search>

**Использование**

```java
Page.url();
```

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-url-return"/><a href="#page-url-return" class="list-anchor">#</a>

---

### video {#page-video}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.video</x-search>

Объект видео, связанный с этой страницей.

**Использование**

```java
Page.video();
```

**Возвращает**
- [null] | [Video]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-video-return"/><a href="#page-video-return" class="list-anchor">#</a>

---

### viewportSize {#page-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.viewportSize</x-search>

**Использование**

```java
Page.viewportSize();
```

**Возвращает**
- [null] | ViewportSize<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-viewport-size-return"/><a href="#page-viewport-size-return" class="list-anchor">#</a>
  - `width` [int]
    
    ширина страницы в пикселях.
  - `height` [int]
    
    высота страницы в пикселях.

---

### waitForClose {#page-wait-for-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>page.waitForClose</x-search>

Выполняет действие и ждет, пока страница не закроется.

**Использование**

```java
Page.waitForClose(callback);
Page.waitForClose(callback, options);
```

**Аргументы**
- `options` `Page.WaitForCloseOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)* <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-close-option-timeout"/><a href="#page-wait-for-close-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-close-option-callback"/><a href="#page-wait-for-close-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-close-return"/><a href="#page-wait-for-close-return" class="list-anchor">#</a>

---

### waitForCondition {#page-wait-for-condition}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.32</font><x-search>page.waitForCondition</x-search>

Метод будет блокировать выполнение, пока условие не вернет true. Все события Playwright будут отправлены, пока метод ожидает выполнения условия.

**Использование**

Используйте метод для ожидания условия, зависящего от событий страницы:

```java
List<String> messages = new ArrayList<>();
page.onConsoleMessage(m -> messages.add(m.text()));
page.getByText("Submit button").click();
page.waitForCondition(() -> messages.size() > 3);
```

**Аргументы**
- `condition` [BooleanSupplier]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-condition-option-condition"/><a href="#page-wait-for-condition-option-condition" class="list-anchor">#</a>
  
  Условие для ожидания.
- `options` `Page.WaitForConditionOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-condition-option-timeout"/><a href="#page-wait-for-condition-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-condition-return"/><a href="#page-wait-for-condition-return" class="list-anchor">#</a>

---

### waitForConsoleMessage {#page-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForConsoleMessage</x-search>

Выполняет действие и ждет, пока [ConsoleMessage] не будет зарегистрировано на странице. Если предикат предоставлен, он передает значение [ConsoleMessage] в функцию `predicate` и ждет, пока `predicate(message)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [Page.onConsoleMessage(handler)](/api/class-page.mdx#page-event-console) будет вызвано.

**Использование**

```java
Page.waitForConsoleMessage(callback);
Page.waitForConsoleMessage(callback, options);
```

**Аргументы**
- `options` `Page.WaitForConsoleMessageOptions` *(опционально)*
  - `setPredicate` [Predicate]&lt;[ConsoleMessage]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-predicate"/><a href="#page-wait-for-console-message-option-predicate" class="list-anchor">#</a>
    
    Получает объект [ConsoleMessage] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-timeout"/><a href="#page-wait-for-console-message-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-callback"/><a href="#page-wait-for-console-message-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [ConsoleMessage]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-return"/><a href="#page-wait-for-console-message-return" class="list-anchor">#</a>

---

### waitForDownload {#page-wait-for-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForDownload</x-search>

Выполняет действие и ждет, пока не начнется новая [Download]. Если предикат предоставлен, он передает значение [Download] в функцию `predicate` и ждет, пока `predicate(download)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие загрузки будет вызвано.

**Использование**

```java
Page.waitForDownload(callback);
Page.waitForDownload(callback, options);
```

**Аргументы**
- `options` `Page.WaitForDownloadOptions` *(опционально)*
  - `setPredicate` [Predicate]&lt;[Download]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-predicate"/><a href="#page-wait-for-download-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Download] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-timeout"/><a href="#page-wait-for-download-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-callback"/><a href="#page-wait-for-download-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [Download]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-return"/><a href="#page-wait-for-download-return" class="list-anchor">#</a>

---

### waitForFileChooser {#page-wait-for-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForFileChooser</x-search>

Выполняет действие и ожидает создания нового [FileChooser]. Если предоставлен предикат, он передает значение [FileChooser] в функцию `predicate` и ожидает, пока `predicate(fileChooser)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до открытия выбора файла.

**Usage**

```java
Page.waitForFileChooser(callback);
Page.waitForFileChooser(callback, options);
```

**Arguments**
- `options` `Page.WaitForFileChooserOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[FileChooser]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-predicate"/><a href="#page-wait-for-file-chooser-option-predicate" class="list-anchor">#</a>
    
    Получает объект [FileChooser] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-timeout"/><a href="#page-wait-for-file-chooser-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-callback"/><a href="#page-wait-for-file-chooser-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Returns**
- [FileChooser]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-return"/><a href="#page-wait-for-file-chooser-return" class="list-anchor">#</a>

---

### waitForFunction {#page-wait-for-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForFunction</x-search>

Возвращает, когда [expression](/api/class-page.mdx#page-wait-for-function-option-expression) возвращает истинное значение. Разрешается в JSHandle истинного значения.

**Usage**

[Page.waitForFunction()](/api/class-page.mdx#page-wait-for-function) может быть использован для наблюдения за изменением размера области просмотра:

```java
import com.microsoft.playwright.*;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch();
      Page page = browser.newPage();
      page.setViewportSize(50,  50);
      page.waitForFunction("() => window.innerWidth < 100");
      browser.close();
    }
  }
}
```

Чтобы передать аргумент в предикат функции [Page.waitForFunction()](/api/class-page.mdx#page-wait-for-function):

```java
String selector = ".foo";
page.waitForFunction("selector => !!document.querySelector(selector)", selector);
```

**Arguments**
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-expression"/><a href="#page-wait-for-function-option-expression" class="list-anchor">#</a>
  
  JavaScript выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-arg"/><a href="#page-wait-for-function-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-wait-for-function-option-expression).
- `options` `Page.WaitForFunctionOptions` *(optional)*
  - `setPollingInterval` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-polling-interval"/><a href="#page-wait-for-function-option-polling-interval" class="list-anchor">#</a>
    
    Если указано, то это интервал в миллисекундах, с которым функция будет выполняться. По умолчанию, если опция не указана, [expression](/api/class-page.mdx#page-wait-for-function-option-expression) выполняется в `requestAnimationFrame` обратном вызове.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-timeout"/><a href="#page-wait-for-function-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-return"/><a href="#page-wait-for-function-return" class="list-anchor">#</a>

---

### waitForLoadState {#page-wait-for-load-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForLoadState</x-search>

Возвращает, когда достигнуто требуемое состояние загрузки.

Это разрешается, когда страница достигает требуемого состояния загрузки, по умолчанию `load`. Навигация должна быть завершена, когда вызывается этот метод. Если текущий документ уже достиг требуемого состояния, разрешается немедленно.

:::note

Большую часть времени этот метод не нужен, потому что Playwright [автоматически ожидает перед каждым действием](../actionability.mdx).
:::

**Usage**

```java
page.getByRole(AriaRole.BUTTON).click(); // Клик вызывает навигацию.
page.waitForLoadState(); // Обещание разрешается после события "load".
```

```java
Page popup = page.waitForPopup(() -> {
  page.getByRole(AriaRole.BUTTON).click(); // Клик вызывает всплывающее окно.
});
// Ожидание события "DOMContentLoaded"
popup.waitForLoadState(LoadState.DOMCONTENTLOADED);
System.out.println(popup.title()); // Всплывающее окно готово к использованию.
```

**Arguments**
- `state` `enum LoadState { LOAD, DOMCONTENTLOADED, NETWORKIDLE }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-state"/><a href="#page-wait-for-load-state-option-state" class="list-anchor">#</a>
  
  Необязательное состояние загрузки для ожидания, по умолчанию `load`. Если состояние уже достигнуто при загрузке текущего документа, метод разрешается немедленно. Может быть одним из:
  * `'load'` - ожидание, пока не будет вызвано событие `load`.
  * `'domcontentloaded'` - ожидание, пока не будет вызвано событие `DOMContentLoaded`.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** ожидание, пока не будет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
- `options` `Page.WaitForLoadStateOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-timeout"/><a href="#page-wait-for-load-state-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-return"/><a href="#page-wait-for-load-state-return" class="list-anchor">#</a>

---

### waitForPopup {#page-wait-for-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForPopup</x-search>

Выполняет действие и ожидает всплывающее окно [Page]. Если предоставлен предикат, он передает значение [Popup] в функцию `predicate` и ожидает, пока `predicate(page)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до вызова события всплывающего окна.

**Usage**

```java
Page.waitForPopup(callback);
Page.waitForPopup(callback, options);
```

**Arguments**
- `options` `Page.WaitForPopupOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[Page]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-predicate"/><a href="#page-wait-for-popup-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Page] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-timeout"/><a href="#page-wait-for-popup-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-callback"/><a href="#page-wait-for-popup-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Returns**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-return"/><a href="#page-wait-for-popup-return" class="list-anchor">#</a>

---

### waitForRequest {#page-wait-for-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForRequest</x-search>

Ожидает совпадения запроса и возвращает его. См. [ожидание события](../events.mdx#waiting-for-event) для получения более подробной информации о событиях.

**Usage**

```java
// Ожидает следующего запроса с указанным URL
Request request = page.waitForRequest("https://example.com/resource", () -> {
  // Вызывает запрос
  page.getByText("trigger request").click();
});

// Ожидает следующего запроса, соответствующего некоторым условиям
Request request = page.waitForRequest(request -> "https://example.com".equals(request.url()) && "GET".equals(request.method()), () -> {
  // Вызывает запрос
  page.getByText("trigger request").click();
});
```

**Arguments**
- `urlOrPredicate` [String] | [Pattern] | [Predicate]&lt;[Request]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-url-or-predicate"/><a href="#page-wait-for-request-option-url-or-predicate" class="list-anchor">#</a>
  
  URL запроса в виде строки, регулярного выражения или предиката, получающего объект [Request]. Когда [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `Page.WaitForRequestOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-timeout"/><a href="#page-wait-for-request-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
- `callback` [Runnable] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-callback"/><a href="#page-wait-for-request-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Returns**
- [Request]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-return"/><a href="#page-wait-for-request-return" class="list-anchor">#</a>

---

### waitForRequestFinished {#page-wait-for-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>page.waitForRequestFinished</x-search>

Выполняет действие и ожидает завершения загрузки [Request]. Если предоставлен предикат, он передает значение [Request] в функцию `predicate` и ожидает, пока `predicate(request)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до вызова события [Page.onRequestFinished(handler)](/api/class-page.mdx#page-event-request-finished).

**Usage**

```java
Page.waitForRequestFinished(callback);
Page.waitForRequestFinished(callback, options);
```

**Arguments**
- `options` `Page.WaitForRequestFinishedOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[Request]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-predicate"/><a href="#page-wait-for-request-finished-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Request] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-timeout"/><a href="#page-wait-for-request-finished-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-callback"/><a href="#page-wait-for-request-finished-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Returns**
- [Request]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-return"/><a href="#page-wait-for-request-finished-return" class="list-anchor">#</a>

---

### waitForResponse {#page-wait-for-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForResponse</x-search>

Возвращает совпавший ответ. См. [ожидание события](../events.mdx#waiting-for-event) для получения более подробной информации о событиях.

**Usage**

```java
// Ожидает следующего ответа с указанным URL
Response response = page.waitForResponse("https://example.com/resource", () -> {
  // Вызывает ответ
  page.getByText("trigger response").click();
});

// Ожидает следующего ответа, соответствующего некоторым условиям
Response response = page.waitForResponse(response -> "https://example.com".equals(response.url()) && response.status() == 200 && "GET".equals(response.request().method()), () -> {
  // Вызывает ответ
  page.getByText("trigger response").click();
});
```

**Arguments**
- `urlOrPredicate` [String] | [Pattern] | [Predicate]&lt;[Response]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-url-or-predicate"/><a href="#page-wait-for-response-option-url-or-predicate" class="list-anchor">#</a>
  
  URL запроса в виде строки, регулярного выражения или предиката, получающего объект [Response]. Когда [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `Page.WaitForResponseOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-timeout"/><a href="#page-wait-for-response-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
- `callback` [Runnable] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-callback"/><a href="#page-wait-for-response-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Returns**
- [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-return"/><a href="#page-wait-for-response-return" class="list-anchor">#</a>

---

### waitForURL {#page-wait-for-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>page.waitForURL</x-search>

Ожидает, пока основной фрейм перейдет на указанный URL.

**Usage**

```java
page.click("a.delayed-navigation"); // Клик по ссылке косвенно вызывает навигацию
page.waitForURL("**/target.html");
```

**Arguments**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-url"/><a href="#page-wait-for-url-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для совпадения при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
- `options` `Page.WaitForURLOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-timeout"/><a href="#page-wait-for-url-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-wait-until"/><a href="#page-wait-for-url-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда вызвано событие `DOMContentLoaded`.
    * `'load'` - считать операцию завершенной, когда вызвано событие `load`.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-return"/><a href="#page-wait-for-url-return" class="list-anchor">#</a>

---

### waitForWebSocket {#page-wait-for-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForWebSocket</x-search>

Выполняет действие и ожидает новый [WebSocket]. Если предоставлен предикат, он передает значение [WebSocket] в функцию `predicate` и ожидает, пока `predicate(webSocket)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до вызова события WebSocket.

**Usage**

```java
Page.waitForWebSocket(callback);
Page.waitForWebSocket(callback, options);
```

**Arguments**
- `options` `Page.WaitForWebSocketOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[WebSocket]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-predicate"/><a href="#page-wait-for-web-socket-option-predicate" class="list-anchor">#</a>
    
    Получает объект [WebSocket] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-timeout"/><a href="#page-wait-for-web-socket-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-callback"/><a href="#page-wait-for-web-socket-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Returns**
- [WebSocket]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-return"/><a href="#page-wait-for-web-socket-return" class="list-anchor">#</a>

---

### waitForWorker {#page-wait-for-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForWorker</x-search>

Выполняет действие и ожидает новый [Worker]. Если предоставлен предикат, он передает значение [Worker] в функцию `predicate` и ожидает, пока `predicate(worker)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до вызова события worker.

**Usage**

```java
Page.waitForWorker(callback);
Page.waitForWorker(callback, options);
```

**Arguments**
- `options` `Page.WaitForWorkerOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[Worker]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-predicate"/><a href="#page-wait-for-worker-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Worker] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-timeout"/><a href="#page-wait-for-worker-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-callback"/><a href="#page-wait-for-worker-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Returns**
- [Worker]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-return"/><a href="#page-wait-for-worker-return" class="list-anchor">#</a>

---

### workers {#page-workers}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.workers</x-search>

Этот метод возвращает всех выделенных [WebWorkers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API), связанных со страницей.

:::note

Это не включает ServiceWorkers
:::

**Usage**

```java
Page.workers();
```

**Returns**
- [List]&lt;[Worker]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-workers-return"/><a href="#page-workers-return" class="list-anchor">#</a>

---

## Properties

### clock() {#page-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.45</font><x-search>page.clock()</x-search>

Playwright имеет возможность имитировать часы и ход времени.

**Usage**

```java
Page.clock()
```

**Returns**
- [Clock]

---

### keyboard() {#page-keyboard}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.keyboard()</x-search>

**Usage**

```java
Page.keyboard()
```

**Returns**
- [Keyboard]

---

### mouse() {#page-mouse}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.mouse()</x-search>

**Usage**

```java
Page.mouse()
```

**Returns**
- [Mouse]

---

### request() {#page-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.16</font><x-search>page.request()</x-search>

Помощник для тестирования API, связанный с этой страницей. Этот метод возвращает тот же экземпляр, что и [BrowserContext.request()](/api/class-browsercontext.mdx#browser-context-request) в контексте страницы. См. [BrowserContext.request()](/api/class-browsercontext.mdx#browser-context-request) для получения более подробной информации.

**Usage**

```java
Page.request()
```

**Returns**
- [APIRequestContext]

---

### touchscreen() {#page-touchscreen}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.touchscreen()</x-search>

**Usage**

```java
Page.touchscreen()
```

**Returns**
- [Touchscreen]

---

## Events

### onClose(handler) {#page-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onClose(handler)</x-search>

Вызывается, когда страница закрывается.

**Usage**

```java
Page.onClose(handler)
```

**Event data**
- [Page]

---

### onConsoleMessage(handler) {#page-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onConsoleMessage(handler)</x-search>

Вызывается, когда JavaScript на странице вызывает один из методов консольного API, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, доступны в аргументе обработчика события [ConsoleMessage].

**Usage**

```java
page.onConsoleMessage(msg -> {
  for (int i = 0; i < msg.args().size(); ++i)
    System.out.println(i + ": " + msg.args().get(i).jsonValue());
});
page.evaluate("() => console.log('hello', 5, { foo: 'bar' })");
```

**Event data**
- [ConsoleMessage]

---

### onCrash(handler) {#page-event-crash}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onCrash(handler)</x-search>

Вызывается, когда страница падает. Страницы браузера могут падать, если они пытаются выделить слишком много памяти. Когда страница падает, текущие и последующие операции будут выдавать ошибку.

Наиболее распространенный способ справиться с падениями - поймать исключение:

```java
try {
  // Падение может произойти во время клика.
  page.click("button");
  // Или во время ожидания события.
  page.waitForPopup(() -> {});
} catch (PlaywrightException e) {
  // Когда страница падает, сообщение об исключении содержит "crash".
}
```

**Usage**

```java
Page.onCrash(handler)
```

**Event data**
- [Page]

---

### onDialog(handler) {#page-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onDialog(handler)</x-search>

Вызывается, когда появляется JavaScript-диалог, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Слушатель **должен** либо [Dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [Dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница [заморозится](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалога, и действия, такие как клик, никогда не завершатся.

**Использование**

```java
page.onDialog(dialog -> {
  dialog.accept();
});
```

:::note
Когда нет слушателей [Page.onDialog(handler)](/api/class-page.mdx#page-event-dialog) или [BrowserContext.onDialog(handler)](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### onDOMContentLoaded(handler) {#page-event-dom-content-loaded}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onDOMContentLoaded(handler)</x-search>

Вызывается, когда JavaScript-событие [`DOMContentLoaded`](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded) отправляется.

**Использование**

```java
Page.onDOMContentLoaded(handler)
```

**Данные события**
- [Page]

---

### onDownload(handler) {#page-event-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onDownload(handler)</x-search>

Вызывается, когда начинается загрузка вложения. Пользователь может получить доступ к основным операциям с файлами на загруженном контенте через переданный экземпляр [Download].

**Использование**

```java
Page.onDownload(handler)
```

**Данные события**
- [Download]

---

### onFileChooser(handler) {#page-event-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onFileChooser(handler)</x-search>

Вызывается, когда предполагается появление выбора файла, например, после нажатия на `<input type=file>`. Playwright может ответить на это, установив файлы ввода с помощью [FileChooser.setFiles()](/api/class-filechooser.mdx#file-chooser-set-files), которые могут быть загружены после этого.

```java
page.onFileChooser(fileChooser -> {
  fileChooser.setFiles(Paths.get("/tmp/myfile.pdf"));
});
```

**Использование**

```java
Page.onFileChooser(handler)
```

**Данные события**
- [FileChooser]

---

### onFrameAttached(handler) {#page-event-frame-attached}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onFrameAttached(handler)</x-search>

Вызывается, когда фрейм присоединяется.

**Использование**

```java
Page.onFrameAttached(handler)
```

**Данные события**
- [Frame]

---

### onFrameDetached(handler) {#page-event-frame-detached}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onFrameDetached(handler)</x-search>

Вызывается, когда фрейм отсоединяется.

**Использование**

```java
Page.onFrameDetached(handler)
```

**Данные события**
- [Frame]

---

### onFrameNavigated(handler) {#page-event-frame-navigated}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onFrameNavigated(handler)</x-search>

Вызывается, когда фрейм переходит на новый URL.

**Использование**

```java
Page.onFrameNavigated(handler)
```

**Данные события**
- [Frame]

---

### onLoad(handler) {#page-event-load}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onLoad(handler)</x-search>

Вызывается, когда JavaScript-событие [`load`](https://developer.mozilla.org/en-US/docs/Web/Events/load) отправляется.

**Использование**

```java
Page.onLoad(handler)
```

**Данные события**
- [Page]

---

### onPageError(handler) {#page-event-page-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onPageError(handler)</x-search>

Вызывается, когда на странице происходит необработанное исключение.

```java
// Логировать все необработанные ошибки в терминал
page.onPageError(exception -> {
  System.out.println("Uncaught exception: " + exception);
});

// Перейти на страницу с исключением.
page.navigate("data:text/html,<script>throw new Error('Test')</script>");
```

**Использование**

```java
Page.onPageError(handler)
```

**Данные события**
- [String]

---

### onPopup(handler) {#page-event-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onPopup(handler)</x-search>

Вызывается, когда страница открывает новую вкладку или окно. Это событие вызывается в дополнение к [BrowserContext.onPage(handler)](/api/class-browsercontext.mdx#browser-context-event-page), но только для всплывающих окон, относящихся к этой странице.

Самый ранний момент, когда страница доступна, это когда она перешла на начальный URL. Например, при открытии всплывающего окна с `window.open('http://example.com')`, это событие сработает, когда сетевой запрос к "http://example.com" будет выполнен и его ответ начнет загружаться во всплывающем окне. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [BrowserContext.onRequest(handler)](/api/class-browsercontext.mdx#browser-context-event-request) соответственно вместо аналогичных методов на [Page].

```java
Page popup = page.waitForPopup(() -> {
  page.getByText("open the popup").click();
});
System.out.println(popup.evaluate("location.href"));
```

:::note
Используйте [Page.waitForLoadState()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев это не потребуется).
:::

**Использование**

```java
Page.onPopup(handler)
```

**Данные события**
- [Page]

---

### onRequest(handler) {#page-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onRequest(handler)</x-search>

Вызывается, когда страница выполняет запрос. Объект [request] доступен только для чтения. Чтобы перехватывать и изменять запросы, смотрите [Page.route()](/api/class-page.mdx#page-route) или [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route).

**Использование**

```java
Page.onRequest(handler)
```

**Данные события**
- [Request]

---

### onRequestFailed(handler) {#page-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onRequestFailed(handler)</x-search>

Вызывается, когда запрос не удается, например, из-за истечения времени ожидания.

```java
page.onRequestFailed(request -> {
  System.out.println(request.url() + " " + request.failure());
});
```

:::note
Ответы с ошибками HTTP, такие как 404 или 503, все еще считаются успешными ответами с точки зрения HTTP, поэтому запрос завершится событием [Page.onRequestFinished(handler)](/api/class-page.mdx#page-event-request-finished), а не [Page.onRequestFailed(handler)](/api/class-page.mdx#page-event-request-failed). Запрос будет считаться неудачным только в том случае, если клиент не может получить HTTP-ответ от сервера, например, из-за сетевой ошибки net::ERR_FAILED.
:::

**Использование**

```java
Page.onRequestFailed(handler)
```

**Данные события**
- [Request]

---

### onRequestFinished(handler) {#page-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onRequestFinished(handler)</x-search>

Вызывается, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```java
Page.onRequestFinished(handler)
```

**Данные события**
- [Request]

---

### onResponse(handler) {#page-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onResponse(handler)</x-search>

Вызывается, когда [response] статус и заголовки получены для запроса. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```java
Page.onResponse(handler)
```

**Данные события**
- [Response]

---

### onWebSocket(handler) {#page-event-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onWebSocket(handler)</x-search>

Вызывается, когда отправляется запрос [WebSocket].

**Использование**

```java
Page.onWebSocket(handler)
```

**Данные события**
- [WebSocket]

---

### onWorker(handler) {#page-event-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onWorker(handler)</x-search>

Вызывается, когда страница порождает выделенный [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API).

**Использование**

```java
Page.onWorker(handler)
```

**Данные события**
- [Worker]

---

## Устарело

### check {#page-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.check</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.check()](/api/class-locator.mdx#locator-check) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод отмечает элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже отмечен, этот метод возвращается немедленно.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [setForce](/api/class-page.mdx#page-check-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы кликнуть в центр элемента.
1. Убедитесь, что элемент теперь отмечен. Если нет, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-check-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
Page.check(selector);
Page.check(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-selector"/><a href="#page-check-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `Page.CheckOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-force"/><a href="#page-check-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-no-wait-after"/><a href="#page-check-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setPosition` Position *(опционально)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-position"/><a href="#page-check-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-strict"/><a href="#page-check-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-timeout"/><a href="#page-check-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-trial"/><a href="#page-check-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-return"/><a href="#page-check-return" class="list-anchor">#</a>

---

### click {#page-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.click</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.click()](/api/class-locator.mdx#locator-click) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод кликает по элементу, соответствующему [selector](/api/class-page.mdx#page-click-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-click-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [setForce](/api/class-page.mdx#page-click-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы кликнуть в центр элемента или в указанную [setPosition](/api/class-page.mdx#page-click-option-position).
1. Подождите, пока инициированные навигации либо не завершатся успешно, либо не завершатся с ошибкой, если только не установлена опция [setNoWaitAfter](/api/class-page.mdx#page-click-option-no-wait-after).

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-click-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
Page.click(selector);
Page.click(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-selector"/><a href="#page-click-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `Page.ClickOptions` *(опционально)*
  - `setButton` `enum MouseButton { LEFT, RIGHT, MIDDLE }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-button"/><a href="#page-click-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `setClickCount` [int] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-click-count"/><a href="#page-click-option-click-count" class="list-anchor">#</a>
    
    по умолчанию 1. См. [UIEvent.detail].
  - `setDelay` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-delay"/><a href="#page-click-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-force"/><a href="#page-click-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-modifiers"/><a href="#page-click-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-no-wait-after"/><a href="#page-click-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция по умолчанию будет `true` в будущем.
    :::
    
    
    Действия, инициирующие навигации, ожидают, пока эти навигации не произойдут и страницы не начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится эта опция только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `setPosition` Position *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-position"/><a href="#page-click-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-strict"/><a href="#page-click-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-timeout"/><a href="#page-click-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-trial"/><a href="#page-click-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-return"/><a href="#page-click-return" class="list-anchor">#</a>

---

### dblclick {#page-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.dblclick</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.dblclick()](/api/class-locator.mdx#locator-dblclick) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод двойного клика по элементу, соответствующему [selector](/api/class-page.mdx#page-dblclick-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-dblclick-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [setForce](/api/class-page.mdx#page-dblclick-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы дважды кликнуть в центр элемента или в указанную [setPosition](/api/class-page.mdx#page-dblclick-option-position).

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-dblclick-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

`page.dblclick()` отправляет два события `click` и одно событие `dblclick`.
:::

**Использование**

```java
Page.dblclick(selector);
Page.dblclick(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-selector"/><a href="#page-dblclick-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `Page.DblclickOptions` *(опционально)*
  - `setButton` `enum MouseButton { LEFT, RIGHT, MIDDLE }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-button"/><a href="#page-dblclick-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `setDelay` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-delay"/><a href="#page-dblclick-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-force"/><a href="#page-dblclick-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-modifiers"/><a href="#page-dblclick-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-no-wait-after"/><a href="#page-dblclick-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setPosition` Position *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-position"/><a href="#page-dblclick-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-strict"/><a href="#page-dblclick-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-timeout"/><a href="#page-dblclick-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-trial"/><a href="#page-dblclick-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-return"/><a href="#page-dblclick-return" class="list-anchor">#</a>

---

### dispatchEvent {#page-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.dispatchEvent</x-search>

:::warning[Discouraged]

Use locator-based [Locator.dispatchEvent()](/api/class-locator.mdx#locator-dispatch-event) instead. Read more about [locators](../locators.mdx).

:::


Пример ниже отправляет событие `click` на элемент. Независимо от состояния видимости элемента, `click` отправляется. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Usage**

```java
page.dispatchEvent("button#submit", "click");
```

Внутри создается экземпляр события на основе указанного [type](/api/class-page.mdx#page-dispatch-event-option-type), инициализируется с помощью свойств [eventInit](/api/class-page.mdx#page-dispatch-event-option-event-init) и отправляется на элемент. События по умолчанию `composed`, `cancelable` и всплывают.

Поскольку [eventInit](/api/class-page.mdx#page-dispatch-event-option-event-init) специфичен для события, пожалуйста, обратитесь к документации по событиям для списков начальных свойств:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Вы также можете указать `JSHandle` в качестве значения свойства, если хотите, чтобы живые объекты передавались в событие:

```java
// Обратите внимание, что вы можете создать DataTransfer только в Chromium и Firefox
JSHandle dataTransfer = page.evaluateHandle("() => new DataTransfer()");
Map<String, Object> arg = new HashMap<>();
arg.put("dataTransfer", dataTransfer);
page.dispatchEvent("#source", "dragstart", arg);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-selector"/><a href="#page-dispatch-event-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `type` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-type"/><a href="#page-dispatch-event-option-type" class="list-anchor">#</a>
  
  Тип DOM события: `"click"`, `"dragstart"`, и т.д.
- `eventInit` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-event-init"/><a href="#page-dispatch-event-option-event-init" class="list-anchor">#</a>
  
  Необязательные свойства инициализации, специфичные для события.
- `options` `Page.DispatchEventOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-strict"/><a href="#page-dispatch-event-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-timeout"/><a href="#page-dispatch-event-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-return"/><a href="#page-dispatch-event-return" class="list-anchor">#</a>

---

### evalOnSelector {#page-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.evalOnSelector</x-search>

:::warning[Discouraged]

This method does not wait for the element to pass actionability checks and therefore can lead to the flaky tests. Use [Locator.evaluate()](/api/class-locator.mdx#locator-evaluate), other [Locator] helper methods or web-first assertions instead.

:::


Метод находит элемент, соответствующий указанному селектору на странице, и передает его в качестве первого аргумента в [expression](/api/class-page.mdx#page-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выдает ошибку. Возвращает значение [expression](/api/class-page.mdx#page-eval-on-selector-option-expression).

Если [expression](/api/class-page.mdx#page-eval-on-selector-option-expression) возвращает [Promise], то [Page.evalOnSelector()](/api/class-page.mdx#page-eval-on-selector) будет ждать разрешения промиса и вернет его значение.

**Usage**

```java
String searchValue = (String) page.evalOnSelector("#search", "el => el.value");
String preloadHref = (String) page.evalOnSelector("link[rel=preload]", "el => el.href");
String html = (String) page.evalOnSelector(".main-container", "(e, suffix) => e.outerHTML + suffix", "hello");
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-selector"/><a href="#page-eval-on-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-expression"/><a href="#page-eval-on-selector-option-expression" class="list-anchor">#</a>
  
  JavaScript выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-arg"/><a href="#page-eval-on-selector-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-eval-on-selector-option-expression).
- `options` `Page.EvalOnSelectorOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-strict"/><a href="#page-eval-on-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.

**Returns**
- [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-return"/><a href="#page-eval-on-selector-return" class="list-anchor">#</a>

---

### evalOnSelectorAll {#page-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.evalOnSelectorAll</x-search>

:::warning[Discouraged]

In most cases, [Locator.evaluateAll()](/api/class-locator.mdx#locator-evaluate-all), other [Locator] helper methods and web-first assertions do a better job.

:::


Метод находит все элементы, соответствующие указанному селектору на странице, и передает массив найденных элементов в качестве первого аргумента в [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression). Возвращает результат вызова [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

Если [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression) возвращает [Promise], то [Page.evalOnSelectorAll()](/api/class-page.mdx#page-eval-on-selector-all) будет ждать разрешения промиса и вернет его значение.

**Usage**

```java
boolean divCounts = (boolean) page.evalOnSelectorAll("div", "(divs, min) => divs.length >= min", 10);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-selector"/><a href="#page-eval-on-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-expression"/><a href="#page-eval-on-selector-all-option-expression" class="list-anchor">#</a>
  
  JavaScript выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-arg"/><a href="#page-eval-on-selector-all-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

**Returns**
- [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-return"/><a href="#page-eval-on-selector-all-return" class="list-anchor">#</a>

---

### fill {#page-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.fill</x-search>

:::warning[Discouraged]

Use locator-based [Locator.fill()](/api/class-locator.mdx#locator-fill) instead. Read more about [locators](../locators.mdx).

:::


Этот метод ждет элемент, соответствующий [selector](/api/class-page.mdx#page-fill-option-selector), ждет проверки [actionability](../actionability.mdx), фокусируется на элементе, заполняет его и вызывает событие `input` после заполнения. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является `<input>`, `<textarea>` или `[contenteditable]` элементом, этот метод выдает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен именно этот элемент управления.

Для отправки более детализированных событий клавиатуры используйте [Locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially).

**Usage**

```java
Page.fill(selector, value);
Page.fill(selector, value, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-selector"/><a href="#page-fill-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `value` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-value"/><a href="#page-fill-option-value" class="list-anchor">#</a>
  
  Значение для заполнения элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `options` `Page.FillOptions` *(optional)*
  - `setForce` [boolean] *(optional)* <font size="2">Added in: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-force"/><a href="#page-fill-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-no-wait-after"/><a href="#page-fill-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-strict"/><a href="#page-fill-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-timeout"/><a href="#page-fill-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-return"/><a href="#page-fill-return" class="list-anchor">#</a>

---

### focus {#page-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.focus</x-search>

:::warning[Discouraged]

Use locator-based [Locator.focus()](/api/class-locator.mdx#locator-focus) instead. Read more about [locators](../locators.mdx).

:::


Этот метод получает элемент с [selector](/api/class-page.mdx#page-focus-option-selector) и фокусируется на нем. Если нет элемента, соответствующего [selector](/api/class-page.mdx#page-focus-option-selector), метод ждет, пока соответствующий элемент не появится в DOM.

**Usage**

```java
Page.focus(selector);
Page.focus(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-selector"/><a href="#page-focus-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.FocusOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-strict"/><a href="#page-focus-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-timeout"/><a href="#page-focus-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-return"/><a href="#page-focus-return" class="list-anchor">#</a>

---

### getAttribute {#page-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.getAttribute</x-search>

:::warning[Discouraged]

Use locator-based [Locator.getAttribute()](/api/class-locator.mdx#locator-get-attribute) instead. Read more about [locators](../locators.mdx).

:::


Возвращает значение атрибута элемента.

**Usage**

```java
Page.getAttribute(selector, name);
Page.getAttribute(selector, name, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-selector"/><a href="#page-get-attribute-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `name` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-name"/><a href="#page-get-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута, для которого нужно получить значение.
- `options` `Page.GetAttributeOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-strict"/><a href="#page-get-attribute-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-timeout"/><a href="#page-get-attribute-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Returns**
- [null] | [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-return"/><a href="#page-get-attribute-return" class="list-anchor">#</a>

---

### hover {#page-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.hover</x-search>

:::warning[Discouraged]

Use locator-based [Locator.hover()](/api/class-locator.mdx#locator-hover) instead. Read more about [locators](../locators.mdx).

:::


Этот метод наводит курсор на элемент, соответствующий [selector](/api/class-page.mdx#page-hover-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-hover-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите проверки [actionability](../actionability.mdx) на найденном элементе, если не установлен параметр [setForce](/api/class-page.mdx#page-hover-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы навести курсор на центр элемента или указанную позицию [setPosition](/api/class-page.mdx#page-hover-option-position).

Когда все шаги в совокупности не завершены в течение указанного времени [setTimeout](/api/class-page.mdx#page-hover-option-timeout), этот метод выдает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Usage**

```java
Page.hover(selector);
Page.hover(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-selector"/><a href="#page-hover-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.HoverOptions` *(optional)*
  - `setForce` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-force"/><a href="#page-hover-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-modifiers"/><a href="#page-hover-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(optional)* <font size="2">Added in: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-no-wait-after"/><a href="#page-hover-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `setPosition` Position *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-position"/><a href="#page-hover-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-strict"/><a href="#page-hover-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-timeout"/><a href="#page-hover-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.
  - `setTrial` [boolean] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-trial"/><a href="#page-hover-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-return"/><a href="#page-hover-return" class="list-anchor">#</a>

---

### innerHTML {#page-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.innerHTML</x-search>

:::warning[Discouraged]

Use locator-based [Locator.innerHTML()](/api/class-locator.mdx#locator-inner-html) instead. Read more about [locators](../locators.mdx).

:::


Возвращает `element.innerHTML`.

**Usage**

```java
Page.innerHTML(selector);
Page.innerHTML(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-selector"/><a href="#page-inner-html-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.InnerHTMLOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-strict"/><a href="#page-inner-html-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-timeout"/><a href="#page-inner-html-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Returns**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-return"/><a href="#page-inner-html-return" class="list-anchor">#</a>

---

### innerText {#page-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.innerText</x-search>

:::warning[Discouraged]

Use locator-based [Locator.innerText()](/api/class-locator.mdx#locator-inner-text) instead. Read more about [locators](../locators.mdx).

:::


Возвращает `element.innerText`.

**Usage**

```java
Page.innerText(selector);
Page.innerText(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-selector"/><a href="#page-inner-text-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.InnerTextOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-strict"/><a href="#page-inner-text-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-timeout"/><a href="#page-inner-text-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Returns**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-return"/><a href="#page-inner-text-return" class="list-anchor">#</a>

---

### inputValue {#page-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.13</font><x-search>page.inputValue</x-search>

:::warning[Discouraged]

Use locator-based [Locator.inputValue()](/api/class-locator.mdx#locator-input-value) instead. Read more about [locators](../locators.mdx).

:::


Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Выдает ошибку для не-вводных элементов. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращает значение этого элемента управления.

**Usage**

```java
Page.inputValue(selector);
Page.inputValue(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-selector"/><a href="#page-input-value-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.InputValueOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-strict"/><a href="#page-input-value-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-timeout"/><a href="#page-input-value-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Returns**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-return"/><a href="#page-input-value-return" class="list-anchor">#</a>

---

### isChecked {#page-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isChecked</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isChecked()](/api/class-locator.mdx#locator-is-checked) instead. Read more about [locators](../locators.mdx).

:::


Возвращает, отмечен ли элемент. Выдает ошибку, если элемент не является флажком или радиокнопкой.

**Usage**

```java
Page.isChecked(selector);
Page.isChecked(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-selector"/><a href="#page-is-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsCheckedOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-strict"/><a href="#page-is-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-timeout"/><a href="#page-is-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Returns**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-return"/><a href="#page-is-checked-return" class="list-anchor">#</a>

---

### isDisabled {#page-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isDisabled</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isDisabled()](/api/class-locator.mdx#locator-is-disabled) instead. Read more about [locators](../locators.mdx).

:::


Возвращает, отключен ли элемент, противоположность [enabled](../actionability.mdx#enabled).

**Usage**

```java
Page.isDisabled(selector);
Page.isDisabled(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-selector"/><a href="#page-is-disabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsDisabledOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-strict"/><a href="#page-is-disabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-timeout"/><a href="#page-is-disabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Returns**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-return"/><a href="#page-is-disabled-return" class="list-anchor">#</a>

---

### isEditable {#page-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isEditable</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isEditable()](/api/class-locator.mdx#locator-is-editable) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Usage**

```java
Page.isEditable(selector);
Page.isEditable(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-selector"/><a href="#page-is-editable-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsEditableOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-strict"/><a href="#page-is-editable-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-timeout"/><a href="#page-is-editable-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-return"/><a href="#page-is-editable-return" class="list-anchor">#</a>

---

### isEnabled {#page-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isEnabled</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isEnabled()](/api/class-locator.mdx#locator-is-enabled) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент [включенным](../actionability.mdx#enabled).

**Usage**

```java
Page.isEnabled(selector);
Page.isEnabled(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-selector"/><a href="#page-is-enabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsEnabledOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-strict"/><a href="#page-is-enabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-timeout"/><a href="#page-is-enabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-return"/><a href="#page-is-enabled-return" class="list-anchor">#</a>

---

### isHidden {#page-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isHidden</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isHidden()](/api/class-locator.mdx#locator-is-hidden) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент скрытым, противоположность [видимости](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-hidden-option-selector), который не соответствует ни одному элементу, считается скрытым.

**Usage**

```java
Page.isHidden(selector);
Page.isHidden(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-selector"/><a href="#page-is-hidden-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsHiddenOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-strict"/><a href="#page-is-hidden-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-timeout"/><a href="#page-is-hidden-option-timeout" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр игнорируется. [Page.isHidden()](/api/class-page.mdx#page-is-hidden) не ждет, пока элемент станет скрытым, и возвращается немедленно.
    :::

**Returns**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-return"/><a href="#page-is-hidden-return" class="list-anchor">#</a>

---

### isVisible {#page-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isVisible</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isVisible()](/api/class-locator.mdx#locator-is-visible) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент [видимым](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-visible-option-selector), который не соответствует ни одному элементу, считается невидимым.

**Usage**

```java
Page.isVisible(selector);
Page.isVisible(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-selector"/><a href="#page-is-visible-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsVisibleOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-strict"/><a href="#page-is-visible-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-timeout"/><a href="#page-is-visible-option-timeout" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр игнорируется. [Page.isVisible()](/api/class-page.mdx#page-is-visible) не ждет, пока элемент станет видимым, и возвращается немедленно.
    :::

**Returns**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-return"/><a href="#page-is-visible-return" class="list-anchor">#</a>

---

### press {#page-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.press</x-search>

:::warning[Discouraged]

Use locator-based [Locator.press()](/api/class-locator.mdx#locator-press) instead. Read more about [locators](../locators.mdx).

:::

Фокусируется на элементе, а затем использует [Keyboard.down()](/api/class-keyboard.mdx#keyboard-down) и [Keyboard.up()](/api/class-keyboard.mdx#keyboard-up).

[key](/api/class-page.mdx#page-press-option-key) может указывать предполагаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или один символ для генерации текста. Надмножество значений [key](/api/class-page.mdx#page-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры клавиш:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются следующие модификационные сочетания: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`. `ControlOrMeta` разрешается в `Control` на Windows и Linux и в `Meta` на macOS.

Удержание `Shift` будет вводить текст, соответствующий [key](/api/class-page.mdx#page-press-option-key) в верхнем регистре.

Если [key](/api/class-page.mdx#page-press-option-key) является одним символом, он чувствителен к регистру, поэтому значения `a` и `A` будут генерировать разные соответствующие тексты.

Также поддерживаются сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++` или `key: "Control+Shift+T"`. При указании с модификатором, модификатор нажимается и удерживается, пока не будет нажата последующая клавиша.

**Usage**

```java
Page page = browser.newPage();
page.navigate("https://keycode.info");
page.press("body", "A");
page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("A.png")));
page.press("body", "ArrowLeft");
page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("ArrowLeft.png" )));
page.press("body", "Shift+O");
page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("O.png" )));
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-selector"/><a href="#page-press-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `key` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-key"/><a href="#page-press-option-key" class="list-anchor">#</a>
  
  Имя клавиши для нажатия или символ для генерации, например, `ArrowLeft` или `a`.
- `options` `Page.PressOptions` *(optional)*
  - `setDelay` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-delay"/><a href="#page-press-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `keydown` и `keyup` в миллисекундах. По умолчанию 0.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-no-wait-after"/><a href="#page-press-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр по умолчанию будет `true` в будущем.
    :::
    
    Действия, инициирующие навигацию, ожидают, пока эти навигации произойдут и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится этот параметр только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-strict"/><a href="#page-press-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-timeout"/><a href="#page-press-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-return"/><a href="#page-press-return" class="list-anchor">#</a>

---

### querySelector {#page-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.querySelector</x-search>

:::warning[Discouraged]

Use locator-based [Page.locator()](/api/class-page.mdx#page-locator) instead. Read more about [locators](../locators.mdx).

:::

Метод находит элемент, соответствующий указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение разрешается в `null`. Чтобы дождаться элемента на странице, используйте [Locator.waitFor()](/api/class-locator.mdx#locator-wait-for).

**Usage**

```java
Page.querySelector(selector);
Page.querySelector(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-selector"/><a href="#page-query-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` `Page.QuerySelectorOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-strict"/><a href="#page-query-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Returns**
- [null] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-return"/><a href="#page-query-selector-return" class="list-anchor">#</a>

---

### querySelectorAll {#page-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.querySelectorAll</x-search>

:::warning[Discouraged]

Use locator-based [Page.locator()](/api/class-page.mdx#page-locator) instead. Read more about [locators](../locators.mdx).

:::

Метод находит все элементы, соответствующие указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение разрешается в `[]`.

**Usage**

```java
Page.querySelectorAll(selector);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-option-selector"/><a href="#page-query-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.

**Returns**
- [List]&lt;[ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-return"/><a href="#page-query-selector-all-return" class="list-anchor">#</a>

---

### selectOption {#page-select-option}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.selectOption</x-search>

:::warning[Discouraged]

Use locator-based [Locator.selectOption()](/api/class-locator.mdx#locator-select-option) instead. Read more about [locators](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [selector](/api/class-page.mdx#page-select-option-option-selector), ожидает проверки [actionability](../actionability.mdx), ждет, пока все указанные опции не будут присутствовать в элементе `<select>`, и выбирает эти опции.

Если целевой элемент не является элементом `<select>`, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контроль.

Возвращает массив значений опций, которые были успешно выбраны.

Вызывает событие `change` и `input`, как только все предоставленные опции были выбраны.

**Usage**

```java
// Single selection matching the value or label
page.selectOption("select#colors", "blue");
// single selection matching both the value and the label
page.selectOption("select#colors", new SelectOption().setLabel("Blue"));
// multiple selection
page.selectOption("select#colors", new String[] {"red", "green", "blue"});
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-selector"/><a href="#page-select-option-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `values` [null] | [String] | [ElementHandle] | [String]&#91;&#93; | `SelectOption` | [ElementHandle]&#91;&#93; | `SelectOption`&#91;&#93;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-values"/><a href="#page-select-option-option-values" class="list-anchor">#</a>
  - `setValue` [String] *(optional)*
    
    Соответствует `option.value`. Необязательно.
  - `setLabel` [String] *(optional)*
    
    Соответствует `option.label`. Необязательно.
  - `setIndex` [int] *(optional)*
    
    Соответствует индексу. Необязательно.
  
  Опции для выбора. Если `<select>` имеет атрибут `multiple`, все соответствующие опции выбираются, в противном случае выбирается только первая опция, соответствующая одной из переданных опций. Строковые значения соответствуют как значениям, так и меткам. Опция считается соответствующей, если все указанные свойства совпадают.
- `options` `Page.SelectOptionOptions` *(optional)*
  - `setForce` [boolean] *(optional)* <font size="2">Added in: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-force"/><a href="#page-select-option-option-force" class="list-anchor">#</a>
    
    Обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-no-wait-after"/><a href="#page-select-option-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    Этот параметр не имеет эффекта.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-strict"/><a href="#page-select-option-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-timeout"/><a href="#page-select-option-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [List]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-return"/><a href="#page-select-option-return" class="list-anchor">#</a>

---

### setChecked {#page-set-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.15</font><x-search>page.setChecked</x-search>

:::warning[Discouraged]

Use locator-based [Locator.setChecked()](/api/class-locator.mdx#locator-set-checked) instead. Read more about [locators](../locators.mdx).

:::

Этот метод отмечает или снимает отметку с элемента, соответствующего [selector](/api/class-page.mdx#page-set-checked-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-set-checked-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение.
3. Если элемент уже имеет правильное состояние, этот метод возвращается немедленно.
4. Подождите проверки [actionability](../actionability.mdx) на найденном элементе, если не установлен параметр [setForce](/api/class-page.mdx#page-set-checked-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
5. Прокрутите элемент в вид, если это необходимо.
6. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента.
7. Убедитесь, что элемент теперь отмечен или снят. Если нет, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-set-checked-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Usage**

```java
Page.setChecked(selector, checked);
Page.setChecked(selector, checked, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-selector"/><a href="#page-set-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `checked` [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-checked"/><a href="#page-set-checked-option-checked" class="list-anchor">#</a>
  
  Отметить или снять отметку с флажка.
- `options` `Page.SetCheckedOptions` *(optional)*
  - `setForce` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-force"/><a href="#page-set-checked-option-force" class="list-anchor">#</a>
    
    Обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-no-wait-after"/><a href="#page-set-checked-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    Этот параметр не имеет эффекта.
  - `setPosition` Position *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-position"/><a href="#page-set-checked-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-strict"/><a href="#page-set-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-timeout"/><a href="#page-set-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.
  - `setTrial` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-trial"/><a href="#page-set-checked-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-return"/><a href="#page-set-checked-return" class="list-anchor">#</a>

---

### setInputFiles {#page-set-input-files}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setInputFiles</x-search>

:::warning[Discouraged]

Use locator-based [Locator.setInputFiles()](/api/class-locator.mdx#locator-set-input-files) instead. Read more about [locators](../locators.mdx).

:::

Устанавливает значение входного файла на эти пути файлов или файлы. Если некоторые из `filePaths` являются относительными путями, они разрешаются относительно текущего рабочего каталога. Для пустого массива очищает выбранные файлы. Для входов с атрибутом `[webkitdirectory]` поддерживается только один путь к каталогу.

Этот метод ожидает, что [selector](/api/class-page.mdx#page-set-input-files-option-selector) указывает на [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контроль.

**Usage**

```java
Page.setInputFiles(selector, files);
Page.setInputFiles(selector, files, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-selector"/><a href="#page-set-input-files-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `files` [Path] | [Path]&#91;&#93; | `FilePayload` | `FilePayload`&#91;&#93;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-files"/><a href="#page-set-input-files-option-files" class="list-anchor">#</a>
  - `setName` [String]
    
    Имя файла
  - `setMimeType` [String]
    
    Тип файла
  - `setBuffer` [byte&#91;&#93;]
    
    Содержимое файла
- `options` `Page.SetInputFilesOptions` *(optional)*
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-no-wait-after"/><a href="#page-set-input-files-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    Этот параметр не имеет эффекта.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-strict"/><a href="#page-set-input-files-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-timeout"/><a href="#page-set-input-files-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-return"/><a href="#page-set-input-files-return" class="list-anchor">#</a>

---

### tap {#page-tap}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.tap</x-search>

:::warning[Discouraged]

Use locator-based [Locator.tap()](/api/class-locator.mdx#locator-tap) instead. Read more about [locators](../locators.mdx).

:::

Этот метод нажимает на элемент, соответствующий [selector](/api/class-page.mdx#page-tap-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-tap-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Подождите проверки [actionability](../actionability.mdx) на найденном элементе, если не установлен параметр [setForce](/api/class-page.mdx#page-tap-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
3. Прокрутите элемент в вид, если это необходимо.
4. Используйте [Page.touchscreen()](/api/class-page.mdx#page-touchscreen), чтобы нажать в центре элемента или в указанной [setPosition](/api/class-page.mdx#page-tap-option-position).

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-tap-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

Метод [Page.tap()](/api/class-page.mdx#page-tap) выбросит исключение, если параметр [setHasTouch](/api/class-browser.mdx#browser-new-context-option-has-touch) контекста браузера равен false.
:::

**Usage**

```java
Page.tap(selector);
Page.tap(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-selector"/><a href="#page-tap-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.TapOptions` *(optional)*
  - `setForce` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-force"/><a href="#page-tap-option-force" class="list-anchor">#</a>
    
    Обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-modifiers"/><a href="#page-tap-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-no-wait-after"/><a href="#page-tap-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    Этот параметр не имеет эффекта.
  - `setPosition` Position *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-position"/><a href="#page-tap-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-strict"/><a href="#page-tap-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-timeout"/><a href="#page-tap-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.
  - `setTrial` [boolean] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-trial"/><a href="#page-tap-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-return"/><a href="#page-tap-return" class="list-anchor">#</a>

---

### textContent {#page-text-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.textContent</x-search>

:::warning[Discouraged]

Use locator-based [Locator.textContent()](/api/class-locator.mdx#locator-text-content) instead. Read more about [locators](../locators.mdx).

:::

Возвращает `element.textContent`.

**Usage**

```java
Page.textContent(selector);
Page.textContent(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-selector"/><a href="#page-text-content-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.TextContentOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-strict"/><a href="#page-text-content-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-timeout"/><a href="#page-text-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [null] | [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-return"/><a href="#page-text-content-return" class="list-anchor">#</a>

---

### type {#page-type}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.type</x-search>

:::warning Deprecated

In most cases, you should use [Locator.fill()](/api/class-locator.mdx#locator-fill) instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [Locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially).

:::

Отправляет событие `keydown`, `keypress`/`input` и `keyup` для каждого символа в тексте. `page.type` может использоваться для отправки детализированных событий клавиатуры. Для заполнения значений в полях формы используйте [Page.fill()](/api/class-page.mdx#page-fill).

Чтобы нажать специальную клавишу, такую как `Control` или `ArrowDown`, используйте [Keyboard.press()](/api/class-keyboard.mdx#keyboard-press).

**Usage**

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-selector"/><a href="#page-type-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `text` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-text"/><a href="#page-type-option-text" class="list-anchor">#</a>
  
  Текст для ввода в фокусированный элемент.
- `options` `Page.TypeOptions` *(optional)*
  - `setDelay` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-delay"/><a href="#page-type-option-delay" class="list-anchor">#</a>
    
    Время ожидания между нажатиями клавиш в миллисекундах. По умолчанию 0.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-no-wait-after"/><a href="#page-type-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    This option has no effect.
    :::
    
    
    This option has no effect.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-strict"/><a href="#page-type-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-timeout"/><a href="#page-type-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-return"/><a href="#page-type-return" class="list-anchor">#</a>

---

### uncheck {#page-uncheck}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.uncheck</x-search>

:::warning[Discouraged]

Use locator-based [Locator.uncheck()](/api/class-locator.mdx#locator-uncheck) instead. Read more about [locators](../locators.mdx).

:::

Этот метод снимает отметку с элемента, соответствующего [selector](/api/class-page.mdx#page-uncheck-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-uncheck-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже снят с отметки, этот метод возвращается немедленно.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если не установлена опция [setForce](/api/class-page.mdx#page-uncheck-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента.
1. Убедитесь, что элемент теперь снят с отметки. Если нет, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-uncheck-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Usage**

```java
Page.uncheck(selector);
Page.uncheck(selector, options);
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-selector"/><a href="#page-uncheck-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.UncheckOptions` *(optional)*
  - `setForce` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-force"/><a href="#page-uncheck-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-no-wait-after"/><a href="#page-uncheck-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    This option has no effect.
    :::
    
    
    This option has no effect.
  - `setPosition` Position *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-position"/><a href="#page-uncheck-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-strict"/><a href="#page-uncheck-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-timeout"/><a href="#page-uncheck-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-trial"/><a href="#page-uncheck-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-return"/><a href="#page-uncheck-return" class="list-anchor">#</a>

---

### waitForNavigation {#page-wait-for-navigation}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForNavigation</x-search>

:::warning Deprecated

This method is inherently racy, please use [Page.waitForURL()](/api/class-page.mdx#page-wait-for-url) instead.

:::

Ожидает навигации основного фрейма и возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. В случае навигации к другому якорю или навигации из-за использования History API, навигация будет разрешена с `null`.

**Usage**

Это разрешается, когда страница переходит на новый URL или перезагружается. Это полезно, когда вы выполняете код, который косвенно вызывает навигацию страницы. Например, цель клика имеет обработчик `onclick`, который вызывает навигацию из `setTimeout`. Рассмотрим этот пример:

```java
// Метод возвращается после завершения навигации
Response response = page.waitForNavigation(() -> {
  // Это действие вызывает навигацию после тайм-аута.
  page.getByText("Navigate after timeout").click();
});
```

:::note
Использование [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) для изменения URL считается навигацией.
:::

**Arguments**
- `options` `Page.WaitForNavigationOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-timeout"/><a href="#page-wait-for-navigation-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setUrl` [String] | [Pattern] | [Predicate]&lt;[String]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-url"/><a href="#page-wait-for-navigation-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для соответствия при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-wait-until"/><a href="#page-wait-for-navigation-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.
- `callback` [Runnable] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-callback"/><a href="#page-wait-for-navigation-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, выполняющий действие, вызывающее событие.

**Returns**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-return"/><a href="#page-wait-for-navigation-return" class="list-anchor">#</a>

---

### waitForSelector {#page-wait-for-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForSelector</x-search>

:::warning[Discouraged]

Use web assertions that assert visibility or a locator-based [Locator.waitFor()](/api/class-locator.mdx#locator-wait-for) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, когда элемент, указанный селектором, удовлетворяет опции [setState](/api/class-page.mdx#page-wait-for-selector-option-state). Возвращает `null`, если ожидание для `hidden` или `detached`.

:::note

Playwright автоматически ожидает, пока элемент будет готов перед выполнением действия. Использование объектов [Locator] и веб-первых утверждений делает код свободным от ожидания селектора.
:::

Ожидайте, пока [selector](/api/class-page.mdx#page-wait-for-selector-option-selector) не удовлетворит опцию [setState](/api/class-page.mdx#page-wait-for-selector-option-state) (либо появится/исчезнет из DOM, либо станет видимым/скрытым). Если на момент вызова метода [selector](/api/class-page.mdx#page-wait-for-selector-option-selector) уже удовлетворяет условию, метод вернется немедленно. Если селектор не удовлетворяет условию в течение [setTimeout](/api/class-page.mdx#page-wait-for-selector-option-timeout) миллисекунд, функция выбросит исключение.

**Usage**

Этот метод работает через навигации:

```java
import com.microsoft.playwright.*;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType chromium = playwright.chromium();
      Browser browser = chromium.launch();
      Page page = browser.newPage();
      for (String currentURL : Arrays.asList("https://google.com", "https://bbc.com")) {
        page.navigate(currentURL);
        ElementHandle element = page.waitForSelector("img");
        System.out.println("Loaded image: " + element.getAttribute("src"));
      }
      browser.close();
    }
  }
}
```

**Arguments**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-selector"/><a href="#page-wait-for-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` `Page.WaitForSelectorOptions` *(optional)*
  - `setState` `enum WaitForSelectorState { ATTACHED, DETACHED, VISIBLE, HIDDEN }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-state"/><a href="#page-wait-for-selector-option-state" class="list-anchor">#</a>
    
    По умолчанию `'visible'`. Может быть:
    * `'attached'` - ожидание, пока элемент будет присутствовать в DOM.
    * `'detached'` - ожидание, пока элемент не будет присутствовать в DOM.
    * `'visible'` - ожидание, пока элемент не будет иметь пустую рамку и не будет `visibility:hidden`. Обратите внимание, что элемент без содержимого или с `display:none` имеет пустую рамку и не считается видимым.
    * `'hidden'` - ожидание, пока элемент не будет отсоединен от DOM, или не будет иметь пустую рамку или `visibility:hidden`. Это противоположно опции `'visible'`.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-strict"/><a href="#page-wait-for-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-timeout"/><a href="#page-wait-for-selector-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Returns**
- [null] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-return"/><a href="#page-wait-for-selector-return" class="list-anchor">#</a>

---

### waitForTimeout {#page-wait-for-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForTimeout</x-search>

:::warning[Discouraged]

Never wait for timeout in production. Tests that wait for time are inherently flaky. Use [Locator] actions and web assertions that wait automatically.

:::

Ожидает заданный [timeout](/api/class-page.mdx#page-wait-for-timeout-option-timeout) в миллисекундах.

Обратите внимание, что `page.waitForTimeout()` следует использовать только для отладки. Тесты, использующие таймер в производстве, будут ненадежными. Используйте сигналы, такие как сетевые события, селекторы, становящиеся видимыми, и другие.

**Usage**

```java
// ожидание 1 секунду
page.waitForTimeout(1000);
```

**Arguments**
- `timeout` [double]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-option-timeout"/><a href="#page-wait-for-timeout-option-timeout" class="list-anchor">#</a>
  
  Тайм-аут для ожидания

**Returns**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-return"/><a href="#page-wait-for-timeout-return" class="list-anchor">#</a>


[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[PlaywrightException]: /api/class-playwrightexception.mdx "PlaywrightException"
[Request]: /api/class-request.mdx "Request"
[RequestOptions]: /api/class-requestoptions.mdx "RequestOptions"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[boolean]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "boolean"
[byte&#91;&#93;]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "byte[]"
[Consumer]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html "Consumer"
[Date]: https://docs.oracle.com/javase/8/docs/api/java/util/Date.html "Date"
[double]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "double"
[InputStream]: https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html "InputStream"
[int]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "int"
[long]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "long"
[JsonObject]: https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/JsonObject.html "JsonObject"
[List]: https://docs.oracle.com/javase/8/docs/api/java/util/List.html "List"
[Map]: https://docs.oracle.com/javase/8/docs/api/java/util/Map.html "Map"
[null]: https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.7 "null"
[Object]: https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html "Object"
[Path]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html "Path"
[Pattern]: https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html "Pattern"
[Predicate]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html "Predicate"
[void]: https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html "void"
[Runnable]: https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html "Runnable"
[RuntimeException]: https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html "RuntimeException"
[String]: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html "String"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/java/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/java/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-java/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
