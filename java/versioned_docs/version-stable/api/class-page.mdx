---
id: class-page
title: "Page"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';


Page предоставляет методы для взаимодействия с одной вкладкой в [Browser] или [background page расширения](https://developer.chrome.com/extensions/background_pages) в Chromium. Один экземпляр [Browser] может иметь несколько экземпляров [Page].

Этот пример создает страницу, переходит на URL и затем сохраняет скриншот:

```java
import com.microsoft.playwright.*;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch();
      BrowserContext context = browser.newContext();
      Page page = context.newPage();
      page.navigate("https://example.com");
      page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("screenshot.png")));
      browser.close();
    }
  }
}
```

Класс Page генерирует различные события (описанные ниже), которые могут быть обработаны с использованием любых методов нативного [`EventEmitter`](https://nodejs.org/api/events.html#events_class_eventemitter) в Node, таких как `on`, `once` или `removeListener`.

Этот пример выводит сообщение для одного события загрузки страницы `load`:

```java
page.onLoad(p -> System.out.println("Page loaded!"));
```

Чтобы отписаться от событий, используйте метод `removeListener`:

```java
Consumer<Request> logRequest = interceptedRequest -> {
  System.out.println("A request was made: " + interceptedRequest.url());
};
page.onRequest(logRequest);
// Позже...
page.offRequest(logRequest);
```


---

## Методы

### addInitScript {#page-add-init-script}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.addInitScript</x-search>

Добавляет скрипт, который будет выполнен в одном из следующих случаев:
* Каждый раз, когда страница переходит на новый URL.
* Каждый раз, когда дочерний фрейм присоединяется или переходит на новый URL. В этом случае скрипт выполняется в контексте вновь присоединенного фрейма.

Скрипт выполняется после создания документа, но до выполнения любых его скриптов. Это полезно для изменения среды JavaScript, например, для установки начального значения `Math.random`.

**Использование**

Пример переопределения `Math.random` перед загрузкой страницы:

```js
// preload.js
Math.random = () => 42;
```

```java
// В вашем скрипте playwright, предполагая, что файл preload.js находится в той же директории
page.addInitScript(Paths.get("./preload.js"));
```

:::note
Порядок выполнения нескольких скриптов, установленных через [BrowserContext.addInitScript()](/api/class-browsercontext.mdx#browser-context-add-init-script) и [Page.addInitScript()](/api/class-page.mdx#page-add-init-script), не определен.
:::

**Аргументы**
- `script` [String] | [Path]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-option-script"/><a href="#page-add-init-script-option-script" class="list-anchor">#</a>
  
  Скрипт, который будет выполнен на всех страницах в контексте браузера.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-init-script-return"/><a href="#page-add-init-script-return" class="list-anchor">#</a>

---

### addLocatorHandler {#page-add-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.42</font><x-search>page.addLocatorHandler</x-search>

При тестировании веб-страницы иногда появляются неожиданные наложения, такие как диалог "Зарегистрироваться", которые блокируют действия, которые вы хотите автоматизировать, например, нажатие кнопки. Эти наложения не всегда появляются одинаково или в одно и то же время, что делает их сложными для обработки в автоматизированных тестах.

Этот метод позволяет вам настроить специальную функцию, называемую обработчиком, которая активируется, когда обнаруживает, что наложение видно. Задача обработчика - удалить наложение, позволяя вашему тесту продолжаться так, как будто наложения не было.

Вещи, которые нужно учитывать:
* Когда наложение показывается предсказуемо, мы рекомендуем явно ожидать его в вашем тесте и закрывать его как часть вашего обычного тестового потока, вместо использования [Page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler).
* Playwright проверяет наличие наложения каждый раз перед выполнением или повторной попыткой действия, требующего [проверки возможности действия](../actionability.mdx), или перед выполнением проверки утверждения с автоматическим ожиданием. Когда наложение видно, Playwright сначала вызывает обработчик, а затем продолжает с действием/утверждением. Обратите внимание, что обработчик вызывается только тогда, когда вы выполняете действие/утверждение - если наложение становится видимым, но вы не выполняете никаких действий, обработчик не будет вызван.
* После выполнения обработчика Playwright убедится, что наложение, вызвавшее обработчик, больше не видно. Вы можете отказаться от этого поведения с помощью [setNoWaitAfter](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after).
* Время выполнения обработчика учитывается в тайм-ауте действия/утверждения, которое вызвало обработчик. Если ваш обработчик занимает слишком много времени, это может вызвать тайм-ауты.
* Вы можете зарегистрировать несколько обработчиков. Однако в любой момент времени будет выполняться только один обработчик. Убедитесь, что действия внутри обработчика не зависят от другого обработчика.

:::warning

Выполнение обработчика изменит состояние вашей страницы в середине теста. Например, это изменит текущий фокусированный элемент и переместит мышь. Убедитесь, что действия, выполняемые после обработчика, являются автономными и не зависят от того, что фокус и состояние мыши не изменились.

Например, рассмотрим тест, который вызывает [Locator.focus()](/api/class-locator.mdx#locator-focus) с последующим [Keyboard.press()](/api/class-keyboard.mdx#keyboard-press). Если ваш обработчик нажимает кнопку между этими двумя действиями, фокусированный элемент, скорее всего, будет неправильным, и нажатие клавиши произойдет на неожиданном элементе. Используйте [Locator.press()](/api/class-locator.mdx#locator-press) вместо этого, чтобы избежать этой проблемы.

Другой пример - серия действий с мышью, где [Mouse.move()](/api/class-mouse.mdx#mouse-move) следует за [Mouse.down()](/api/class-mouse.mdx#mouse-down). Опять же, когда обработчик выполняется между этими двумя действиями, положение мыши будет неправильным во время нажатия мыши. Предпочитайте автономные действия, такие как [Locator.click()](/api/class-locator.mdx#locator-click), которые не зависят от того, что состояние не изменилось обработчиком.
:::

**Использование**

Пример, который закрывает диалог "Подписаться на рассылку", когда он появляется:

```java
// Настройте обработчик.
page.addLocatorHandler(page.getByText("Sign up to the newsletter"), () -> {
  page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("No thanks")).click();
});

// Пишите тест как обычно.
page.navigate("https://example.com");
page.getByRole("button", Page.GetByRoleOptions().setName("Start here")).click();
```

Пример, который пропускает страницу "Подтвердите свои данные безопасности", когда она показывается:

```java
// Настройте обработчик.
page.addLocatorHandler(page.getByText("Confirm your security details"), () -> {
  page.getByRole(AriaRole.BUTTON, new Page.GetByRoleOptions().setName("Remind me later")).click();
});

// Пишите тест как обычно.
page.navigate("https://example.com");
page.getByRole("button", Page.GetByRoleOptions().setName("Start here")).click();
```

Пример с пользовательским обратным вызовом на каждую проверку возможности действия. Он использует локатор `<body>`, который всегда виден, поэтому обработчик вызывается перед каждой проверкой возможности действия. Важно указать [setNoWaitAfter](/api/class-page.mdx#page-add-locator-handler-option-no-wait-after), потому что обработчик не скрывает элемент `<body>`.

```java
// Настройте обработчик.
page.addLocatorHandler(page.locator("body"), () -> {
  page.evaluate("window.removeObstructionsForTestIfNeeded()");
}, new Page.AddLocatorHandlerOptions().setNoWaitAfter(true));

// Пишите тест как обычно.
page.navigate("https://example.com");
page.getByRole("button", Page.GetByRoleOptions().setName("Start here")).click();
```

Обработчик принимает оригинальный локатор в качестве аргумента. Вы также можете автоматически удалить обработчик после определенного количества вызовов, установив [setTimes](/api/class-page.mdx#page-add-locator-handler-option-times):

```java
page.addLocatorHandler(page.getByLabel("Close"), locator -> {
  locator.click();
}, new Page.AddLocatorHandlerOptions().setTimes(1));
```

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-locator"/><a href="#page-add-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, который вызывает обработчик.
- `handler` [Consumer]&lt;[Locator]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-handler"/><a href="#page-add-locator-handler-option-handler" class="list-anchor">#</a>
  
  Функция, которая должна быть выполнена, как только [локатор](/api/class-page.mdx#page-add-locator-handler-option-locator) появится. Эта функция должна избавиться от элемента, который блокирует действия, такие как клик.
- `options` `Page.AddLocatorHandlerOptions` *(опционально)*
  - `setNoWaitAfter` [boolean] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-no-wait-after"/><a href="#page-add-locator-handler-option-no-wait-after" class="list-anchor">#</a>
    
    По умолчанию, после вызова обработчика Playwright будет ждать, пока наложение не станет скрытым, и только затем продолжит с действием/утверждением, которое вызвало обработчик. Эта опция позволяет отказаться от этого поведения, так что наложение может оставаться видимым после выполнения обработчика.
  - `setTimes` [int] *(опционально)* <font size="2">Добавлено в: v1.44</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-option-times"/><a href="#page-add-locator-handler-option-times" class="list-anchor">#</a>
    
    Указывает максимальное количество раз, которое этот обработчик должен быть вызван. По умолчанию неограниченно.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-locator-handler-return"/><a href="#page-add-locator-handler-return" class="list-anchor">#</a>

---

### addScriptTag {#page-add-script-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.addScriptTag</x-search>

Добавляет тег `<script>` на страницу с желаемым URL или содержимым. Возвращает добавленный тег, когда срабатывает событие onload скрипта или когда содержимое скрипта было внедрено в фрейм.

**Использование**

```java
Page.addScriptTag();
Page.addScriptTag(options);
```

**Аргументы**
- `options` `Page.AddScriptTagOptions` *(опционально)*
  - `setContent` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-content"/><a href="#page-add-script-tag-option-content" class="list-anchor">#</a>
    
    Сырой JavaScript-контент, который будет внедрен в фрейм.
  - `setPath` [Path] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-path"/><a href="#page-add-script-tag-option-path" class="list-anchor">#</a>
    
    Путь к JavaScript-файлу, который будет внедрен в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `setType` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-type"/><a href="#page-add-script-tag-option-type" class="list-anchor">#</a>
    
    Тип скрипта. Используйте 'module', чтобы загрузить JavaScript ES6 модуль. Подробнее см. [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script).
  - `setUrl` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-option-url"/><a href="#page-add-script-tag-option-url" class="list-anchor">#</a>
    
    URL скрипта, который будет добавлен.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-script-tag-return"/><a href="#page-add-script-tag-return" class="list-anchor">#</a>

---

### addStyleTag {#page-add-style-tag}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.addStyleTag</x-search>

Добавляет тег `<link rel="stylesheet">` на страницу с желаемым URL или тег `<style type="text/css">` с содержимым. Возвращает добавленный тег, когда срабатывает событие onload стиля или когда CSS-контент был внедрен в фрейм.

**Использование**

```java
Page.addStyleTag();
Page.addStyleTag(options);
```

**Аргументы**
- `options` `Page.AddStyleTagOptions` *(опционально)*
  - `setContent` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-content"/><a href="#page-add-style-tag-option-content" class="list-anchor">#</a>
    
    Сырой CSS-контент, который будет внедрен в фрейм.
  - `setPath` [Path] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-path"/><a href="#page-add-style-tag-option-path" class="list-anchor">#</a>
    
    Путь к CSS-файлу, который будет внедрен в фрейм. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
  - `setUrl` [String] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-option-url"/><a href="#page-add-style-tag-option-url" class="list-anchor">#</a>
    
    URL тега `<link>`.

**Возвращает**
- [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-add-style-tag-return"/><a href="#page-add-style-tag-return" class="list-anchor">#</a>

---

### bringToFront {#page-bring-to-front}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.bringToFront</x-search>

Выводит страницу на передний план (активирует вкладку).

**Использование**

```java
Page.bringToFront();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-bring-to-front-return"/><a href="#page-bring-to-front-return" class="list-anchor">#</a>

---

### close {#page-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.close</x-search>

Если [setRunBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) равен `false`, не выполняет обработчики выгрузки и ждет, пока страница не будет закрыта. Если [setRunBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) равен `true`, метод выполнит обработчики выгрузки, но **не** будет ждать закрытия страницы.

По умолчанию, `page.close()` **не** выполняет обработчики `beforeunload`.

:::note

если [setRunBeforeUnload](/api/class-page.mdx#page-close-option-run-before-unload) передан как true, может быть вызван диалог `beforeunload`, который должен быть обработан вручную через событие [Page.onDialog(handler)](/api/class-page.mdx#page-event-dialog).
:::

**Использование**

```java
Page.close();
Page.close(options);
```

**Аргументы**
- `options` `Page.CloseOptions` *(опционально)*
  - `setReason` [String] *(опционально)* <font size="2">Добавлено в: v1.40</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-reason"/><a href="#page-close-option-reason" class="list-anchor">#</a>
    
    Причина, которая будет сообщена операциям, прерванным закрытием страницы.
  - `setRunBeforeUnload` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-option-run-before-unload"/><a href="#page-close-option-run-before-unload" class="list-anchor">#</a>
    
    По умолчанию `false`. Выполнять ли обработчики страницы [before unload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-close-return"/><a href="#page-close-return" class="list-anchor">#</a>

---

### consoleMessages {#page-console-messages}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.56</font><x-search>page.consoleMessages</x-search>

Returns up to (currently) 200 last console messages from this page. See [Page.onConsoleMessage(handler)](/api/class-page.mdx#page-event-console) for more details.

**Использование**

```java
Page.consoleMessages();
```

**Возвращает**
- [List]&lt;[ConsoleMessage]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-console-messages-return"/><a href="#page-console-messages-return" class="list-anchor">#</a>

---

### content {#page-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.content</x-search>

Получает полное содержимое HTML страницы, включая doctype.

**Использование**

```java
Page.content();
```

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-content-return"/><a href="#page-content-return" class="list-anchor">#</a>

---

### context {#page-context}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.context</x-search>

Получает контекст браузера, к которому принадлежит страница.

**Использование**

```java
Page.context();
```

**Возвращает**
- [BrowserContext]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-context-return"/><a href="#page-context-return" class="list-anchor">#</a>

---

### dragAndDrop {#page-drag-and-drop}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено в: v1.13</font><x-search>page.dragAndDrop</x-search>

Этот метод перетаскивает исходный элемент на целевой элемент. Сначала он перемещается к исходному элементу, выполняет `mousedown`, затем перемещается к целевому элементу и выполняет `mouseup`.

**Использование**

```java
page.dragAndDrop("#source", "#target");
// или укажите точные позиции относительно верхнего левого угла элементов:
page.dragAndDrop("#source", "#target", new Page.DragAndDropOptions()
  .setSourcePosition(34, 7).setTargetPosition(10, 20));
```

**Аргументы**
- `source` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source"/><a href="#page-drag-and-drop-option-source" class="list-anchor">#</a>
  
  Селектор для поиска элемента, который нужно перетащить. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `target` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target"/><a href="#page-drag-and-drop-option-target" class="list-anchor">#</a>
  
  Селектор для поиска элемента, на который нужно сбросить. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `Page.DragAndDropOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-force"/><a href="#page-drag-and-drop-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [возможности действия](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-no-wait-after"/><a href="#page-drag-and-drop-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setSourcePosition` SourcePosition *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-source-position"/><a href="#page-drag-and-drop-option-source-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Clicks on the source element at this point relative to the top-left corner of the element's padding box. If not specified, some visible point of the element is used.
  - `setSteps` [int] *(optional)* <font size="2">Added in: v1.57</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-steps"/><a href="#page-drag-and-drop-option-steps" class="list-anchor">#</a>
    
    Defaults to 1. Sends `n` interpolated `mousemove` events to represent travel between the `mousedown` and `mouseup` of the drag. When set to 1, emits a single `mousemove` event at the destination location.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-strict"/><a href="#page-drag-and-drop-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTargetPosition` TargetPosition *(опционально)* <font size="2">Добавлено в: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-target-position"/><a href="#page-drag-and-drop-option-target-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Сбрасывает на целевой элемент в этой точке относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-timeout"/><a href="#page-drag-and-drop-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-option-trial"/><a href="#page-drag-and-drop-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [возможности действия](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-drag-and-drop-return"/><a href="#page-drag-and-drop-return" class="list-anchor">#</a>

---

### emulateMedia {#page-emulate-media}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.emulateMedia</x-search>

Этот метод изменяет `CSS media type` через аргумент `media`, и/или медиа-функцию `'prefers-colors-scheme'`, используя аргумент `colorScheme`.

**Использование**

```java
page.evaluate("() => matchMedia('screen').matches");
// → true
page.evaluate("() => matchMedia('print').matches");
// → false

page.emulateMedia(new Page.EmulateMediaOptions().setMedia(Media.PRINT));
page.evaluate("() => matchMedia('screen').matches");
// → false
page.evaluate("() => matchMedia('print').matches");
// → true

page.emulateMedia(new Page.EmulateMediaOptions());
page.evaluate("() => matchMedia('screen').matches");
// → true
page.evaluate("() => matchMedia('print').matches");
// → false
```

```java
page.emulateMedia(new Page.EmulateMediaOptions().setColorScheme(ColorScheme.DARK));
page.evaluate("() => matchMedia('(prefers-color-scheme: dark)').matches");
// → true
page.evaluate("() => matchMedia('(prefers-color-scheme: light)').matches");
// → false
```

**Аргументы**
- `options` `Page.EmulateMediaOptions` *(опционально)*
  - `setColorScheme` [null] | `enum ColorScheme { LIGHT, DARK, NO_PREFERENCE }` *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-color-scheme"/><a href="#page-emulate-media-option-color-scheme" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию [prefers-colors-scheme](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme), поддерживаемые значения: `'light'` и `'dark'`. Передача `null` отключает эмуляцию цветовой схемы. `'no-preference'` устарело.
  - `setContrast` [null] | `enum Contrast { NO_PREFERENCE, MORE }` *(опционально)* <font size="2">Добавлено в: v1.51</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-contrast"/><a href="#page-emulate-media-option-contrast" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'prefers-contrast'`, поддерживаемые значения: `'no-preference'`, `'more'`. Передача `null` отключает эмуляцию контраста.
  - `setForcedColors` [null] | `enum ForcedColors { ACTIVE, NONE }` *(опционально)* <font size="2">Добавлено в: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-forced-colors"/><a href="#page-emulate-media-option-forced-colors" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'forced-colors'`, поддерживаемые значения: `'active'` и `'none'`. Передача `null` отключает эмуляцию принудительных цветов.
  - `setMedia` [null] | `enum Media { SCREEN, PRINT }` *(опционально)* <font size="2">Добавлено в: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-media"/><a href="#page-emulate-media-option-media" class="list-anchor">#</a>
    
    Изменяет тип CSS media страницы. Единственные допустимые значения: `'screen'`, `'print'` и `null`. Передача `null` отключает эмуляцию CSS media.
  - `setReducedMotion` [null] | `enum ReducedMotion { REDUCE, NO_PREFERENCE }` *(опционально)* <font size="2">Добавлено в: v1.12</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-option-reduced-motion"/><a href="#page-emulate-media-option-reduced-motion" class="list-anchor">#</a>
    
    Эмулирует медиа-функцию `'prefers-reduced-motion'`, поддерживаемые значения: `'reduce'`, `'no-preference'`. Передача `null` отключает эмуляцию уменьшенного движения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-emulate-media-return"/><a href="#page-emulate-media-return" class="list-anchor">#</a>

---

### evaluate {#page-evaluate}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.evaluate</x-search>

Возвращает значение вызова [expression](/api/class-page.mdx#page-evaluate-option-expression).

Если функция, переданная в [Page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает [Promise], то [Page.evaluate()](/api/class-page.mdx#page-evaluate) будет ждать разрешения промиса и вернет его значение.

Если функция, переданная в [Page.evaluate()](/api/class-page.mdx#page-evaluate), возвращает значение, не являющееся [Serializable], то [Page.evaluate()](/api/class-page.mdx#page-evaluate) разрешается в `undefined`. Playwright также поддерживает передачу некоторых дополнительных значений, которые не сериализуются через `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`.

**Использование**

Передача аргумента в [expression](/api/class-page.mdx#page-evaluate-option-expression):

```java
Object result = page.evaluate("([x, y]) => {\n" +
  "  return Promise.resolve(x * y);\n" +
  "}", Arrays.asList(7, 8));
System.out.println(result); // выводит "56"
```

Также можно передать строку вместо функции:

```java
System.out.println(page.evaluate("1 + 2")); // выводит "3"
```

Экземпляры [ElementHandle] могут быть переданы в качестве аргумента в [Page.evaluate()](/api/class-page.mdx#page-evaluate):

```java
ElementHandle bodyHandle = page.evaluate("document.body");
String html = (String) page.evaluate("([body, suffix]) => body.innerHTML + suffix", Arrays.asList(bodyHandle, "hello"));
bodyHandle.dispose();
```

**Аргументы**
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-expression"/><a href="#page-evaluate-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение, которое будет выполнено в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-option-arg"/><a href="#page-evaluate-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-evaluate-option-expression).

**Возвращает**
- [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-return"/><a href="#page-evaluate-return" class="list-anchor">#</a>

---

### evaluateHandle {#page-evaluate-handle}

<font size="2" style={{position: "relative", top: "-20px"}}>Добавлено до v1.9</font><x-search>page.evaluateHandle</x-search>

Возвращает значение вызова [expression](/api/class-page.mdx#page-evaluate-handle-option-expression) в виде [JSHandle].

Единственное отличие между [Page.evaluate()](/api/class-page.mdx#page-evaluate) и [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle) заключается в том, что [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle) возвращает [JSHandle].

Если функция, переданная в [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle), возвращает [Promise], то [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle) будет ждать разрешения промиса и вернет его значение.

**Использование**

```java
// Обработчик для объекта window.
JSHandle aWindowHandle = page.evaluateHandle("() => Promise.resolve(window)");
```

Также можно передать строку вместо функции:

```java
JSHandle aHandle = page.evaluateHandle("document"); // Обработчик для "document".
```

Экземпляры [JSHandle] могут быть переданы в качестве аргумента в [Page.evaluateHandle()](/api/class-page.mdx#page-evaluate-handle):

```java
JSHandle aHandle = page.evaluateHandle("() => document.body");
JSHandle resultHandle = page.evaluateHandle("([body, suffix]) => body.innerHTML + suffix", Arrays.asList(aHandle, "hello"));
System.out.println(resultHandle.jsonValue());
resultHandle.dispose();
```

**Аргументы**
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-expression"/><a href="#page-evaluate-handle-option-expression" class="list-anchor">#</a>
  
  JavaScript-выражение, которое будет выполнено в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-option-arg"/><a href="#page-evaluate-handle-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-evaluate-handle-option-expression).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-evaluate-handle-return"/><a href="#page-evaluate-handle-return" class="list-anchor">#</a>

---

### exposeBinding {#page-expose-binding}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.exposeBinding</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-binding-option-name) в объект `window` каждого фрейма на этой странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-binding-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-binding-option-callback). Если [callback](/api/class-page.mdx#page-expose-binding-option-callback) возвращает [Promise], он будет ожидаться.

Первый аргумент функции [callback](/api/class-page.mdx#page-expose-binding-option-callback) содержит информацию о вызывающем: `{ browserContext: BrowserContext, page: Page, frame: Frame }`.

Смотрите [BrowserContext.exposeBinding()](/api/class-browsercontext.mdx#browser-context-expose-binding) для версии, охватывающей весь контекст.

:::note

Функции, установленные через [Page.exposeBinding()](/api/class-page.mdx#page-expose-binding), сохраняются при навигации.
:::

**Использование**

Пример предоставления URL страницы всем фреймам на странице:

```java
import com.microsoft.playwright.*;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch(new BrowserType.LaunchOptions().setHeadless(false));
      BrowserContext context = browser.newContext();
      Page page = context.newPage();
      page.exposeBinding("pageURL", (source, args) -> source.page().url());
      page.setContent("<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.pageURL();\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>");
      page.click("button");
    }
  }
}
```

**Аргументы**
- `name` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-name"/><a href="#page-expose-binding-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` `BindingCallback`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-callback"/><a href="#page-expose-binding-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.
- `options` `Page.ExposeBindingOptions` *(optional)*
  - `setHandle` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-option-handle"/><a href="#page-expose-binding-option-handle" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция будет удалена в будущем.
    :::
    
    Передавать ли аргумент как handle, вместо передачи по значению. При передаче handle поддерживается только один аргумент. При передаче по значению поддерживается несколько аргументов.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-binding-return"/><a href="#page-expose-binding-return" class="list-anchor">#</a>

---

### exposeFunction {#page-expose-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.exposeFunction</x-search>

Метод добавляет функцию с именем [name](/api/class-page.mdx#page-expose-function-option-name) в объект `window` каждого фрейма на странице. При вызове функция выполняет [callback](/api/class-page.mdx#page-expose-function-option-callback) и возвращает [Promise], который разрешается в возвращаемое значение [callback](/api/class-page.mdx#page-expose-function-option-callback).

Если [callback](/api/class-page.mdx#page-expose-function-option-callback) возвращает [Promise], он будет ожидаться.

Смотрите [BrowserContext.exposeFunction()](/api/class-browsercontext.mdx#browser-context-expose-function) для версии, охватывающей весь контекст.

:::note

Функции, установленные через [Page.exposeFunction()](/api/class-page.mdx#page-expose-function), сохраняются при навигации.
:::

**Использование**

Пример добавления функции `sha256` на страницу:

```java
import com.microsoft.playwright.*;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch(new BrowserType.LaunchOptions().setHeadless(false));
      Page page = browser.newPage();
      page.exposeFunction("sha256", args -> {
        try {
          String text = (String) args[0];
          MessageDigest crypto = MessageDigest.getInstance("SHA-256");
          byte[] token = crypto.digest(text.getBytes(StandardCharsets.UTF_8));
          return Base64.getEncoder().encodeToString(token);
        } catch (NoSuchAlgorithmException e) {
          return null;
        }
      });
      page.setContent(
        "<script>\n" +
        "  async function onClick() {\n" +
        "    document.querySelector('div').textContent = await window.sha256('PLAYWRIGHT');\n" +
        "  }\n" +
        "</script>\n" +
        "<button onclick=\"onClick()\">Click me</button>\n" +
        "<div></div>"
      );
      page.click("button");
    }
  }
}
```

**Аргументы**
- `name` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-name"/><a href="#page-expose-function-option-name" class="list-anchor">#</a>
  
  Имя функции в объекте window.
- `callback` `FunctionCallback`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-option-callback"/><a href="#page-expose-function-option-callback" class="list-anchor">#</a>
  
  Функция обратного вызова, которая будет вызвана в контексте Playwright.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-expose-function-return"/><a href="#page-expose-function-return" class="list-anchor">#</a>

---

### frame {#page-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.frame</x-search>

Возвращает фрейм, соответствующий указанным критериям. Должно быть указано либо `name`, либо `url`.

**Использование**

```java
Frame frame = page.frame("frame-name");
```

```java
Frame frame = page.frameByUrl(Pattern.compile(".*domain.*"));
```

**Аргументы**
- `name` [String] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-option-name"/><a href="#page-frame-option-name" class="list-anchor">#</a>
  
  Имя фрейма, указанное в атрибуте `name` тега `iframe`.

**Возвращает**
- [null] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-return"/><a href="#page-frame-return" class="list-anchor">#</a>

---

### frameByUrl {#page-frame-by-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.frameByUrl</x-search>

Возвращает фрейм с соответствующим URL.

**Использование**

```java
Page.frameByUrl(url);
```

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-by-url-option-url"/><a href="#page-frame-by-url-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий `url` фрейма как объект [URL].

**Возвращает**
- [null] | [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-by-url-return"/><a href="#page-frame-by-url-return" class="list-anchor">#</a>

---

### frameLocator {#page-frame-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.17</font><x-search>page.frameLocator</x-search>

При работе с iframes вы можете создать локатор фрейма, который войдет в iframe и позволит выбирать элементы в этом iframe.

**Использование**

Следующий фрагмент кода находит элемент с текстом "Submit" в iframe с id `my-frame`, например `<iframe id="my-frame">`:

```java
Locator locator = page.frameLocator("#my-iframe").getByText("Submit");
locator.click();
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-option-selector"/><a href="#page-frame-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении DOM элемента.

**Возвращает**
- [FrameLocator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frame-locator-return"/><a href="#page-frame-locator-return" class="list-anchor">#</a>

---

### frames {#page-frames}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.frames</x-search>

Массив всех фреймов, прикрепленных к странице.

**Использование**

```java
Page.frames();
```

**Возвращает**
- [List]&lt;[Frame]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-frames-return"/><a href="#page-frames-return" class="list-anchor">#</a>

---

### getByAltText {#page-get-by-alt-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByAltText</x-search>

Позволяет находить элементы по их alt тексту.

**Использование**

Например, этот метод найдет изображение по alt тексту "Playwright logo":

```html
<img alt='Playwright logo'>
```

```java
page.getByAltText("Playwright logo").click();
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-text"/><a href="#page-get-by-alt-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByAltTextOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-option-exact"/><a href="#page-get-by-alt-text-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-alt-text-return"/><a href="#page-get-by-alt-text-return" class="list-anchor">#</a>

---

### getByLabel {#page-get-by-label}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByLabel</x-search>

Позволяет находить элементы ввода по тексту связанного элемента `<label>` или элемента `aria-labelledby`, или по атрибуту `aria-label`.

**Использование**

Например, этот метод найдет поля ввода по меткам "Username" и "Password" в следующем DOM:

```html
<input aria-label="Username">
<label for="password-input">Password:</label>
<input id="password-input">
```

```java
page.getByLabel("Username").fill("john");
page.getByLabel("Password").fill("secret");
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-text"/><a href="#page-get-by-label-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByLabelOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-option-exact"/><a href="#page-get-by-label-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-label-return"/><a href="#page-get-by-label-return" class="list-anchor">#</a>

---

### getByPlaceholder {#page-get-by-placeholder}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByPlaceholder</x-search>

Позволяет находить элементы ввода по тексту-заполнителю.

**Использование**

Например, рассмотрим следующую структуру DOM.

```html
<input type="email" placeholder="name@example.com" />
```

Вы можете заполнить поле ввода, найдя его по тексту-заполнителю:

```java
page.getByPlaceholder("name@example.com").fill("playwright@microsoft.com");
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-text"/><a href="#page-get-by-placeholder-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByPlaceholderOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-option-exact"/><a href="#page-get-by-placeholder-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-placeholder-return"/><a href="#page-get-by-placeholder-return" class="list-anchor">#</a>

---

### getByRole {#page-get-by-role}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByRole</x-search>

Позволяет находить элементы по их [ARIA роли](https://www.w3.org/TR/wai-aria-1.2/#roles), [ARIA атрибутам](https://www.w3.org/TR/wai-aria-1.2/#aria-attributes) и [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name).

**Использование**

Рассмотрим следующую структуру DOM.

```html
<h3>Sign up</h3>
<label>
  <input type="checkbox" /> Subscribe
</label>
<br/>
<button>Submit</button>
```

Вы можете найти каждый элемент по его неявной роли:

```java
assertThat(page
    .getByRole(AriaRole.HEADING,
               new Page.GetByRoleOptions().setName("Sign up")))
    .isVisible();

page.getByRole(AriaRole.CHECKBOX,
               new Page.GetByRoleOptions().setName("Subscribe"))
    .check();

page.getByRole(AriaRole.BUTTON,
               new Page.GetByRoleOptions().setName(
                   Pattern.compile("submit", Pattern.CASE_INSENSITIVE)))
    .click();
```

**Аргументы**
- `role` `enum AriaRole { ALERT, ALERTDIALOG, APPLICATION, ARTICLE, BANNER, BLOCKQUOTE, BUTTON, CAPTION, CELL, CHECKBOX, CODE, COLUMNHEADER, COMBOBOX, COMPLEMENTARY, CONTENTINFO, DEFINITION, DELETION, DIALOG, DIRECTORY, DOCUMENT, EMPHASIS, FEED, FIGURE, FORM, GENERIC, GRID, GRIDCELL, GROUP, HEADING, IMG, INSERTION, LINK, LIST, LISTBOX, LISTITEM, LOG, MAIN, MARQUEE, MATH, METER, MENU, MENUBAR, MENUITEM, MENUITEMCHECKBOX, MENUITEMRADIO, NAVIGATION, NONE, NOTE, OPTION, PARAGRAPH, PRESENTATION, PROGRESSBAR, RADIO, RADIOGROUP, REGION, ROW, ROWGROUP, ROWHEADER, SCROLLBAR, SEARCH, SEARCHBOX, SEPARATOR, SLIDER, SPINBUTTON, STATUS, STRONG, SUBSCRIPT, SUPERSCRIPT, SWITCH, TAB, TABLE, TABLIST, TABPANEL, TERM, TEXTBOX, TIME, TIMER, TOOLBAR, TOOLTIP, TREE, TREEGRID, TREEITEM }`<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-role"/><a href="#page-get-by-role-option-role" class="list-anchor">#</a>
  
  Требуемая ARIA роль.
- `options` `Page.GetByRoleOptions` *(optional)*
  - `setChecked` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-checked"/><a href="#page-get-by-role-option-checked" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-checked` или нативными элементами `<input type=checkbox>`.
    
    Узнайте больше о [`aria-checked`](https://www.w3.org/TR/wai-aria-1.2/#aria-checked).
  - `setDisabled` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-disabled"/><a href="#page-get-by-role-option-disabled" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-disabled` или `disabled`.
    
    :::note
    
    В отличие от большинства других атрибутов, `disabled` наследуется через иерархию DOM. Узнайте больше о [`aria-disabled`](https://www.w3.org/TR/wai-aria-1.2/#aria-disabled).
    :::
    
  - `setExact` [boolean] *(optional)* <font size="2">Added in: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-exact"/><a href="#page-get-by-role-option-exact" class="list-anchor">#</a>
    
    Совпадает ли [setName](/api/class-page.mdx#page-get-by-role-option-name) точно: с учетом регистра и всей строки. По умолчанию false. Игнорируется, когда [setName](/api/class-page.mdx#page-get-by-role-option-name) является регулярным выражением. Обратите внимание, что точное совпадение все равно обрезает пробелы.
  - `setExpanded` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-expanded"/><a href="#page-get-by-role-option-expanded" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-expanded`.
    
    Узнайте больше о [`aria-expanded`](https://www.w3.org/TR/wai-aria-1.2/#aria-expanded).
  - `setIncludeHidden` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-include-hidden"/><a href="#page-get-by-role-option-include-hidden" class="list-anchor">#</a>
    
    Опция, которая контролирует, соответствуют ли скрытые элементы. По умолчанию, только не скрытые элементы, как [определено ARIA](https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion), соответствуют селектору роли.
    
    Узнайте больше о [`aria-hidden`](https://www.w3.org/TR/wai-aria-1.2/#aria-hidden).
  - `setLevel` [int] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-level"/><a href="#page-get-by-role-option-level" class="list-anchor">#</a>
    
    Числовой атрибут, который обычно присутствует для ролей `heading`, `listitem`, `row`, `treeitem`, с значениями по умолчанию для элементов `<h1>-<h6>`.
    
    Узнайте больше о [`aria-level`](https://www.w3.org/TR/wai-aria-1.2/#aria-level).
  - `setName` [String] | [Pattern] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-name"/><a href="#page-get-by-role-option-name" class="list-anchor">#</a>
    
    Опция для соответствия [доступному имени](https://w3c.github.io/accname/#dfn-accessible-name). По умолчанию, соответствие не учитывает регистр и ищет подстроку, используйте [setExact](/api/class-page.mdx#page-get-by-role-option-exact) для управления этим поведением.
    
    Узнайте больше о [доступном имени](https://w3c.github.io/accname/#dfn-accessible-name).
  - `setPressed` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-pressed"/><a href="#page-get-by-role-option-pressed" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-pressed`.
    
    Узнайте больше о [`aria-pressed`](https://www.w3.org/TR/wai-aria-1.2/#aria-pressed).
  - `setSelected` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-option-selected"/><a href="#page-get-by-role-option-selected" class="list-anchor">#</a>
    
    Атрибут, который обычно устанавливается `aria-selected`.
    
    Узнайте больше о [`aria-selected`](https://www.w3.org/TR/wai-aria-1.2/#aria-selected).

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-role-return"/><a href="#page-get-by-role-return" class="list-anchor">#</a>

**Детали**

Селектор роли **не заменяет** аудиты доступности и тесты на соответствие, но дает раннюю обратную связь о рекомендациях ARIA.

Многие HTML элементы имеют неявно [определенную роль](https://w3c.github.io/html-aam/#html-element-role-mappings), которая распознается селектором роли. Вы можете найти все [поддерживаемые роли здесь](https://www.w3.org/TR/wai-aria-1.2/#role_definitions). Рекомендации ARIA **не рекомендуют** дублировать неявные роли и атрибуты, устанавливая `role` и/или `aria-*` атрибуты на значения по умолчанию.

---

### getByTestId {#page-get-by-test-id}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByTestId</x-search>

Находит элемент по тестовому идентификатору.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<button data-testid="directions">Itinéraire</button>
```

Вы можете найти элемент по его тестовому идентификатору:

```java
page.getByTestId("directions").click();
```

**Аргументы**
- `testId` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-option-test-id"/><a href="#page-get-by-test-id-option-test-id" class="list-anchor">#</a>
  
  Идентификатор для поиска элемента.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-test-id-return"/><a href="#page-get-by-test-id-return" class="list-anchor">#</a>

**Детали**

По умолчанию используется атрибут `data-testid` в качестве тестового идентификатора. Используйте [Selectors.setTestIdAttribute()](/api/class-selectors.mdx#selectors-set-test-id-attribute) для настройки другого атрибута тестового идентификатора, если это необходимо.

---

### getByText {#page-get-by-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByText</x-search>

Позволяет находить элементы, содержащие заданный текст.

Смотрите также [Locator.filter()](/api/class-locator.mdx#locator-filter), который позволяет сопоставлять по другим критериям, таким как доступная роль, а затем фильтровать по текстовому содержимому.

**Использование**

Рассмотрим следующую структуру DOM:

```html
<div>Hello <span>world</span></div>
<div>Hello</div>
```

Вы можете найти по подстроке текста, точной строке или регулярному выражению:

```java
// Соответствует <span>
page.getByText("world");

// Соответствует первому <div>
page.getByText("Hello world");

// Соответствует второму <div>
page.getByText("Hello", new Page.GetByTextOptions().setExact(true));

// Соответствует обоим <div>
page.getByText(Pattern.compile("Hello"));

// Соответствует второму <div>
page.getByText(Pattern.compile("^hello$", Pattern.CASE_INSENSITIVE));
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-text"/><a href="#page-get-by-text-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByTextOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-option-exact"/><a href="#page-get-by-text-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-text-return"/><a href="#page-get-by-text-return" class="list-anchor">#</a>

**Детали**

Сопоставление по тексту всегда нормализует пробелы, даже при точном совпадении. Например, оно превращает несколько пробелов в один, превращает разрывы строк в пробелы и игнорирует начальные и конечные пробелы.

Элементы ввода типа `button` и `submit` сопоставляются по их `value`, а не по текстовому содержимому. Например, поиск по тексту `"Log in"` соответствует `<input type=button value="Log in">`.

---

### getByTitle {#page-get-by-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.27</font><x-search>page.getByTitle</x-search>

Позволяет находить элементы по их атрибуту title.

**Использование**

Рассмотрим следующую структуру DOM.

```html
<span title='Issues count'>25 issues</span>
```

Вы можете проверить количество проблем, найдя его по тексту заголовка:

```java
assertThat(page.getByTitle("Issues count")).hasText("25 issues");
```

**Аргументы**
- `text` [String] | [Pattern]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-text"/><a href="#page-get-by-title-option-text" class="list-anchor">#</a>
  
  Текст для поиска элемента.
- `options` `Page.GetByTitleOptions` *(optional)*
  - `setExact` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-option-exact"/><a href="#page-get-by-title-option-exact" class="list-anchor">#</a>
    
    Искать ли точное совпадение: с учетом регистра и всей строки. По умолчанию false. Игнорируется при поиске по регулярному выражению. Обратите внимание, что точное совпадение все равно обрезает пробелы.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-by-title-return"/><a href="#page-get-by-title-return" class="list-anchor">#</a>

---

### goBack {#page-go-back}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.goBack</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. Если невозможно вернуться назад, возвращает `null`.

Переход на предыдущую страницу в истории.

**Использование**

```java
Page.goBack();
Page.goBack(options);
```

**Аргументы**
- `options` `Page.GoBackOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-timeout"/><a href="#page-go-back-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-option-wait-until"/><a href="#page-go-back-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-back-return"/><a href="#page-go-back-return" class="list-anchor">#</a>

---

### goForward {#page-go-forward}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.goForward</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. Если невозможно перейти вперед, возвращает `null`.

Переход на следующую страницу в истории.

**Использование**

```java
Page.goForward();
Page.goForward(options);
```

**Аргументы**
- `options` `Page.GoForwardOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-timeout"/><a href="#page-go-forward-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-option-wait-until"/><a href="#page-go-forward-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-go-forward-return"/><a href="#page-go-forward-return" class="list-anchor">#</a>

---

### isClosed {#page-is-closed}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isClosed</x-search>

Указывает, что страница была закрыта.

**Использование**

```java
Page.isClosed();
```

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-closed-return"/><a href="#page-is-closed-return" class="list-anchor">#</a>

---

### locator {#page-locator}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.14</font><x-search>page.locator</x-search>

Метод возвращает локатор элемента, который можно использовать для выполнения действий на этой странице/фрейме. Локатор разрешается в элемент непосредственно перед выполнением действия, поэтому серия действий на одном и том же локаторе может фактически выполняться на разных элементах DOM. Это произойдет, если структура DOM между этими действиями изменилась.

[Узнайте больше о локаторах](../locators.mdx).

**Использование**

```java
Page.locator(selector);
Page.locator(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-selector"/><a href="#page-locator-option-selector" class="list-anchor">#</a>
  
  Селектор для использования при разрешении элемента DOM.
- `options` `Page.LocatorOptions` *(optional)*
  - `setHas` [Locator] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has"/><a href="#page-locator-option-has" class="list-anchor">#</a>
    
    Сужает результаты метода до тех, которые содержат элементы, соответствующие этому относительному локатору. Например, `article`, который имеет `text=Playwright`, соответствует `<article><div>Playwright</div></article>`.
    
    Внутренний локатор **должен быть относительным** к внешнему локатору и запрашивается, начиная с совпадения внешнего локатора, а не с корня документа. Например, вы можете найти `content`, который имеет `div` в `<article><content><div>Playwright</div></content></article>`. Однако поиск `content`, который имеет `article div`, не удастся, потому что внутренний локатор должен быть относительным и не должен использовать элементы за пределами `content`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `setHasNot` [Locator] *(optional)* <font size="2">Added in: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not"/><a href="#page-locator-option-has-not" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат элемент, соответствующий внутреннему локатору. Внутренний локатор запрашивается относительно внешнего. Например, `article`, который не имеет `div`, соответствует `<article><span>Playwright</span></article>`.
    
    Обратите внимание, что внешние и внутренние локаторы должны принадлежать одному и тому же фрейму. Внутренний локатор не должен содержать [FrameLocator]s.
  - `setHasNotText` [String] | [Pattern] *(optional)* <font size="2">Added in: v1.33</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-not-text"/><a href="#page-locator-option-has-not-text" class="list-anchor">#</a>
    
    Соответствует элементам, которые не содержат указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [строки] сопоставление нечувствительно к регистру и ищет подстроку.
  - `setHasText` [String] | [Pattern] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-option-has-text"/><a href="#page-locator-option-has-text" class="list-anchor">#</a>
    
    Соответствует элементам, содержащим указанный текст где-либо внутри, возможно, в дочернем или потомке элемента. При передаче [строки] сопоставление нечувствительно к регистру и ищет подстроку. Например, `"Playwright"` соответствует `<article><div>Playwright</div></article>`.

**Возвращает**
- [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-locator-return"/><a href="#page-locator-return" class="list-anchor">#</a>

---

### mainFrame {#page-main-frame}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.mainFrame</x-search>

Основной фрейм страницы. Страница гарантированно имеет основной фрейм, который сохраняется во время навигации.

**Использование**

```java
Page.mainFrame();
```

**Возвращает**
- [Frame]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-main-frame-return"/><a href="#page-main-frame-return" class="list-anchor">#</a>

---

### navigate {#page-goto}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.navigate</x-search>

Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с первым не перенаправленным ответом.

Метод вызовет ошибку, если:
* произошла ошибка SSL (например, в случае самоподписанных сертификатов).
* целевой URL недействителен.
* [setTimeout](/api/class-page.mdx#page-goto-option-timeout) превышен во время навигации.
* удаленный сервер не отвечает или недоступен.
* основной ресурс не удалось загрузить.

Метод не вызовет ошибку, если удаленный сервер вернет любой допустимый код состояния HTTP, включая 404 "Не найдено" и 500 "Внутренняя ошибка сервера". Код состояния для таких ответов можно получить, вызвав [Response.status()](/api/class-response.mdx#response-status).

:::note

Метод либо вызывает ошибку, либо возвращает ответ основного ресурса. Единственными исключениями являются навигация на `about:blank` или навигация на тот же URL с другим хэшем, которые будут успешными и вернут `null`.
:::

:::note
Режим без головы не поддерживает навигацию к PDF-документу. См. [проблему](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).
:::

**Использование**

```java
Page.navigate(url);
Page.navigate(url, options);
```

**Аргументы**
- `url` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-url"/><a href="#page-goto-option-url" class="list-anchor">#</a>
  
  URL для перехода на страницу. URL должен включать схему, например, `https://`. Когда [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `Page.NavigateOptions` *(optional)*
  - `setReferer` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-referer"/><a href="#page-goto-option-referer" class="list-anchor">#</a>
    
    Значение заголовка Referer. Если предоставлено, оно будет иметь приоритет над значением заголовка referer, установленным с помощью [Page.setExtraHTTPHeaders()](/api/class-page.mdx#page-set-extra-http-headers).
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-timeout"/><a href="#page-goto-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-option-wait-until"/><a href="#page-goto-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-goto-return"/><a href="#page-goto-return" class="list-anchor">#</a>

---

### onceDialog {#page-once-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.10</font><x-search>page.onceDialog</x-search>

Добавляет одноразовый обработчик [Dialog]. Обработчик будет удален сразу после создания следующего [Dialog].

```java
page.onceDialog(dialog -> {
  dialog.accept("foo");
});

// выводит 'foo'
System.out.println(page.evaluate("prompt('Enter string:')"));

// выводит 'null', так как диалог будет автоматически отклонен, потому что нет обработчиков.
System.out.println(page.evaluate("prompt('Enter string:')"));
```

Этот код выше эквивалентен:

```java
Consumer<Dialog> handler = new Consumer<Dialog>() {
  @Override
  public void accept(Dialog dialog) {
    dialog.accept("foo");
    page.offDialog(this);
  }
};
page.onDialog(handler);

// выводит 'foo'
System.out.println(page.evaluate("prompt('Enter string:')"));

// выводит 'null', так как диалог будет автоматически отклонен, потому что нет обработчиков.
System.out.println(page.evaluate("prompt('Enter string:')"));
```

**Использование**

```java
Page.onceDialog(handler);
```

**Аргументы**
- `handler` [Consumer]&lt;[Dialog]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-once-dialog-option-handler"/><a href="#page-once-dialog-option-handler" class="list-anchor">#</a>
  
  Получает объект [Dialog], он **должен** либо [Dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [Dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница будет [заморожена](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалога, и такие действия, как клик, никогда не завершатся.

---

### opener {#page-opener}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.opener</x-search>

Возвращает открыватель для всплывающих страниц и `null` для других. Если открыватель уже был закрыт, возвращает `null`.

**Использование**

```java
Page.opener();
```

**Возвращает**
- [null] | [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-opener-return"/><a href="#page-opener-return" class="list-anchor">#</a>

---

### pageErrors {#page-page-errors}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.56</font><x-search>page.pageErrors</x-search>

Returns up to (currently) 200 last page errors from this page. See [Page.onPageError(handler)](/api/class-page.mdx#page-event-page-error) for more details.

**Использование**

```java
Page.pageErrors();
```

**Возвращает**
- [List]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-page-errors-return"/><a href="#page-page-errors-return" class="list-anchor">#</a>

---

### pause {#page-pause}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.pause</x-search>

Приостанавливает выполнение скрипта. Playwright перестанет выполнять скрипт и будет ждать, пока пользователь либо нажмёт кнопку 'Resume' в оверлее страницы, либо вызовет `playwright.resume()` в консоли DevTools.

Пользователь может исследовать селекторы или выполнять ручные шаги во время паузы. Возобновление продолжит выполнение оригинального скрипта с того места, где он был приостановлен.

:::note

Этот метод требует, чтобы Playwright был запущен в режиме с интерфейсом, с ложным параметром [setHeadless](/api/class-browsertype.mdx#browser-type-launch-option-headless).
:::

**Использование**

```java
Page.pause();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pause-return"/><a href="#page-pause-return" class="list-anchor">#</a>

---

### pdf {#page-pdf}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.pdf</x-search>

Возвращает буфер PDF.

`page.pdf()` генерирует pdf страницы с `print` css media. Чтобы сгенерировать pdf с `screen` media, вызовите [Page.emulateMedia()](/api/class-page.mdx#page-emulate-media) перед вызовом `page.pdf()`:

:::note

По умолчанию `page.pdf()` генерирует pdf с измененными цветами для печати. Используйте свойство [`-webkit-print-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust), чтобы принудительно отобразить точные цвета.
:::

**Использование**

```java
// Генерирует PDF с типом медиа "screen".
page.emulateMedia(new Page.EmulateMediaOptions().setMedia(Media.SCREEN));
page.pdf(new Page.PdfOptions().setPath(Paths.get("page.pdf")));
```

Параметры [setWidth](/api/class-page.mdx#page-pdf-option-width), [setHeight](/api/class-page.mdx#page-pdf-option-height) и [setMargin](/api/class-page.mdx#page-pdf-option-margin) принимают значения с указанием единиц измерения. Значения без указания единиц измерения считаются пикселями.

Несколько примеров:
* `page.pdf({width: 100})` - печатает с шириной, установленной в 100 пикселей
* `page.pdf({width: '100px'})` - печатает с шириной, установленной в 100 пикселей
* `page.pdf({width: '10cm'})` - печатает с шириной, установленной в 10 сантиметров.

Все возможные единицы измерения:
* `px` - пиксель
* `in` - дюйм
* `cm` - сантиметр
* `mm` - миллиметр

Параметры [setFormat](/api/class-page.mdx#page-pdf-option-format):
* `Letter`: 8.5in x 11in
* `Legal`: 8.5in x 14in
* `Tabloid`: 11in x 17in
* `Ledger`: 17in x 11in
* `A0`: 33.1in x 46.8in
* `A1`: 23.4in x 33.1in
* `A2`: 16.54in x 23.4in
* `A3`: 11.7in x 16.54in
* `A4`: 8.27in x 11.7in
* `A5`: 5.83in x 8.27in
* `A6`: 4.13in x 5.83in

:::note

Разметка [setHeaderTemplate](/api/class-page.mdx#page-pdf-option-header-template) и [setFooterTemplate](/api/class-page.mdx#page-pdf-option-footer-template) имеет следующие ограничения: > 1. Теги скриптов внутри шаблонов не оцениваются. > 2. Стили страницы не видны внутри шаблонов.
:::

**Аргументы**
- `options` `Page.PdfOptions` *(optional)*
  - `setDisplayHeaderFooter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-display-header-footer"/><a href="#page-pdf-option-display-header-footer" class="list-anchor">#</a>
    
    Отображать заголовок и нижний колонтитул. По умолчанию `false`.
  - `setFooterTemplate` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-footer-template"/><a href="#page-pdf-option-footer-template" class="list-anchor">#</a>
    
    HTML-шаблон для нижнего колонтитула печати. Должен использовать тот же формат, что и [setHeaderTemplate](/api/class-page.mdx#page-pdf-option-header-template).
  - `setFormat` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-format"/><a href="#page-pdf-option-format" class="list-anchor">#</a>
    
    Формат бумаги. Если установлен, имеет приоритет над параметрами [setWidth](/api/class-page.mdx#page-pdf-option-width) или [setHeight](/api/class-page.mdx#page-pdf-option-height). По умолчанию 'Letter'.
  - `setHeaderTemplate` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-header-template"/><a href="#page-pdf-option-header-template" class="list-anchor">#</a>
    
    HTML-шаблон для заголовка печати. Должен быть допустимой HTML-разметкой с использованием следующих классов для вставки значений печати в них:
    * `'date'` отформатированная дата печати
    * `'title'` заголовок документа
    * `'url'` местоположение документа
    * `'pageNumber'` номер текущей страницы
    * `'totalPages'` общее количество страниц в документе
  - `setHeight` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-height"/><a href="#page-pdf-option-height" class="list-anchor">#</a>
    
    Высота бумаги, принимает значения с указанием единиц измерения.
  - `setLandscape` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-landscape"/><a href="#page-pdf-option-landscape" class="list-anchor">#</a>
    
    Ориентация бумаги. По умолчанию `false`.
  - `setMargin` Margin *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-margin"/><a href="#page-pdf-option-margin" class="list-anchor">#</a>
    - `setTop` [String] *(optional)*
      
      Верхнее поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    - `setRight` [String] *(optional)*
      
      Правое поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    - `setBottom` [String] *(optional)*
      
      Нижнее поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    - `setLeft` [String] *(optional)*
      
      Левое поле, принимает значения с указанием единиц измерения. По умолчанию `0`.
    
    Поля бумаги, по умолчанию отсутствуют.
  - `setOutline` [boolean] *(optional)* <font size="2">Added in: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-outline"/><a href="#page-pdf-option-outline" class="list-anchor">#</a>
    
    Включать ли контур документа в PDF. По умолчанию `false`.
  - `setPageRanges` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-page-ranges"/><a href="#page-pdf-option-page-ranges" class="list-anchor">#</a>
    
    Диапазоны страниц для печати, например, '1-5, 8, 11-13'. По умолчанию пустая строка, что означает печать всех страниц.
  - `setPath` [Path] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-path"/><a href="#page-pdf-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения PDF. Если [setPath](/api/class-page.mdx#page-pdf-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, PDF не будет сохранен на диск.
  - `setPreferCSSPageSize` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-prefer-css-page-size"/><a href="#page-pdf-option-prefer-css-page-size" class="list-anchor">#</a>
    
    Предпочитать любой размер страницы CSS `@page`, объявленный на странице, над тем, что объявлено в параметрах [setWidth](/api/class-page.mdx#page-pdf-option-width) и [setHeight](/api/class-page.mdx#page-pdf-option-height) или [setFormat](/api/class-page.mdx#page-pdf-option-format). По умолчанию `false`, что будет масштабировать содержимое, чтобы оно соответствовало размеру бумаги.
  - `setPrintBackground` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-print-background"/><a href="#page-pdf-option-print-background" class="list-anchor">#</a>
    
    Печать фоновой графики. По умолчанию `false`.
  - `setScale` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-scale"/><a href="#page-pdf-option-scale" class="list-anchor">#</a>
    
    Масштаб рендеринга веб-страницы. По умолчанию `1`. Масштаб должен быть между 0.1 и 2.
  - `setTagged` [boolean] *(optional)* <font size="2">Added in: v1.42</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-tagged"/><a href="#page-pdf-option-tagged" class="list-anchor">#</a>
    
    Генерировать ли тегированный (доступный) PDF. По умолчанию `false`.
  - `setWidth` [String] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-option-width"/><a href="#page-pdf-option-width" class="list-anchor">#</a>
    
    Ширина бумаги, принимает значения с указанием единиц измерения.

**Возвращает**
- [byte&#91;&#93;]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-pdf-return"/><a href="#page-pdf-return" class="list-anchor">#</a>

---

### reload {#page-reload}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.reload</x-search>

Этот метод перезагружает текущую страницу так же, как если бы пользователь инициировал обновление браузера. Возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления.

**Использование**

```java
Page.reload();
Page.reload(options);
```

**Аргументы**
- `options` `Page.ReloadOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-timeout"/><a href="#page-reload-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-option-wait-until"/><a href="#page-reload-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-reload-return"/><a href="#page-reload-return" class="list-anchor">#</a>

---

### removeLocatorHandler {#page-remove-locator-handler}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.44</font><x-search>page.removeLocatorHandler</x-search>

Удаляет все обработчики локаторов, добавленные с помощью [Page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler) для конкретного локатора.

**Использование**

```java
Page.removeLocatorHandler(locator);
```

**Аргументы**
- `locator` [Locator]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-option-locator"/><a href="#page-remove-locator-handler-option-locator" class="list-anchor">#</a>
  
  Локатор, переданный в [Page.addLocatorHandler()](/api/class-page.mdx#page-add-locator-handler).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-remove-locator-handler-return"/><a href="#page-remove-locator-handler-return" class="list-anchor">#</a>

---

### requestGC {#page-request-gc}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.48</font><x-search>page.requestGC</x-search>

Запросить у страницы выполнение сборки мусора. Обратите внимание, что нет гарантии, что все недоступные объекты будут собраны.

Это полезно для обнаружения утечек памяти. Например, если на вашей странице есть большой объект `'suspect'`, который может утекать, вы можете проверить, что он не утек, используя [`WeakRef`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef).

```java
// 1. На вашей странице сохраните WeakRef для "suspect".
page.evaluate("globalThis.suspectWeakRef = new WeakRef(suspect)");
// 2. Запросите сборку мусора.
page.requestGC();
// 3. Убедитесь, что weak ref не ссылается на оригинальный объект.
assertTrue(page.evaluate("!globalThis.suspectWeakRef.deref()"));
```

**Использование**

```java
Page.requestGC();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-request-gc-return"/><a href="#page-request-gc-return" class="list-anchor">#</a>

---

### requests {#page-requests}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.56</font><x-search>page.requests</x-search>

Returns up to (currently) 100 last network request from this page. See [Page.onRequest(handler)](/api/class-page.mdx#page-event-request) for more details.

Returned requests should be accessed immediately, otherwise they might be collected to prevent unbounded memory growth as new requests come in. Once collected, retrieving most information about the request is impossible.

Note that requests reported through the [Page.onRequest(handler)](/api/class-page.mdx#page-event-request) request are not collected, so there is a trade off between efficient memory usage with [Page.requests()](/api/class-page.mdx#page-requests) and the amount of available information reported through [Page.onRequest(handler)](/api/class-page.mdx#page-event-request).

**Использование**

```java
Page.requests();
```

**Возвращает**
- [List]&lt;[Request]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-requests-return"/><a href="#page-requests-return" class="list-anchor">#</a>

---

### route {#page-route}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.route</x-search>

Маршрутизация предоставляет возможность изменять сетевые запросы, которые выполняются страницей.

После включения маршрутизации каждый запрос, соответствующий шаблону URL, будет приостановлен, если он не будет продолжен, выполнен или прерван.

:::note

Обработчик будет вызван только для первого URL, если ответ является перенаправлением.
:::

:::note
[Page.route()](/api/class-page.mdx#page-route) не будет перехватывать запросы, перехваченные Service Worker. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [setServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.
:::

:::note
[Page.route()](/api/class-page.mdx#page-route) не будет перехватывать первый запрос всплывающей страницы. Используйте [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route) вместо этого.
:::

**Использование**

Пример наивного обработчика, который прерывает все запросы изображений:

```java
Page page = browser.newPage();
page.route("**/*.{png,jpg,jpeg}", route -> route.abort());
page.navigate("https://example.com");
browser.close();
```

или тот же фрагмент, используя вместо этого шаблон регулярного выражения:

```java
Page page = browser.newPage();
page.route(Pattern.compile("(\\.png$)|(\\.jpg$)"),route -> route.abort());
page.navigate("https://example.com");
browser.close();
```

Возможно исследовать запрос, чтобы решить, какое действие маршрута выполнить. Например, имитируя все запросы, содержащие некоторые данные POST, и оставляя все остальные запросы как есть:

```java
page.route("/api/**", route -> {
  if (route.request().postData().contains("my-string"))
    route.fulfill(new Route.FulfillOptions().setBody("mocked-data"));
  else
    route.resume();
});
```

Маршруты страницы имеют приоритет над маршрутами контекста браузера (настроенными с помощью [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route)), когда запрос соответствует обоим обработчикам.

Чтобы удалить маршрут с его обработчиком, вы можете использовать [Page.unroute()](/api/class-page.mdx#page-unroute).

:::note

Включение маршрутизации отключает http-кэш.
:::

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-url"/><a href="#page-route-option-url" class="list-anchor">#</a>
  
  Шаблон glob, регулярное выражение или предикат, который получает [URL] для сопоставления при маршрутизации. Если в параметрах контекста задан [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) и переданный URL является строкой, не начинающейся с `*`, он будет разрешён с помощью конструктора [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `handler` [Consumer]&lt;[Route]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-handler"/><a href="#page-route-option-handler" class="list-anchor">#</a>
  
  функция обработчика для маршрутизации запроса.
- `options` `Page.RouteOptions` *(optional)*
  - `setTimes` [int] *(optional)* <font size="2">Added in: v1.15</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-option-times"/><a href="#page-route-option-times" class="list-anchor">#</a>
    
    Как часто маршрут должен использоваться. По умолчанию он будет использоваться каждый раз.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-return"/><a href="#page-route-return" class="list-anchor">#</a>

---

### routeFromHAR {#page-route-from-har}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.23</font><x-search>page.routeFromHAR</x-search>

Если указано, сетевые запросы, сделанные на странице, будут обслуживаться из HAR-файла. Подробнее читайте в разделе [Replaying from HAR](../mock.mdx#replaying-from-har).

Playwright не будет обслуживать запросы, перехваченные Service Worker, из HAR-файла. См. [эту](https://github.com/microsoft/playwright/issues/1090) проблему. Мы рекомендуем отключать Service Workers при использовании перехвата запросов, установив [setServiceWorkers](/api/class-browser.mdx#browser-new-context-option-service-workers) в `'block'`.

**Использование**

```java
Page.routeFromHAR(har);
Page.routeFromHAR(har, options);
```

**Аргументы**
- `har` [Path]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-har"/><a href="#page-route-from-har-option-har" class="list-anchor">#</a>
  
  Путь к [HAR](http://www.softwareishard.com/blog/har-12-spec) файлу с предварительно записанными сетевыми данными. Если `path` является относительным путем, то он разрешается относительно текущей рабочей директории.
- `options` `Page.RouteFromHAROptions` *(опционально)*
  - `setNotFound` `enum HarNotFound { ABORT, FALLBACK }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-not-found"/><a href="#page-route-from-har-option-not-found" class="list-anchor">#</a>
    * Если установлено в 'abort', любой запрос, не найденный в HAR-файле, будет прерван.
    * Если установлено в 'fallback', отсутствующие запросы будут отправлены в сеть.
    
    По умолчанию `abort`.
  - `setUpdate` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update"/><a href="#page-route-from-har-option-update" class="list-anchor">#</a>
    
    Если указано, обновляет данный HAR с фактической сетевой информацией вместо обслуживания из файла. Файл записывается на диск, когда [BrowserContext.close()](/api/class-browsercontext.mdx#browser-context-close) вызывается.
  - `setUpdateContent` `enum RouteFromHarUpdateContentPolicy { EMBED, ATTACH }` *(опционально)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-content"/><a href="#page-route-from-har-option-update-content" class="list-anchor">#</a>
    
    Опциональная настройка для управления содержимым ресурсов. Если указано `attach`, ресурсы сохраняются как отдельные файлы или записи в ZIP-архиве. Если указано `embed`, содержимое хранится в HAR-файле.
  - `setUpdateMode` `enum HarMode { FULL, MINIMAL }` *(опционально)* <font size="2">Added in: v1.32</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-update-mode"/><a href="#page-route-from-har-option-update-mode" class="list-anchor">#</a>
    
    Когда установлено в `minimal`, записывается только информация, необходимая для маршрутизации из HAR. Это исключает размеры, время, страницу, куки, безопасность и другие типы информации HAR, которые не используются при воспроизведении из HAR. По умолчанию `minimal`.
  - `setUrl` [String] | [Pattern] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-option-url"/><a href="#page-route-from-har-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат для сопоставления URL запроса. Только запросы с URL, соответствующим шаблону, будут обслуживаться из HAR-файла. Если не указано, все запросы обслуживаются из HAR-файла.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-from-har-return"/><a href="#page-route-from-har-return" class="list-anchor">#</a>

---

### routeWebSocket {#page-route-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.48</font><x-search>page.routeWebSocket</x-search>

Этот метод позволяет изменять WebSocket-соединения, которые создаются страницей.

Обратите внимание, что только `WebSocket`, созданные после вызова этого метода, будут маршрутизированы. Рекомендуется вызывать этот метод перед навигацией по странице.

**Использование**

Ниже приведен пример простого мока, который отвечает на одно сообщение. Подробнее и примеры смотрите в [WebSocketRoute].

```java
page.routeWebSocket("/ws", ws -> {
  ws.onMessage(frame -> {
    if ("request".equals(frame.text()))
      ws.send("response");
  });
});
```

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-url"/><a href="#page-route-web-socket-option-url" class="list-anchor">#</a>
  
  Только WebSocket с URL, соответствующим этому шаблону, будут маршрутизированы. Строковый шаблон может быть относительным к [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) контекстной опции.
- `handler` [Consumer]&lt;[WebSocketRoute]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-option-handler"/><a href="#page-route-web-socket-option-handler" class="list-anchor">#</a>
  
  Функция-обработчик для маршрутизации WebSocket.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-route-web-socket-return"/><a href="#page-route-web-socket-return" class="list-anchor">#</a>

---

### screenshot {#page-screenshot}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.screenshot</x-search>

Возвращает буфер с захваченным скриншотом.

**Использование**

```java
Page.screenshot();
Page.screenshot(options);
```

**Аргументы**
- `options` `Page.ScreenshotOptions` *(опционально)*
  - `setAnimations` `enum ScreenshotAnimations { DISABLED, ALLOW }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-animations"/><a href="#page-screenshot-option-animations" class="list-anchor">#</a>
    
    Когда установлено в `"disabled"`, останавливает CSS-анимации, CSS-переходы и Web-анимации. Анимации получают разное обращение в зависимости от их продолжительности:
    * конечные анимации быстро перематываются до завершения, так что они вызовут событие `transitionend`.
    * бесконечные анимации отменяются до начального состояния, а затем воспроизводятся после скриншота.
    
    По умолчанию `"allow"`, что оставляет анимации нетронутыми.
  - `setCaret` `enum ScreenshotCaret { HIDE, INITIAL }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-caret"/><a href="#page-screenshot-option-caret" class="list-anchor">#</a>
    
    Когда установлено в `"hide"`, скриншот скроет текстовый курсор. Когда установлено в `"initial"`, поведение текстового курсора не изменится. По умолчанию `"hide"`.
  - `setClip` Clip *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-clip"/><a href="#page-screenshot-option-clip" class="list-anchor">#</a>
    - `setX` [double]
      
      x-координата верхнего левого угла области обрезки
    - `setY` [double]
      
      y-координата верхнего левого угла области обрезки
    - `setWidth` [double]
      
      ширина области обрезки
    - `setHeight` [double]
      
      высота области обрезки
    
    Объект, который указывает обрезку результирующего изображения.
  - `setFullPage` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-full-page"/><a href="#page-screenshot-option-full-page" class="list-anchor">#</a>
    
    Если true, делает скриншот всей прокручиваемой страницы, вместо текущего видимого окна. По умолчанию `false`.
  - `setMask` [List]&lt;[Locator]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask"/><a href="#page-screenshot-option-mask" class="list-anchor">#</a>
    
    Укажите локаторы, которые должны быть замаскированы при создании скриншота. Замаскированные элементы будут перекрыты розовым прямоугольником `#FF00FF` (настраивается с помощью [setMaskColor](/api/class-page.mdx#page-screenshot-option-mask-color)), который полностью покрывает их ограничивающий прямоугольник. Маска также применяется к невидимым элементам, см. [Matching only visible elements](../locators.mdx#matching-only-visible-elements) для отключения этого.
  - `setMaskColor` [String] *(опционально)* <font size="2">Added in: v1.35</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-mask-color"/><a href="#page-screenshot-option-mask-color" class="list-anchor">#</a>
    
    Укажите цвет перекрывающего прямоугольника для замаскированных элементов в [CSS color format](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value). Цвет по умолчанию розовый `#FF00FF`.
  - `setOmitBackground` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-omit-background"/><a href="#page-screenshot-option-omit-background" class="list-anchor">#</a>
    
    Скрывает белый фон по умолчанию и позволяет делать скриншоты с прозрачностью. Не применимо к изображениям `jpeg`. По умолчанию `false`.
  - `setPath` [Path] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-path"/><a href="#page-screenshot-option-path" class="list-anchor">#</a>
    
    Путь к файлу для сохранения изображения. Тип скриншота будет определен по расширению файла. Если [setPath](/api/class-page.mdx#page-screenshot-option-path) является относительным путем, то он разрешается относительно текущей рабочей директории. Если путь не указан, изображение не будет сохранено на диск.
  - `setQuality` [int] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-quality"/><a href="#page-screenshot-option-quality" class="list-anchor">#</a>
    
    Качество изображения, от 0 до 100. Не применимо к изображениям `png`.
  - `setScale` `enum ScreenshotScale { CSS, DEVICE }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-scale"/><a href="#page-screenshot-option-scale" class="list-anchor">#</a>
    
    Когда установлено в `"css"`, скриншот будет иметь один пиксель на каждый css пиксель на странице. Для устройств с высоким разрешением это позволит сохранить скриншоты небольшими. Использование опции `"device"` создаст один пиксель на каждый пиксель устройства, так что скриншоты устройств с высоким разрешением будут в два раза больше или даже больше.
    
    По умолчанию `"device"`.
  - `setStyle` [String] *(опционально)* <font size="2">Added in: v1.41</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-style"/><a href="#page-screenshot-option-style" class="list-anchor">#</a>
    
    Текст стиля, который будет применен при создании скриншота. Здесь вы можете скрыть динамические элементы, сделать элементы невидимыми или изменить их свойства, чтобы помочь вам создавать повторяемые скриншоты. Этот стиль проникает в Shadow DOM и применяется к внутренним фреймам.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-timeout"/><a href="#page-screenshot-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setType` `enum ScreenshotType { PNG, JPEG }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-option-type"/><a href="#page-screenshot-option-type" class="list-anchor">#</a>
    
    Укажите тип скриншота, по умолчанию `png`.

**Возвращает**
- [byte&#91;&#93;]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-screenshot-return"/><a href="#page-screenshot-return" class="list-anchor">#</a>

---

### setContent {#page-set-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setContent</x-search>

Этот метод внутренне вызывает [document.write()](https://developer.mozilla.org/en-US/docs/Web/API/Document/write), наследуя все его специфические характеристики и поведение.

**Использование**

```java
Page.setContent(html);
Page.setContent(html, options);
```

**Аргументы**
- `html` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-html"/><a href="#page-set-content-option-html" class="list-anchor">#</a>
  
  HTML-разметка для назначения странице.
- `options` `Page.SetContentOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-timeout"/><a href="#page-set-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-option-wait-until"/><a href="#page-set-content-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-content-return"/><a href="#page-set-content-return" class="list-anchor">#</a>

---

### setDefaultNavigationTimeout {#page-set-default-navigation-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setDefaultNavigationTimeout</x-search>

Эта настройка изменит максимальное время навигации по умолчанию для следующих методов и связанных с ними ярлыков:
* [Page.goBack()](/api/class-page.mdx#page-go-back)
* [Page.goForward()](/api/class-page.mdx#page-go-forward)
* [Page.navigate()](/api/class-page.mdx#page-goto)
* [Page.reload()](/api/class-page.mdx#page-reload)
* [Page.setContent()](/api/class-page.mdx#page-set-content)
* [Page.waitForNavigation()](/api/class-page.mdx#page-wait-for-navigation)
* [Page.waitForURL()](/api/class-page.mdx#page-wait-for-url)

:::note

[Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) и [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout).
:::

**Использование**

```java
Page.setDefaultNavigationTimeout(timeout);
```

**Аргументы**
- `timeout` [double]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-navigation-timeout-option-timeout"/><a href="#page-set-default-navigation-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время навигации в миллисекундах

---

### setDefaultTimeout {#page-set-default-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setDefaultTimeout</x-search>

Эта настройка изменит максимальное время по умолчанию для всех методов, принимающих опцию [timeout](/api/class-page.mdx#page-set-default-timeout-option-timeout).

:::note

[Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) имеет приоритет над [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
:::

**Использование**

```java
Page.setDefaultTimeout(timeout);
```

**Аргументы**
- `timeout` [double]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-default-timeout-option-timeout"/><a href="#page-set-default-timeout-option-timeout" class="list-anchor">#</a>
  
  Максимальное время в миллисекундах. Передайте `0`, чтобы отключить тайм-аут.

---

### setExtraHTTPHeaders {#page-set-extra-http-headers}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setExtraHTTPHeaders</x-search>

Дополнительные HTTP-заголовки будут отправлены с каждым запросом, инициированным страницей.

:::note

[Page.setExtraHTTPHeaders()](/api/class-page.mdx#page-set-extra-http-headers) не гарантирует порядок заголовков в исходящих запросах.
:::

**Использование**

```java
Page.setExtraHTTPHeaders(headers);
```

**Аргументы**
- `headers` [Map]&lt;[String], [String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-option-headers"/><a href="#page-set-extra-http-headers-option-headers" class="list-anchor">#</a>
  
  Объект, содержащий дополнительные HTTP-заголовки, которые будут отправлены с каждым запросом. Все значения заголовков должны быть строками.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-extra-http-headers-return"/><a href="#page-set-extra-http-headers-return" class="list-anchor">#</a>

---

### setViewportSize {#page-set-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setViewportSize</x-search>

В случае нескольких страниц в одном браузере каждая страница может иметь свой собственный размер области просмотра. Однако [Browser.newContext()](/api/class-browser.mdx#browser-new-context) позволяет установить размер области просмотра (и многое другое) для всех страниц в контексте сразу.

[Page.setViewportSize()](/api/class-page.mdx#page-set-viewport-size) изменит размер страницы. Многие веб-сайты не ожидают, что телефоны изменят размер, поэтому вы должны установить размер области просмотра перед навигацией по странице. [Page.setViewportSize()](/api/class-page.mdx#page-set-viewport-size) также сбросит размер `screen`, используйте [Browser.newContext()](/api/class-browser.mdx#browser-new-context) с параметрами `screen` и `viewport`, если вам нужно лучше контролировать эти свойства.

**Использование**

```java
Page page = browser.newPage();
page.setViewportSize(640, 480);
page.navigate("https://example.com");
```

**Аргументы**
- `width` [int] <font size="2">Added in: v1.10</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-option-width"/><a href="#page-set-viewport-size-option-width" class="list-anchor">#</a>
  
  Ширина страницы в пикселях.
- `height` [int] <font size="2">Added in: v1.10</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-option-height"/><a href="#page-set-viewport-size-option-height" class="list-anchor">#</a>
  
  Высота страницы в пикселях.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-viewport-size-return"/><a href="#page-set-viewport-size-return" class="list-anchor">#</a>

---

### title {#page-title}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.title</x-search>

Возвращает заголовок страницы.

**Использование**

```java
Page.title();
```

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-title-return"/><a href="#page-title-return" class="list-anchor">#</a>

---

### unroute {#page-unroute}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.unroute</x-search>

Удаляет маршрут, созданный с помощью [Page.route()](/api/class-page.mdx#page-route). Когда [handler](/api/class-page.mdx#page-unroute-option-handler) не указан, удаляет все маршруты для [url](/api/class-page.mdx#page-unroute-option-url).

**Использование**

```java
Page.unroute(url);
Page.unroute(url, handler);
```

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-url"/><a href="#page-unroute-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для сопоставления при маршрутизации.
- `handler` [Consumer]&lt;[Route]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-option-handler"/><a href="#page-unroute-option-handler" class="list-anchor">#</a>
  
  Опциональная функция-обработчик для маршрутизации запроса.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-return"/><a href="#page-unroute-return" class="list-anchor">#</a>

---

### unrouteAll {#page-unroute-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.41</font><x-search>page.unrouteAll</x-search>

Удаляет все маршруты, созданные с помощью [Page.route()](/api/class-page.mdx#page-route) и [Page.routeFromHAR()](/api/class-page.mdx#page-route-from-har).

**Использование**

```java
Page.unrouteAll();
```

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-unroute-all-return"/><a href="#page-unroute-all-return" class="list-anchor">#</a>

---

### url {#page-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.url</x-search>

**Использование**

```java
Page.url();
```

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-url-return"/><a href="#page-url-return" class="list-anchor">#</a>

---

### video {#page-video}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.video</x-search>

Объект видео, связанный с этой страницей.

**Использование**

```java
Page.video();
```

**Возвращает**
- [null] | [Video]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-video-return"/><a href="#page-video-return" class="list-anchor">#</a>

---

### viewportSize {#page-viewport-size}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.viewportSize</x-search>

**Использование**

```java
Page.viewportSize();
```

**Возвращает**
- [null] | ViewportSize<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-viewport-size-return"/><a href="#page-viewport-size-return" class="list-anchor">#</a>
  - `width` [int]
    
    ширина страницы в пикселях.
  - `height` [int]
    
    высота страницы в пикселях.

---

### waitForClose {#page-wait-for-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>page.waitForClose</x-search>

Выполняет действие и ждет, пока страница не закроется.

**Использование**

```java
Page.waitForClose(callback);
Page.waitForClose(callback, options);
```

**Аргументы**
- `options` `Page.WaitForCloseOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)* <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-close-option-timeout"/><a href="#page-wait-for-close-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-close-option-callback"/><a href="#page-wait-for-close-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-close-return"/><a href="#page-wait-for-close-return" class="list-anchor">#</a>

---

### waitForCondition {#page-wait-for-condition}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.32</font><x-search>page.waitForCondition</x-search>

Метод будет блокировать выполнение, пока условие не вернет true. Все события Playwright будут отправлены, пока метод ожидает выполнения условия.

**Использование**

Используйте метод для ожидания условия, зависящего от событий страницы:

```java
List<String> messages = new ArrayList<>();
page.onConsoleMessage(m -> messages.add(m.text()));
page.getByText("Submit button").click();
page.waitForCondition(() -> messages.size() > 3);
```

**Аргументы**
- `condition` [BooleanSupplier]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-condition-option-condition"/><a href="#page-wait-for-condition-option-condition" class="list-anchor">#</a>
  
  Условие для ожидания.
- `options` `Page.WaitForConditionOptions` *(опционально)*
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-condition-option-timeout"/><a href="#page-wait-for-condition-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-condition-return"/><a href="#page-wait-for-condition-return" class="list-anchor">#</a>

---

### waitForConsoleMessage {#page-wait-for-console-message}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForConsoleMessage</x-search>

Выполняет действие и ждет, пока [ConsoleMessage] не будет зарегистрировано на странице. Если предикат предоставлен, он передает значение [ConsoleMessage] в функцию `predicate` и ждет, пока `predicate(message)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие [Page.onConsoleMessage(handler)](/api/class-page.mdx#page-event-console) будет вызвано.

**Использование**

```java
Page.waitForConsoleMessage(callback);
Page.waitForConsoleMessage(callback, options);
```

**Аргументы**
- `options` `Page.WaitForConsoleMessageOptions` *(опционально)*
  - `setPredicate` [Predicate]&lt;[ConsoleMessage]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-predicate"/><a href="#page-wait-for-console-message-option-predicate" class="list-anchor">#</a>
    
    Получает объект [ConsoleMessage] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-timeout"/><a href="#page-wait-for-console-message-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-option-callback"/><a href="#page-wait-for-console-message-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [ConsoleMessage]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-console-message-return"/><a href="#page-wait-for-console-message-return" class="list-anchor">#</a>

---

### waitForDownload {#page-wait-for-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForDownload</x-search>

Выполняет действие и ждет, пока не начнется новая [Download]. Если предикат предоставлен, он передает значение [Download] в функцию `predicate` и ждет, пока `predicate(download)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до того, как событие загрузки будет вызвано.

**Использование**

```java
Page.waitForDownload(callback);
Page.waitForDownload(callback, options);
```

**Аргументы**
- `options` `Page.WaitForDownloadOptions` *(опционально)*
  - `setPredicate` [Predicate]&lt;[Download]&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-predicate"/><a href="#page-wait-for-download-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Download] и разрешается в истинное значение, когда ожидание должно завершиться.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-timeout"/><a href="#page-wait-for-download-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-option-callback"/><a href="#page-wait-for-download-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [Download]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-download-return"/><a href="#page-wait-for-download-return" class="list-anchor">#</a>

---

### waitForFileChooser {#page-wait-for-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForFileChooser</x-search>

Выполняет действие и ожидает создания нового [FileChooser]. Если предоставлен предикат, он передает значение [FileChooser] в функцию `predicate` и ожидает, пока `predicate(fileChooser)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до открытия выбора файла.

**Использование**

```java
Page.waitForFileChooser(callback);
Page.waitForFileChooser(callback, options);
```

**Аргументы**
- `options` `Page.WaitForFileChooserOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[FileChooser]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-predicate"/><a href="#page-wait-for-file-chooser-option-predicate" class="list-anchor">#</a>
    
    Получает объект [FileChooser] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-timeout"/><a href="#page-wait-for-file-chooser-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-option-callback"/><a href="#page-wait-for-file-chooser-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [FileChooser]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-file-chooser-return"/><a href="#page-wait-for-file-chooser-return" class="list-anchor">#</a>

---

### waitForFunction {#page-wait-for-function}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForFunction</x-search>

Возвращает, когда [expression](/api/class-page.mdx#page-wait-for-function-option-expression) возвращает истинное значение. Разрешается в JSHandle истинного значения.

**Использование**

[Page.waitForFunction()](/api/class-page.mdx#page-wait-for-function) может быть использован для наблюдения за изменением размера области просмотра:

```java
import com.microsoft.playwright.*;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType webkit = playwright.webkit();
      Browser browser = webkit.launch();
      Page page = browser.newPage();
      page.setViewportSize(50,  50);
      page.waitForFunction("() => window.innerWidth < 100");
      browser.close();
    }
  }
}
```

Чтобы передать аргумент в предикат функции [Page.waitForFunction()](/api/class-page.mdx#page-wait-for-function):

```java
String selector = ".foo";
page.waitForFunction("selector => !!document.querySelector(selector)", selector);
```

**Аргументы**
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-expression"/><a href="#page-wait-for-function-option-expression" class="list-anchor">#</a>
  
  JavaScript выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-arg"/><a href="#page-wait-for-function-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-wait-for-function-option-expression).
- `options` `Page.WaitForFunctionOptions` *(optional)*
  - `setPollingInterval` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-polling-interval"/><a href="#page-wait-for-function-option-polling-interval" class="list-anchor">#</a>
    
    Если указано, то это интервал в миллисекундах, с которым функция будет выполняться. По умолчанию, если опция не указана, [expression](/api/class-page.mdx#page-wait-for-function-option-expression) выполняется в `requestAnimationFrame` обратном вызове.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-option-timeout"/><a href="#page-wait-for-function-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [JSHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-function-return"/><a href="#page-wait-for-function-return" class="list-anchor">#</a>

---

### waitForLoadState {#page-wait-for-load-state}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForLoadState</x-search>

Возвращает, когда достигнуто требуемое состояние загрузки.

Это разрешается, когда страница достигает требуемого состояния загрузки, по умолчанию `load`. Навигация должна быть завершена, когда вызывается этот метод. Если текущий документ уже достиг требуемого состояния, разрешается немедленно.

:::note

Большую часть времени этот метод не нужен, потому что Playwright [автоматически ожидает перед каждым действием](../actionability.mdx).
:::

**Использование**

```java
page.getByRole(AriaRole.BUTTON).click(); // Клик вызывает навигацию.
page.waitForLoadState(); // Обещание разрешается после события "load".
```

```java
Page popup = page.waitForPopup(() -> {
  page.getByRole(AriaRole.BUTTON).click(); // Клик вызывает всплывающее окно.
});
// Ожидание события "DOMContentLoaded"
popup.waitForLoadState(LoadState.DOMCONTENTLOADED);
System.out.println(popup.title()); // Всплывающее окно готово к использованию.
```

**Аргументы**
- `state` `enum LoadState { LOAD, DOMCONTENTLOADED, NETWORKIDLE }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-state"/><a href="#page-wait-for-load-state-option-state" class="list-anchor">#</a>
  
  Необязательное состояние загрузки для ожидания, по умолчанию `load`. Если состояние уже достигнуто при загрузке текущего документа, метод разрешается немедленно. Может быть одним из:
  * `'load'` - ожидание, пока не будет вызвано событие `load`.
  * `'domcontentloaded'` - ожидание, пока не будет вызвано событие `DOMContentLoaded`.
  * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** ожидание, пока не будет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
- `options` `Page.WaitForLoadStateOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-option-timeout"/><a href="#page-wait-for-load-state-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-load-state-return"/><a href="#page-wait-for-load-state-return" class="list-anchor">#</a>

---

### waitForPopup {#page-wait-for-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForPopup</x-search>

Выполняет действие и ожидает всплывающее окно [Page]. Если предоставлен предикат, он передает значение [Popup] в функцию `predicate` и ожидает, пока `predicate(page)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до вызова события всплывающего окна.

**Использование**

```java
Page.waitForPopup(callback);
Page.waitForPopup(callback, options);
```

**Аргументы**
- `options` `Page.WaitForPopupOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[Page]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-predicate"/><a href="#page-wait-for-popup-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Page] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-timeout"/><a href="#page-wait-for-popup-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-option-callback"/><a href="#page-wait-for-popup-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [Page]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-popup-return"/><a href="#page-wait-for-popup-return" class="list-anchor">#</a>

---

### waitForRequest {#page-wait-for-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForRequest</x-search>

Ожидает совпадения запроса и возвращает его. См. [ожидание события](../events.mdx#waiting-for-event) для получения более подробной информации о событиях.

**Использование**

```java
// Ожидает следующего запроса с указанным URL
Request request = page.waitForRequest("https://example.com/resource", () -> {
  // Вызывает запрос
  page.getByText("trigger request").click();
});

// Ожидает следующего запроса, соответствующего некоторым условиям
Request request = page.waitForRequest(request -> "https://example.com".equals(request.url()) && "GET".equals(request.method()), () -> {
  // Вызывает запрос
  page.getByText("trigger request").click();
});
```

**Аргументы**
- `urlOrPredicate` [String] | [Pattern] | [Predicate]&lt;[Request]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-url-or-predicate"/><a href="#page-wait-for-request-option-url-or-predicate" class="list-anchor">#</a>
  
  URL запроса в виде строки, регулярного выражения или предиката, получающего объект [Request]. Когда [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `Page.WaitForRequestOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-timeout"/><a href="#page-wait-for-request-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя метод [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
- `callback` [Runnable] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-option-callback"/><a href="#page-wait-for-request-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [Request]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-return"/><a href="#page-wait-for-request-return" class="list-anchor">#</a>

---

### waitForRequestFinished {#page-wait-for-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.12</font><x-search>page.waitForRequestFinished</x-search>

Выполняет действие и ожидает завершения загрузки [Request]. Если предоставлен предикат, он передает значение [Request] в функцию `predicate` и ожидает, пока `predicate(request)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до вызова события [Page.onRequestFinished(handler)](/api/class-page.mdx#page-event-request-finished).

**Использование**

```java
Page.waitForRequestFinished(callback);
Page.waitForRequestFinished(callback, options);
```

**Аргументы**
- `options` `Page.WaitForRequestFinishedOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[Request]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-predicate"/><a href="#page-wait-for-request-finished-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Request] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-timeout"/><a href="#page-wait-for-request-finished-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-option-callback"/><a href="#page-wait-for-request-finished-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [Request]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-request-finished-return"/><a href="#page-wait-for-request-finished-return" class="list-anchor">#</a>

---

### waitForResponse {#page-wait-for-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForResponse</x-search>

Возвращает совпавший ответ. См. [ожидание события](../events.mdx#waiting-for-event) для получения более подробной информации о событиях.

**Использование**

```java
// Ожидает следующего ответа с указанным URL
Response response = page.waitForResponse("https://example.com/resource", () -> {
  // Вызывает ответ
  page.getByText("trigger response").click();
});

// Ожидает следующего ответа, соответствующего некоторым условиям
Response response = page.waitForResponse(response -> "https://example.com".equals(response.url()) && response.status() == 200 && "GET".equals(response.request().method()), () -> {
  // Вызывает ответ
  page.getByText("trigger response").click();
});
```

**Аргументы**
- `urlOrPredicate` [String] | [Pattern] | [Predicate]&lt;[Response]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-url-or-predicate"/><a href="#page-wait-for-response-option-url-or-predicate" class="list-anchor">#</a>
  
  URL запроса в виде строки, регулярного выражения или предиката, получающего объект [Response]. Когда [setBaseURL](/api/class-browser.mdx#browser-new-context-option-base-url) был предоставлен через параметры контекста и переданный URL является путем, он объединяется через конструктор [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).
- `options` `Page.WaitForResponseOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-timeout"/><a href="#page-wait-for-response-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
- `callback` [Runnable] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-option-callback"/><a href="#page-wait-for-response-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-response-return"/><a href="#page-wait-for-response-return" class="list-anchor">#</a>

---

### waitForURL {#page-wait-for-url}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.11</font><x-search>page.waitForURL</x-search>

Ожидает, пока основной фрейм перейдет на указанный URL.

**Использование**

```java
page.click("a.delayed-navigation"); // Клик по ссылке косвенно вызывает навигацию
page.waitForURL("**/target.html");
```

**Аргументы**
- `url` [String] | [Pattern] | [Predicate]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-url"/><a href="#page-wait-for-url-option-url" class="list-anchor">#</a>
  
  Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для совпадения при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
- `options` `Page.WaitForURLOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-timeout"/><a href="#page-wait-for-url-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-option-wait-until"/><a href="#page-wait-for-url-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда вызвано событие `DOMContentLoaded`.
    * `'load'` - считать операцию завершенной, когда вызвано событие `load`.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда получен сетевой ответ и документ начал загружаться.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-url-return"/><a href="#page-wait-for-url-return" class="list-anchor">#</a>

---

### waitForWebSocket {#page-wait-for-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForWebSocket</x-search>

Выполняет действие и ожидает новый [WebSocket]. Если предоставлен предикат, он передает значение [WebSocket] в функцию `predicate` и ожидает, пока `predicate(webSocket)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до вызова события WebSocket.

**Использование**

```java
Page.waitForWebSocket(callback);
Page.waitForWebSocket(callback, options);
```

**Аргументы**
- `options` `Page.WaitForWebSocketOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[WebSocket]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-predicate"/><a href="#page-wait-for-web-socket-option-predicate" class="list-anchor">#</a>
    
    Получает объект [WebSocket] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-timeout"/><a href="#page-wait-for-web-socket-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-option-callback"/><a href="#page-wait-for-web-socket-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [WebSocket]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-web-socket-return"/><a href="#page-wait-for-web-socket-return" class="list-anchor">#</a>

---

### waitForWorker {#page-wait-for-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.waitForWorker</x-search>

Выполняет действие и ожидает новый [Worker]. Если предоставлен предикат, он передает значение [Worker] в функцию `predicate` и ожидает, пока `predicate(worker)` не вернет истинное значение. Выдаст ошибку, если страница будет закрыта до вызова события worker.

**Использование**

```java
Page.waitForWorker(callback);
Page.waitForWorker(callback, options);
```

**Аргументы**
- `options` `Page.WaitForWorkerOptions` *(optional)*
  - `setPredicate` [Predicate]&lt;[Worker]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-predicate"/><a href="#page-wait-for-worker-option-predicate" class="list-anchor">#</a>
    
    Получает объект [Worker] и разрешает в истинное значение, когда ожидание должно разрешиться.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-timeout"/><a href="#page-wait-for-worker-option-timeout" class="list-anchor">#</a>
    
    Максимальное время ожидания в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout).
- `callback` [Runnable]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-option-callback"/><a href="#page-wait-for-worker-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, который выполняет действие, вызывающее событие.

**Возвращает**
- [Worker]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-worker-return"/><a href="#page-wait-for-worker-return" class="list-anchor">#</a>

---

### workers {#page-workers}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.workers</x-search>

Этот метод возвращает всех выделенных [WebWorkers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API), связанных со страницей.

:::note

Это не включает ServiceWorkers
:::

**Использование**

```java
Page.workers();
```

**Возвращает**
- [List]&lt;[Worker]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-workers-return"/><a href="#page-workers-return" class="list-anchor">#</a>

---

## Properties

### clock() {#page-clock}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.45</font><x-search>page.clock()</x-search>

Playwright имеет возможность имитировать часы и ход времени.

**Использование**

```java
Page.clock()
```

**Возвращает**
- [Clock]

---

### keyboard() {#page-keyboard}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.keyboard()</x-search>

**Использование**

```java
Page.keyboard()
```

**Возвращает**
- [Keyboard]

---

### mouse() {#page-mouse}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.mouse()</x-search>

**Использование**

```java
Page.mouse()
```

**Возвращает**
- [Mouse]

---

### request() {#page-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.16</font><x-search>page.request()</x-search>

Помощник для тестирования API, связанный с этой страницей. Этот метод возвращает тот же экземпляр, что и [BrowserContext.request()](/api/class-browsercontext.mdx#browser-context-request) в контексте страницы. См. [BrowserContext.request()](/api/class-browsercontext.mdx#browser-context-request) для получения более подробной информации.

**Использование**

```java
Page.request()
```

**Возвращает**
- [APIRequestContext]

---

### touchscreen() {#page-touchscreen}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.touchscreen()</x-search>

**Использование**

```java
Page.touchscreen()
```

**Возвращает**
- [Touchscreen]

---

## Events

### onClose(handler) {#page-event-close}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onClose(handler)</x-search>

Вызывается, когда страница закрывается.

**Использование**

```java
Page.onClose(handler)
```

**Event data**
- [Page]

---

### onConsoleMessage(handler) {#page-event-console}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onConsoleMessage(handler)</x-search>

Вызывается, когда JavaScript на странице вызывает один из методов консольного API, например, `console.log` или `console.dir`.

Аргументы, переданные в `console.log`, доступны в аргументе обработчика события [ConsoleMessage].

**Использование**

```java
page.onConsoleMessage(msg -> {
  for (int i = 0; i < msg.args().size(); ++i)
    System.out.println(i + ": " + msg.args().get(i).jsonValue());
});
page.evaluate("() => console.log('hello', 5, { foo: 'bar' })");
```

**Event data**
- [ConsoleMessage]

---

### onCrash(handler) {#page-event-crash}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onCrash(handler)</x-search>

Вызывается, когда страница падает. Страницы браузера могут падать, если они пытаются выделить слишком много памяти. Когда страница падает, текущие и последующие операции будут выдавать ошибку.

Наиболее распространенный способ справиться с падениями - поймать исключение:

```java
try {
  // Падение может произойти во время клика.
  page.click("button");
  // Или во время ожидания события.
  page.waitForPopup(() -> {});
} catch (PlaywrightException e) {
  // Когда страница падает, сообщение об исключении содержит "crash".
}
```

**Использование**

```java
Page.onCrash(handler)
```

**Event data**
- [Page]

---

### onDialog(handler) {#page-event-dialog}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onDialog(handler)</x-search>

Вызывается, когда появляется JavaScript-диалог, такой как `alert`, `prompt`, `confirm` или `beforeunload`. Слушатель **должен** либо [Dialog.accept()](/api/class-dialog.mdx#dialog-accept), либо [Dialog.dismiss()](/api/class-dialog.mdx#dialog-dismiss) диалог - в противном случае страница [заморозится](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking), ожидая диалога, и действия, такие как клик, никогда не завершатся.

**Использование**

```java
page.onDialog(dialog -> {
  dialog.accept();
});
```

:::note
Когда нет слушателей [Page.onDialog(handler)](/api/class-page.mdx#page-event-dialog) или [BrowserContext.onDialog(handler)](/api/class-browsercontext.mdx#browser-context-event-dialog), все диалоги автоматически отклоняются.
:::

**Данные события**
- [Dialog]

---

### onDOMContentLoaded(handler) {#page-event-dom-content-loaded}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onDOMContentLoaded(handler)</x-search>

Вызывается, когда JavaScript-событие [`DOMContentLoaded`](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded) отправляется.

**Использование**

```java
Page.onDOMContentLoaded(handler)
```

**Данные события**
- [Page]

---

### onDownload(handler) {#page-event-download}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onDownload(handler)</x-search>

Вызывается, когда начинается загрузка вложения. Пользователь может получить доступ к основным операциям с файлами на загруженном контенте через переданный экземпляр [Download].

**Использование**

```java
Page.onDownload(handler)
```

**Данные события**
- [Download]

---

### onFileChooser(handler) {#page-event-file-chooser}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onFileChooser(handler)</x-search>

Вызывается, когда предполагается появление выбора файла, например, после нажатия на `<input type=file>`. Playwright может ответить на это, установив файлы ввода с помощью [FileChooser.setFiles()](/api/class-filechooser.mdx#file-chooser-set-files), которые могут быть загружены после этого.

```java
page.onFileChooser(fileChooser -> {
  fileChooser.setFiles(Paths.get("/tmp/myfile.pdf"));
});
```

**Использование**

```java
Page.onFileChooser(handler)
```

**Данные события**
- [FileChooser]

---

### onFrameAttached(handler) {#page-event-frame-attached}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onFrameAttached(handler)</x-search>

Вызывается, когда фрейм присоединяется.

**Использование**

```java
Page.onFrameAttached(handler)
```

**Данные события**
- [Frame]

---

### onFrameDetached(handler) {#page-event-frame-detached}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onFrameDetached(handler)</x-search>

Вызывается, когда фрейм отсоединяется.

**Использование**

```java
Page.onFrameDetached(handler)
```

**Данные события**
- [Frame]

---

### onFrameNavigated(handler) {#page-event-frame-navigated}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onFrameNavigated(handler)</x-search>

Вызывается, когда фрейм переходит на новый URL.

**Использование**

```java
Page.onFrameNavigated(handler)
```

**Данные события**
- [Frame]

---

### onLoad(handler) {#page-event-load}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onLoad(handler)</x-search>

Вызывается, когда JavaScript-событие [`load`](https://developer.mozilla.org/en-US/docs/Web/Events/load) отправляется.

**Использование**

```java
Page.onLoad(handler)
```

**Данные события**
- [Page]

---

### onPageError(handler) {#page-event-page-error}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onPageError(handler)</x-search>

Вызывается, когда на странице происходит необработанное исключение.

```java
// Логировать все необработанные ошибки в терминал
page.onPageError(exception -> {
  System.out.println("Uncaught exception: " + exception);
});

// Перейти на страницу с исключением.
page.navigate("data:text/html,<script>throw new Error('Test')</script>");
```

**Использование**

```java
Page.onPageError(handler)
```

**Данные события**
- [String]

---

### onPopup(handler) {#page-event-popup}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onPopup(handler)</x-search>

Вызывается, когда страница открывает новую вкладку или окно. Это событие вызывается в дополнение к [BrowserContext.onPage(handler)](/api/class-browsercontext.mdx#browser-context-event-page), но только для всплывающих окон, относящихся к этой странице.

Самый ранний момент, когда страница доступна, это когда она перешла на начальный URL. Например, при открытии всплывающего окна с `window.open('http://example.com')`, это событие сработает, когда сетевой запрос к "http://example.com" будет выполнен и его ответ начнет загружаться во всплывающем окне. Если вы хотите маршрутизировать/слушать этот сетевой запрос, используйте [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route) и [BrowserContext.onRequest(handler)](/api/class-browsercontext.mdx#browser-context-event-request) соответственно вместо аналогичных методов на [Page].

```java
Page popup = page.waitForPopup(() -> {
  page.getByText("open the popup").click();
});
System.out.println(popup.evaluate("location.href"));
```

:::note
Используйте [Page.waitForLoadState()](/api/class-page.mdx#page-wait-for-load-state), чтобы дождаться, пока страница достигнет определенного состояния (в большинстве случаев это не потребуется).
:::

**Использование**

```java
Page.onPopup(handler)
```

**Данные события**
- [Page]

---

### onRequest(handler) {#page-event-request}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onRequest(handler)</x-search>

Вызывается, когда страница выполняет запрос. Объект [request] доступен только для чтения. Чтобы перехватывать и изменять запросы, смотрите [Page.route()](/api/class-page.mdx#page-route) или [BrowserContext.route()](/api/class-browsercontext.mdx#browser-context-route).

**Использование**

```java
Page.onRequest(handler)
```

**Данные события**
- [Request]

---

### onRequestFailed(handler) {#page-event-request-failed}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onRequestFailed(handler)</x-search>

Вызывается, когда запрос не удается, например, из-за истечения времени ожидания.

```java
page.onRequestFailed(request -> {
  System.out.println(request.url() + " " + request.failure());
});
```

:::note
Ответы с ошибками HTTP, такие как 404 или 503, все еще считаются успешными ответами с точки зрения HTTP, поэтому запрос завершится событием [Page.onRequestFinished(handler)](/api/class-page.mdx#page-event-request-finished), а не [Page.onRequestFailed(handler)](/api/class-page.mdx#page-event-request-failed). Запрос будет считаться неудачным только в том случае, если клиент не может получить HTTP-ответ от сервера, например, из-за сетевой ошибки net::ERR_FAILED.
:::

**Использование**

```java
Page.onRequestFailed(handler)
```

**Данные события**
- [Request]

---

### onRequestFinished(handler) {#page-event-request-finished}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onRequestFinished(handler)</x-search>

Вызывается, когда запрос успешно завершается после загрузки тела ответа. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```java
Page.onRequestFinished(handler)
```

**Данные события**
- [Request]

---

### onResponse(handler) {#page-event-response}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onResponse(handler)</x-search>

Вызывается, когда [response] статус и заголовки получены для запроса. Для успешного ответа последовательность событий: `request`, `response` и `requestfinished`.

**Использование**

```java
Page.onResponse(handler)
```

**Данные события**
- [Response]

---

### onWebSocket(handler) {#page-event-web-socket}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.onWebSocket(handler)</x-search>

Вызывается, когда отправляется запрос [WebSocket].

**Использование**

```java
Page.onWebSocket(handler)
```

**Данные события**
- [WebSocket]

---

### onWorker(handler) {#page-event-worker}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.onWorker(handler)</x-search>

Вызывается, когда страница порождает выделенный [WebWorker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API).

**Использование**

```java
Page.onWorker(handler)
```

**Данные события**
- [Worker]

---

## Устарело

### check {#page-check}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.check</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.check()](/api/class-locator.mdx#locator-check) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод отмечает элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-check-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже отмечен, этот метод возвращается немедленно.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [setForce](/api/class-page.mdx#page-check-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы кликнуть в центр элемента.
1. Убедитесь, что элемент теперь отмечен. Если нет, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-check-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
Page.check(selector);
Page.check(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-selector"/><a href="#page-check-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `Page.CheckOptions` *(опционально)*
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-force"/><a href="#page-check-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-no-wait-after"/><a href="#page-check-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setPosition` Position *(опционально)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-position"/><a href="#page-check-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-strict"/><a href="#page-check-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-timeout"/><a href="#page-check-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-option-trial"/><a href="#page-check-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-check-return"/><a href="#page-check-return" class="list-anchor">#</a>

---

### click {#page-click}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.click</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.click()](/api/class-locator.mdx#locator-click) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод кликает по элементу, соответствующему [selector](/api/class-page.mdx#page-click-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-click-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [setForce](/api/class-page.mdx#page-click-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы кликнуть в центр элемента или в указанную [setPosition](/api/class-page.mdx#page-click-option-position).
1. Подождите, пока инициированные навигации либо не завершатся успешно, либо не завершатся с ошибкой, если только не установлена опция [setNoWaitAfter](/api/class-page.mdx#page-click-option-no-wait-after).

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-click-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
Page.click(selector);
Page.click(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-selector"/><a href="#page-click-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `Page.ClickOptions` *(опционально)*
  - `setButton` `enum MouseButton { LEFT, RIGHT, MIDDLE }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-button"/><a href="#page-click-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `setClickCount` [int] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-click-count"/><a href="#page-click-option-click-count" class="list-anchor">#</a>
    
    по умолчанию 1. См. [UIEvent.detail].
  - `setDelay` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-delay"/><a href="#page-click-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-force"/><a href="#page-click-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-modifiers"/><a href="#page-click-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-no-wait-after"/><a href="#page-click-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция по умолчанию будет `true` в будущем.
    :::
    
    
    Действия, инициирующие навигации, ожидают, пока эти навигации не произойдут и страницы не начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится эта опция только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `setPosition` Position *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-position"/><a href="#page-click-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-strict"/><a href="#page-click-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-timeout"/><a href="#page-click-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-option-trial"/><a href="#page-click-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-click-return"/><a href="#page-click-return" class="list-anchor">#</a>

---

### dblclick {#page-dblclick}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.dblclick</x-search>

:::warning[Не рекомендуется]

Используйте основанный на локаторах [Locator.dblclick()](/api/class-locator.mdx#locator-dblclick) вместо этого. Подробнее о [локаторах](../locators.mdx).

:::

Этот метод двойного клика по элементу, соответствующему [selector](/api/class-page.mdx#page-dblclick-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-dblclick-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если только не установлена опция [setForce](/api/class-page.mdx#page-dblclick-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы дважды кликнуть в центр элемента или в указанную [setPosition](/api/class-page.mdx#page-dblclick-option-position).

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-dblclick-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

`page.dblclick()` отправляет два события `click` и одно событие `dblclick`.
:::

**Использование**

```java
Page.dblclick(selector);
Page.dblclick(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-selector"/><a href="#page-dblclick-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если есть несколько элементов, удовлетворяющих селектору, будет использован первый.
- `options` `Page.DblclickOptions` *(опционально)*
  - `setButton` `enum MouseButton { LEFT, RIGHT, MIDDLE }` *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-button"/><a href="#page-dblclick-option-button" class="list-anchor">#</a>
    
    По умолчанию `left`.
  - `setDelay` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-delay"/><a href="#page-dblclick-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `mousedown` и `mouseup` в миллисекундах. По умолчанию 0.
  - `setForce` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-force"/><a href="#page-dblclick-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-modifiers"/><a href="#page-dblclick-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-no-wait-after"/><a href="#page-dblclick-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Устарело]
    Эта опция не имеет эффекта.
    :::
    
    
    Эта опция не имеет эффекта.
  - `setPosition` Position *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-position"/><a href="#page-dblclick-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(опционально)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-strict"/><a href="#page-dblclick-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(опционально)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-timeout"/><a href="#page-dblclick-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(опционально)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-option-trial"/><a href="#page-dblclick-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dblclick-return"/><a href="#page-dblclick-return" class="list-anchor">#</a>

---

### dispatchEvent {#page-dispatch-event}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.dispatchEvent</x-search>

:::warning[Discouraged]

Use locator-based [Locator.dispatchEvent()](/api/class-locator.mdx#locator-dispatch-event) instead. Read more about [locators](../locators.mdx).

:::


Пример ниже отправляет событие `click` на элемент. Независимо от состояния видимости элемента, `click` отправляется. Это эквивалентно вызову [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

**Использование**

```java
page.dispatchEvent("button#submit", "click");
```

Внутри создается экземпляр события на основе указанного [type](/api/class-page.mdx#page-dispatch-event-option-type), инициализируется с помощью свойств [eventInit](/api/class-page.mdx#page-dispatch-event-option-event-init) и отправляется на элемент. События по умолчанию `composed`, `cancelable` и всплывают.

Поскольку [eventInit](/api/class-page.mdx#page-dispatch-event-option-event-init) специфичен для события, пожалуйста, обратитесь к документации по событиям для списков начальных свойств:
* [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent)
* [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent)
* [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
* [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)
* [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
* [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
* [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
* [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
* [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
* [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent)

Вы также можете указать `JSHandle` в качестве значения свойства, если хотите, чтобы живые объекты передавались в событие:

```java
// Обратите внимание, что вы можете создать DataTransfer только в Chromium и Firefox
JSHandle dataTransfer = page.evaluateHandle("() => new DataTransfer()");
Map<String, Object> arg = new HashMap<>();
arg.put("dataTransfer", dataTransfer);
page.dispatchEvent("#source", "dragstart", arg);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-selector"/><a href="#page-dispatch-event-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `type` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-type"/><a href="#page-dispatch-event-option-type" class="list-anchor">#</a>
  
  Тип DOM события: `"click"`, `"dragstart"`, и т.д.
- `eventInit` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-event-init"/><a href="#page-dispatch-event-option-event-init" class="list-anchor">#</a>
  
  Необязательные свойства инициализации, специфичные для события.
- `options` `Page.DispatchEventOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-strict"/><a href="#page-dispatch-event-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-option-timeout"/><a href="#page-dispatch-event-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-dispatch-event-return"/><a href="#page-dispatch-event-return" class="list-anchor">#</a>

---

### evalOnSelector {#page-eval-on-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.evalOnSelector</x-search>

:::warning[Discouraged]

This method does not wait for the element to pass actionability checks and therefore can lead to the flaky tests. Use [Locator.evaluate()](/api/class-locator.mdx#locator-evaluate), other [Locator] helper methods or web-first assertions instead.

:::


Метод находит элемент, соответствующий указанному селектору на странице, и передает его в качестве первого аргумента в [expression](/api/class-page.mdx#page-eval-on-selector-option-expression). Если ни один элемент не соответствует селектору, метод выдает ошибку. Возвращает значение [expression](/api/class-page.mdx#page-eval-on-selector-option-expression).

Если [expression](/api/class-page.mdx#page-eval-on-selector-option-expression) возвращает [Promise], то [Page.evalOnSelector()](/api/class-page.mdx#page-eval-on-selector) будет ждать разрешения промиса и вернет его значение.

**Использование**

```java
String searchValue = (String) page.evalOnSelector("#search", "el => el.value");
String preloadHref = (String) page.evalOnSelector("link[rel=preload]", "el => el.href");
String html = (String) page.evalOnSelector(".main-container", "(e, suffix) => e.outerHTML + suffix", "hello");
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-selector"/><a href="#page-eval-on-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-expression"/><a href="#page-eval-on-selector-option-expression" class="list-anchor">#</a>
  
  JavaScript выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-arg"/><a href="#page-eval-on-selector-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-eval-on-selector-option-expression).
- `options` `Page.EvalOnSelectorOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-option-strict"/><a href="#page-eval-on-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.

**Возвращает**
- [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-return"/><a href="#page-eval-on-selector-return" class="list-anchor">#</a>

---

### evalOnSelectorAll {#page-eval-on-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.evalOnSelectorAll</x-search>

:::warning[Discouraged]

In most cases, [Locator.evaluateAll()](/api/class-locator.mdx#locator-evaluate-all), other [Locator] helper methods and web-first assertions do a better job.

:::


Метод находит все элементы, соответствующие указанному селектору на странице, и передает массив найденных элементов в качестве первого аргумента в [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression). Возвращает результат вызова [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

Если [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression) возвращает [Promise], то [Page.evalOnSelectorAll()](/api/class-page.mdx#page-eval-on-selector-all) будет ждать разрешения промиса и вернет его значение.

**Использование**

```java
boolean divCounts = (boolean) page.evalOnSelectorAll("div", "(divs, min) => divs.length >= min", 10);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-selector"/><a href="#page-eval-on-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `expression` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-expression"/><a href="#page-eval-on-selector-all-option-expression" class="list-anchor">#</a>
  
  JavaScript выражение для выполнения в контексте браузера. Если выражение оценивается как функция, функция автоматически вызывается.
- `arg` [EvaluationArgument] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-option-arg"/><a href="#page-eval-on-selector-all-option-arg" class="list-anchor">#</a>
  
  Необязательный аргумент для передачи в [expression](/api/class-page.mdx#page-eval-on-selector-all-option-expression).

**Возвращает**
- [Object]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-eval-on-selector-all-return"/><a href="#page-eval-on-selector-all-return" class="list-anchor">#</a>

---

### fill {#page-fill}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.fill</x-search>

:::warning[Discouraged]

Use locator-based [Locator.fill()](/api/class-locator.mdx#locator-fill) instead. Read more about [locators](../locators.mdx).

:::


Этот метод ждет элемент, соответствующий [selector](/api/class-page.mdx#page-fill-option-selector), ждет проверки [actionability](../actionability.mdx), фокусируется на элементе, заполняет его и вызывает событие `input` после заполнения. Обратите внимание, что вы можете передать пустую строку, чтобы очистить поле ввода.

Если целевой элемент не является `<input>`, `<textarea>` или `[contenteditable]` элементом, этот метод выдает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет заполнен именно этот элемент управления.

Для отправки более детализированных событий клавиатуры используйте [Locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially).

**Использование**

```java
Page.fill(selector, value);
Page.fill(selector, value, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-selector"/><a href="#page-fill-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `value` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-value"/><a href="#page-fill-option-value" class="list-anchor">#</a>
  
  Значение для заполнения элемента `<input>`, `<textarea>` или `[contenteditable]`.
- `options` `Page.FillOptions` *(optional)*
  - `setForce` [boolean] *(optional)* <font size="2">Added in: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-force"/><a href="#page-fill-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-no-wait-after"/><a href="#page-fill-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-strict"/><a href="#page-fill-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-option-timeout"/><a href="#page-fill-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-fill-return"/><a href="#page-fill-return" class="list-anchor">#</a>

---

### focus {#page-focus}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.focus</x-search>

:::warning[Discouraged]

Use locator-based [Locator.focus()](/api/class-locator.mdx#locator-focus) instead. Read more about [locators](../locators.mdx).

:::


Этот метод получает элемент с [selector](/api/class-page.mdx#page-focus-option-selector) и фокусируется на нем. Если нет элемента, соответствующего [selector](/api/class-page.mdx#page-focus-option-selector), метод ждет, пока соответствующий элемент не появится в DOM.

**Использование**

```java
Page.focus(selector);
Page.focus(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-selector"/><a href="#page-focus-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.FocusOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-strict"/><a href="#page-focus-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-option-timeout"/><a href="#page-focus-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-focus-return"/><a href="#page-focus-return" class="list-anchor">#</a>

---

### getAttribute {#page-get-attribute}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.getAttribute</x-search>

:::warning[Discouraged]

Use locator-based [Locator.getAttribute()](/api/class-locator.mdx#locator-get-attribute) instead. Read more about [locators](../locators.mdx).

:::


Возвращает значение атрибута элемента.

**Использование**

```java
Page.getAttribute(selector, name);
Page.getAttribute(selector, name, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-selector"/><a href="#page-get-attribute-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `name` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-name"/><a href="#page-get-attribute-option-name" class="list-anchor">#</a>
  
  Имя атрибута, для которого нужно получить значение.
- `options` `Page.GetAttributeOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-strict"/><a href="#page-get-attribute-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-option-timeout"/><a href="#page-get-attribute-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [null] | [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-get-attribute-return"/><a href="#page-get-attribute-return" class="list-anchor">#</a>

---

### hover {#page-hover}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.hover</x-search>

:::warning[Discouraged]

Use locator-based [Locator.hover()](/api/class-locator.mdx#locator-hover) instead. Read more about [locators](../locators.mdx).

:::


Этот метод наводит курсор на элемент, соответствующий [selector](/api/class-page.mdx#page-hover-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-hover-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Подождите проверки [actionability](../actionability.mdx) на найденном элементе, если не установлен параметр [setForce](/api/class-page.mdx#page-hover-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в вид, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы навести курсор на центр элемента или указанную позицию [setPosition](/api/class-page.mdx#page-hover-option-position).

Когда все шаги в совокупности не завершены в течение указанного времени [setTimeout](/api/class-page.mdx#page-hover-option-timeout), этот метод выдает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
Page.hover(selector);
Page.hover(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-selector"/><a href="#page-hover-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.HoverOptions` *(optional)*
  - `setForce` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-force"/><a href="#page-hover-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-modifiers"/><a href="#page-hover-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы будут нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(optional)* <font size="2">Added in: v1.28</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-no-wait-after"/><a href="#page-hover-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    
    Этот параметр не имеет эффекта.
  - `setPosition` Position *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-position"/><a href="#page-hover-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-strict"/><a href="#page-hover-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-timeout"/><a href="#page-hover-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.
  - `setTrial` [boolean] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-option-trial"/><a href="#page-hover-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-hover-return"/><a href="#page-hover-return" class="list-anchor">#</a>

---

### innerHTML {#page-inner-html}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.innerHTML</x-search>

:::warning[Discouraged]

Use locator-based [Locator.innerHTML()](/api/class-locator.mdx#locator-inner-html) instead. Read more about [locators](../locators.mdx).

:::


Возвращает `element.innerHTML`.

**Использование**

```java
Page.innerHTML(selector);
Page.innerHTML(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-selector"/><a href="#page-inner-html-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.InnerHTMLOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-strict"/><a href="#page-inner-html-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-option-timeout"/><a href="#page-inner-html-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-html-return"/><a href="#page-inner-html-return" class="list-anchor">#</a>

---

### innerText {#page-inner-text}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.innerText</x-search>

:::warning[Discouraged]

Use locator-based [Locator.innerText()](/api/class-locator.mdx#locator-inner-text) instead. Read more about [locators](../locators.mdx).

:::


Возвращает `element.innerText`.

**Использование**

```java
Page.innerText(selector);
Page.innerText(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-selector"/><a href="#page-inner-text-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.InnerTextOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-strict"/><a href="#page-inner-text-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-option-timeout"/><a href="#page-inner-text-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-inner-text-return"/><a href="#page-inner-text-return" class="list-anchor">#</a>

---

### inputValue {#page-input-value}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.13</font><x-search>page.inputValue</x-search>

:::warning[Discouraged]

Use locator-based [Locator.inputValue()](/api/class-locator.mdx#locator-input-value) instead. Read more about [locators](../locators.mdx).

:::


Возвращает `input.value` для выбранного элемента `<input>`, `<textarea>` или `<select>`.

Выдает ошибку для не-вводных элементов. Однако, если элемент находится внутри элемента `<label>`, который имеет связанный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), возвращает значение этого элемента управления.

**Использование**

```java
Page.inputValue(selector);
Page.inputValue(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-selector"/><a href="#page-input-value-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.InputValueOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-strict"/><a href="#page-input-value-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-option-timeout"/><a href="#page-input-value-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-input-value-return"/><a href="#page-input-value-return" class="list-anchor">#</a>

---

### isChecked {#page-is-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isChecked</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isChecked()](/api/class-locator.mdx#locator-is-checked) instead. Read more about [locators](../locators.mdx).

:::


Возвращает, отмечен ли элемент. Выдает ошибку, если элемент не является флажком или радиокнопкой.

**Использование**

```java
Page.isChecked(selector);
Page.isChecked(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-selector"/><a href="#page-is-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsCheckedOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-strict"/><a href="#page-is-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-option-timeout"/><a href="#page-is-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-checked-return"/><a href="#page-is-checked-return" class="list-anchor">#</a>

---

### isDisabled {#page-is-disabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isDisabled</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isDisabled()](/api/class-locator.mdx#locator-is-disabled) instead. Read more about [locators](../locators.mdx).

:::


Возвращает, отключен ли элемент, противоположность [enabled](../actionability.mdx#enabled).

**Использование**

```java
Page.isDisabled(selector);
Page.isDisabled(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-selector"/><a href="#page-is-disabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsDisabledOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-strict"/><a href="#page-is-disabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов вызывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-option-timeout"/><a href="#page-is-disabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-disabled-return"/><a href="#page-is-disabled-return" class="list-anchor">#</a>

---

### isEditable {#page-is-editable}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isEditable</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isEditable()](/api/class-locator.mdx#locator-is-editable) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент [редактируемым](../actionability.mdx#editable).

**Использование**

```java
Page.isEditable(selector);
Page.isEditable(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-selector"/><a href="#page-is-editable-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsEditableOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-strict"/><a href="#page-is-editable-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-option-timeout"/><a href="#page-is-editable-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-editable-return"/><a href="#page-is-editable-return" class="list-anchor">#</a>

---

### isEnabled {#page-is-enabled}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isEnabled</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isEnabled()](/api/class-locator.mdx#locator-is-enabled) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент [включенным](../actionability.mdx#enabled).

**Использование**

```java
Page.isEnabled(selector);
Page.isEnabled(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-selector"/><a href="#page-is-enabled-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsEnabledOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-strict"/><a href="#page-is-enabled-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-option-timeout"/><a href="#page-is-enabled-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-enabled-return"/><a href="#page-is-enabled-return" class="list-anchor">#</a>

---

### isHidden {#page-is-hidden}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isHidden</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isHidden()](/api/class-locator.mdx#locator-is-hidden) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент скрытым, противоположность [видимости](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-hidden-option-selector), который не соответствует ни одному элементу, считается скрытым.

**Использование**

```java
Page.isHidden(selector);
Page.isHidden(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-selector"/><a href="#page-is-hidden-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsHiddenOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-strict"/><a href="#page-is-hidden-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-option-timeout"/><a href="#page-is-hidden-option-timeout" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр игнорируется. [Page.isHidden()](/api/class-page.mdx#page-is-hidden) не ждет, пока элемент станет скрытым, и возвращается немедленно.
    :::

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-hidden-return"/><a href="#page-is-hidden-return" class="list-anchor">#</a>

---

### isVisible {#page-is-visible}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.isVisible</x-search>

:::warning[Discouraged]

Use locator-based [Locator.isVisible()](/api/class-locator.mdx#locator-is-visible) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, является ли элемент [видимым](../actionability.mdx#visible). [selector](/api/class-page.mdx#page-is-visible-option-selector), который не соответствует ни одному элементу, считается невидимым.

**Использование**

```java
Page.isVisible(selector);
Page.isVisible(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-selector"/><a href="#page-is-visible-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.IsVisibleOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-strict"/><a href="#page-is-visible-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-option-timeout"/><a href="#page-is-visible-option-timeout" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр игнорируется. [Page.isVisible()](/api/class-page.mdx#page-is-visible) не ждет, пока элемент станет видимым, и возвращается немедленно.
    :::

**Возвращает**
- [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-is-visible-return"/><a href="#page-is-visible-return" class="list-anchor">#</a>

---

### press {#page-press}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.press</x-search>

:::warning[Discouraged]

Use locator-based [Locator.press()](/api/class-locator.mdx#locator-press) instead. Read more about [locators](../locators.mdx).

:::

Фокусируется на элементе, а затем использует [Keyboard.down()](/api/class-keyboard.mdx#keyboard-down) и [Keyboard.up()](/api/class-keyboard.mdx#keyboard-up).

[key](/api/class-page.mdx#page-press-option-key) может указывать предполагаемое значение [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) или один символ для генерации текста. Надмножество значений [key](/api/class-page.mdx#page-press-option-key) можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Примеры клавиш:

`F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`, `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp` и т.д.

Также поддерживаются следующие модификационные сочетания: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`, `ControlOrMeta`. `ControlOrMeta` разрешается в `Control` на Windows и Linux и в `Meta` на macOS.

Удержание `Shift` будет вводить текст, соответствующий [key](/api/class-page.mdx#page-press-option-key) в верхнем регистре.

Если [key](/api/class-page.mdx#page-press-option-key) является одним символом, он чувствителен к регистру, поэтому значения `a` и `A` будут генерировать разные соответствующие тексты.

Также поддерживаются сочетания клавиш, такие как `key: "Control+o"`, `key: "Control++` или `key: "Control+Shift+T"`. При указании с модификатором, модификатор нажимается и удерживается, пока не будет нажата последующая клавиша.

**Использование**

```java
Page page = browser.newPage();
page.navigate("https://keycode.info");
page.press("body", "A");
page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("A.png")));
page.press("body", "ArrowLeft");
page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("ArrowLeft.png" )));
page.press("body", "Shift+O");
page.screenshot(new Page.ScreenshotOptions().setPath(Paths.get("O.png" )));
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-selector"/><a href="#page-press-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `key` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-key"/><a href="#page-press-option-key" class="list-anchor">#</a>
  
  Имя клавиши для нажатия или символ для генерации, например, `ArrowLeft` или `a`.
- `options` `Page.PressOptions` *(optional)*
  - `setDelay` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-delay"/><a href="#page-press-option-delay" class="list-anchor">#</a>
    
    Время ожидания между `keydown` и `keyup` в миллисекундах. По умолчанию 0.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-no-wait-after"/><a href="#page-press-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр по умолчанию будет `true` в будущем.
    :::
    
    Действия, инициирующие навигацию, ожидают, пока эти навигации произойдут и страницы начнут загружаться. Вы можете отказаться от ожидания, установив этот флаг. Вам понадобится этот параметр только в исключительных случаях, таких как навигация на недоступные страницы. По умолчанию `false`.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-strict"/><a href="#page-press-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-option-timeout"/><a href="#page-press-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-press-return"/><a href="#page-press-return" class="list-anchor">#</a>

---

### querySelector {#page-query-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.querySelector</x-search>

:::warning[Discouraged]

Use locator-based [Page.locator()](/api/class-page.mdx#page-locator) instead. Read more about [locators](../locators.mdx).

:::

Метод находит элемент, соответствующий указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение разрешается в `null`. Чтобы дождаться элемента на странице, используйте [Locator.waitFor()](/api/class-locator.mdx#locator-wait-for).

**Использование**

```java
Page.querySelector(selector);
Page.querySelector(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-selector"/><a href="#page-query-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` `Page.QuerySelectorOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-option-strict"/><a href="#page-query-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.

**Возвращает**
- [null] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-return"/><a href="#page-query-selector-return" class="list-anchor">#</a>

---

### querySelectorAll {#page-query-selector-all}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.9</font><x-search>page.querySelectorAll</x-search>

:::warning[Discouraged]

Use locator-based [Page.locator()](/api/class-page.mdx#page-locator) instead. Read more about [locators](../locators.mdx).

:::

Метод находит все элементы, соответствующие указанному селектору на странице. Если ни один элемент не соответствует селектору, возвращаемое значение разрешается в `[]`.

**Использование**

```java
Page.querySelectorAll(selector);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-option-selector"/><a href="#page-query-selector-all-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.

**Возвращает**
- [List]&lt;[ElementHandle]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-query-selector-all-return"/><a href="#page-query-selector-all-return" class="list-anchor">#</a>

---

### selectOption {#page-select-option}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.selectOption</x-search>

:::warning[Discouraged]

Use locator-based [Locator.selectOption()](/api/class-locator.mdx#locator-select-option) instead. Read more about [locators](../locators.mdx).

:::

Этот метод ожидает элемент, соответствующий [selector](/api/class-page.mdx#page-select-option-option-selector), ожидает проверки [actionability](../actionability.mdx), ждет, пока все указанные опции не будут присутствовать в элементе `<select>`, и выбирает эти опции.

Если целевой элемент не является элементом `<select>`, этот метод выбрасывает ошибку. Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контроль.

Возвращает массив значений опций, которые были успешно выбраны.

Вызывает событие `change` и `input`, как только все предоставленные опции были выбраны.

**Использование**

```java
// Single selection matching the value or label
page.selectOption("select#colors", "blue");
// single selection matching both the value and the label
page.selectOption("select#colors", new SelectOption().setLabel("Blue"));
// multiple selection
page.selectOption("select#colors", new String[] {"red", "green", "blue"});
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-selector"/><a href="#page-select-option-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `values` [null] | [String] | [ElementHandle] | [String]&#91;&#93; | `SelectOption` | [ElementHandle]&#91;&#93; | `SelectOption`&#91;&#93;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-values"/><a href="#page-select-option-option-values" class="list-anchor">#</a>
  - `setValue` [String] *(optional)*
    
    Соответствует `option.value`. Необязательно.
  - `setLabel` [String] *(optional)*
    
    Соответствует `option.label`. Необязательно.
  - `setIndex` [int] *(optional)*
    
    Соответствует индексу. Необязательно.
  
  Опции для выбора. Если `<select>` имеет атрибут `multiple`, все соответствующие опции выбираются, в противном случае выбирается только первая опция, соответствующая одной из переданных опций. Строковые значения соответствуют как значениям, так и меткам. Опция считается соответствующей, если все указанные свойства совпадают.
- `options` `Page.SelectOptionOptions` *(optional)*
  - `setForce` [boolean] *(optional)* <font size="2">Added in: v1.13</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-force"/><a href="#page-select-option-option-force" class="list-anchor">#</a>
    
    Обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-no-wait-after"/><a href="#page-select-option-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    Этот параметр не имеет эффекта.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-strict"/><a href="#page-select-option-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-option-timeout"/><a href="#page-select-option-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [List]&lt;[String]&gt;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-select-option-return"/><a href="#page-select-option-return" class="list-anchor">#</a>

---

### setChecked {#page-set-checked}

<font size="2" style={{position: "relative", top: "-20px"}}>Added in: v1.15</font><x-search>page.setChecked</x-search>

:::warning[Discouraged]

Use locator-based [Locator.setChecked()](/api/class-locator.mdx#locator-set-checked) instead. Read more about [locators](../locators.mdx).

:::

Этот метод отмечает или снимает отметку с элемента, соответствующего [selector](/api/class-page.mdx#page-set-checked-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-set-checked-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение.
3. Если элемент уже имеет правильное состояние, этот метод возвращается немедленно.
4. Подождите проверки [actionability](../actionability.mdx) на найденном элементе, если не установлен параметр [setForce](/api/class-page.mdx#page-set-checked-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
5. Прокрутите элемент в вид, если это необходимо.
6. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента.
7. Убедитесь, что элемент теперь отмечен или снят. Если нет, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-set-checked-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
Page.setChecked(selector, checked);
Page.setChecked(selector, checked, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-selector"/><a href="#page-set-checked-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `checked` [boolean]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-checked"/><a href="#page-set-checked-option-checked" class="list-anchor">#</a>
  
  Отметить или снять отметку с флажка.
- `options` `Page.SetCheckedOptions` *(optional)*
  - `setForce` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-force"/><a href="#page-set-checked-option-force" class="list-anchor">#</a>
    
    Обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-no-wait-after"/><a href="#page-set-checked-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    Этот параметр не имеет эффекта.
  - `setPosition` Position *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-position"/><a href="#page-set-checked-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-strict"/><a href="#page-set-checked-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-timeout"/><a href="#page-set-checked-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.
  - `setTrial` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-option-trial"/><a href="#page-set-checked-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-checked-return"/><a href="#page-set-checked-return" class="list-anchor">#</a>

---

### setInputFiles {#page-set-input-files}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.setInputFiles</x-search>

:::warning[Discouraged]

Use locator-based [Locator.setInputFiles()](/api/class-locator.mdx#locator-set-input-files) instead. Read more about [locators](../locators.mdx).

:::

Устанавливает значение входного файла на эти пути файлов или файлы. Если некоторые из `filePaths` являются относительными путями, они разрешаются относительно текущего рабочего каталога. Для пустого массива очищает выбранные файлы. Для входов с атрибутом `[webkitdirectory]` поддерживается только один путь к каталогу.

Этот метод ожидает, что [selector](/api/class-page.mdx#page-set-input-files-option-selector) указывает на [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input). Однако, если элемент находится внутри элемента `<label>`, который имеет ассоциированный [control](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control), будет использован контроль.

**Использование**

```java
Page.setInputFiles(selector, files);
Page.setInputFiles(selector, files, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-selector"/><a href="#page-set-input-files-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `files` [Path] | [Path]&#91;&#93; | `FilePayload` | `FilePayload`&#91;&#93;<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-files"/><a href="#page-set-input-files-option-files" class="list-anchor">#</a>
  - `setName` [String]
    
    Имя файла
  - `setMimeType` [String]
    
    Тип файла
  - `setBuffer` [byte&#91;&#93;]
    
    Содержимое файла
- `options` `Page.SetInputFilesOptions` *(optional)*
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-no-wait-after"/><a href="#page-set-input-files-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    Этот параметр не имеет эффекта.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-strict"/><a href="#page-set-input-files-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-option-timeout"/><a href="#page-set-input-files-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-set-input-files-return"/><a href="#page-set-input-files-return" class="list-anchor">#</a>

---

### tap {#page-tap}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.tap</x-search>

:::warning[Discouraged]

Use locator-based [Locator.tap()](/api/class-locator.mdx#locator-tap) instead. Read more about [locators](../locators.mdx).

:::

Этот метод нажимает на элемент, соответствующий [selector](/api/class-page.mdx#page-tap-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-tap-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
2. Подождите проверки [actionability](../actionability.mdx) на найденном элементе, если не установлен параметр [setForce](/api/class-page.mdx#page-tap-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
3. Прокрутите элемент в вид, если это необходимо.
4. Используйте [Page.touchscreen()](/api/class-page.mdx#page-touchscreen), чтобы нажать в центре элемента или в указанной [setPosition](/api/class-page.mdx#page-tap-option-position).

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-tap-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

:::note

Метод [Page.tap()](/api/class-page.mdx#page-tap) выбросит исключение, если параметр [setHasTouch](/api/class-browser.mdx#browser-new-context-option-has-touch) контекста браузера равен false.
:::

**Использование**

```java
Page.tap(selector);
Page.tap(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-selector"/><a href="#page-tap-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.TapOptions` *(optional)*
  - `setForce` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-force"/><a href="#page-tap-option-force" class="list-anchor">#</a>
    
    Обойти проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setModifiers` [List]&lt;`enum KeyboardModifier { ALT, CONTROL, CONTROLORMETA, META, SHIFT }`&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-modifiers"/><a href="#page-tap-option-modifiers" class="list-anchor">#</a>
    
    Модификаторные клавиши для нажатия. Гарантирует, что только эти модификаторы нажаты во время операции, а затем восстанавливает текущие модификаторы обратно. Если не указано, используются текущие нажатые модификаторы. "ControlOrMeta" разрешается в "Control" на Windows и Linux и в "Meta" на macOS.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-no-wait-after"/><a href="#page-tap-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    Этот параметр не имеет эффекта.
    :::
    
    Этот параметр не имеет эффекта.
  - `setPosition` Position *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-position"/><a href="#page-tap-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка для использования относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-strict"/><a href="#page-tap-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-timeout"/><a href="#page-tap-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout) methods.
  - `setTrial` [boolean] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-option-trial"/><a href="#page-tap-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно, чтобы дождаться, пока элемент будет готов к действию, не выполняя его. Обратите внимание, что клавиатурные `modifiers` будут нажаты независимо от `trial`, чтобы позволить тестировать элементы, которые видны только при нажатии этих клавиш.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-tap-return"/><a href="#page-tap-return" class="list-anchor">#</a>

---

### textContent {#page-text-content}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.textContent</x-search>

:::warning[Discouraged]

Use locator-based [Locator.textContent()](/api/class-locator.mdx#locator-text-content) instead. Read more about [locators](../locators.mdx).

:::

Возвращает `element.textContent`.

**Использование**

```java
Page.textContent(selector);
Page.textContent(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-selector"/><a href="#page-text-content-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.TextContentOptions` *(optional)*
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-strict"/><a href="#page-text-content-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-option-timeout"/><a href="#page-text-content-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [null] | [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-text-content-return"/><a href="#page-text-content-return" class="list-anchor">#</a>

---

### type {#page-type}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.type</x-search>

:::warning Deprecated

In most cases, you should use [Locator.fill()](/api/class-locator.mdx#locator-fill) instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [Locator.pressSequentially()](/api/class-locator.mdx#locator-press-sequentially).

:::

Отправляет событие `keydown`, `keypress`/`input` и `keyup` для каждого символа в тексте. `page.type` может использоваться для отправки детализированных событий клавиатуры. Для заполнения значений в полях формы используйте [Page.fill()](/api/class-page.mdx#page-fill).

Чтобы нажать специальную клавишу, такую как `Control` или `ArrowDown`, используйте [Keyboard.press()](/api/class-keyboard.mdx#keyboard-press).

**Использование**

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-selector"/><a href="#page-type-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `text` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-text"/><a href="#page-type-option-text" class="list-anchor">#</a>
  
  Текст для ввода в фокусированный элемент.
- `options` `Page.TypeOptions` *(optional)*
  - `setDelay` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-delay"/><a href="#page-type-option-delay" class="list-anchor">#</a>
    
    Время ожидания между нажатиями клавиш в миллисекундах. По умолчанию 0.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-no-wait-after"/><a href="#page-type-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    This option has no effect.
    :::
    
    
    This option has no effect.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-strict"/><a href="#page-type-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-option-timeout"/><a href="#page-type-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-type-return"/><a href="#page-type-return" class="list-anchor">#</a>

---

### uncheck {#page-uncheck}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.uncheck</x-search>

:::warning[Discouraged]

Use locator-based [Locator.uncheck()](/api/class-locator.mdx#locator-uncheck) instead. Read more about [locators](../locators.mdx).

:::

Этот метод снимает отметку с элемента, соответствующего [selector](/api/class-page.mdx#page-uncheck-option-selector), выполняя следующие шаги:
1. Найдите элемент, соответствующий [selector](/api/class-page.mdx#page-uncheck-option-selector). Если его нет, подождите, пока соответствующий элемент не будет добавлен в DOM.
1. Убедитесь, что найденный элемент является флажком или радиокнопкой. Если нет, этот метод выбрасывает исключение. Если элемент уже снят с отметки, этот метод возвращается немедленно.
1. Подождите, пока не будут выполнены проверки [actionability](../actionability.mdx) на найденном элементе, если не установлена опция [setForce](/api/class-page.mdx#page-uncheck-option-force). Если элемент отсоединяется во время проверок, все действие повторяется.
1. Прокрутите элемент в видимую область, если это необходимо.
1. Используйте [Page.mouse()](/api/class-page.mdx#page-mouse), чтобы щелкнуть в центре элемента.
1. Убедитесь, что элемент теперь снят с отметки. Если нет, этот метод выбрасывает исключение.

Когда все шаги в совокупности не завершены в течение указанного [setTimeout](/api/class-page.mdx#page-uncheck-option-timeout), этот метод выбрасывает [TimeoutError]. Передача нулевого тайм-аута отключает это.

**Использование**

```java
Page.uncheck(selector);
Page.uncheck(selector, options);
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-selector"/><a href="#page-uncheck-option-selector" class="list-anchor">#</a>
  
  Селектор для поиска элемента. Если несколько элементов удовлетворяют селектору, будет использован первый.
- `options` `Page.UncheckOptions` *(optional)*
  - `setForce` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-force"/><a href="#page-uncheck-option-force" class="list-anchor">#</a>
    
    Нужно ли обходить проверки [actionability](../actionability.mdx). По умолчанию `false`.
  - `setNoWaitAfter` [boolean] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-no-wait-after"/><a href="#page-uncheck-option-no-wait-after" class="list-anchor">#</a>
    
    :::warning[Deprecated]
    This option has no effect.
    :::
    
    
    This option has no effect.
  - `setPosition` Position *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-position"/><a href="#page-uncheck-option-position" class="list-anchor">#</a>
    - `setX` [double]
      
      
    - `setY` [double]
      
      
    Точка, используемая относительно верхнего левого угла рамки элемента. Если не указано, используется видимая точка элемента.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-strict"/><a href="#page-uncheck-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-timeout"/><a href="#page-uncheck-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setTrial` [boolean] *(optional)* <font size="2">Added in: v1.11</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-option-trial"/><a href="#page-uncheck-option-trial" class="list-anchor">#</a>
    
    Если установлено, этот метод выполняет только проверки [actionability](../actionability.mdx) и пропускает действие. По умолчанию `false`. Полезно для ожидания, пока элемент будет готов к действию без его выполнения.

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-uncheck-return"/><a href="#page-uncheck-return" class="list-anchor">#</a>

---

### waitForNavigation {#page-wait-for-navigation}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForNavigation</x-search>

:::warning Deprecated

This method is inherently racy, please use [Page.waitForURL()](/api/class-page.mdx#page-wait-for-url) instead.

:::

Ожидает навигации основного фрейма и возвращает ответ основного ресурса. В случае нескольких перенаправлений навигация будет разрешена с ответом последнего перенаправления. В случае навигации к другому якорю или навигации из-за использования History API, навигация будет разрешена с `null`.

**Использование**

Это разрешается, когда страница переходит на новый URL или перезагружается. Это полезно, когда вы выполняете код, который косвенно вызывает навигацию страницы. Например, цель клика имеет обработчик `onclick`, который вызывает навигацию из `setTimeout`. Рассмотрим этот пример:

```java
// Метод возвращается после завершения навигации
Response response = page.waitForNavigation(() -> {
  // Это действие вызывает навигацию после тайм-аута.
  page.getByText("Navigate after timeout").click();
});
```

:::note
Использование [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) для изменения URL считается навигацией.
:::

**Аргументы**
- `options` `Page.WaitForNavigationOptions` *(optional)*
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-timeout"/><a href="#page-wait-for-navigation-option-timeout" class="list-anchor">#</a>
    
    Максимальное время операции в миллисекундах, по умолчанию 30 секунд, передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultNavigationTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-navigation-timeout), [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout), [Page.setDefaultNavigationTimeout()](/api/class-page.mdx#page-set-default-navigation-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).
  - `setUrl` [String] | [Pattern] | [Predicate]&lt;[String]&gt; *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-url"/><a href="#page-wait-for-navigation-option-url" class="list-anchor">#</a>
    
    Глобальный шаблон, регулярное выражение или предикат, получающий [URL] для соответствия при ожидании навигации. Обратите внимание, что если параметр является строкой без символов подстановки, метод будет ожидать навигации к URL, который точно равен строке.
  - `setWaitUntil` `enum WaitUntilState { LOAD, DOMCONTENTLOADED, NETWORKIDLE, COMMIT }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-wait-until"/><a href="#page-wait-for-navigation-option-wait-until" class="list-anchor">#</a>
    
    Когда считать операцию успешной, по умолчанию `load`. События могут быть:
    * `'domcontentloaded'` - считать операцию завершенной, когда событие `DOMContentLoaded` будет вызвано.
    * `'load'` - считать операцию завершенной, когда событие `load` будет вызвано.
    * `'networkidle'` - **НЕ РЕКОМЕНДУЕТСЯ** считать операцию завершенной, когда нет сетевых соединений в течение как минимум `500` мс. Не используйте этот метод для тестирования, полагайтесь на веб-утверждения для оценки готовности.
    * `'commit'` - считать операцию завершенной, когда сетевой ответ получен и документ начал загружаться.
- `callback` [Runnable] <font size="2">Added in: v1.9</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-option-callback"/><a href="#page-wait-for-navigation-option-callback" class="list-anchor">#</a>
  
  Обратный вызов, выполняющий действие, вызывающее событие.

**Возвращает**
- [null] | [Response]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-navigation-return"/><a href="#page-wait-for-navigation-return" class="list-anchor">#</a>

---

### waitForSelector {#page-wait-for-selector}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForSelector</x-search>

:::warning[Discouraged]

Use web assertions that assert visibility or a locator-based [Locator.waitFor()](/api/class-locator.mdx#locator-wait-for) instead. Read more about [locators](../locators.mdx).

:::

Возвращает, когда элемент, указанный селектором, удовлетворяет опции [setState](/api/class-page.mdx#page-wait-for-selector-option-state). Возвращает `null`, если ожидание для `hidden` или `detached`.

:::note

Playwright автоматически ожидает, пока элемент будет готов перед выполнением действия. Использование объектов [Locator] и веб-первых утверждений делает код свободным от ожидания селектора.
:::

Ожидайте, пока [selector](/api/class-page.mdx#page-wait-for-selector-option-selector) не удовлетворит опцию [setState](/api/class-page.mdx#page-wait-for-selector-option-state) (либо появится/исчезнет из DOM, либо станет видимым/скрытым). Если на момент вызова метода [selector](/api/class-page.mdx#page-wait-for-selector-option-selector) уже удовлетворяет условию, метод вернется немедленно. Если селектор не удовлетворяет условию в течение [setTimeout](/api/class-page.mdx#page-wait-for-selector-option-timeout) миллисекунд, функция выбросит исключение.

**Использование**

Этот метод работает через навигации:

```java
import com.microsoft.playwright.*;

public class Example {
  public static void main(String[] args) {
    try (Playwright playwright = Playwright.create()) {
      BrowserType chromium = playwright.chromium();
      Browser browser = chromium.launch();
      Page page = browser.newPage();
      for (String currentURL : Arrays.asList("https://google.com", "https://bbc.com")) {
        page.navigate(currentURL);
        ElementHandle element = page.waitForSelector("img");
        System.out.println("Loaded image: " + element.getAttribute("src"));
      }
      browser.close();
    }
  }
}
```

**Аргументы**
- `selector` [String]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-selector"/><a href="#page-wait-for-selector-option-selector" class="list-anchor">#</a>
  
  Селектор для запроса.
- `options` `Page.WaitForSelectorOptions` *(optional)*
  - `setState` `enum WaitForSelectorState { ATTACHED, DETACHED, VISIBLE, HIDDEN }` *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-state"/><a href="#page-wait-for-selector-option-state" class="list-anchor">#</a>
    
    По умолчанию `'visible'`. Может быть:
    * `'attached'` - ожидание, пока элемент будет присутствовать в DOM.
    * `'detached'` - ожидание, пока элемент не будет присутствовать в DOM.
    * `'visible'` - ожидание, пока элемент не будет иметь пустую рамку и не будет `visibility:hidden`. Обратите внимание, что элемент без содержимого или с `display:none` имеет пустую рамку и не считается видимым.
    * `'hidden'` - ожидание, пока элемент не будет отсоединен от DOM, или не будет иметь пустую рамку или `visibility:hidden`. Это противоположно опции `'visible'`.
  - `setStrict` [boolean] *(optional)* <font size="2">Added in: v1.14</font><a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-strict"/><a href="#page-wait-for-selector-option-strict" class="list-anchor">#</a>
    
    Если true, вызов требует, чтобы селектор разрешался в один элемент. Если данный селектор разрешается в более чем один элемент, вызов выбрасывает исключение.
  - `setTimeout` [double] *(optional)*<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-option-timeout"/><a href="#page-wait-for-selector-option-timeout" class="list-anchor">#</a>
    
    Максимальное время в миллисекундах. По умолчанию `30000` (30 секунд). Передайте `0`, чтобы отключить тайм-аут. Значение по умолчанию можно изменить, используя методы [BrowserContext.setDefaultTimeout()](/api/class-browsercontext.mdx#browser-context-set-default-timeout) или [Page.setDefaultTimeout()](/api/class-page.mdx#page-set-default-timeout).

**Возвращает**
- [null] | [ElementHandle]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-selector-return"/><a href="#page-wait-for-selector-return" class="list-anchor">#</a>

---

### waitForTimeout {#page-wait-for-timeout}

<font size="2" style={{position: "relative", top: "-20px"}}>Added before v1.9</font><x-search>page.waitForTimeout</x-search>

:::warning[Discouraged]

Never wait for timeout in production. Tests that wait for time are inherently flaky. Use [Locator] actions and web assertions that wait automatically.

:::

Ожидает заданный [timeout](/api/class-page.mdx#page-wait-for-timeout-option-timeout) в миллисекундах.

Обратите внимание, что `page.waitForTimeout()` следует использовать только для отладки. Тесты, использующие таймер в производстве, будут ненадежными. Используйте сигналы, такие как сетевые события, селекторы, становящиеся видимыми, и другие.

**Использование**

```java
// ожидание 1 секунду
page.waitForTimeout(1000);
```

**Аргументы**
- `timeout` [double]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-option-timeout"/><a href="#page-wait-for-timeout-option-timeout" class="list-anchor">#</a>
  
  Тайм-аут для ожидания

**Возвращает**
- [void]<a aria-hidden="true" tabIndex="-1" class="list-anchor-link" id="page-wait-for-timeout-return"/><a href="#page-wait-for-timeout-return" class="list-anchor">#</a>


[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[PlaywrightException]: /api/class-playwrightexception.mdx "PlaywrightException"
[Request]: /api/class-request.mdx "Request"
[RequestOptions]: /api/class-requestoptions.mdx "RequestOptions"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[boolean]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "boolean"
[byte&#91;&#93;]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "byte[]"
[Consumer]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html "Consumer"
[Date]: https://docs.oracle.com/javase/8/docs/api/java/util/Date.html "Date"
[double]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "double"
[InputStream]: https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html "InputStream"
[int]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "int"
[long]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "long"
[JsonObject]: https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/JsonObject.html "JsonObject"
[List]: https://docs.oracle.com/javase/8/docs/api/java/util/List.html "List"
[Map]: https://docs.oracle.com/javase/8/docs/api/java/util/Map.html "Map"
[null]: https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.7 "null"
[Object]: https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html "Object"
[Path]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html "Path"
[Pattern]: https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html "Pattern"
[Predicate]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html "Predicate"
[void]: https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html "void"
[Runnable]: https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html "Runnable"
[RuntimeException]: https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html "RuntimeException"
[String]: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html "String"

[all available image tags]: https://mcr.microsoft.com/en-us/product/playwright/java/about "all available image tags"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/java/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-java/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
