---
id: aria-snapshots
title: "Тестирование снимков"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HTMLCard from '@site/src/components/HTMLCard';

import LiteYouTube from '@site/src/components/LiteYouTube';

## Обзор {#overview}

С помощью тестирования снимков в Playwright вы можете проверять дерево доступности страницы по сравнению с заранее определенным шаблоном снимка.

```java
page.navigate("https://playwright.dev/");
assertThat(page.locator("banner")).matchesAriaSnapshot("""
  - banner:
    - heading /Playwright enables reliable end-to-end/ [level=1]
    - link "Get started"
    - link "Star microsoft/playwright on GitHub"
    - link /[\\d]+k\\+ stargazers on GitHub/
""");
```

<LiteYouTube id="P4R6hnsE0UY" title="Начало работы с ARIA Snapshots" />

## Тестирование утверждений vs Тестирование снимков {#assertion-testing-vs-snapshot-testing}

Тестирование снимков и тестирование утверждений служат разным целям в автоматизации тестирования:

### Тестирование утверждений {#assertion-testing}

Тестирование утверждений — это целенаправленный подход, при котором вы утверждаете конкретные значения или условия для элементов или компонентов. Например, с помощью Playwright, [assertThat(locator).hasText()](/api/class-locatorassertions.mdx#locator-assertions-to-have-text) проверяет, что элемент содержит ожидаемый текст, а [assertThat(locator).hasValue()](/api/class-locatorassertions.mdx#locator-assertions-to-have-value) подтверждает, что поле ввода имеет ожидаемое значение. Тесты утверждений специфичны и обычно проверяют текущее состояние элемента или свойства по сравнению с ожидаемым, заранее определенным состоянием. Они хорошо работают для предсказуемых, однозначных проверок, но ограничены в охвате при тестировании более широкой структуры или вариаций.

**Преимущества**
- **Ясность**: Намерение теста явно и легко понять.
- **Специфичность**: Тесты сосредоточены на конкретных аспектах функциональности, что делает их более устойчивыми к несвязанным изменениям.
- **Отладка**: Ошибки предоставляют целенаправленную обратную связь, указывая непосредственно на проблемный аспект.

**Недостатки**
- **Многословность для сложных выводов**: Написание утверждений для сложных структур данных или больших выводов может быть громоздким и подверженным ошибкам.
- **Затраты на обслуживание**: По мере развития кода ручное обновление утверждений может быть трудоемким.

### Тестирование снимков {#snapshot-testing}

Тестирование снимков захватывает "снимок" или представление всего состояния элемента, компонента или данных в данный момент, который затем сохраняется для будущих сравнений. При повторном запуске тестов текущее состояние сравнивается со снимком, и если есть различия, тест не проходит. Этот подход особенно полезен для сложных или динамических структур, где ручное утверждение каждой детали было бы слишком трудоемким. Тестирование снимков более широкое и целостное, чем тестирование утверждений, позволяя отслеживать более сложные изменения с течением времени.

**Преимущества**
- **Упрощает сложные выводы**: Например, тестирование визуального компонента может быть утомительным с традиционными утверждениями. Снимки захватывают весь вывод для легкого сравнения.
- **Быстрая обратная связь**: Разработчики могут легко заметить непреднамеренные изменения в выводе.
- **Поощряет согласованность**: Помогает поддерживать согласованный вывод по мере развития кода.

**Недостатки**
- **Чрезмерная зависимость**: Может возникнуть соблазн принять изменения в снимках, не полностью понимая их, что потенциально скрывает ошибки.
- **Гранулярность**: Большие снимки могут быть трудными для интерпретации, когда возникают различия, особенно если незначительные изменения затрагивают большие части вывода.
- **Пригодность**: Не подходит для высокодинамичного контента, где выводы часто или непредсказуемо меняются.

### Когда использовать {#when-to-use}
- **Тестирование снимков** идеально для:
  - Тестирования пользовательского интерфейса целых страниц и компонентов.
  - Широких структурных проверок для сложных компонентов пользовательского интерфейса.
  - Регрессионного тестирования для выводов, которые редко меняют структуру.
- **Тестирование утверждений** идеально для:
  - Проверки основной логики.
  - Тестирования вычисленных значений.
  - Тонко настроенных тестов, требующих точных условий.

Комбинируя тестирование снимков для широких, структурных проверок и тестирование утверждений для конкретной функциональности, вы можете достичь всесторонней стратегии тестирования.

## Aria снимки {#aria-snapshots}

В Playwright aria снимки предоставляют YAML представление дерева доступности страницы. Эти снимки могут быть сохранены и сравнены позже, чтобы проверить, остается ли структура страницы согласованной или соответствует определенным ожиданиям.

Формат YAML описывает иерархическую структуру доступных элементов на странице, детализируя **роли**, **атрибуты**, **значения** и **текстовое содержимое**. Структура следует синтаксису, подобному дереву, где каждый узел представляет доступный элемент, а отступы указывают на вложенные элементы.

Каждый доступный элемент в дереве представлен как узел YAML:

```yaml
- role "name" [attribute=value]
```

- **role**: Указывает ARIA или HTML роль элемента (например, `heading`, `list`, `listitem`, `button`).
- **"name"**: Доступное имя элемента. Строки в кавычках указывают точные значения, `/patterns/` используются для регулярных выражений.
- **[attribute=value]**: Атрибуты и значения в квадратных скобках представляют конкретные ARIA атрибуты, такие как `checked`, `disabled`, `expanded`, `level`, `pressed` или `selected`.

Эти значения берутся из ARIA-атрибутов или вычисляются на основе семантики HTML. Чтобы посмотреть структуру дерева доступности (accessibility tree) страницы, используйте вкладку [Chrome DevTools Accessibility Tab](https://developer.chrome.com/docs/devtools/accessibility/reference#tab).

## Сопоставление снимков {#snapshot-matching}

Метод утверждения [assertThat(locator).matchesAriaSnapshot()](/api/class-locatorassertions.mdx#locator-assertions-to-match-aria-snapshot) в Playwright сравнивает доступную структуру области локатора с заранее определенным шаблоном aria снимка, помогая проверить состояние страницы в соответствии с требованиями тестирования.

Для следующего DOM:

```html
<h1>title</h1>
```

Вы можете сопоставить его, используя следующий шаблон снимка:

```java
assertThat(page.locator("body")).matchesAriaSnapshot("""
  - heading "title"
""");
```

При сопоставлении шаблон снимка сравнивается с текущим деревом доступности страницы:
* Если структура дерева соответствует шаблону, тест проходит; в противном случае он не проходит, указывая на несоответствие между ожидаемыми и фактическими состояниями доступности.
* Сравнение чувствительно к регистру и сворачивает пробелы, поэтому отступы и разрывы строк игнорируются.
* Сравнение чувствительно к порядку, что означает, что порядок элементов в шаблоне снимка должен соответствовать порядку в дереве доступности страницы.

### Частичное сопоставление {#partial-matching}

Вы можете выполнять частичные сопоставления узлов, опуская атрибуты или доступные имена, что позволяет проверять конкретные части дерева доступности без необходимости точных совпадений. Эта гибкость полезна для динамических или несущественных атрибутов.

```html
<button>Submit</button>
```

*aria снимок*

```yaml
- button
```

В этом примере роль кнопки сопоставляется, но доступное имя ("Submit") не указано, что позволяет тесту пройти независимо от метки кнопки.

<hr/>

Для элементов с ARIA атрибутами, такими как `checked` или `disabled`, опуская эти атрибуты, можно выполнять частичное сопоставление, сосредотачиваясь только на роли и иерархии.

```html
<input type="checkbox" checked>
```

*aria снимок для частичного сопоставления*

```yaml
- checkbox
```

В этом частичном сопоставлении атрибут `checked` игнорируется, поэтому тест пройдет независимо от состояния флажка.

<hr/>

Аналогично, вы можете частично сопоставлять дочерние элементы в списках или группах, опуская конкретные элементы списка или вложенные элементы.

```html
<ul>
  <li>Feature A</li>
  <li>Feature B</li>
  <li>Feature C</li>
</ul>
```

*aria снимок для частичного сопоставления*

```yaml
- list
  - listitem: Feature B
```

Частичные сопоставления позволяют создавать гибкие тесты снимков, которые проверяют основную структуру страницы без навязывания конкретного содержимого или атрибутов.

### Строгое сопоставление {#strict-matching}

По умолчанию будет сопоставлен шаблон, содержащий подмножество дочерних элементов:

```html
<ul>
  <li>Feature A</li>
  <li>Feature B</li>
  <li>Feature C</li>
</ul>
```

*ARIA-снимок для частичного совпадения*

```yaml
- list
  - listitem: Feature B
```

Свойство `/children` можно использовать, чтобы управлять тем, как сопоставляются дочерние элементы:
- `contain` (по умолчанию): совпадает, если все указанные дочерние элементы присутствуют в заданном порядке
- `equal`: совпадает, если дочерние элементы в точности соответствуют указанному списку в заданном порядке
- `deep-equal`: совпадает, если дочерние элементы в точности соответствуют указанному списку в заданном порядке, включая вложенные дочерние элементы

```html
<ul>
  <li>Feature A</li>
  <li>Feature B</li>
  <li>Feature C</li>
</ul>
```

*ARIA-снимок завершится неудачей, потому что Feature C отсутствует в шаблоне*

```yaml
- list
  - /children: equal
  - listitem: Feature A
  - listitem: Feature B
```

### Сопоставление с регулярными выражениями {#matching-with-regular-expressions}

Регулярные выражения позволяют гибко сопоставлять элементы с динамическим или переменным текстом. Доступные имена и текст могут поддерживать шаблоны регулярных выражений.

```html
<h1>Issues 12</h1>
```

*aria снимок с регулярным выражением*

```yaml
- heading /Issues \d+/
```

## Генерация снимков {#generating-snapshots}

Создание aria снимков в Playwright помогает обеспечить и поддерживать структуру вашего приложения. Вы можете генерировать снимки различными способами в зависимости от вашей настройки тестирования и рабочего процесса.

### Генерация снимков с помощью генератора кода Playwright {#generating-snapshots-with-the-playwright-code-generator}

Если вы используете [Генератор кода](./codegen.mdx) Playwright, генерация aria снимков упрощается с его интерактивным интерфейсом:
- **Действие "Assert snapshot"**: В генераторе кода вы можете использовать действие "Assert snapshot", чтобы автоматически создать утверждение снимка для выбранных элементов. Это быстрый способ захватить aria снимок как часть вашего записанного тестового потока.
- **Вкладка "Aria snapshot"**: Вкладка "Aria snapshot" в интерфейсе генератора кода визуально представляет aria снимок для выбранного локатора, позволяя вам исследовать, проверять и проверять роли элементов, атрибуты и доступные имена, чтобы помочь в создании и проверке снимков.

### Использование метода `Locator.ariaSnapshot` {#using-the-locatorariasnapshot-method}

Метод [Locator.ariaSnapshot()](/api/class-locator.mdx#locator-aria-snapshot) позволяет программно создавать YAML представление доступных элементов в пределах области локатора, что особенно полезно для динамической генерации снимков во время выполнения теста.

**Пример**:

```java
String snapshot = page.locator("body").ariaSnapshot();
System.out.println(snapshot);
```

Эта команда выводит aria снимок в пределах указанной области локатора в формате YAML, который вы можете проверить или сохранить по мере необходимости.

## Примеры дерева доступности {#accessibility-tree-examples}

### Заголовки с атрибутами уровня {#headings-with-level-attributes}

Заголовки могут включать атрибут `level`, указывающий их уровень заголовка.

```html
<h1>Title</h1>
<h2>Subtitle</h2>
```

*aria снимок*

```yaml
- heading "Title" [level=1]
- heading "Subtitle" [level=2]
```

### Текстовые узлы {#text-nodes}

Отдельные или описательные текстовые элементы появляются как текстовые узлы.

```html
<div>Sample accessible name</div>
```

*aria снимок*

```yaml
- text: Sample accessible name
```

### Встроенный многострочный текст {#inline-multiline-text}

Многострочный текст, такой как абзацы, нормализуется в aria снимке.

```html
<p>Line 1<br>Line 2</p>
```

*aria снимок*

```yaml
- paragraph: Line 1 Line 2
```

### Ссылки {#links}

Ссылки отображают свой текст или составное содержимое из псевдоэлементов.

```html
<a href="#more-info">Read more about Accessibility</a>
```

*aria снимок*

```yaml
- link "Read more about Accessibility"
```

### Текстовые поля {#text-boxes}

Элементы ввода типа `text` показывают содержимое своего атрибута `value`.

```html
<input type="text" value="Enter your name">
```

*aria снимок*

```yaml
- textbox: Enter your name
```

### Списки с элементами {#lists-with-items}

Упорядоченные и неупорядоченные списки включают свои элементы списка.

```html
<ul aria-label="Main Features">
  <li>Feature 1</li>
  <li>Feature 2</li>
</ul>
```

*aria снимок*

```yaml
- list "Main Features":
  - listitem: Feature 1
  - listitem: Feature 2
```

### Группированные элементы {#grouped-elements}

Группы захватывают вложенные элементы, такие как элементы `<details>` с содержимым summary.

```html
<details>
  <summary>Summary</summary>
  <p>Detail content here</p>
</details>
```

*aria снимок*

```yaml
- group: Summary
```

### Атрибуты и состояния {#attributes-and-states}

Часто используемые ARIA атрибуты, такие как `checked`, `disabled`, `expanded`, `level`, `pressed` и `selected`, представляют состояния управления.

#### Флажок с атрибутом `checked` {#checkbox-with-checked-attribute}

```html
<input type="checkbox" checked>
```

*aria снимок*

```yaml
- checkbox [checked]
```

#### Кнопка с атрибутом `pressed` {#button-with-pressed-attribute}

```html
<button aria-pressed="true">Toggle</button>
```

*aria снимок*

```yaml
- button "Toggle" [pressed=true]
```


[APIRequest]: /api/class-apirequest.mdx "APIRequest"
[APIRequestContext]: /api/class-apirequestcontext.mdx "APIRequestContext"
[APIResponse]: /api/class-apiresponse.mdx "APIResponse"
[APIResponseAssertions]: /api/class-apiresponseassertions.mdx "APIResponseAssertions"
[Browser]: /api/class-browser.mdx "Browser"
[BrowserContext]: /api/class-browsercontext.mdx "BrowserContext"
[BrowserType]: /api/class-browsertype.mdx "BrowserType"
[CDPSession]: /api/class-cdpsession.mdx "CDPSession"
[Clock]: /api/class-clock.mdx "Clock"
[ConsoleMessage]: /api/class-consolemessage.mdx "ConsoleMessage"
[Dialog]: /api/class-dialog.mdx "Dialog"
[Download]: /api/class-download.mdx "Download"
[ElementHandle]: /api/class-elementhandle.mdx "ElementHandle"
[FileChooser]: /api/class-filechooser.mdx "FileChooser"
[FormData]: /api/class-formdata.mdx "FormData"
[Frame]: /api/class-frame.mdx "Frame"
[FrameLocator]: /api/class-framelocator.mdx "FrameLocator"
[JSHandle]: /api/class-jshandle.mdx "JSHandle"
[Keyboard]: /api/class-keyboard.mdx "Keyboard"
[Locator]: /api/class-locator.mdx "Locator"
[LocatorAssertions]: /api/class-locatorassertions.mdx "LocatorAssertions"
[Mouse]: /api/class-mouse.mdx "Mouse"
[Page]: /api/class-page.mdx "Page"
[PageAssertions]: /api/class-pageassertions.mdx "PageAssertions"
[Playwright]: /api/class-playwright.mdx "Playwright"
[PlaywrightAssertions]: /api/class-playwrightassertions.mdx "PlaywrightAssertions"
[PlaywrightException]: /api/class-playwrightexception.mdx "PlaywrightException"
[Request]: /api/class-request.mdx "Request"
[RequestOptions]: /api/class-requestoptions.mdx "RequestOptions"
[Response]: /api/class-response.mdx "Response"
[Route]: /api/class-route.mdx "Route"
[Selectors]: /api/class-selectors.mdx "Selectors"
[TimeoutError]: /api/class-timeouterror.mdx "TimeoutError"
[Touchscreen]: /api/class-touchscreen.mdx "Touchscreen"
[Tracing]: /api/class-tracing.mdx "Tracing"
[Video]: /api/class-video.mdx "Video"
[WebError]: /api/class-weberror.mdx "WebError"
[WebSocket]: /api/class-websocket.mdx "WebSocket"
[WebSocketFrame]: /api/class-websocketframe.mdx "WebSocketFrame"
[WebSocketRoute]: /api/class-websocketroute.mdx "WebSocketRoute"
[Worker]: /api/class-worker.mdx "Worker"
[Element]: https://developer.mozilla.org/en-US/docs/Web/API/element "Element"
[EvaluationArgument]: /evaluating.mdx#evaluation-argument "EvaluationArgument"
[Promise]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise "Promise"
[iterator]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols "Iterator"
[origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin "Origin"
[selector]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors "selector"
[Serializable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Description "Serializable"
[UIEvent.detail]: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail "UIEvent.detail"
[UnixTime]: https://en.wikipedia.org/wiki/Unix_time "Unix Time"
[xpath]: https://developer.mozilla.org/en-US/docs/Web/XPath "xpath"

[boolean]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "boolean"
[byte&#91;&#93;]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "byte[]"
[Consumer]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html "Consumer"
[Date]: https://docs.oracle.com/javase/8/docs/api/java/util/Date.html "Date"
[double]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "double"
[InputStream]: https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html "InputStream"
[int]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "int"
[long]: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html "long"
[JsonObject]: https://www.javadoc.io/doc/com.google.code.gson/gson/latest/com.google.gson/com/google/gson/JsonObject.html "JsonObject"
[List]: https://docs.oracle.com/javase/8/docs/api/java/util/List.html "List"
[Map]: https://docs.oracle.com/javase/8/docs/api/java/util/Map.html "Map"
[null]: https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.7 "null"
[Object]: https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html "Object"
[Path]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html "Path"
[Pattern]: https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html "Pattern"
[Predicate]: https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html "Predicate"
[void]: https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html "void"
[Runnable]: https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html "Runnable"
[RuntimeException]: https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html "RuntimeException"
[String]: https://docs.oracle.com/javase/8/docs/api/java/lang/String.html "String"

[все доступные теги образов]: https://mcr.microsoft.com/en-us/product/playwright/java/about "все доступные теги образов"
[Microsoft Artifact Registry]: https://mcr.microsoft.com/en-us/product/playwright/java/about "Microsoft Artifact Registry"
[Dockerfile.noble]: https://github.com/microsoft/playwright-java/blob/main/utils/docker/Dockerfile.noble "Dockerfile.noble"
